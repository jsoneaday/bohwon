function _mergeNamespaces(ae, ie) {
  for (var se = 0; se < ie.length; se++) {
    const fe = ie[se];
    if (typeof fe != "string" && !Array.isArray(fe)) {
      for (const ue in fe)
        if (ue !== "default" && !(ue in ae)) {
          const ce = Object.getOwnPropertyDescriptor(fe, ue);
          ce && Object.defineProperty(ae, ue, ce.get ? ce : {
            enumerable: !0,
            get: () => fe[ue]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(ae, Symbol.toStringTag, { value: "Module" }));
}
const hack = () => {
  throw new Error("Unimplemented");
};
globalThis.crypto ??= {};
globalThis.crypto.subtle ??= {};
globalThis.crypto.subtle.generateKey ??= hack;
globalThis.crypto.subtle.importKey ??= hack;
globalThis.crypto.subtle.exportKey ??= hack;
globalThis.crypto.subtle.digest ??= hack;
globalThis.crypto.subtle.sign ??= hack;
const global$1 = globalThis || void 0 || self;
function bind$3(ae, ie) {
  return function() {
    return ae.apply(ie, arguments);
  };
}
const { toString: toString$1 } = Object.prototype, { getPrototypeOf: getPrototypeOf$3 } = Object, kindOf$1 = /* @__PURE__ */ ((ae) => (ie) => {
  const se = toString$1.call(ie);
  return ae[se] || (ae[se] = se.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), kindOfTest$1 = (ae) => (ae = ae.toLowerCase(), (ie) => kindOf$1(ie) === ae), typeOfTest$1 = (ae) => (ie) => typeof ie === ae, { isArray: isArray$1 } = Array, isUndefined$1 = typeOfTest$1("undefined");
function isBuffer$1(ae) {
  return ae !== null && !isUndefined$1(ae) && ae.constructor !== null && !isUndefined$1(ae.constructor) && isFunction$2(ae.constructor.isBuffer) && ae.constructor.isBuffer(ae);
}
const isArrayBuffer$1 = kindOfTest$1("ArrayBuffer");
function isArrayBufferView$1(ae) {
  let ie;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ie = ArrayBuffer.isView(ae) : ie = ae && ae.buffer && isArrayBuffer$1(ae.buffer), ie;
}
const isString$2 = typeOfTest$1("string"), isFunction$2 = typeOfTest$1("function"), isNumber$1 = typeOfTest$1("number"), isObject$3 = (ae) => ae !== null && typeof ae == "object", isBoolean$1 = (ae) => ae === !0 || ae === !1, isPlainObject$1 = (ae) => {
  if (kindOf$1(ae) !== "object")
    return !1;
  const ie = getPrototypeOf$3(ae);
  return (ie === null || ie === Object.prototype || Object.getPrototypeOf(ie) === null) && !(Symbol.toStringTag in ae) && !(Symbol.iterator in ae);
}, isDate$1 = kindOfTest$1("Date"), isFile$1 = kindOfTest$1("File"), isBlob$1 = kindOfTest$1("Blob"), isFileList$1 = kindOfTest$1("FileList"), isStream$1 = (ae) => isObject$3(ae) && isFunction$2(ae.pipe), isFormData$1 = (ae) => {
  let ie;
  return ae && (typeof FormData == "function" && ae instanceof FormData || isFunction$2(ae.append) && ((ie = kindOf$1(ae)) === "formdata" || // detect form-data instance
  ie === "object" && isFunction$2(ae.toString) && ae.toString() === "[object FormData]"));
}, isURLSearchParams$1 = kindOfTest$1("URLSearchParams"), trim$1 = (ae) => ae.trim ? ae.trim() : ae.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach$3(ae, ie, { allOwnKeys: se = !1 } = {}) {
  if (ae === null || typeof ae > "u")
    return;
  let fe, ue;
  if (typeof ae != "object" && (ae = [ae]), isArray$1(ae))
    for (fe = 0, ue = ae.length; fe < ue; fe++)
      ie.call(null, ae[fe], fe, ae);
  else {
    const ce = se ? Object.getOwnPropertyNames(ae) : Object.keys(ae), de = ce.length;
    let me;
    for (fe = 0; fe < de; fe++)
      me = ce[fe], ie.call(null, ae[me], me, ae);
  }
}
function findKey$1(ae, ie) {
  ie = ie.toLowerCase();
  const se = Object.keys(ae);
  let fe = se.length, ue;
  for (; fe-- > 0; )
    if (ue = se[fe], ie === ue.toLowerCase())
      return ue;
  return null;
}
const _global$1 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global$1, isContextDefined$1 = (ae) => !isUndefined$1(ae) && ae !== _global$1;
function merge$1() {
  const { caseless: ae } = isContextDefined$1(this) && this || {}, ie = {}, se = (fe, ue) => {
    const ce = ae && findKey$1(ie, ue) || ue;
    isPlainObject$1(ie[ce]) && isPlainObject$1(fe) ? ie[ce] = merge$1(ie[ce], fe) : isPlainObject$1(fe) ? ie[ce] = merge$1({}, fe) : isArray$1(fe) ? ie[ce] = fe.slice() : ie[ce] = fe;
  };
  for (let fe = 0, ue = arguments.length; fe < ue; fe++)
    arguments[fe] && forEach$3(arguments[fe], se);
  return ie;
}
const extend$1 = (ae, ie, se, { allOwnKeys: fe } = {}) => (forEach$3(ie, (ue, ce) => {
  se && isFunction$2(ue) ? ae[ce] = bind$3(ue, se) : ae[ce] = ue;
}, { allOwnKeys: fe }), ae), stripBOM$1 = (ae) => (ae.charCodeAt(0) === 65279 && (ae = ae.slice(1)), ae), inherits$y = (ae, ie, se, fe) => {
  ae.prototype = Object.create(ie.prototype, fe), ae.prototype.constructor = ae, Object.defineProperty(ae, "super", {
    value: ie.prototype
  }), se && Object.assign(ae.prototype, se);
}, toFlatObject$1 = (ae, ie, se, fe) => {
  let ue, ce, de;
  const me = {};
  if (ie = ie || {}, ae == null)
    return ie;
  do {
    for (ue = Object.getOwnPropertyNames(ae), ce = ue.length; ce-- > 0; )
      de = ue[ce], (!fe || fe(de, ae, ie)) && !me[de] && (ie[de] = ae[de], me[de] = !0);
    ae = se !== !1 && getPrototypeOf$3(ae);
  } while (ae && (!se || se(ae, ie)) && ae !== Object.prototype);
  return ie;
}, endsWith$2 = (ae, ie, se) => {
  ae = String(ae), (se === void 0 || se > ae.length) && (se = ae.length), se -= ie.length;
  const fe = ae.indexOf(ie, se);
  return fe !== -1 && fe === se;
}, toArray$3 = (ae) => {
  if (!ae)
    return null;
  if (isArray$1(ae))
    return ae;
  let ie = ae.length;
  if (!isNumber$1(ie))
    return null;
  const se = new Array(ie);
  for (; ie-- > 0; )
    se[ie] = ae[ie];
  return se;
}, isTypedArray$2 = /* @__PURE__ */ ((ae) => (ie) => ae && ie instanceof ae)(typeof Uint8Array < "u" && getPrototypeOf$3(Uint8Array)), forEachEntry$1 = (ae, ie) => {
  const fe = (ae && ae[Symbol.iterator]).call(ae);
  let ue;
  for (; (ue = fe.next()) && !ue.done; ) {
    const ce = ue.value;
    ie.call(ae, ce[0], ce[1]);
  }
}, matchAll$1 = (ae, ie) => {
  let se;
  const fe = [];
  for (; (se = ae.exec(ie)) !== null; )
    fe.push(se);
  return fe;
}, isHTMLForm$1 = kindOfTest$1("HTMLFormElement"), toCamelCase$1 = (ae) => ae.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(se, fe, ue) {
    return fe.toUpperCase() + ue;
  }
), hasOwnProperty$2 = (({ hasOwnProperty: ae }) => (ie, se) => ae.call(ie, se))(Object.prototype), isRegExp$1 = kindOfTest$1("RegExp"), reduceDescriptors$1 = (ae, ie) => {
  const se = Object.getOwnPropertyDescriptors(ae), fe = {};
  forEach$3(se, (ue, ce) => {
    let de;
    (de = ie(ue, ce, ae)) !== !1 && (fe[ce] = de || ue);
  }), Object.defineProperties(ae, fe);
}, freezeMethods$1 = (ae) => {
  reduceDescriptors$1(ae, (ie, se) => {
    if (isFunction$2(ae) && ["arguments", "caller", "callee"].indexOf(se) !== -1)
      return !1;
    const fe = ae[se];
    if (isFunction$2(fe)) {
      if (ie.enumerable = !1, "writable" in ie) {
        ie.writable = !1;
        return;
      }
      ie.set || (ie.set = () => {
        throw Error("Can not rewrite read-only method '" + se + "'");
      });
    }
  });
}, toObjectSet$1 = (ae, ie) => {
  const se = {}, fe = (ue) => {
    ue.forEach((ce) => {
      se[ce] = !0;
    });
  };
  return isArray$1(ae) ? fe(ae) : fe(String(ae).split(ie)), se;
}, noop$4 = () => {
}, toFiniteNumber$1 = (ae, ie) => (ae = +ae, Number.isFinite(ae) ? ae : ie), ALPHA$1 = "abcdefghijklmnopqrstuvwxyz", DIGIT$1 = "0123456789", ALPHABET$5 = {
  DIGIT: DIGIT$1,
  ALPHA: ALPHA$1,
  ALPHA_DIGIT: ALPHA$1 + ALPHA$1.toUpperCase() + DIGIT$1
}, generateString$1 = (ae = 16, ie = ALPHABET$5.ALPHA_DIGIT) => {
  let se = "";
  const { length: fe } = ie;
  for (; ae--; )
    se += ie[Math.random() * fe | 0];
  return se;
};
function isSpecCompliantForm$1(ae) {
  return !!(ae && isFunction$2(ae.append) && ae[Symbol.toStringTag] === "FormData" && ae[Symbol.iterator]);
}
const toJSONObject$1 = (ae) => {
  const ie = new Array(10), se = (fe, ue) => {
    if (isObject$3(fe)) {
      if (ie.indexOf(fe) >= 0)
        return;
      if (!("toJSON" in fe)) {
        ie[ue] = fe;
        const ce = isArray$1(fe) ? [] : {};
        return forEach$3(fe, (de, me) => {
          const we = se(de, ue + 1);
          !isUndefined$1(we) && (ce[me] = we);
        }), ie[ue] = void 0, ce;
      }
    }
    return fe;
  };
  return se(ae, 0);
}, isAsyncFn$1 = kindOfTest$1("AsyncFunction"), isThenable$1 = (ae) => ae && (isObject$3(ae) || isFunction$2(ae)) && isFunction$2(ae.then) && isFunction$2(ae.catch), utils$t = {
  isArray: isArray$1,
  isArrayBuffer: isArrayBuffer$1,
  isBuffer: isBuffer$1,
  isFormData: isFormData$1,
  isArrayBufferView: isArrayBufferView$1,
  isString: isString$2,
  isNumber: isNumber$1,
  isBoolean: isBoolean$1,
  isObject: isObject$3,
  isPlainObject: isPlainObject$1,
  isUndefined: isUndefined$1,
  isDate: isDate$1,
  isFile: isFile$1,
  isBlob: isBlob$1,
  isRegExp: isRegExp$1,
  isFunction: isFunction$2,
  isStream: isStream$1,
  isURLSearchParams: isURLSearchParams$1,
  isTypedArray: isTypedArray$2,
  isFileList: isFileList$1,
  forEach: forEach$3,
  merge: merge$1,
  extend: extend$1,
  trim: trim$1,
  stripBOM: stripBOM$1,
  inherits: inherits$y,
  toFlatObject: toFlatObject$1,
  kindOf: kindOf$1,
  kindOfTest: kindOfTest$1,
  endsWith: endsWith$2,
  toArray: toArray$3,
  forEachEntry: forEachEntry$1,
  matchAll: matchAll$1,
  isHTMLForm: isHTMLForm$1,
  hasOwnProperty: hasOwnProperty$2,
  hasOwnProp: hasOwnProperty$2,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: reduceDescriptors$1,
  freezeMethods: freezeMethods$1,
  toObjectSet: toObjectSet$1,
  toCamelCase: toCamelCase$1,
  noop: noop$4,
  toFiniteNumber: toFiniteNumber$1,
  findKey: findKey$1,
  global: _global$1,
  isContextDefined: isContextDefined$1,
  ALPHABET: ALPHABET$5,
  generateString: generateString$1,
  isSpecCompliantForm: isSpecCompliantForm$1,
  toJSONObject: toJSONObject$1,
  isAsyncFn: isAsyncFn$1,
  isThenable: isThenable$1
};
var buffer$2 = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray$1;
base64Js.fromByteArray = fromByteArray$1;
var lookup$1 = [], revLookup$1 = [], Arr$1 = typeof Uint8Array < "u" ? Uint8Array : Array, code$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$b = 0, len$1 = code$1.length; i$b < len$1; ++i$b)
  lookup$1[i$b] = code$1[i$b], revLookup$1[code$1.charCodeAt(i$b)] = i$b;
revLookup$1[45] = 62;
revLookup$1[95] = 63;
function getLens$1(ae) {
  var ie = ae.length;
  if (ie % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var se = ae.indexOf("=");
  se === -1 && (se = ie);
  var fe = se === ie ? 0 : 4 - se % 4;
  return [se, fe];
}
function byteLength(ae) {
  var ie = getLens$1(ae), se = ie[0], fe = ie[1];
  return (se + fe) * 3 / 4 - fe;
}
function _byteLength$1(ae, ie, se) {
  return (ie + se) * 3 / 4 - se;
}
function toByteArray$1(ae) {
  var ie, se = getLens$1(ae), fe = se[0], ue = se[1], ce = new Arr$1(_byteLength$1(ae, fe, ue)), de = 0, me = ue > 0 ? fe - 4 : fe, we;
  for (we = 0; we < me; we += 4)
    ie = revLookup$1[ae.charCodeAt(we)] << 18 | revLookup$1[ae.charCodeAt(we + 1)] << 12 | revLookup$1[ae.charCodeAt(we + 2)] << 6 | revLookup$1[ae.charCodeAt(we + 3)], ce[de++] = ie >> 16 & 255, ce[de++] = ie >> 8 & 255, ce[de++] = ie & 255;
  return ue === 2 && (ie = revLookup$1[ae.charCodeAt(we)] << 2 | revLookup$1[ae.charCodeAt(we + 1)] >> 4, ce[de++] = ie & 255), ue === 1 && (ie = revLookup$1[ae.charCodeAt(we)] << 10 | revLookup$1[ae.charCodeAt(we + 1)] << 4 | revLookup$1[ae.charCodeAt(we + 2)] >> 2, ce[de++] = ie >> 8 & 255, ce[de++] = ie & 255), ce;
}
function tripletToBase64$1(ae) {
  return lookup$1[ae >> 18 & 63] + lookup$1[ae >> 12 & 63] + lookup$1[ae >> 6 & 63] + lookup$1[ae & 63];
}
function encodeChunk$1(ae, ie, se) {
  for (var fe, ue = [], ce = ie; ce < se; ce += 3)
    fe = (ae[ce] << 16 & 16711680) + (ae[ce + 1] << 8 & 65280) + (ae[ce + 2] & 255), ue.push(tripletToBase64$1(fe));
  return ue.join("");
}
function fromByteArray$1(ae) {
  for (var ie, se = ae.length, fe = se % 3, ue = [], ce = 16383, de = 0, me = se - fe; de < me; de += ce)
    ue.push(encodeChunk$1(ae, de, de + ce > me ? me : de + ce));
  return fe === 1 ? (ie = ae[se - 1], ue.push(
    lookup$1[ie >> 2] + lookup$1[ie << 4 & 63] + "=="
  )) : fe === 2 && (ie = (ae[se - 2] << 8) + ae[se - 1], ue.push(
    lookup$1[ie >> 10] + lookup$1[ie >> 4 & 63] + lookup$1[ie << 2 & 63] + "="
  )), ue.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(ae, ie, se, fe, ue) {
  var ce, de, me = ue * 8 - fe - 1, we = (1 << me) - 1, Ee = we >> 1, Se = -7, Be = se ? ue - 1 : 0, Ce = se ? -1 : 1, Ie = ae[ie + Be];
  for (Be += Ce, ce = Ie & (1 << -Se) - 1, Ie >>= -Se, Se += me; Se > 0; ce = ce * 256 + ae[ie + Be], Be += Ce, Se -= 8)
    ;
  for (de = ce & (1 << -Se) - 1, ce >>= -Se, Se += fe; Se > 0; de = de * 256 + ae[ie + Be], Be += Ce, Se -= 8)
    ;
  if (ce === 0)
    ce = 1 - Ee;
  else {
    if (ce === we)
      return de ? NaN : (Ie ? -1 : 1) * (1 / 0);
    de = de + Math.pow(2, fe), ce = ce - Ee;
  }
  return (Ie ? -1 : 1) * de * Math.pow(2, ce - fe);
};
ieee754.write = function(ae, ie, se, fe, ue, ce) {
  var de, me, we, Ee = ce * 8 - ue - 1, Se = (1 << Ee) - 1, Be = Se >> 1, Ce = ue === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, Ie = fe ? 0 : ce - 1, Pe = fe ? 1 : -1, Ne = ie < 0 || ie === 0 && 1 / ie < 0 ? 1 : 0;
  for (ie = Math.abs(ie), isNaN(ie) || ie === 1 / 0 ? (me = isNaN(ie) ? 1 : 0, de = Se) : (de = Math.floor(Math.log(ie) / Math.LN2), ie * (we = Math.pow(2, -de)) < 1 && (de--, we *= 2), de + Be >= 1 ? ie += Ce / we : ie += Ce * Math.pow(2, 1 - Be), ie * we >= 2 && (de++, we /= 2), de + Be >= Se ? (me = 0, de = Se) : de + Be >= 1 ? (me = (ie * we - 1) * Math.pow(2, ue), de = de + Be) : (me = ie * Math.pow(2, Be - 1) * Math.pow(2, ue), de = 0)); ue >= 8; ae[se + Ie] = me & 255, Ie += Pe, me /= 256, ue -= 8)
    ;
  for (de = de << ue | me, Ee += ue; Ee > 0; ae[se + Ie] = de & 255, Ie += Pe, de /= 256, Ee -= 8)
    ;
  ae[se + Ie - Pe] |= Ne * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(ae) {
  const ie = base64Js, se = ieee754, fe = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  ae.Buffer = Se, ae.SlowBuffer = st, ae.INSPECT_MAX_BYTES = 50;
  const ue = 2147483647;
  ae.kMaxLength = ue;
  const { Uint8Array: ce, ArrayBuffer: de, SharedArrayBuffer: me } = globalThis;
  Se.TYPED_ARRAY_SUPPORT = we(), !Se.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function we() {
    try {
      const We = new ce(1), Le = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(Le, ce.prototype), Object.setPrototypeOf(We, Le), We.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(Se.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (Se.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(Se.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (Se.isBuffer(this))
        return this.byteOffset;
    }
  });
  function Ee(We) {
    if (We > ue)
      throw new RangeError('The value "' + We + '" is invalid for option "size"');
    const Le = new ce(We);
    return Object.setPrototypeOf(Le, Se.prototype), Le;
  }
  function Se(We, Le, Ke) {
    if (typeof We == "number") {
      if (typeof Le == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return Pe(We);
    }
    return Be(We, Le, Ke);
  }
  Se.poolSize = 8192;
  function Be(We, Le, Ke) {
    if (typeof We == "string")
      return Ne(We, Le);
    if (de.isView(We))
      return He(We);
    if (We == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof We
      );
    if (ar(We, de) || We && ar(We.buffer, de) || typeof me < "u" && (ar(We, me) || We && ar(We.buffer, me)))
      return De(We, Le, Ke);
    if (typeof We == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const rt = We.valueOf && We.valueOf();
    if (rt != null && rt !== We)
      return Se.from(rt, Le, Ke);
    const lt = Ge(We);
    if (lt)
      return lt;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof We[Symbol.toPrimitive] == "function")
      return Se.from(We[Symbol.toPrimitive]("string"), Le, Ke);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof We
    );
  }
  Se.from = function(We, Le, Ke) {
    return Be(We, Le, Ke);
  }, Object.setPrototypeOf(Se.prototype, ce.prototype), Object.setPrototypeOf(Se, ce);
  function Ce(We) {
    if (typeof We != "number")
      throw new TypeError('"size" argument must be of type number');
    if (We < 0)
      throw new RangeError('The value "' + We + '" is invalid for option "size"');
  }
  function Ie(We, Le, Ke) {
    return Ce(We), We <= 0 ? Ee(We) : Le !== void 0 ? typeof Ke == "string" ? Ee(We).fill(Le, Ke) : Ee(We).fill(Le) : Ee(We);
  }
  Se.alloc = function(We, Le, Ke) {
    return Ie(We, Le, Ke);
  };
  function Pe(We) {
    return Ce(We), Ee(We < 0 ? 0 : Ye(We) | 0);
  }
  Se.allocUnsafe = function(We) {
    return Pe(We);
  }, Se.allocUnsafeSlow = function(We) {
    return Pe(We);
  };
  function Ne(We, Le) {
    if ((typeof Le != "string" || Le === "") && (Le = "utf8"), !Se.isEncoding(Le))
      throw new TypeError("Unknown encoding: " + Le);
    const Ke = at(We, Le) | 0;
    let rt = Ee(Ke);
    const lt = rt.write(We, Le);
    return lt !== Ke && (rt = rt.slice(0, lt)), rt;
  }
  function ke(We) {
    const Le = We.length < 0 ? 0 : Ye(We.length) | 0, Ke = Ee(Le);
    for (let rt = 0; rt < Le; rt += 1)
      Ke[rt] = We[rt] & 255;
    return Ke;
  }
  function He(We) {
    if (ar(We, ce)) {
      const Le = new ce(We);
      return De(Le.buffer, Le.byteOffset, Le.byteLength);
    }
    return ke(We);
  }
  function De(We, Le, Ke) {
    if (Le < 0 || We.byteLength < Le)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (We.byteLength < Le + (Ke || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let rt;
    return Le === void 0 && Ke === void 0 ? rt = new ce(We) : Ke === void 0 ? rt = new ce(We, Le) : rt = new ce(We, Le, Ke), Object.setPrototypeOf(rt, Se.prototype), rt;
  }
  function Ge(We) {
    if (Se.isBuffer(We)) {
      const Le = Ye(We.length) | 0, Ke = Ee(Le);
      return Ke.length === 0 || We.copy(Ke, 0, 0, Le), Ke;
    }
    if (We.length !== void 0)
      return typeof We.length != "number" || Dr(We.length) ? Ee(0) : ke(We);
    if (We.type === "Buffer" && Array.isArray(We.data))
      return ke(We.data);
  }
  function Ye(We) {
    if (We >= ue)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + ue.toString(16) + " bytes");
    return We | 0;
  }
  function st(We) {
    return +We != We && (We = 0), Se.alloc(+We);
  }
  Se.isBuffer = function(Le) {
    return Le != null && Le._isBuffer === !0 && Le !== Se.prototype;
  }, Se.compare = function(Le, Ke) {
    if (ar(Le, ce) && (Le = Se.from(Le, Le.offset, Le.byteLength)), ar(Ke, ce) && (Ke = Se.from(Ke, Ke.offset, Ke.byteLength)), !Se.isBuffer(Le) || !Se.isBuffer(Ke))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (Le === Ke)
      return 0;
    let rt = Le.length, lt = Ke.length;
    for (let It = 0, yt = Math.min(rt, lt); It < yt; ++It)
      if (Le[It] !== Ke[It]) {
        rt = Le[It], lt = Ke[It];
        break;
      }
    return rt < lt ? -1 : lt < rt ? 1 : 0;
  }, Se.isEncoding = function(Le) {
    switch (String(Le).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, Se.concat = function(Le, Ke) {
    if (!Array.isArray(Le))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (Le.length === 0)
      return Se.alloc(0);
    let rt;
    if (Ke === void 0)
      for (Ke = 0, rt = 0; rt < Le.length; ++rt)
        Ke += Le[rt].length;
    const lt = Se.allocUnsafe(Ke);
    let It = 0;
    for (rt = 0; rt < Le.length; ++rt) {
      let yt = Le[rt];
      if (ar(yt, ce))
        It + yt.length > lt.length ? (Se.isBuffer(yt) || (yt = Se.from(yt)), yt.copy(lt, It)) : ce.prototype.set.call(
          lt,
          yt,
          It
        );
      else if (Se.isBuffer(yt))
        yt.copy(lt, It);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      It += yt.length;
    }
    return lt;
  };
  function at(We, Le) {
    if (Se.isBuffer(We))
      return We.length;
    if (de.isView(We) || ar(We, de))
      return We.byteLength;
    if (typeof We != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof We
      );
    const Ke = We.length, rt = arguments.length > 2 && arguments[2] === !0;
    if (!rt && Ke === 0)
      return 0;
    let lt = !1;
    for (; ; )
      switch (Le) {
        case "ascii":
        case "latin1":
        case "binary":
          return Ke;
        case "utf8":
        case "utf-8":
          return Hr(We).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Ke * 2;
        case "hex":
          return Ke >>> 1;
        case "base64":
          return qr(We).length;
        default:
          if (lt)
            return rt ? -1 : Hr(We).length;
          Le = ("" + Le).toLowerCase(), lt = !0;
      }
  }
  Se.byteLength = at;
  function mt(We, Le, Ke) {
    let rt = !1;
    if ((Le === void 0 || Le < 0) && (Le = 0), Le > this.length || ((Ke === void 0 || Ke > this.length) && (Ke = this.length), Ke <= 0) || (Ke >>>= 0, Le >>>= 0, Ke <= Le))
      return "";
    for (We || (We = "utf8"); ; )
      switch (We) {
        case "hex":
          return Me(this, Le, Ke);
        case "utf8":
        case "utf-8":
          return _e(this, Le, Ke);
        case "ascii":
          return he(this, Le, Ke);
        case "latin1":
        case "binary":
          return be(this, Le, Ke);
        case "base64":
          return xe(this, Le, Ke);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Re(this, Le, Ke);
        default:
          if (rt)
            throw new TypeError("Unknown encoding: " + We);
          We = (We + "").toLowerCase(), rt = !0;
      }
  }
  Se.prototype._isBuffer = !0;
  function qe(We, Le, Ke) {
    const rt = We[Le];
    We[Le] = We[Ke], We[Ke] = rt;
  }
  Se.prototype.swap16 = function() {
    const Le = this.length;
    if (Le % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let Ke = 0; Ke < Le; Ke += 2)
      qe(this, Ke, Ke + 1);
    return this;
  }, Se.prototype.swap32 = function() {
    const Le = this.length;
    if (Le % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let Ke = 0; Ke < Le; Ke += 4)
      qe(this, Ke, Ke + 3), qe(this, Ke + 1, Ke + 2);
    return this;
  }, Se.prototype.swap64 = function() {
    const Le = this.length;
    if (Le % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let Ke = 0; Ke < Le; Ke += 8)
      qe(this, Ke, Ke + 7), qe(this, Ke + 1, Ke + 6), qe(this, Ke + 2, Ke + 5), qe(this, Ke + 3, Ke + 4);
    return this;
  }, Se.prototype.toString = function() {
    const Le = this.length;
    return Le === 0 ? "" : arguments.length === 0 ? _e(this, 0, Le) : mt.apply(this, arguments);
  }, Se.prototype.toLocaleString = Se.prototype.toString, Se.prototype.equals = function(Le) {
    if (!Se.isBuffer(Le))
      throw new TypeError("Argument must be a Buffer");
    return this === Le ? !0 : Se.compare(this, Le) === 0;
  }, Se.prototype.inspect = function() {
    let Le = "";
    const Ke = ae.INSPECT_MAX_BYTES;
    return Le = this.toString("hex", 0, Ke).replace(/(.{2})/g, "$1 ").trim(), this.length > Ke && (Le += " ... "), "<Buffer " + Le + ">";
  }, fe && (Se.prototype[fe] = Se.prototype.inspect), Se.prototype.compare = function(Le, Ke, rt, lt, It) {
    if (ar(Le, ce) && (Le = Se.from(Le, Le.offset, Le.byteLength)), !Se.isBuffer(Le))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof Le
      );
    if (Ke === void 0 && (Ke = 0), rt === void 0 && (rt = Le ? Le.length : 0), lt === void 0 && (lt = 0), It === void 0 && (It = this.length), Ke < 0 || rt > Le.length || lt < 0 || It > this.length)
      throw new RangeError("out of range index");
    if (lt >= It && Ke >= rt)
      return 0;
    if (lt >= It)
      return -1;
    if (Ke >= rt)
      return 1;
    if (Ke >>>= 0, rt >>>= 0, lt >>>= 0, It >>>= 0, this === Le)
      return 0;
    let yt = It - lt, jt = rt - Ke;
    const Lr = Math.min(yt, jt), zt = this.slice(lt, It), rr = Le.slice(Ke, rt);
    for (let Cr = 0; Cr < Lr; ++Cr)
      if (zt[Cr] !== rr[Cr]) {
        yt = zt[Cr], jt = rr[Cr];
        break;
      }
    return yt < jt ? -1 : jt < yt ? 1 : 0;
  };
  function ze(We, Le, Ke, rt, lt) {
    if (We.length === 0)
      return -1;
    if (typeof Ke == "string" ? (rt = Ke, Ke = 0) : Ke > 2147483647 ? Ke = 2147483647 : Ke < -2147483648 && (Ke = -2147483648), Ke = +Ke, Dr(Ke) && (Ke = lt ? 0 : We.length - 1), Ke < 0 && (Ke = We.length + Ke), Ke >= We.length) {
      if (lt)
        return -1;
      Ke = We.length - 1;
    } else if (Ke < 0)
      if (lt)
        Ke = 0;
      else
        return -1;
    if (typeof Le == "string" && (Le = Se.from(Le, rt)), Se.isBuffer(Le))
      return Le.length === 0 ? -1 : ot(We, Le, Ke, rt, lt);
    if (typeof Le == "number")
      return Le = Le & 255, typeof ce.prototype.indexOf == "function" ? lt ? ce.prototype.indexOf.call(We, Le, Ke) : ce.prototype.lastIndexOf.call(We, Le, Ke) : ot(We, [Le], Ke, rt, lt);
    throw new TypeError("val must be string, number or Buffer");
  }
  function ot(We, Le, Ke, rt, lt) {
    let It = 1, yt = We.length, jt = Le.length;
    if (rt !== void 0 && (rt = String(rt).toLowerCase(), rt === "ucs2" || rt === "ucs-2" || rt === "utf16le" || rt === "utf-16le")) {
      if (We.length < 2 || Le.length < 2)
        return -1;
      It = 2, yt /= 2, jt /= 2, Ke /= 2;
    }
    function Lr(rr, Cr) {
      return It === 1 ? rr[Cr] : rr.readUInt16BE(Cr * It);
    }
    let zt;
    if (lt) {
      let rr = -1;
      for (zt = Ke; zt < yt; zt++)
        if (Lr(We, zt) === Lr(Le, rr === -1 ? 0 : zt - rr)) {
          if (rr === -1 && (rr = zt), zt - rr + 1 === jt)
            return rr * It;
        } else
          rr !== -1 && (zt -= zt - rr), rr = -1;
    } else
      for (Ke + jt > yt && (Ke = yt - jt), zt = Ke; zt >= 0; zt--) {
        let rr = !0;
        for (let Cr = 0; Cr < jt; Cr++)
          if (Lr(We, zt + Cr) !== Lr(Le, Cr)) {
            rr = !1;
            break;
          }
        if (rr)
          return zt;
      }
    return -1;
  }
  Se.prototype.includes = function(Le, Ke, rt) {
    return this.indexOf(Le, Ke, rt) !== -1;
  }, Se.prototype.indexOf = function(Le, Ke, rt) {
    return ze(this, Le, Ke, rt, !0);
  }, Se.prototype.lastIndexOf = function(Le, Ke, rt) {
    return ze(this, Le, Ke, rt, !1);
  };
  function $e(We, Le, Ke, rt) {
    Ke = Number(Ke) || 0;
    const lt = We.length - Ke;
    rt ? (rt = Number(rt), rt > lt && (rt = lt)) : rt = lt;
    const It = Le.length;
    rt > It / 2 && (rt = It / 2);
    let yt;
    for (yt = 0; yt < rt; ++yt) {
      const jt = parseInt(Le.substr(yt * 2, 2), 16);
      if (Dr(jt))
        return yt;
      We[Ke + yt] = jt;
    }
    return yt;
  }
  function le(We, Le, Ke, rt) {
    return Wt(Hr(Le, We.length - Ke), We, Ke, rt);
  }
  function pe(We, Le, Ke, rt) {
    return Wt(tr(Le), We, Ke, rt);
  }
  function ge(We, Le, Ke, rt) {
    return Wt(qr(Le), We, Ke, rt);
  }
  function ye(We, Le, Ke, rt) {
    return Wt(cr(Le, We.length - Ke), We, Ke, rt);
  }
  Se.prototype.write = function(Le, Ke, rt, lt) {
    if (Ke === void 0)
      lt = "utf8", rt = this.length, Ke = 0;
    else if (rt === void 0 && typeof Ke == "string")
      lt = Ke, rt = this.length, Ke = 0;
    else if (isFinite(Ke))
      Ke = Ke >>> 0, isFinite(rt) ? (rt = rt >>> 0, lt === void 0 && (lt = "utf8")) : (lt = rt, rt = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const It = this.length - Ke;
    if ((rt === void 0 || rt > It) && (rt = It), Le.length > 0 && (rt < 0 || Ke < 0) || Ke > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    lt || (lt = "utf8");
    let yt = !1;
    for (; ; )
      switch (lt) {
        case "hex":
          return $e(this, Le, Ke, rt);
        case "utf8":
        case "utf-8":
          return le(this, Le, Ke, rt);
        case "ascii":
        case "latin1":
        case "binary":
          return pe(this, Le, Ke, rt);
        case "base64":
          return ge(this, Le, Ke, rt);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ye(this, Le, Ke, rt);
        default:
          if (yt)
            throw new TypeError("Unknown encoding: " + lt);
          lt = ("" + lt).toLowerCase(), yt = !0;
      }
  }, Se.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function xe(We, Le, Ke) {
    return Le === 0 && Ke === We.length ? ie.fromByteArray(We) : ie.fromByteArray(We.slice(Le, Ke));
  }
  function _e(We, Le, Ke) {
    Ke = Math.min(We.length, Ke);
    const rt = [];
    let lt = Le;
    for (; lt < Ke; ) {
      const It = We[lt];
      let yt = null, jt = It > 239 ? 4 : It > 223 ? 3 : It > 191 ? 2 : 1;
      if (lt + jt <= Ke) {
        let Lr, zt, rr, Cr;
        switch (jt) {
          case 1:
            It < 128 && (yt = It);
            break;
          case 2:
            Lr = We[lt + 1], (Lr & 192) === 128 && (Cr = (It & 31) << 6 | Lr & 63, Cr > 127 && (yt = Cr));
            break;
          case 3:
            Lr = We[lt + 1], zt = We[lt + 2], (Lr & 192) === 128 && (zt & 192) === 128 && (Cr = (It & 15) << 12 | (Lr & 63) << 6 | zt & 63, Cr > 2047 && (Cr < 55296 || Cr > 57343) && (yt = Cr));
            break;
          case 4:
            Lr = We[lt + 1], zt = We[lt + 2], rr = We[lt + 3], (Lr & 192) === 128 && (zt & 192) === 128 && (rr & 192) === 128 && (Cr = (It & 15) << 18 | (Lr & 63) << 12 | (zt & 63) << 6 | rr & 63, Cr > 65535 && Cr < 1114112 && (yt = Cr));
        }
      }
      yt === null ? (yt = 65533, jt = 1) : yt > 65535 && (yt -= 65536, rt.push(yt >>> 10 & 1023 | 55296), yt = 56320 | yt & 1023), rt.push(yt), lt += jt;
    }
    return ve(rt);
  }
  const Ae = 4096;
  function ve(We) {
    const Le = We.length;
    if (Le <= Ae)
      return String.fromCharCode.apply(String, We);
    let Ke = "", rt = 0;
    for (; rt < Le; )
      Ke += String.fromCharCode.apply(
        String,
        We.slice(rt, rt += Ae)
      );
    return Ke;
  }
  function he(We, Le, Ke) {
    let rt = "";
    Ke = Math.min(We.length, Ke);
    for (let lt = Le; lt < Ke; ++lt)
      rt += String.fromCharCode(We[lt] & 127);
    return rt;
  }
  function be(We, Le, Ke) {
    let rt = "";
    Ke = Math.min(We.length, Ke);
    for (let lt = Le; lt < Ke; ++lt)
      rt += String.fromCharCode(We[lt]);
    return rt;
  }
  function Me(We, Le, Ke) {
    const rt = We.length;
    (!Le || Le < 0) && (Le = 0), (!Ke || Ke < 0 || Ke > rt) && (Ke = rt);
    let lt = "";
    for (let It = Le; It < Ke; ++It)
      lt += Jt[We[It]];
    return lt;
  }
  function Re(We, Le, Ke) {
    const rt = We.slice(Le, Ke);
    let lt = "";
    for (let It = 0; It < rt.length - 1; It += 2)
      lt += String.fromCharCode(rt[It] + rt[It + 1] * 256);
    return lt;
  }
  Se.prototype.slice = function(Le, Ke) {
    const rt = this.length;
    Le = ~~Le, Ke = Ke === void 0 ? rt : ~~Ke, Le < 0 ? (Le += rt, Le < 0 && (Le = 0)) : Le > rt && (Le = rt), Ke < 0 ? (Ke += rt, Ke < 0 && (Ke = 0)) : Ke > rt && (Ke = rt), Ke < Le && (Ke = Le);
    const lt = this.subarray(Le, Ke);
    return Object.setPrototypeOf(lt, Se.prototype), lt;
  };
  function Oe(We, Le, Ke) {
    if (We % 1 !== 0 || We < 0)
      throw new RangeError("offset is not uint");
    if (We + Le > Ke)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Se.prototype.readUintLE = Se.prototype.readUIntLE = function(Le, Ke, rt) {
    Le = Le >>> 0, Ke = Ke >>> 0, rt || Oe(Le, Ke, this.length);
    let lt = this[Le], It = 1, yt = 0;
    for (; ++yt < Ke && (It *= 256); )
      lt += this[Le + yt] * It;
    return lt;
  }, Se.prototype.readUintBE = Se.prototype.readUIntBE = function(Le, Ke, rt) {
    Le = Le >>> 0, Ke = Ke >>> 0, rt || Oe(Le, Ke, this.length);
    let lt = this[Le + --Ke], It = 1;
    for (; Ke > 0 && (It *= 256); )
      lt += this[Le + --Ke] * It;
    return lt;
  }, Se.prototype.readUint8 = Se.prototype.readUInt8 = function(Le, Ke) {
    return Le = Le >>> 0, Ke || Oe(Le, 1, this.length), this[Le];
  }, Se.prototype.readUint16LE = Se.prototype.readUInt16LE = function(Le, Ke) {
    return Le = Le >>> 0, Ke || Oe(Le, 2, this.length), this[Le] | this[Le + 1] << 8;
  }, Se.prototype.readUint16BE = Se.prototype.readUInt16BE = function(Le, Ke) {
    return Le = Le >>> 0, Ke || Oe(Le, 2, this.length), this[Le] << 8 | this[Le + 1];
  }, Se.prototype.readUint32LE = Se.prototype.readUInt32LE = function(Le, Ke) {
    return Le = Le >>> 0, Ke || Oe(Le, 4, this.length), (this[Le] | this[Le + 1] << 8 | this[Le + 2] << 16) + this[Le + 3] * 16777216;
  }, Se.prototype.readUint32BE = Se.prototype.readUInt32BE = function(Le, Ke) {
    return Le = Le >>> 0, Ke || Oe(Le, 4, this.length), this[Le] * 16777216 + (this[Le + 1] << 16 | this[Le + 2] << 8 | this[Le + 3]);
  }, Se.prototype.readBigUInt64LE = ir(function(Le) {
    Le = Le >>> 0, Lt(Le, "offset");
    const Ke = this[Le], rt = this[Le + 7];
    (Ke === void 0 || rt === void 0) && Tr(Le, this.length - 8);
    const lt = Ke + this[++Le] * 2 ** 8 + this[++Le] * 2 ** 16 + this[++Le] * 2 ** 24, It = this[++Le] + this[++Le] * 2 ** 8 + this[++Le] * 2 ** 16 + rt * 2 ** 24;
    return BigInt(lt) + (BigInt(It) << BigInt(32));
  }), Se.prototype.readBigUInt64BE = ir(function(Le) {
    Le = Le >>> 0, Lt(Le, "offset");
    const Ke = this[Le], rt = this[Le + 7];
    (Ke === void 0 || rt === void 0) && Tr(Le, this.length - 8);
    const lt = Ke * 2 ** 24 + this[++Le] * 2 ** 16 + this[++Le] * 2 ** 8 + this[++Le], It = this[++Le] * 2 ** 24 + this[++Le] * 2 ** 16 + this[++Le] * 2 ** 8 + rt;
    return (BigInt(lt) << BigInt(32)) + BigInt(It);
  }), Se.prototype.readIntLE = function(Le, Ke, rt) {
    Le = Le >>> 0, Ke = Ke >>> 0, rt || Oe(Le, Ke, this.length);
    let lt = this[Le], It = 1, yt = 0;
    for (; ++yt < Ke && (It *= 256); )
      lt += this[Le + yt] * It;
    return It *= 128, lt >= It && (lt -= Math.pow(2, 8 * Ke)), lt;
  }, Se.prototype.readIntBE = function(Le, Ke, rt) {
    Le = Le >>> 0, Ke = Ke >>> 0, rt || Oe(Le, Ke, this.length);
    let lt = Ke, It = 1, yt = this[Le + --lt];
    for (; lt > 0 && (It *= 256); )
      yt += this[Le + --lt] * It;
    return It *= 128, yt >= It && (yt -= Math.pow(2, 8 * Ke)), yt;
  }, Se.prototype.readInt8 = function(Le, Ke) {
    return Le = Le >>> 0, Ke || Oe(Le, 1, this.length), this[Le] & 128 ? (255 - this[Le] + 1) * -1 : this[Le];
  }, Se.prototype.readInt16LE = function(Le, Ke) {
    Le = Le >>> 0, Ke || Oe(Le, 2, this.length);
    const rt = this[Le] | this[Le + 1] << 8;
    return rt & 32768 ? rt | 4294901760 : rt;
  }, Se.prototype.readInt16BE = function(Le, Ke) {
    Le = Le >>> 0, Ke || Oe(Le, 2, this.length);
    const rt = this[Le + 1] | this[Le] << 8;
    return rt & 32768 ? rt | 4294901760 : rt;
  }, Se.prototype.readInt32LE = function(Le, Ke) {
    return Le = Le >>> 0, Ke || Oe(Le, 4, this.length), this[Le] | this[Le + 1] << 8 | this[Le + 2] << 16 | this[Le + 3] << 24;
  }, Se.prototype.readInt32BE = function(Le, Ke) {
    return Le = Le >>> 0, Ke || Oe(Le, 4, this.length), this[Le] << 24 | this[Le + 1] << 16 | this[Le + 2] << 8 | this[Le + 3];
  }, Se.prototype.readBigInt64LE = ir(function(Le) {
    Le = Le >>> 0, Lt(Le, "offset");
    const Ke = this[Le], rt = this[Le + 7];
    (Ke === void 0 || rt === void 0) && Tr(Le, this.length - 8);
    const lt = this[Le + 4] + this[Le + 5] * 2 ** 8 + this[Le + 6] * 2 ** 16 + (rt << 24);
    return (BigInt(lt) << BigInt(32)) + BigInt(Ke + this[++Le] * 2 ** 8 + this[++Le] * 2 ** 16 + this[++Le] * 2 ** 24);
  }), Se.prototype.readBigInt64BE = ir(function(Le) {
    Le = Le >>> 0, Lt(Le, "offset");
    const Ke = this[Le], rt = this[Le + 7];
    (Ke === void 0 || rt === void 0) && Tr(Le, this.length - 8);
    const lt = (Ke << 24) + // Overflow
    this[++Le] * 2 ** 16 + this[++Le] * 2 ** 8 + this[++Le];
    return (BigInt(lt) << BigInt(32)) + BigInt(this[++Le] * 2 ** 24 + this[++Le] * 2 ** 16 + this[++Le] * 2 ** 8 + rt);
  }), Se.prototype.readFloatLE = function(Le, Ke) {
    return Le = Le >>> 0, Ke || Oe(Le, 4, this.length), se.read(this, Le, !0, 23, 4);
  }, Se.prototype.readFloatBE = function(Le, Ke) {
    return Le = Le >>> 0, Ke || Oe(Le, 4, this.length), se.read(this, Le, !1, 23, 4);
  }, Se.prototype.readDoubleLE = function(Le, Ke) {
    return Le = Le >>> 0, Ke || Oe(Le, 8, this.length), se.read(this, Le, !0, 52, 8);
  }, Se.prototype.readDoubleBE = function(Le, Ke) {
    return Le = Le >>> 0, Ke || Oe(Le, 8, this.length), se.read(this, Le, !1, 52, 8);
  };
  function Te(We, Le, Ke, rt, lt, It) {
    if (!Se.isBuffer(We))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (Le > lt || Le < It)
      throw new RangeError('"value" argument is out of bounds');
    if (Ke + rt > We.length)
      throw new RangeError("Index out of range");
  }
  Se.prototype.writeUintLE = Se.prototype.writeUIntLE = function(Le, Ke, rt, lt) {
    if (Le = +Le, Ke = Ke >>> 0, rt = rt >>> 0, !lt) {
      const jt = Math.pow(2, 8 * rt) - 1;
      Te(this, Le, Ke, rt, jt, 0);
    }
    let It = 1, yt = 0;
    for (this[Ke] = Le & 255; ++yt < rt && (It *= 256); )
      this[Ke + yt] = Le / It & 255;
    return Ke + rt;
  }, Se.prototype.writeUintBE = Se.prototype.writeUIntBE = function(Le, Ke, rt, lt) {
    if (Le = +Le, Ke = Ke >>> 0, rt = rt >>> 0, !lt) {
      const jt = Math.pow(2, 8 * rt) - 1;
      Te(this, Le, Ke, rt, jt, 0);
    }
    let It = rt - 1, yt = 1;
    for (this[Ke + It] = Le & 255; --It >= 0 && (yt *= 256); )
      this[Ke + It] = Le / yt & 255;
    return Ke + rt;
  }, Se.prototype.writeUint8 = Se.prototype.writeUInt8 = function(Le, Ke, rt) {
    return Le = +Le, Ke = Ke >>> 0, rt || Te(this, Le, Ke, 1, 255, 0), this[Ke] = Le & 255, Ke + 1;
  }, Se.prototype.writeUint16LE = Se.prototype.writeUInt16LE = function(Le, Ke, rt) {
    return Le = +Le, Ke = Ke >>> 0, rt || Te(this, Le, Ke, 2, 65535, 0), this[Ke] = Le & 255, this[Ke + 1] = Le >>> 8, Ke + 2;
  }, Se.prototype.writeUint16BE = Se.prototype.writeUInt16BE = function(Le, Ke, rt) {
    return Le = +Le, Ke = Ke >>> 0, rt || Te(this, Le, Ke, 2, 65535, 0), this[Ke] = Le >>> 8, this[Ke + 1] = Le & 255, Ke + 2;
  }, Se.prototype.writeUint32LE = Se.prototype.writeUInt32LE = function(Le, Ke, rt) {
    return Le = +Le, Ke = Ke >>> 0, rt || Te(this, Le, Ke, 4, 4294967295, 0), this[Ke + 3] = Le >>> 24, this[Ke + 2] = Le >>> 16, this[Ke + 1] = Le >>> 8, this[Ke] = Le & 255, Ke + 4;
  }, Se.prototype.writeUint32BE = Se.prototype.writeUInt32BE = function(Le, Ke, rt) {
    return Le = +Le, Ke = Ke >>> 0, rt || Te(this, Le, Ke, 4, 4294967295, 0), this[Ke] = Le >>> 24, this[Ke + 1] = Le >>> 16, this[Ke + 2] = Le >>> 8, this[Ke + 3] = Le & 255, Ke + 4;
  };
  function Fe(We, Le, Ke, rt, lt) {
    $t(Le, rt, lt, We, Ke, 7);
    let It = Number(Le & BigInt(4294967295));
    We[Ke++] = It, It = It >> 8, We[Ke++] = It, It = It >> 8, We[Ke++] = It, It = It >> 8, We[Ke++] = It;
    let yt = Number(Le >> BigInt(32) & BigInt(4294967295));
    return We[Ke++] = yt, yt = yt >> 8, We[Ke++] = yt, yt = yt >> 8, We[Ke++] = yt, yt = yt >> 8, We[Ke++] = yt, Ke;
  }
  function je(We, Le, Ke, rt, lt) {
    $t(Le, rt, lt, We, Ke, 7);
    let It = Number(Le & BigInt(4294967295));
    We[Ke + 7] = It, It = It >> 8, We[Ke + 6] = It, It = It >> 8, We[Ke + 5] = It, It = It >> 8, We[Ke + 4] = It;
    let yt = Number(Le >> BigInt(32) & BigInt(4294967295));
    return We[Ke + 3] = yt, yt = yt >> 8, We[Ke + 2] = yt, yt = yt >> 8, We[Ke + 1] = yt, yt = yt >> 8, We[Ke] = yt, Ke + 8;
  }
  Se.prototype.writeBigUInt64LE = ir(function(Le, Ke = 0) {
    return Fe(this, Le, Ke, BigInt(0), BigInt("0xffffffffffffffff"));
  }), Se.prototype.writeBigUInt64BE = ir(function(Le, Ke = 0) {
    return je(this, Le, Ke, BigInt(0), BigInt("0xffffffffffffffff"));
  }), Se.prototype.writeIntLE = function(Le, Ke, rt, lt) {
    if (Le = +Le, Ke = Ke >>> 0, !lt) {
      const Lr = Math.pow(2, 8 * rt - 1);
      Te(this, Le, Ke, rt, Lr - 1, -Lr);
    }
    let It = 0, yt = 1, jt = 0;
    for (this[Ke] = Le & 255; ++It < rt && (yt *= 256); )
      Le < 0 && jt === 0 && this[Ke + It - 1] !== 0 && (jt = 1), this[Ke + It] = (Le / yt >> 0) - jt & 255;
    return Ke + rt;
  }, Se.prototype.writeIntBE = function(Le, Ke, rt, lt) {
    if (Le = +Le, Ke = Ke >>> 0, !lt) {
      const Lr = Math.pow(2, 8 * rt - 1);
      Te(this, Le, Ke, rt, Lr - 1, -Lr);
    }
    let It = rt - 1, yt = 1, jt = 0;
    for (this[Ke + It] = Le & 255; --It >= 0 && (yt *= 256); )
      Le < 0 && jt === 0 && this[Ke + It + 1] !== 0 && (jt = 1), this[Ke + It] = (Le / yt >> 0) - jt & 255;
    return Ke + rt;
  }, Se.prototype.writeInt8 = function(Le, Ke, rt) {
    return Le = +Le, Ke = Ke >>> 0, rt || Te(this, Le, Ke, 1, 127, -128), Le < 0 && (Le = 255 + Le + 1), this[Ke] = Le & 255, Ke + 1;
  }, Se.prototype.writeInt16LE = function(Le, Ke, rt) {
    return Le = +Le, Ke = Ke >>> 0, rt || Te(this, Le, Ke, 2, 32767, -32768), this[Ke] = Le & 255, this[Ke + 1] = Le >>> 8, Ke + 2;
  }, Se.prototype.writeInt16BE = function(Le, Ke, rt) {
    return Le = +Le, Ke = Ke >>> 0, rt || Te(this, Le, Ke, 2, 32767, -32768), this[Ke] = Le >>> 8, this[Ke + 1] = Le & 255, Ke + 2;
  }, Se.prototype.writeInt32LE = function(Le, Ke, rt) {
    return Le = +Le, Ke = Ke >>> 0, rt || Te(this, Le, Ke, 4, 2147483647, -2147483648), this[Ke] = Le & 255, this[Ke + 1] = Le >>> 8, this[Ke + 2] = Le >>> 16, this[Ke + 3] = Le >>> 24, Ke + 4;
  }, Se.prototype.writeInt32BE = function(Le, Ke, rt) {
    return Le = +Le, Ke = Ke >>> 0, rt || Te(this, Le, Ke, 4, 2147483647, -2147483648), Le < 0 && (Le = 4294967295 + Le + 1), this[Ke] = Le >>> 24, this[Ke + 1] = Le >>> 16, this[Ke + 2] = Le >>> 8, this[Ke + 3] = Le & 255, Ke + 4;
  }, Se.prototype.writeBigInt64LE = ir(function(Le, Ke = 0) {
    return Fe(this, Le, Ke, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), Se.prototype.writeBigInt64BE = ir(function(Le, Ke = 0) {
    return je(this, Le, Ke, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function ct(We, Le, Ke, rt, lt, It) {
    if (Ke + rt > We.length)
      throw new RangeError("Index out of range");
    if (Ke < 0)
      throw new RangeError("Index out of range");
  }
  function nt(We, Le, Ke, rt, lt) {
    return Le = +Le, Ke = Ke >>> 0, lt || ct(We, Le, Ke, 4), se.write(We, Le, Ke, rt, 23, 4), Ke + 4;
  }
  Se.prototype.writeFloatLE = function(Le, Ke, rt) {
    return nt(this, Le, Ke, !0, rt);
  }, Se.prototype.writeFloatBE = function(Le, Ke, rt) {
    return nt(this, Le, Ke, !1, rt);
  };
  function dt(We, Le, Ke, rt, lt) {
    return Le = +Le, Ke = Ke >>> 0, lt || ct(We, Le, Ke, 8), se.write(We, Le, Ke, rt, 52, 8), Ke + 8;
  }
  Se.prototype.writeDoubleLE = function(Le, Ke, rt) {
    return dt(this, Le, Ke, !0, rt);
  }, Se.prototype.writeDoubleBE = function(Le, Ke, rt) {
    return dt(this, Le, Ke, !1, rt);
  }, Se.prototype.copy = function(Le, Ke, rt, lt) {
    if (!Se.isBuffer(Le))
      throw new TypeError("argument should be a Buffer");
    if (rt || (rt = 0), !lt && lt !== 0 && (lt = this.length), Ke >= Le.length && (Ke = Le.length), Ke || (Ke = 0), lt > 0 && lt < rt && (lt = rt), lt === rt || Le.length === 0 || this.length === 0)
      return 0;
    if (Ke < 0)
      throw new RangeError("targetStart out of bounds");
    if (rt < 0 || rt >= this.length)
      throw new RangeError("Index out of range");
    if (lt < 0)
      throw new RangeError("sourceEnd out of bounds");
    lt > this.length && (lt = this.length), Le.length - Ke < lt - rt && (lt = Le.length - Ke + rt);
    const It = lt - rt;
    return this === Le && typeof ce.prototype.copyWithin == "function" ? this.copyWithin(Ke, rt, lt) : ce.prototype.set.call(
      Le,
      this.subarray(rt, lt),
      Ke
    ), It;
  }, Se.prototype.fill = function(Le, Ke, rt, lt) {
    if (typeof Le == "string") {
      if (typeof Ke == "string" ? (lt = Ke, Ke = 0, rt = this.length) : typeof rt == "string" && (lt = rt, rt = this.length), lt !== void 0 && typeof lt != "string")
        throw new TypeError("encoding must be a string");
      if (typeof lt == "string" && !Se.isEncoding(lt))
        throw new TypeError("Unknown encoding: " + lt);
      if (Le.length === 1) {
        const yt = Le.charCodeAt(0);
        (lt === "utf8" && yt < 128 || lt === "latin1") && (Le = yt);
      }
    } else
      typeof Le == "number" ? Le = Le & 255 : typeof Le == "boolean" && (Le = Number(Le));
    if (Ke < 0 || this.length < Ke || this.length < rt)
      throw new RangeError("Out of range index");
    if (rt <= Ke)
      return this;
    Ke = Ke >>> 0, rt = rt === void 0 ? this.length : rt >>> 0, Le || (Le = 0);
    let It;
    if (typeof Le == "number")
      for (It = Ke; It < rt; ++It)
        this[It] = Le;
    else {
      const yt = Se.isBuffer(Le) ? Le : Se.from(Le, lt), jt = yt.length;
      if (jt === 0)
        throw new TypeError('The value "' + Le + '" is invalid for argument "value"');
      for (It = 0; It < rt - Ke; ++It)
        this[It + Ke] = yt[It % jt];
    }
    return this;
  };
  const it = {};
  function Je(We, Le, Ke) {
    it[We] = class extends Ke {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: Le.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${We}]`, this.stack, delete this.name;
      }
      get code() {
        return We;
      }
      set code(lt) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: lt,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${We}]: ${this.message}`;
      }
    };
  }
  Je(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(We) {
      return We ? `${We} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Je(
    "ERR_INVALID_ARG_TYPE",
    function(We, Le) {
      return `The "${We}" argument must be of type number. Received type ${typeof Le}`;
    },
    TypeError
  ), Je(
    "ERR_OUT_OF_RANGE",
    function(We, Le, Ke) {
      let rt = `The value of "${We}" is out of range.`, lt = Ke;
      return Number.isInteger(Ke) && Math.abs(Ke) > 2 ** 32 ? lt = gt(String(Ke)) : typeof Ke == "bigint" && (lt = String(Ke), (Ke > BigInt(2) ** BigInt(32) || Ke < -(BigInt(2) ** BigInt(32))) && (lt = gt(lt)), lt += "n"), rt += ` It must be ${Le}. Received ${lt}`, rt;
    },
    RangeError
  );
  function gt(We) {
    let Le = "", Ke = We.length;
    const rt = We[0] === "-" ? 1 : 0;
    for (; Ke >= rt + 4; Ke -= 3)
      Le = `_${We.slice(Ke - 3, Ke)}${Le}`;
    return `${We.slice(0, Ke)}${Le}`;
  }
  function Ht(We, Le, Ke) {
    Lt(Le, "offset"), (We[Le] === void 0 || We[Le + Ke] === void 0) && Tr(Le, We.length - (Ke + 1));
  }
  function $t(We, Le, Ke, rt, lt, It) {
    if (We > Ke || We < Le) {
      const yt = typeof Le == "bigint" ? "n" : "";
      let jt;
      throw It > 3 ? Le === 0 || Le === BigInt(0) ? jt = `>= 0${yt} and < 2${yt} ** ${(It + 1) * 8}${yt}` : jt = `>= -(2${yt} ** ${(It + 1) * 8 - 1}${yt}) and < 2 ** ${(It + 1) * 8 - 1}${yt}` : jt = `>= ${Le}${yt} and <= ${Ke}${yt}`, new it.ERR_OUT_OF_RANGE("value", jt, We);
    }
    Ht(rt, lt, It);
  }
  function Lt(We, Le) {
    if (typeof We != "number")
      throw new it.ERR_INVALID_ARG_TYPE(Le, "number", We);
  }
  function Tr(We, Le, Ke) {
    throw Math.floor(We) !== We ? (Lt(We, Ke), new it.ERR_OUT_OF_RANGE(Ke || "offset", "an integer", We)) : Le < 0 ? new it.ERR_BUFFER_OUT_OF_BOUNDS() : new it.ERR_OUT_OF_RANGE(
      Ke || "offset",
      `>= ${Ke ? 1 : 0} and <= ${Le}`,
      We
    );
  }
  const Zt = /[^+/0-9A-Za-z-_]/g;
  function wt(We) {
    if (We = We.split("=")[0], We = We.trim().replace(Zt, ""), We.length < 2)
      return "";
    for (; We.length % 4 !== 0; )
      We = We + "=";
    return We;
  }
  function Hr(We, Le) {
    Le = Le || 1 / 0;
    let Ke;
    const rt = We.length;
    let lt = null;
    const It = [];
    for (let yt = 0; yt < rt; ++yt) {
      if (Ke = We.charCodeAt(yt), Ke > 55295 && Ke < 57344) {
        if (!lt) {
          if (Ke > 56319) {
            (Le -= 3) > -1 && It.push(239, 191, 189);
            continue;
          } else if (yt + 1 === rt) {
            (Le -= 3) > -1 && It.push(239, 191, 189);
            continue;
          }
          lt = Ke;
          continue;
        }
        if (Ke < 56320) {
          (Le -= 3) > -1 && It.push(239, 191, 189), lt = Ke;
          continue;
        }
        Ke = (lt - 55296 << 10 | Ke - 56320) + 65536;
      } else
        lt && (Le -= 3) > -1 && It.push(239, 191, 189);
      if (lt = null, Ke < 128) {
        if ((Le -= 1) < 0)
          break;
        It.push(Ke);
      } else if (Ke < 2048) {
        if ((Le -= 2) < 0)
          break;
        It.push(
          Ke >> 6 | 192,
          Ke & 63 | 128
        );
      } else if (Ke < 65536) {
        if ((Le -= 3) < 0)
          break;
        It.push(
          Ke >> 12 | 224,
          Ke >> 6 & 63 | 128,
          Ke & 63 | 128
        );
      } else if (Ke < 1114112) {
        if ((Le -= 4) < 0)
          break;
        It.push(
          Ke >> 18 | 240,
          Ke >> 12 & 63 | 128,
          Ke >> 6 & 63 | 128,
          Ke & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return It;
  }
  function tr(We) {
    const Le = [];
    for (let Ke = 0; Ke < We.length; ++Ke)
      Le.push(We.charCodeAt(Ke) & 255);
    return Le;
  }
  function cr(We, Le) {
    let Ke, rt, lt;
    const It = [];
    for (let yt = 0; yt < We.length && !((Le -= 2) < 0); ++yt)
      Ke = We.charCodeAt(yt), rt = Ke >> 8, lt = Ke % 256, It.push(lt), It.push(rt);
    return It;
  }
  function qr(We) {
    return ie.toByteArray(wt(We));
  }
  function Wt(We, Le, Ke, rt) {
    let lt;
    for (lt = 0; lt < rt && !(lt + Ke >= Le.length || lt >= We.length); ++lt)
      Le[lt + Ke] = We[lt];
    return lt;
  }
  function ar(We, Le) {
    return We instanceof Le || We != null && We.constructor != null && We.constructor.name != null && We.constructor.name === Le.name;
  }
  function Dr(We) {
    return We !== We;
  }
  const Jt = function() {
    const We = "0123456789abcdef", Le = new Array(256);
    for (let Ke = 0; Ke < 16; ++Ke) {
      const rt = Ke * 16;
      for (let lt = 0; lt < 16; ++lt)
        Le[rt + lt] = We[Ke] + We[lt];
    }
    return Le;
  }();
  function ir(We) {
    return typeof BigInt > "u" ? Gr : We;
  }
  function Gr() {
    throw new Error("BigInt not supported");
  }
})(buffer$2);
const Buffer$F = buffer$2.Buffer, Buffer$1$1 = buffer$2.Buffer, dist$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Buffer: Buffer$1$1,
  default: Buffer$F
}, Symbol.toStringTag, { value: "Module" }));
function AxiosError$1(ae, ie, se, fe, ue) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = ae, this.name = "AxiosError", ie && (this.code = ie), se && (this.config = se), fe && (this.request = fe), ue && (this.response = ue);
}
utils$t.inherits(AxiosError$1, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$t.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$3 = AxiosError$1.prototype, descriptors$1 = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((ae) => {
  descriptors$1[ae] = { value: ae };
});
Object.defineProperties(AxiosError$1, descriptors$1);
Object.defineProperty(prototype$3, "isAxiosError", { value: !0 });
AxiosError$1.from = (ae, ie, se, fe, ue, ce) => {
  const de = Object.create(prototype$3);
  return utils$t.toFlatObject(ae, de, function(we) {
    return we !== Error.prototype;
  }, (me) => me !== "isAxiosError"), AxiosError$1.call(de, ae.message, ie, se, fe, ue), de.cause = ae, de.name = ae.name, ce && Object.assign(de, ce), de;
};
const httpAdapter$1 = null;
function isVisitable$1(ae) {
  return utils$t.isPlainObject(ae) || utils$t.isArray(ae);
}
function removeBrackets$1(ae) {
  return utils$t.endsWith(ae, "[]") ? ae.slice(0, -2) : ae;
}
function renderKey$1(ae, ie, se) {
  return ae ? ae.concat(ie).map(function(ue, ce) {
    return ue = removeBrackets$1(ue), !se && ce ? "[" + ue + "]" : ue;
  }).join(se ? "." : "") : ie;
}
function isFlatArray$1(ae) {
  return utils$t.isArray(ae) && !ae.some(isVisitable$1);
}
const predicates$1 = utils$t.toFlatObject(utils$t, {}, null, function(ie) {
  return /^is[A-Z]/.test(ie);
});
function toFormData$1(ae, ie, se) {
  if (!utils$t.isObject(ae))
    throw new TypeError("target must be an object");
  ie = ie || new FormData(), se = utils$t.toFlatObject(se, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(Ne, ke) {
    return !utils$t.isUndefined(ke[Ne]);
  });
  const fe = se.metaTokens, ue = se.visitor || Se, ce = se.dots, de = se.indexes, we = (se.Blob || typeof Blob < "u" && Blob) && utils$t.isSpecCompliantForm(ie);
  if (!utils$t.isFunction(ue))
    throw new TypeError("visitor must be a function");
  function Ee(Pe) {
    if (Pe === null)
      return "";
    if (utils$t.isDate(Pe))
      return Pe.toISOString();
    if (!we && utils$t.isBlob(Pe))
      throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
    return utils$t.isArrayBuffer(Pe) || utils$t.isTypedArray(Pe) ? we && typeof Blob == "function" ? new Blob([Pe]) : Buffer$F.from(Pe) : Pe;
  }
  function Se(Pe, Ne, ke) {
    let He = Pe;
    if (Pe && !ke && typeof Pe == "object") {
      if (utils$t.endsWith(Ne, "{}"))
        Ne = fe ? Ne : Ne.slice(0, -2), Pe = JSON.stringify(Pe);
      else if (utils$t.isArray(Pe) && isFlatArray$1(Pe) || (utils$t.isFileList(Pe) || utils$t.endsWith(Ne, "[]")) && (He = utils$t.toArray(Pe)))
        return Ne = removeBrackets$1(Ne), He.forEach(function(Ge, Ye) {
          !(utils$t.isUndefined(Ge) || Ge === null) && ie.append(
            // eslint-disable-next-line no-nested-ternary
            de === !0 ? renderKey$1([Ne], Ye, ce) : de === null ? Ne : Ne + "[]",
            Ee(Ge)
          );
        }), !1;
    }
    return isVisitable$1(Pe) ? !0 : (ie.append(renderKey$1(ke, Ne, ce), Ee(Pe)), !1);
  }
  const Be = [], Ce = Object.assign(predicates$1, {
    defaultVisitor: Se,
    convertValue: Ee,
    isVisitable: isVisitable$1
  });
  function Ie(Pe, Ne) {
    if (!utils$t.isUndefined(Pe)) {
      if (Be.indexOf(Pe) !== -1)
        throw Error("Circular reference detected in " + Ne.join("."));
      Be.push(Pe), utils$t.forEach(Pe, function(He, De) {
        (!(utils$t.isUndefined(He) || He === null) && ue.call(
          ie,
          He,
          utils$t.isString(De) ? De.trim() : De,
          Ne,
          Ce
        )) === !0 && Ie(He, Ne ? Ne.concat(De) : [De]);
      }), Be.pop();
    }
  }
  if (!utils$t.isObject(ae))
    throw new TypeError("data must be an object");
  return Ie(ae), ie;
}
function encode$5(ae) {
  const ie = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(ae).replace(/[!'()~]|%20|%00/g, function(fe) {
    return ie[fe];
  });
}
function AxiosURLSearchParams$1(ae, ie) {
  this._pairs = [], ae && toFormData$1(ae, this, ie);
}
const prototype$2 = AxiosURLSearchParams$1.prototype;
prototype$2.append = function(ie, se) {
  this._pairs.push([ie, se]);
};
prototype$2.toString = function(ie) {
  const se = ie ? function(fe) {
    return ie.call(this, fe, encode$5);
  } : encode$5;
  return this._pairs.map(function(ue) {
    return se(ue[0]) + "=" + se(ue[1]);
  }, "").join("&");
};
function encode$4(ae) {
  return encodeURIComponent(ae).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL$1(ae, ie, se) {
  if (!ie)
    return ae;
  const fe = se && se.encode || encode$4, ue = se && se.serialize;
  let ce;
  if (ue ? ce = ue(ie, se) : ce = utils$t.isURLSearchParams(ie) ? ie.toString() : new AxiosURLSearchParams$1(ie, se).toString(fe), ce) {
    const de = ae.indexOf("#");
    de !== -1 && (ae = ae.slice(0, de)), ae += (ae.indexOf("?") === -1 ? "?" : "&") + ce;
  }
  return ae;
}
let InterceptorManager$1 = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(ie, se, fe) {
    return this.handlers.push({
      fulfilled: ie,
      rejected: se,
      synchronous: fe ? fe.synchronous : !1,
      runWhen: fe ? fe.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(ie) {
    this.handlers[ie] && (this.handlers[ie] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(ie) {
    utils$t.forEach(this.handlers, function(fe) {
      fe !== null && ie(fe);
    });
  }
};
const transitionalDefaults$1 = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, URLSearchParams$2 = typeof URLSearchParams < "u" ? URLSearchParams : AxiosURLSearchParams$1, FormData$2 = typeof FormData < "u" ? FormData : null, Blob$3 = typeof Blob < "u" ? Blob : null, platform$3 = {
  isBrowser: !0,
  classes: {
    URLSearchParams: URLSearchParams$2,
    FormData: FormData$2,
    Blob: Blob$3
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, hasBrowserEnv$1 = typeof window < "u" && typeof document < "u", hasStandardBrowserEnv$1 = ((ae) => hasBrowserEnv$1 && ["ReactNative", "NativeScript", "NS"].indexOf(ae) < 0)(typeof navigator < "u" && navigator.product), hasStandardBrowserWebWorkerEnv$1 = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", utils$s = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: hasBrowserEnv$1,
  hasStandardBrowserEnv: hasStandardBrowserEnv$1,
  hasStandardBrowserWebWorkerEnv: hasStandardBrowserWebWorkerEnv$1
}, Symbol.toStringTag, { value: "Module" })), platform$2 = {
  ...utils$s,
  ...platform$3
};
function toURLEncodedForm$1(ae, ie) {
  return toFormData$1(ae, new platform$2.classes.URLSearchParams(), Object.assign({
    visitor: function(se, fe, ue, ce) {
      return platform$2.isNode && utils$t.isBuffer(se) ? (this.append(fe, se.toString("base64")), !1) : ce.defaultVisitor.apply(this, arguments);
    }
  }, ie));
}
function parsePropPath$1(ae) {
  return utils$t.matchAll(/\w+|\[(\w*)]/g, ae).map((ie) => ie[0] === "[]" ? "" : ie[1] || ie[0]);
}
function arrayToObject$1(ae) {
  const ie = {}, se = Object.keys(ae);
  let fe;
  const ue = se.length;
  let ce;
  for (fe = 0; fe < ue; fe++)
    ce = se[fe], ie[ce] = ae[ce];
  return ie;
}
function formDataToJSON$1(ae) {
  function ie(se, fe, ue, ce) {
    let de = se[ce++];
    if (de === "__proto__")
      return !0;
    const me = Number.isFinite(+de), we = ce >= se.length;
    return de = !de && utils$t.isArray(ue) ? ue.length : de, we ? (utils$t.hasOwnProp(ue, de) ? ue[de] = [ue[de], fe] : ue[de] = fe, !me) : ((!ue[de] || !utils$t.isObject(ue[de])) && (ue[de] = []), ie(se, fe, ue[de], ce) && utils$t.isArray(ue[de]) && (ue[de] = arrayToObject$1(ue[de])), !me);
  }
  if (utils$t.isFormData(ae) && utils$t.isFunction(ae.entries)) {
    const se = {};
    return utils$t.forEachEntry(ae, (fe, ue) => {
      ie(parsePropPath$1(fe), ue, se, 0);
    }), se;
  }
  return null;
}
function stringifySafely$1(ae, ie, se) {
  if (utils$t.isString(ae))
    try {
      return (ie || JSON.parse)(ae), utils$t.trim(ae);
    } catch (fe) {
      if (fe.name !== "SyntaxError")
        throw fe;
    }
  return (se || JSON.stringify)(ae);
}
const defaults$2 = {
  transitional: transitionalDefaults$1,
  adapter: ["xhr", "http"],
  transformRequest: [function(ie, se) {
    const fe = se.getContentType() || "", ue = fe.indexOf("application/json") > -1, ce = utils$t.isObject(ie);
    if (ce && utils$t.isHTMLForm(ie) && (ie = new FormData(ie)), utils$t.isFormData(ie))
      return ue ? JSON.stringify(formDataToJSON$1(ie)) : ie;
    if (utils$t.isArrayBuffer(ie) || utils$t.isBuffer(ie) || utils$t.isStream(ie) || utils$t.isFile(ie) || utils$t.isBlob(ie))
      return ie;
    if (utils$t.isArrayBufferView(ie))
      return ie.buffer;
    if (utils$t.isURLSearchParams(ie))
      return se.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), ie.toString();
    let me;
    if (ce) {
      if (fe.indexOf("application/x-www-form-urlencoded") > -1)
        return toURLEncodedForm$1(ie, this.formSerializer).toString();
      if ((me = utils$t.isFileList(ie)) || fe.indexOf("multipart/form-data") > -1) {
        const we = this.env && this.env.FormData;
        return toFormData$1(
          me ? { "files[]": ie } : ie,
          we && new we(),
          this.formSerializer
        );
      }
    }
    return ce || ue ? (se.setContentType("application/json", !1), stringifySafely$1(ie)) : ie;
  }],
  transformResponse: [function(ie) {
    const se = this.transitional || defaults$2.transitional, fe = se && se.forcedJSONParsing, ue = this.responseType === "json";
    if (ie && utils$t.isString(ie) && (fe && !this.responseType || ue)) {
      const de = !(se && se.silentJSONParsing) && ue;
      try {
        return JSON.parse(ie);
      } catch (me) {
        if (de)
          throw me.name === "SyntaxError" ? AxiosError$1.from(me, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response) : me;
      }
    }
    return ie;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform$2.classes.FormData,
    Blob: platform$2.classes.Blob
  },
  validateStatus: function(ie) {
    return ie >= 200 && ie < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$t.forEach(["delete", "get", "head", "post", "put", "patch"], (ae) => {
  defaults$2.headers[ae] = {};
});
const defaults$3 = defaults$2, ignoreDuplicateOf$1 = utils$t.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), parseHeaders$1 = (ae) => {
  const ie = {};
  let se, fe, ue;
  return ae && ae.split(`
`).forEach(function(de) {
    ue = de.indexOf(":"), se = de.substring(0, ue).trim().toLowerCase(), fe = de.substring(ue + 1).trim(), !(!se || ie[se] && ignoreDuplicateOf$1[se]) && (se === "set-cookie" ? ie[se] ? ie[se].push(fe) : ie[se] = [fe] : ie[se] = ie[se] ? ie[se] + ", " + fe : fe);
  }), ie;
}, $internals$1 = Symbol("internals");
function normalizeHeader$1(ae) {
  return ae && String(ae).trim().toLowerCase();
}
function normalizeValue$1(ae) {
  return ae === !1 || ae == null ? ae : utils$t.isArray(ae) ? ae.map(normalizeValue$1) : String(ae);
}
function parseTokens$1(ae) {
  const ie = /* @__PURE__ */ Object.create(null), se = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let fe;
  for (; fe = se.exec(ae); )
    ie[fe[1]] = fe[2];
  return ie;
}
const isValidHeaderName$1 = (ae) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(ae.trim());
function matchHeaderValue$1(ae, ie, se, fe, ue) {
  if (utils$t.isFunction(fe))
    return fe.call(this, ie, se);
  if (ue && (ie = se), !!utils$t.isString(ie)) {
    if (utils$t.isString(fe))
      return ie.indexOf(fe) !== -1;
    if (utils$t.isRegExp(fe))
      return fe.test(ie);
  }
}
function formatHeader$1(ae) {
  return ae.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (ie, se, fe) => se.toUpperCase() + fe);
}
function buildAccessors$1(ae, ie) {
  const se = utils$t.toCamelCase(" " + ie);
  ["get", "set", "has"].forEach((fe) => {
    Object.defineProperty(ae, fe + se, {
      value: function(ue, ce, de) {
        return this[fe].call(this, ie, ue, ce, de);
      },
      configurable: !0
    });
  });
}
let AxiosHeaders$2 = class {
  constructor(ie) {
    ie && this.set(ie);
  }
  set(ie, se, fe) {
    const ue = this;
    function ce(me, we, Ee) {
      const Se = normalizeHeader$1(we);
      if (!Se)
        throw new Error("header name must be a non-empty string");
      const Be = utils$t.findKey(ue, Se);
      (!Be || ue[Be] === void 0 || Ee === !0 || Ee === void 0 && ue[Be] !== !1) && (ue[Be || we] = normalizeValue$1(me));
    }
    const de = (me, we) => utils$t.forEach(me, (Ee, Se) => ce(Ee, Se, we));
    return utils$t.isPlainObject(ie) || ie instanceof this.constructor ? de(ie, se) : utils$t.isString(ie) && (ie = ie.trim()) && !isValidHeaderName$1(ie) ? de(parseHeaders$1(ie), se) : ie != null && ce(se, ie, fe), this;
  }
  get(ie, se) {
    if (ie = normalizeHeader$1(ie), ie) {
      const fe = utils$t.findKey(this, ie);
      if (fe) {
        const ue = this[fe];
        if (!se)
          return ue;
        if (se === !0)
          return parseTokens$1(ue);
        if (utils$t.isFunction(se))
          return se.call(this, ue, fe);
        if (utils$t.isRegExp(se))
          return se.exec(ue);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(ie, se) {
    if (ie = normalizeHeader$1(ie), ie) {
      const fe = utils$t.findKey(this, ie);
      return !!(fe && this[fe] !== void 0 && (!se || matchHeaderValue$1(this, this[fe], fe, se)));
    }
    return !1;
  }
  delete(ie, se) {
    const fe = this;
    let ue = !1;
    function ce(de) {
      if (de = normalizeHeader$1(de), de) {
        const me = utils$t.findKey(fe, de);
        me && (!se || matchHeaderValue$1(fe, fe[me], me, se)) && (delete fe[me], ue = !0);
      }
    }
    return utils$t.isArray(ie) ? ie.forEach(ce) : ce(ie), ue;
  }
  clear(ie) {
    const se = Object.keys(this);
    let fe = se.length, ue = !1;
    for (; fe--; ) {
      const ce = se[fe];
      (!ie || matchHeaderValue$1(this, this[ce], ce, ie, !0)) && (delete this[ce], ue = !0);
    }
    return ue;
  }
  normalize(ie) {
    const se = this, fe = {};
    return utils$t.forEach(this, (ue, ce) => {
      const de = utils$t.findKey(fe, ce);
      if (de) {
        se[de] = normalizeValue$1(ue), delete se[ce];
        return;
      }
      const me = ie ? formatHeader$1(ce) : String(ce).trim();
      me !== ce && delete se[ce], se[me] = normalizeValue$1(ue), fe[me] = !0;
    }), this;
  }
  concat(...ie) {
    return this.constructor.concat(this, ...ie);
  }
  toJSON(ie) {
    const se = /* @__PURE__ */ Object.create(null);
    return utils$t.forEach(this, (fe, ue) => {
      fe != null && fe !== !1 && (se[ue] = ie && utils$t.isArray(fe) ? fe.join(", ") : fe);
    }), se;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([ie, se]) => ie + ": " + se).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(ie) {
    return ie instanceof this ? ie : new this(ie);
  }
  static concat(ie, ...se) {
    const fe = new this(ie);
    return se.forEach((ue) => fe.set(ue)), fe;
  }
  static accessor(ie) {
    const fe = (this[$internals$1] = this[$internals$1] = {
      accessors: {}
    }).accessors, ue = this.prototype;
    function ce(de) {
      const me = normalizeHeader$1(de);
      fe[me] || (buildAccessors$1(ue, de), fe[me] = !0);
    }
    return utils$t.isArray(ie) ? ie.forEach(ce) : ce(ie), this;
  }
};
AxiosHeaders$2.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$t.reduceDescriptors(AxiosHeaders$2.prototype, ({ value: ae }, ie) => {
  let se = ie[0].toUpperCase() + ie.slice(1);
  return {
    get: () => ae,
    set(fe) {
      this[se] = fe;
    }
  };
});
utils$t.freezeMethods(AxiosHeaders$2);
const AxiosHeaders$3 = AxiosHeaders$2;
function transformData$1(ae, ie) {
  const se = this || defaults$3, fe = ie || se, ue = AxiosHeaders$3.from(fe.headers);
  let ce = fe.data;
  return utils$t.forEach(ae, function(me) {
    ce = me.call(se, ce, ue.normalize(), ie ? ie.status : void 0);
  }), ue.normalize(), ce;
}
function isCancel$1(ae) {
  return !!(ae && ae.__CANCEL__);
}
function CanceledError$1(ae, ie, se) {
  AxiosError$1.call(this, ae ?? "canceled", AxiosError$1.ERR_CANCELED, ie, se), this.name = "CanceledError";
}
utils$t.inherits(CanceledError$1, AxiosError$1, {
  __CANCEL__: !0
});
function settle$1(ae, ie, se) {
  const fe = se.config.validateStatus;
  !se.status || !fe || fe(se.status) ? ae(se) : ie(new AxiosError$1(
    "Request failed with status code " + se.status,
    [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(se.status / 100) - 4],
    se.config,
    se.request,
    se
  ));
}
const cookies$1 = platform$2.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(ae, ie, se, fe, ue, ce) {
      const de = [ae + "=" + encodeURIComponent(ie)];
      utils$t.isNumber(se) && de.push("expires=" + new Date(se).toGMTString()), utils$t.isString(fe) && de.push("path=" + fe), utils$t.isString(ue) && de.push("domain=" + ue), ce === !0 && de.push("secure"), document.cookie = de.join("; ");
    },
    read(ae) {
      const ie = document.cookie.match(new RegExp("(^|;\\s*)(" + ae + ")=([^;]*)"));
      return ie ? decodeURIComponent(ie[3]) : null;
    },
    remove(ae) {
      this.write(ae, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function isAbsoluteURL$1(ae) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(ae);
}
function combineURLs$1(ae, ie) {
  return ie ? ae.replace(/\/?\/$/, "") + "/" + ie.replace(/^\/+/, "") : ae;
}
function buildFullPath$1(ae, ie) {
  return ae && !isAbsoluteURL$1(ie) ? combineURLs$1(ae, ie) : ie;
}
const isURLSameOrigin$1 = platform$2.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const ie = /(msie|trident)/i.test(navigator.userAgent), se = document.createElement("a");
    let fe;
    function ue(ce) {
      let de = ce;
      return ie && (se.setAttribute("href", de), de = se.href), se.setAttribute("href", de), {
        href: se.href,
        protocol: se.protocol ? se.protocol.replace(/:$/, "") : "",
        host: se.host,
        search: se.search ? se.search.replace(/^\?/, "") : "",
        hash: se.hash ? se.hash.replace(/^#/, "") : "",
        hostname: se.hostname,
        port: se.port,
        pathname: se.pathname.charAt(0) === "/" ? se.pathname : "/" + se.pathname
      };
    }
    return fe = ue(window.location.href), function(de) {
      const me = utils$t.isString(de) ? ue(de) : de;
      return me.protocol === fe.protocol && me.host === fe.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function() {
    return function() {
      return !0;
    };
  }()
);
function parseProtocol$1(ae) {
  const ie = /^([-+\w]{1,25})(:?\/\/|:)/.exec(ae);
  return ie && ie[1] || "";
}
function speedometer$1(ae, ie) {
  ae = ae || 10;
  const se = new Array(ae), fe = new Array(ae);
  let ue = 0, ce = 0, de;
  return ie = ie !== void 0 ? ie : 1e3, function(we) {
    const Ee = Date.now(), Se = fe[ce];
    de || (de = Ee), se[ue] = we, fe[ue] = Ee;
    let Be = ce, Ce = 0;
    for (; Be !== ue; )
      Ce += se[Be++], Be = Be % ae;
    if (ue = (ue + 1) % ae, ue === ce && (ce = (ce + 1) % ae), Ee - de < ie)
      return;
    const Ie = Se && Ee - Se;
    return Ie ? Math.round(Ce * 1e3 / Ie) : void 0;
  };
}
function progressEventReducer$1(ae, ie) {
  let se = 0;
  const fe = speedometer$1(50, 250);
  return (ue) => {
    const ce = ue.loaded, de = ue.lengthComputable ? ue.total : void 0, me = ce - se, we = fe(me), Ee = ce <= de;
    se = ce;
    const Se = {
      loaded: ce,
      total: de,
      progress: de ? ce / de : void 0,
      bytes: me,
      rate: we || void 0,
      estimated: we && de && Ee ? (de - ce) / we : void 0,
      event: ue
    };
    Se[ie ? "download" : "upload"] = !0, ae(Se);
  };
}
const isXHRAdapterSupported$1 = typeof XMLHttpRequest < "u", xhrAdapter$1 = isXHRAdapterSupported$1 && function(ae) {
  return new Promise(function(se, fe) {
    let ue = ae.data;
    const ce = AxiosHeaders$3.from(ae.headers).normalize();
    let { responseType: de, withXSRFToken: me } = ae, we;
    function Ee() {
      ae.cancelToken && ae.cancelToken.unsubscribe(we), ae.signal && ae.signal.removeEventListener("abort", we);
    }
    let Se;
    if (utils$t.isFormData(ue)) {
      if (platform$2.hasStandardBrowserEnv || platform$2.hasStandardBrowserWebWorkerEnv)
        ce.setContentType(!1);
      else if ((Se = ce.getContentType()) !== !1) {
        const [Ne, ...ke] = Se ? Se.split(";").map((He) => He.trim()).filter(Boolean) : [];
        ce.setContentType([Ne || "multipart/form-data", ...ke].join("; "));
      }
    }
    let Be = new XMLHttpRequest();
    if (ae.auth) {
      const Ne = ae.auth.username || "", ke = ae.auth.password ? unescape(encodeURIComponent(ae.auth.password)) : "";
      ce.set("Authorization", "Basic " + btoa(Ne + ":" + ke));
    }
    const Ce = buildFullPath$1(ae.baseURL, ae.url);
    Be.open(ae.method.toUpperCase(), buildURL$1(Ce, ae.params, ae.paramsSerializer), !0), Be.timeout = ae.timeout;
    function Ie() {
      if (!Be)
        return;
      const Ne = AxiosHeaders$3.from(
        "getAllResponseHeaders" in Be && Be.getAllResponseHeaders()
      ), He = {
        data: !de || de === "text" || de === "json" ? Be.responseText : Be.response,
        status: Be.status,
        statusText: Be.statusText,
        headers: Ne,
        config: ae,
        request: Be
      };
      settle$1(function(Ge) {
        se(Ge), Ee();
      }, function(Ge) {
        fe(Ge), Ee();
      }, He), Be = null;
    }
    if ("onloadend" in Be ? Be.onloadend = Ie : Be.onreadystatechange = function() {
      !Be || Be.readyState !== 4 || Be.status === 0 && !(Be.responseURL && Be.responseURL.indexOf("file:") === 0) || setTimeout(Ie);
    }, Be.onabort = function() {
      Be && (fe(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, ae, Be)), Be = null);
    }, Be.onerror = function() {
      fe(new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, ae, Be)), Be = null;
    }, Be.ontimeout = function() {
      let ke = ae.timeout ? "timeout of " + ae.timeout + "ms exceeded" : "timeout exceeded";
      const He = ae.transitional || transitionalDefaults$1;
      ae.timeoutErrorMessage && (ke = ae.timeoutErrorMessage), fe(new AxiosError$1(
        ke,
        He.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
        ae,
        Be
      )), Be = null;
    }, platform$2.hasStandardBrowserEnv && (me && utils$t.isFunction(me) && (me = me(ae)), me || me !== !1 && isURLSameOrigin$1(Ce))) {
      const Ne = ae.xsrfHeaderName && ae.xsrfCookieName && cookies$1.read(ae.xsrfCookieName);
      Ne && ce.set(ae.xsrfHeaderName, Ne);
    }
    ue === void 0 && ce.setContentType(null), "setRequestHeader" in Be && utils$t.forEach(ce.toJSON(), function(ke, He) {
      Be.setRequestHeader(He, ke);
    }), utils$t.isUndefined(ae.withCredentials) || (Be.withCredentials = !!ae.withCredentials), de && de !== "json" && (Be.responseType = ae.responseType), typeof ae.onDownloadProgress == "function" && Be.addEventListener("progress", progressEventReducer$1(ae.onDownloadProgress, !0)), typeof ae.onUploadProgress == "function" && Be.upload && Be.upload.addEventListener("progress", progressEventReducer$1(ae.onUploadProgress)), (ae.cancelToken || ae.signal) && (we = (Ne) => {
      Be && (fe(!Ne || Ne.type ? new CanceledError$1(null, ae, Be) : Ne), Be.abort(), Be = null);
    }, ae.cancelToken && ae.cancelToken.subscribe(we), ae.signal && (ae.signal.aborted ? we() : ae.signal.addEventListener("abort", we)));
    const Pe = parseProtocol$1(Ce);
    if (Pe && platform$2.protocols.indexOf(Pe) === -1) {
      fe(new AxiosError$1("Unsupported protocol " + Pe + ":", AxiosError$1.ERR_BAD_REQUEST, ae));
      return;
    }
    Be.send(ue || null);
  });
}, knownAdapters$1 = {
  http: httpAdapter$1,
  xhr: xhrAdapter$1
};
utils$t.forEach(knownAdapters$1, (ae, ie) => {
  if (ae) {
    try {
      Object.defineProperty(ae, "name", { value: ie });
    } catch {
    }
    Object.defineProperty(ae, "adapterName", { value: ie });
  }
});
const renderReason$1 = (ae) => `- ${ae}`, isResolvedHandle$1 = (ae) => utils$t.isFunction(ae) || ae === null || ae === !1, adapters$1 = {
  getAdapter: (ae) => {
    ae = utils$t.isArray(ae) ? ae : [ae];
    const { length: ie } = ae;
    let se, fe;
    const ue = {};
    for (let ce = 0; ce < ie; ce++) {
      se = ae[ce];
      let de;
      if (fe = se, !isResolvedHandle$1(se) && (fe = knownAdapters$1[(de = String(se)).toLowerCase()], fe === void 0))
        throw new AxiosError$1(`Unknown adapter '${de}'`);
      if (fe)
        break;
      ue[de || "#" + ce] = fe;
    }
    if (!fe) {
      const ce = Object.entries(ue).map(
        ([me, we]) => `adapter ${me} ` + (we === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let de = ie ? ce.length > 1 ? `since :
` + ce.map(renderReason$1).join(`
`) : " " + renderReason$1(ce[0]) : "as no adapter specified";
      throw new AxiosError$1(
        "There is no suitable adapter to dispatch the request " + de,
        "ERR_NOT_SUPPORT"
      );
    }
    return fe;
  },
  adapters: knownAdapters$1
};
function throwIfCancellationRequested$1(ae) {
  if (ae.cancelToken && ae.cancelToken.throwIfRequested(), ae.signal && ae.signal.aborted)
    throw new CanceledError$1(null, ae);
}
function dispatchRequest$1(ae) {
  return throwIfCancellationRequested$1(ae), ae.headers = AxiosHeaders$3.from(ae.headers), ae.data = transformData$1.call(
    ae,
    ae.transformRequest
  ), ["post", "put", "patch"].indexOf(ae.method) !== -1 && ae.headers.setContentType("application/x-www-form-urlencoded", !1), adapters$1.getAdapter(ae.adapter || defaults$3.adapter)(ae).then(function(fe) {
    return throwIfCancellationRequested$1(ae), fe.data = transformData$1.call(
      ae,
      ae.transformResponse,
      fe
    ), fe.headers = AxiosHeaders$3.from(fe.headers), fe;
  }, function(fe) {
    return isCancel$1(fe) || (throwIfCancellationRequested$1(ae), fe && fe.response && (fe.response.data = transformData$1.call(
      ae,
      ae.transformResponse,
      fe.response
    ), fe.response.headers = AxiosHeaders$3.from(fe.response.headers))), Promise.reject(fe);
  });
}
const headersToObject$1 = (ae) => ae instanceof AxiosHeaders$3 ? ae.toJSON() : ae;
function mergeConfig$1(ae, ie) {
  ie = ie || {};
  const se = {};
  function fe(Ee, Se, Be) {
    return utils$t.isPlainObject(Ee) && utils$t.isPlainObject(Se) ? utils$t.merge.call({ caseless: Be }, Ee, Se) : utils$t.isPlainObject(Se) ? utils$t.merge({}, Se) : utils$t.isArray(Se) ? Se.slice() : Se;
  }
  function ue(Ee, Se, Be) {
    if (utils$t.isUndefined(Se)) {
      if (!utils$t.isUndefined(Ee))
        return fe(void 0, Ee, Be);
    } else
      return fe(Ee, Se, Be);
  }
  function ce(Ee, Se) {
    if (!utils$t.isUndefined(Se))
      return fe(void 0, Se);
  }
  function de(Ee, Se) {
    if (utils$t.isUndefined(Se)) {
      if (!utils$t.isUndefined(Ee))
        return fe(void 0, Ee);
    } else
      return fe(void 0, Se);
  }
  function me(Ee, Se, Be) {
    if (Be in ie)
      return fe(Ee, Se);
    if (Be in ae)
      return fe(void 0, Ee);
  }
  const we = {
    url: ce,
    method: ce,
    data: ce,
    baseURL: de,
    transformRequest: de,
    transformResponse: de,
    paramsSerializer: de,
    timeout: de,
    timeoutMessage: de,
    withCredentials: de,
    withXSRFToken: de,
    adapter: de,
    responseType: de,
    xsrfCookieName: de,
    xsrfHeaderName: de,
    onUploadProgress: de,
    onDownloadProgress: de,
    decompress: de,
    maxContentLength: de,
    maxBodyLength: de,
    beforeRedirect: de,
    transport: de,
    httpAgent: de,
    httpsAgent: de,
    cancelToken: de,
    socketPath: de,
    responseEncoding: de,
    validateStatus: me,
    headers: (Ee, Se) => ue(headersToObject$1(Ee), headersToObject$1(Se), !0)
  };
  return utils$t.forEach(Object.keys(Object.assign({}, ae, ie)), function(Se) {
    const Be = we[Se] || ue, Ce = Be(ae[Se], ie[Se], Se);
    utils$t.isUndefined(Ce) && Be !== me || (se[Se] = Ce);
  }), se;
}
const VERSION$2 = "1.6.7", validators$3 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((ae, ie) => {
  validators$3[ae] = function(fe) {
    return typeof fe === ae || "a" + (ie < 1 ? "n " : " ") + ae;
  };
});
const deprecatedWarnings$1 = {};
validators$3.transitional = function(ie, se, fe) {
  function ue(ce, de) {
    return "[Axios v" + VERSION$2 + "] Transitional option '" + ce + "'" + de + (fe ? ". " + fe : "");
  }
  return (ce, de, me) => {
    if (ie === !1)
      throw new AxiosError$1(
        ue(de, " has been removed" + (se ? " in " + se : "")),
        AxiosError$1.ERR_DEPRECATED
      );
    return se && !deprecatedWarnings$1[de] && (deprecatedWarnings$1[de] = !0, console.warn(
      ue(
        de,
        " has been deprecated since v" + se + " and will be removed in the near future"
      )
    )), ie ? ie(ce, de, me) : !0;
  };
};
function assertOptions$1(ae, ie, se) {
  if (typeof ae != "object")
    throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
  const fe = Object.keys(ae);
  let ue = fe.length;
  for (; ue-- > 0; ) {
    const ce = fe[ue], de = ie[ce];
    if (de) {
      const me = ae[ce], we = me === void 0 || de(me, ce, ae);
      if (we !== !0)
        throw new AxiosError$1("option " + ce + " must be " + we, AxiosError$1.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (se !== !0)
      throw new AxiosError$1("Unknown option " + ce, AxiosError$1.ERR_BAD_OPTION);
  }
}
const validator$1 = {
  assertOptions: assertOptions$1,
  validators: validators$3
}, validators$2 = validator$1.validators;
let Axios$2 = class {
  constructor(ie) {
    this.defaults = ie, this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(ie, se) {
    try {
      return await this._request(ie, se);
    } catch (fe) {
      if (fe instanceof Error) {
        let ue;
        Error.captureStackTrace ? Error.captureStackTrace(ue = {}) : ue = new Error();
        const ce = ue.stack ? ue.stack.replace(/^.+\n/, "") : "";
        fe.stack ? ce && !String(fe.stack).endsWith(ce.replace(/^.+\n.+\n/, "")) && (fe.stack += `
` + ce) : fe.stack = ce;
      }
      throw fe;
    }
  }
  _request(ie, se) {
    typeof ie == "string" ? (se = se || {}, se.url = ie) : se = ie || {}, se = mergeConfig$1(this.defaults, se);
    const { transitional: fe, paramsSerializer: ue, headers: ce } = se;
    fe !== void 0 && validator$1.assertOptions(fe, {
      silentJSONParsing: validators$2.transitional(validators$2.boolean),
      forcedJSONParsing: validators$2.transitional(validators$2.boolean),
      clarifyTimeoutError: validators$2.transitional(validators$2.boolean)
    }, !1), ue != null && (utils$t.isFunction(ue) ? se.paramsSerializer = {
      serialize: ue
    } : validator$1.assertOptions(ue, {
      encode: validators$2.function,
      serialize: validators$2.function
    }, !0)), se.method = (se.method || this.defaults.method || "get").toLowerCase();
    let de = ce && utils$t.merge(
      ce.common,
      ce[se.method]
    );
    ce && utils$t.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (Pe) => {
        delete ce[Pe];
      }
    ), se.headers = AxiosHeaders$3.concat(de, ce);
    const me = [];
    let we = !0;
    this.interceptors.request.forEach(function(Ne) {
      typeof Ne.runWhen == "function" && Ne.runWhen(se) === !1 || (we = we && Ne.synchronous, me.unshift(Ne.fulfilled, Ne.rejected));
    });
    const Ee = [];
    this.interceptors.response.forEach(function(Ne) {
      Ee.push(Ne.fulfilled, Ne.rejected);
    });
    let Se, Be = 0, Ce;
    if (!we) {
      const Pe = [dispatchRequest$1.bind(this), void 0];
      for (Pe.unshift.apply(Pe, me), Pe.push.apply(Pe, Ee), Ce = Pe.length, Se = Promise.resolve(se); Be < Ce; )
        Se = Se.then(Pe[Be++], Pe[Be++]);
      return Se;
    }
    Ce = me.length;
    let Ie = se;
    for (Be = 0; Be < Ce; ) {
      const Pe = me[Be++], Ne = me[Be++];
      try {
        Ie = Pe(Ie);
      } catch (ke) {
        Ne.call(this, ke);
        break;
      }
    }
    try {
      Se = dispatchRequest$1.call(this, Ie);
    } catch (Pe) {
      return Promise.reject(Pe);
    }
    for (Be = 0, Ce = Ee.length; Be < Ce; )
      Se = Se.then(Ee[Be++], Ee[Be++]);
    return Se;
  }
  getUri(ie) {
    ie = mergeConfig$1(this.defaults, ie);
    const se = buildFullPath$1(ie.baseURL, ie.url);
    return buildURL$1(se, ie.params, ie.paramsSerializer);
  }
};
utils$t.forEach(["delete", "get", "head", "options"], function(ie) {
  Axios$2.prototype[ie] = function(se, fe) {
    return this.request(mergeConfig$1(fe || {}, {
      method: ie,
      url: se,
      data: (fe || {}).data
    }));
  };
});
utils$t.forEach(["post", "put", "patch"], function(ie) {
  function se(fe) {
    return function(ce, de, me) {
      return this.request(mergeConfig$1(me || {}, {
        method: ie,
        headers: fe ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: ce,
        data: de
      }));
    };
  }
  Axios$2.prototype[ie] = se(), Axios$2.prototype[ie + "Form"] = se(!0);
});
const Axios$3 = Axios$2;
let CancelToken$2 = class Yn {
  constructor(ie) {
    if (typeof ie != "function")
      throw new TypeError("executor must be a function.");
    let se;
    this.promise = new Promise(function(ce) {
      se = ce;
    });
    const fe = this;
    this.promise.then((ue) => {
      if (!fe._listeners)
        return;
      let ce = fe._listeners.length;
      for (; ce-- > 0; )
        fe._listeners[ce](ue);
      fe._listeners = null;
    }), this.promise.then = (ue) => {
      let ce;
      const de = new Promise((me) => {
        fe.subscribe(me), ce = me;
      }).then(ue);
      return de.cancel = function() {
        fe.unsubscribe(ce);
      }, de;
    }, ie(function(ce, de, me) {
      fe.reason || (fe.reason = new CanceledError$1(ce, de, me), se(fe.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(ie) {
    if (this.reason) {
      ie(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(ie) : this._listeners = [ie];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(ie) {
    if (!this._listeners)
      return;
    const se = this._listeners.indexOf(ie);
    se !== -1 && this._listeners.splice(se, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let ie;
    return {
      token: new Yn(function(ue) {
        ie = ue;
      }),
      cancel: ie
    };
  }
};
const CancelToken$3 = CancelToken$2;
function spread$1(ae) {
  return function(se) {
    return ae.apply(null, se);
  };
}
function isAxiosError$1(ae) {
  return utils$t.isObject(ae) && ae.isAxiosError === !0;
}
const HttpStatusCode$2 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode$2).forEach(([ae, ie]) => {
  HttpStatusCode$2[ie] = ae;
});
const HttpStatusCode$3 = HttpStatusCode$2;
function createInstance$1(ae) {
  const ie = new Axios$3(ae), se = bind$3(Axios$3.prototype.request, ie);
  return utils$t.extend(se, Axios$3.prototype, ie, { allOwnKeys: !0 }), utils$t.extend(se, ie, null, { allOwnKeys: !0 }), se.create = function(ue) {
    return createInstance$1(mergeConfig$1(ae, ue));
  }, se;
}
const axios$1 = createInstance$1(defaults$3);
axios$1.Axios = Axios$3;
axios$1.CanceledError = CanceledError$1;
axios$1.CancelToken = CancelToken$3;
axios$1.isCancel = isCancel$1;
axios$1.VERSION = VERSION$2;
axios$1.toFormData = toFormData$1;
axios$1.AxiosError = AxiosError$1;
axios$1.Cancel = axios$1.CanceledError;
axios$1.all = function(ie) {
  return Promise.all(ie);
};
axios$1.spread = spread$1;
axios$1.isAxiosError = isAxiosError$1;
axios$1.mergeConfig = mergeConfig$1;
axios$1.AxiosHeaders = AxiosHeaders$3;
axios$1.formToJSON = (ae) => formDataToJSON$1(utils$t.isHTMLForm(ae) ? new FormData(ae) : ae);
axios$1.getAdapter = adapters$1.getAdapter;
axios$1.HttpStatusCode = HttpStatusCode$3;
axios$1.default = axios$1;
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs$2(ae) {
  return ae && ae.__esModule && Object.prototype.hasOwnProperty.call(ae, "default") ? ae.default : ae;
}
function getAugmentedNamespace(ae) {
  if (ae.__esModule)
    return ae;
  var ie = ae.default;
  if (typeof ie == "function") {
    var se = function fe() {
      return this instanceof fe ? Reflect.construct(ie, arguments, this.constructor) : ie.apply(this, arguments);
    };
    se.prototype = ie.prototype;
  } else
    se = {};
  return Object.defineProperty(se, "__esModule", { value: !0 }), Object.keys(ae).forEach(function(fe) {
    var ue = Object.getOwnPropertyDescriptor(ae, fe);
    Object.defineProperty(se, fe, ue.get ? ue : {
      enumerable: !0,
      get: function() {
        return ae[fe];
      }
    });
  }), se;
}
var cryptoBrowserify = {};
function getDefaultExportFromCjs$1(ae) {
  return ae && ae.__esModule && Object.prototype.hasOwnProperty.call(ae, "default") ? ae.default : ae;
}
var browser$e = { exports: {} }, process = browser$e.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(ae) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(ae, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(ae, 0);
  try {
    return cachedSetTimeout(ae, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, ae, 0);
    } catch {
      return cachedSetTimeout.call(this, ae, 0);
    }
  }
}
function runClearTimeout(ae) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(ae);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(ae);
  try {
    return cachedClearTimeout(ae);
  } catch {
    try {
      return cachedClearTimeout.call(null, ae);
    } catch {
      return cachedClearTimeout.call(this, ae);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var ae = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var ie = queue.length; ie; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < ie; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, ie = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(ae);
  }
}
process.nextTick = function(ae) {
  var ie = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var se = 1; se < arguments.length; se++)
      ie[se - 1] = arguments[se];
  queue.push(new Item(ae, ie)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(ae, ie) {
  this.fun = ae, this.array = ie;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop$3() {
}
process.on = noop$3;
process.addListener = noop$3;
process.once = noop$3;
process.off = noop$3;
process.removeListener = noop$3;
process.removeAllListeners = noop$3;
process.emit = noop$3;
process.prependListener = noop$3;
process.prependOnceListener = noop$3;
process.listeners = function(ae) {
  return [];
};
process.binding = function(ae) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(ae) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports$1 = browser$e.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(browserExports$1);
var browser$d = { exports: {} }, safeBuffer$1 = { exports: {} };
const require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(dist$1);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(ae, ie) {
  var se = require$$0$2, fe = se.Buffer;
  function ue(de, me) {
    for (var we in de)
      me[we] = de[we];
  }
  fe.from && fe.alloc && fe.allocUnsafe && fe.allocUnsafeSlow ? ae.exports = se : (ue(se, ie), ie.Buffer = ce);
  function ce(de, me, we) {
    return fe(de, me, we);
  }
  ce.prototype = Object.create(fe.prototype), ue(fe, ce), ce.from = function(de, me, we) {
    if (typeof de == "number")
      throw new TypeError("Argument must not be a number");
    return fe(de, me, we);
  }, ce.alloc = function(de, me, we) {
    if (typeof de != "number")
      throw new TypeError("Argument must be a number");
    var Ee = fe(de);
    return me !== void 0 ? typeof we == "string" ? Ee.fill(me, we) : Ee.fill(me) : Ee.fill(0), Ee;
  }, ce.allocUnsafe = function(de) {
    if (typeof de != "number")
      throw new TypeError("Argument must be a number");
    return fe(de);
  }, ce.allocUnsafeSlow = function(de) {
    if (typeof de != "number")
      throw new TypeError("Argument must be a number");
    return se.SlowBuffer(de);
  };
})(safeBuffer$1, safeBuffer$1.exports);
var safeBufferExports = safeBuffer$1.exports, MAX_BYTES = 65536, MAX_UINT32 = 4294967295;
function oldBrowser$1() {
  throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
}
var Buffer$E = safeBufferExports.Buffer, crypto$6 = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
crypto$6 && crypto$6.getRandomValues ? browser$d.exports = randomBytes$4 : browser$d.exports = oldBrowser$1;
function randomBytes$4(ae, ie) {
  if (ae > MAX_UINT32)
    throw new RangeError("requested too many random bytes");
  var se = Buffer$E.allocUnsafe(ae);
  if (ae > 0)
    if (ae > MAX_BYTES)
      for (var fe = 0; fe < ae; fe += MAX_BYTES)
        crypto$6.getRandomValues(se.slice(fe, fe + MAX_BYTES));
    else
      crypto$6.getRandomValues(se);
  return typeof ie == "function" ? process$1.nextTick(function() {
    ie(null, se);
  }) : se;
}
var browserExports = browser$d.exports, inherits_browser$1 = { exports: {} };
typeof Object.create == "function" ? inherits_browser$1.exports = function(ie, se) {
  se && (ie.super_ = se, ie.prototype = Object.create(se.prototype, {
    constructor: {
      value: ie,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : inherits_browser$1.exports = function(ie, se) {
  if (se) {
    ie.super_ = se;
    var fe = function() {
    };
    fe.prototype = se.prototype, ie.prototype = new fe(), ie.prototype.constructor = ie;
  }
};
var inherits_browserExports = inherits_browser$1.exports, readableBrowser = { exports: {} }, events = { exports: {} }, R$4 = typeof Reflect == "object" ? Reflect : null, ReflectApply = R$4 && typeof R$4.apply == "function" ? R$4.apply : function(ie, se, fe) {
  return Function.prototype.apply.call(ie, se, fe);
}, ReflectOwnKeys;
R$4 && typeof R$4.ownKeys == "function" ? ReflectOwnKeys = R$4.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys = function(ie) {
  return Object.getOwnPropertyNames(ie).concat(Object.getOwnPropertySymbols(ie));
} : ReflectOwnKeys = function(ie) {
  return Object.getOwnPropertyNames(ie);
};
function ProcessEmitWarning(ae) {
  console && console.warn && console.warn(ae);
}
var NumberIsNaN = Number.isNaN || function(ie) {
  return ie !== ie;
};
function EventEmitter$2() {
  EventEmitter$2.init.call(this);
}
events.exports = EventEmitter$2;
events.exports.once = once$2;
EventEmitter$2.EventEmitter = EventEmitter$2;
EventEmitter$2.prototype._events = void 0;
EventEmitter$2.prototype._eventsCount = 0;
EventEmitter$2.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(ae) {
  if (typeof ae != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof ae);
}
Object.defineProperty(EventEmitter$2, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(ae) {
    if (typeof ae != "number" || ae < 0 || NumberIsNaN(ae))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + ae + ".");
    defaultMaxListeners = ae;
  }
});
EventEmitter$2.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
EventEmitter$2.prototype.setMaxListeners = function(ie) {
  if (typeof ie != "number" || ie < 0 || NumberIsNaN(ie))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + ie + ".");
  return this._maxListeners = ie, this;
};
function _getMaxListeners(ae) {
  return ae._maxListeners === void 0 ? EventEmitter$2.defaultMaxListeners : ae._maxListeners;
}
EventEmitter$2.prototype.getMaxListeners = function() {
  return _getMaxListeners(this);
};
EventEmitter$2.prototype.emit = function(ie) {
  for (var se = [], fe = 1; fe < arguments.length; fe++)
    se.push(arguments[fe]);
  var ue = ie === "error", ce = this._events;
  if (ce !== void 0)
    ue = ue && ce.error === void 0;
  else if (!ue)
    return !1;
  if (ue) {
    var de;
    if (se.length > 0 && (de = se[0]), de instanceof Error)
      throw de;
    var me = new Error("Unhandled error." + (de ? " (" + de.message + ")" : ""));
    throw me.context = de, me;
  }
  var we = ce[ie];
  if (we === void 0)
    return !1;
  if (typeof we == "function")
    ReflectApply(we, this, se);
  else
    for (var Ee = we.length, Se = arrayClone(we, Ee), fe = 0; fe < Ee; ++fe)
      ReflectApply(Se[fe], this, se);
  return !0;
};
function _addListener(ae, ie, se, fe) {
  var ue, ce, de;
  if (checkListener(se), ce = ae._events, ce === void 0 ? (ce = ae._events = /* @__PURE__ */ Object.create(null), ae._eventsCount = 0) : (ce.newListener !== void 0 && (ae.emit(
    "newListener",
    ie,
    se.listener ? se.listener : se
  ), ce = ae._events), de = ce[ie]), de === void 0)
    de = ce[ie] = se, ++ae._eventsCount;
  else if (typeof de == "function" ? de = ce[ie] = fe ? [se, de] : [de, se] : fe ? de.unshift(se) : de.push(se), ue = _getMaxListeners(ae), ue > 0 && de.length > ue && !de.warned) {
    de.warned = !0;
    var me = new Error("Possible EventEmitter memory leak detected. " + de.length + " " + String(ie) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    me.name = "MaxListenersExceededWarning", me.emitter = ae, me.type = ie, me.count = de.length, ProcessEmitWarning(me);
  }
  return ae;
}
EventEmitter$2.prototype.addListener = function(ie, se) {
  return _addListener(this, ie, se, !1);
};
EventEmitter$2.prototype.on = EventEmitter$2.prototype.addListener;
EventEmitter$2.prototype.prependListener = function(ie, se) {
  return _addListener(this, ie, se, !0);
};
function onceWrapper() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap(ae, ie, se) {
  var fe = { fired: !1, wrapFn: void 0, target: ae, type: ie, listener: se }, ue = onceWrapper.bind(fe);
  return ue.listener = se, fe.wrapFn = ue, ue;
}
EventEmitter$2.prototype.once = function(ie, se) {
  return checkListener(se), this.on(ie, _onceWrap(this, ie, se)), this;
};
EventEmitter$2.prototype.prependOnceListener = function(ie, se) {
  return checkListener(se), this.prependListener(ie, _onceWrap(this, ie, se)), this;
};
EventEmitter$2.prototype.removeListener = function(ie, se) {
  var fe, ue, ce, de, me;
  if (checkListener(se), ue = this._events, ue === void 0)
    return this;
  if (fe = ue[ie], fe === void 0)
    return this;
  if (fe === se || fe.listener === se)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete ue[ie], ue.removeListener && this.emit("removeListener", ie, fe.listener || se));
  else if (typeof fe != "function") {
    for (ce = -1, de = fe.length - 1; de >= 0; de--)
      if (fe[de] === se || fe[de].listener === se) {
        me = fe[de].listener, ce = de;
        break;
      }
    if (ce < 0)
      return this;
    ce === 0 ? fe.shift() : spliceOne(fe, ce), fe.length === 1 && (ue[ie] = fe[0]), ue.removeListener !== void 0 && this.emit("removeListener", ie, me || se);
  }
  return this;
};
EventEmitter$2.prototype.off = EventEmitter$2.prototype.removeListener;
EventEmitter$2.prototype.removeAllListeners = function(ie) {
  var se, fe, ue;
  if (fe = this._events, fe === void 0)
    return this;
  if (fe.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : fe[ie] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete fe[ie]), this;
  if (arguments.length === 0) {
    var ce = Object.keys(fe), de;
    for (ue = 0; ue < ce.length; ++ue)
      de = ce[ue], de !== "removeListener" && this.removeAllListeners(de);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (se = fe[ie], typeof se == "function")
    this.removeListener(ie, se);
  else if (se !== void 0)
    for (ue = se.length - 1; ue >= 0; ue--)
      this.removeListener(ie, se[ue]);
  return this;
};
function _listeners(ae, ie, se) {
  var fe = ae._events;
  if (fe === void 0)
    return [];
  var ue = fe[ie];
  return ue === void 0 ? [] : typeof ue == "function" ? se ? [ue.listener || ue] : [ue] : se ? unwrapListeners(ue) : arrayClone(ue, ue.length);
}
EventEmitter$2.prototype.listeners = function(ie) {
  return _listeners(this, ie, !0);
};
EventEmitter$2.prototype.rawListeners = function(ie) {
  return _listeners(this, ie, !1);
};
EventEmitter$2.listenerCount = function(ae, ie) {
  return typeof ae.listenerCount == "function" ? ae.listenerCount(ie) : listenerCount.call(ae, ie);
};
EventEmitter$2.prototype.listenerCount = listenerCount;
function listenerCount(ae) {
  var ie = this._events;
  if (ie !== void 0) {
    var se = ie[ae];
    if (typeof se == "function")
      return 1;
    if (se !== void 0)
      return se.length;
  }
  return 0;
}
EventEmitter$2.prototype.eventNames = function() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(ae, ie) {
  for (var se = new Array(ie), fe = 0; fe < ie; ++fe)
    se[fe] = ae[fe];
  return se;
}
function spliceOne(ae, ie) {
  for (; ie + 1 < ae.length; ie++)
    ae[ie] = ae[ie + 1];
  ae.pop();
}
function unwrapListeners(ae) {
  for (var ie = new Array(ae.length), se = 0; se < ie.length; ++se)
    ie[se] = ae[se].listener || ae[se];
  return ie;
}
function once$2(ae, ie) {
  return new Promise(function(se, fe) {
    function ue(de) {
      ae.removeListener(ie, ce), fe(de);
    }
    function ce() {
      typeof ae.removeListener == "function" && ae.removeListener("error", ue), se([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(ae, ie, ce, { once: !0 }), ie !== "error" && addErrorHandlerIfEventEmitter(ae, ue, { once: !0 });
  });
}
function addErrorHandlerIfEventEmitter(ae, ie, se) {
  typeof ae.on == "function" && eventTargetAgnosticAddListener(ae, "error", ie, se);
}
function eventTargetAgnosticAddListener(ae, ie, se, fe) {
  if (typeof ae.on == "function")
    fe.once ? ae.once(ie, se) : ae.on(ie, se);
  else if (typeof ae.addEventListener == "function")
    ae.addEventListener(ie, function ue(ce) {
      fe.once && ae.removeEventListener(ie, ue), se(ce);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof ae);
}
var eventsExports = events.exports, streamBrowser = eventsExports.EventEmitter, util = {}, types$1 = {}, shams$1 = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var ie = {}, se = Symbol("test"), fe = Object(se);
  if (typeof se == "string" || Object.prototype.toString.call(se) !== "[object Symbol]" || Object.prototype.toString.call(fe) !== "[object Symbol]")
    return !1;
  var ue = 42;
  ie[se] = ue;
  for (se in ie)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(ie).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(ie).length !== 0)
    return !1;
  var ce = Object.getOwnPropertySymbols(ie);
  if (ce.length !== 1 || ce[0] !== se || !Object.prototype.propertyIsEnumerable.call(ie, se))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var de = Object.getOwnPropertyDescriptor(ie, se);
    if (de.value !== ue || de.enumerable !== !0)
      return !1;
  }
  return !0;
}, hasSymbols$2 = shams$1, shams = function() {
  return hasSymbols$2() && !!Symbol.toStringTag;
}, esErrors = Error, _eval = EvalError, range = RangeError, ref = ReferenceError, syntax = SyntaxError, type$1 = TypeError, uri = URIError, origSymbol = typeof Symbol < "u" && Symbol, hasSymbolSham = shams$1, hasSymbols$1 = function() {
  return typeof origSymbol != "function" || typeof Symbol != "function" || typeof origSymbol("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : hasSymbolSham();
}, test = {
  foo: {}
}, $Object = Object, hasProto$1 = function() {
  return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
}, ERROR_MESSAGE = "Function.prototype.bind called on incompatible ", toStr$4 = Object.prototype.toString, max = Math.max, funcType = "[object Function]", concatty = function(ie, se) {
  for (var fe = [], ue = 0; ue < ie.length; ue += 1)
    fe[ue] = ie[ue];
  for (var ce = 0; ce < se.length; ce += 1)
    fe[ce + ie.length] = se[ce];
  return fe;
}, slicy = function(ie, se) {
  for (var fe = [], ue = se || 0, ce = 0; ue < ie.length; ue += 1, ce += 1)
    fe[ce] = ie[ue];
  return fe;
}, joiny = function(ae, ie) {
  for (var se = "", fe = 0; fe < ae.length; fe += 1)
    se += ae[fe], fe + 1 < ae.length && (se += ie);
  return se;
}, implementation$1 = function(ie) {
  var se = this;
  if (typeof se != "function" || toStr$4.apply(se) !== funcType)
    throw new TypeError(ERROR_MESSAGE + se);
  for (var fe = slicy(arguments, 1), ue, ce = function() {
    if (this instanceof ue) {
      var Se = se.apply(
        this,
        concatty(fe, arguments)
      );
      return Object(Se) === Se ? Se : this;
    }
    return se.apply(
      ie,
      concatty(fe, arguments)
    );
  }, de = max(0, se.length - fe.length), me = [], we = 0; we < de; we++)
    me[we] = "$" + we;
  if (ue = Function("binder", "return function (" + joiny(me, ",") + "){ return binder.apply(this,arguments); }")(ce), se.prototype) {
    var Ee = function() {
    };
    Ee.prototype = se.prototype, ue.prototype = new Ee(), Ee.prototype = null;
  }
  return ue;
}, implementation = implementation$1, functionBind = Function.prototype.bind || implementation, call$1 = Function.prototype.call, $hasOwn = Object.prototype.hasOwnProperty, bind$2 = functionBind, hasown = bind$2.call(call$1, $hasOwn), undefined$1, $Error = esErrors, $EvalError = _eval, $RangeError = range, $ReferenceError = ref, $SyntaxError$1 = syntax, $TypeError$2 = type$1, $URIError = uri, $Function = Function, getEvalledConstructor = function(ae) {
  try {
    return $Function('"use strict"; return (' + ae + ").constructor;")();
  } catch {
  }
}, $gOPD$1 = Object.getOwnPropertyDescriptor;
if ($gOPD$1)
  try {
    $gOPD$1({}, "");
  } catch {
    $gOPD$1 = null;
  }
var throwTypeError = function() {
  throw new $TypeError$2();
}, ThrowTypeError = $gOPD$1 ? function() {
  try {
    return arguments.callee, throwTypeError;
  } catch {
    try {
      return $gOPD$1(arguments, "callee").get;
    } catch {
      return throwTypeError;
    }
  }
}() : throwTypeError, hasSymbols = hasSymbols$1(), hasProto = hasProto$1(), getProto$1 = Object.getPrototypeOf || (hasProto ? function(ae) {
  return ae.__proto__;
} : null), needsEval = {}, TypedArray = typeof Uint8Array > "u" || !getProto$1 ? undefined$1 : getProto$1(Uint8Array), INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols && getProto$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics > "u" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt > "u" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array > "u" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols && getProto$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON == "object" ? JSON : undefined$1,
  "%Map%": typeof Map > "u" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy > "u" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols && getProto$1 ? getProto$1(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$2,
  "%Uint8Array%": typeof Uint8Array > "u" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap > "u" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? undefined$1 : WeakSet
};
if (getProto$1)
  try {
    null.error;
  } catch (ae) {
    var errorProto = getProto$1(getProto$1(ae));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
var doEval = function ae(ie) {
  var se;
  if (ie === "%AsyncFunction%")
    se = getEvalledConstructor("async function () {}");
  else if (ie === "%GeneratorFunction%")
    se = getEvalledConstructor("function* () {}");
  else if (ie === "%AsyncGeneratorFunction%")
    se = getEvalledConstructor("async function* () {}");
  else if (ie === "%AsyncGenerator%") {
    var fe = ae("%AsyncGeneratorFunction%");
    fe && (se = fe.prototype);
  } else if (ie === "%AsyncIteratorPrototype%") {
    var ue = ae("%AsyncGenerator%");
    ue && getProto$1 && (se = getProto$1(ue.prototype));
  }
  return INTRINSICS[ie] = se, se;
}, LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, bind$1 = functionBind, hasOwn = hasown, $concat = bind$1.call(Function.call, Array.prototype.concat), $spliceApply = bind$1.call(Function.apply, Array.prototype.splice), $replace = bind$1.call(Function.call, String.prototype.replace), $strSlice = bind$1.call(Function.call, String.prototype.slice), $exec = bind$1.call(Function.call, RegExp.prototype.exec), rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = function(ie) {
  var se = $strSlice(ie, 0, 1), fe = $strSlice(ie, -1);
  if (se === "%" && fe !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  if (fe === "%" && se !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  var ue = [];
  return $replace(ie, rePropName, function(ce, de, me, we) {
    ue[ue.length] = me ? $replace(we, reEscapeChar, "$1") : de || ce;
  }), ue;
}, getBaseIntrinsic = function(ie, se) {
  var fe = ie, ue;
  if (hasOwn(LEGACY_ALIASES, fe) && (ue = LEGACY_ALIASES[fe], fe = "%" + ue[0] + "%"), hasOwn(INTRINSICS, fe)) {
    var ce = INTRINSICS[fe];
    if (ce === needsEval && (ce = doEval(fe)), typeof ce > "u" && !se)
      throw new $TypeError$2("intrinsic " + ie + " exists, but is not available. Please file an issue!");
    return {
      alias: ue,
      name: fe,
      value: ce
    };
  }
  throw new $SyntaxError$1("intrinsic " + ie + " does not exist!");
}, getIntrinsic = function(ie, se) {
  if (typeof ie != "string" || ie.length === 0)
    throw new $TypeError$2("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof se != "boolean")
    throw new $TypeError$2('"allowMissing" argument must be a boolean');
  if ($exec(/^%?[^%]*%?$/, ie) === null)
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var fe = stringToPath(ie), ue = fe.length > 0 ? fe[0] : "", ce = getBaseIntrinsic("%" + ue + "%", se), de = ce.name, me = ce.value, we = !1, Ee = ce.alias;
  Ee && (ue = Ee[0], $spliceApply(fe, $concat([0, 1], Ee)));
  for (var Se = 1, Be = !0; Se < fe.length; Se += 1) {
    var Ce = fe[Se], Ie = $strSlice(Ce, 0, 1), Pe = $strSlice(Ce, -1);
    if ((Ie === '"' || Ie === "'" || Ie === "`" || Pe === '"' || Pe === "'" || Pe === "`") && Ie !== Pe)
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    if ((Ce === "constructor" || !Be) && (we = !0), ue += "." + Ce, de = "%" + ue + "%", hasOwn(INTRINSICS, de))
      me = INTRINSICS[de];
    else if (me != null) {
      if (!(Ce in me)) {
        if (!se)
          throw new $TypeError$2("base intrinsic for " + ie + " exists, but the property is not available.");
        return;
      }
      if ($gOPD$1 && Se + 1 >= fe.length) {
        var Ne = $gOPD$1(me, Ce);
        Be = !!Ne, Be && "get" in Ne && !("originalValue" in Ne.get) ? me = Ne.get : me = me[Ce];
      } else
        Be = hasOwn(me, Ce), me = me[Ce];
      Be && !we && (INTRINSICS[de] = me);
    }
  }
  return me;
}, callBind$2 = { exports: {} }, GetIntrinsic$4 = getIntrinsic, $defineProperty$1 = GetIntrinsic$4("%Object.defineProperty%", !0), hasPropertyDescriptors$1 = function() {
  if ($defineProperty$1)
    try {
      return $defineProperty$1({}, "a", { value: 1 }), !0;
    } catch {
      return !1;
    }
  return !1;
};
hasPropertyDescriptors$1.hasArrayLengthDefineBug = function() {
  if (!hasPropertyDescriptors$1())
    return null;
  try {
    return $defineProperty$1([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors$1, GetIntrinsic$3 = getIntrinsic, $gOPD = GetIntrinsic$3("%Object.getOwnPropertyDescriptor%", !0);
if ($gOPD)
  try {
    $gOPD([], "length");
  } catch {
    $gOPD = null;
  }
var gopd$1 = $gOPD, hasPropertyDescriptors = hasPropertyDescriptors_1(), GetIntrinsic$2 = getIntrinsic, $defineProperty = hasPropertyDescriptors && GetIntrinsic$2("%Object.defineProperty%", !0);
if ($defineProperty)
  try {
    $defineProperty({}, "a", { value: 1 });
  } catch {
    $defineProperty = !1;
  }
var $SyntaxError = syntax, $TypeError$1 = type$1, gopd = gopd$1, defineDataProperty = function(ie, se, fe) {
  if (!ie || typeof ie != "object" && typeof ie != "function")
    throw new $TypeError$1("`obj` must be an object or a function`");
  if (typeof se != "string" && typeof se != "symbol")
    throw new $TypeError$1("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new $TypeError$1("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new $TypeError$1("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new $TypeError$1("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new $TypeError$1("`loose`, if provided, must be a boolean");
  var ue = arguments.length > 3 ? arguments[3] : null, ce = arguments.length > 4 ? arguments[4] : null, de = arguments.length > 5 ? arguments[5] : null, me = arguments.length > 6 ? arguments[6] : !1, we = !!gopd && gopd(ie, se);
  if ($defineProperty)
    $defineProperty(ie, se, {
      configurable: de === null && we ? we.configurable : !de,
      enumerable: ue === null && we ? we.enumerable : !ue,
      value: fe,
      writable: ce === null && we ? we.writable : !ce
    });
  else if (me || !ue && !ce && !de)
    ie[se] = fe;
  else
    throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, GetIntrinsic$1 = getIntrinsic, define$2 = defineDataProperty, hasDescriptors = hasPropertyDescriptors_1(), gOPD$1 = gopd$1, $TypeError = type$1, $floor = GetIntrinsic$1("%Math.floor%"), setFunctionLength = function(ie, se) {
  if (typeof ie != "function")
    throw new $TypeError("`fn` is not a function");
  if (typeof se != "number" || se < 0 || se > 4294967295 || $floor(se) !== se)
    throw new $TypeError("`length` must be a positive 32-bit integer");
  var fe = arguments.length > 2 && !!arguments[2], ue = !0, ce = !0;
  if ("length" in ie && gOPD$1) {
    var de = gOPD$1(ie, "length");
    de && !de.configurable && (ue = !1), de && !de.writable && (ce = !1);
  }
  return (ue || ce || !fe) && (hasDescriptors ? define$2(
    /** @type {Parameters<define>[0]} */
    ie,
    "length",
    se,
    !0,
    !0
  ) : define$2(
    /** @type {Parameters<define>[0]} */
    ie,
    "length",
    se
  )), ie;
};
(function(ae) {
  var ie = functionBind, se = getIntrinsic, fe = setFunctionLength, ue = type$1, ce = se("%Function.prototype.apply%"), de = se("%Function.prototype.call%"), me = se("%Reflect.apply%", !0) || ie.call(de, ce), we = se("%Object.defineProperty%", !0), Ee = se("%Math.max%");
  if (we)
    try {
      we({}, "a", { value: 1 });
    } catch {
      we = null;
    }
  ae.exports = function(Ce) {
    if (typeof Ce != "function")
      throw new ue("a function is required");
    var Ie = me(ie, de, arguments);
    return fe(
      Ie,
      1 + Ee(0, Ce.length - (arguments.length - 1)),
      !0
    );
  };
  var Se = function() {
    return me(ie, ce, arguments);
  };
  we ? we(ae.exports, "apply", { value: Se }) : ae.exports.apply = Se;
})(callBind$2);
var callBindExports = callBind$2.exports, GetIntrinsic = getIntrinsic, callBind$1 = callBindExports, $indexOf$1 = callBind$1(GetIntrinsic("String.prototype.indexOf")), callBound$2 = function(ie, se) {
  var fe = GetIntrinsic(ie, !!se);
  return typeof fe == "function" && $indexOf$1(ie, ".prototype.") > -1 ? callBind$1(fe) : fe;
}, hasToStringTag$3 = shams(), callBound$1 = callBound$2, $toString$1 = callBound$1("Object.prototype.toString"), isStandardArguments = function(ie) {
  return hasToStringTag$3 && ie && typeof ie == "object" && Symbol.toStringTag in ie ? !1 : $toString$1(ie) === "[object Arguments]";
}, isLegacyArguments = function(ie) {
  return isStandardArguments(ie) ? !0 : ie !== null && typeof ie == "object" && typeof ie.length == "number" && ie.length >= 0 && $toString$1(ie) !== "[object Array]" && $toString$1(ie.callee) === "[object Function]";
}, supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments, toStr$3 = Object.prototype.toString, fnToStr$1 = Function.prototype.toString, isFnRegex = /^\s*(?:function)?\*/, hasToStringTag$2 = shams(), getProto = Object.getPrototypeOf, getGeneratorFunc = function() {
  if (!hasToStringTag$2)
    return !1;
  try {
    return Function("return function*() {}")();
  } catch {
  }
}, GeneratorFunction, isGeneratorFunction = function(ie) {
  if (typeof ie != "function")
    return !1;
  if (isFnRegex.test(fnToStr$1.call(ie)))
    return !0;
  if (!hasToStringTag$2) {
    var se = toStr$3.call(ie);
    return se === "[object GeneratorFunction]";
  }
  if (!getProto)
    return !1;
  if (typeof GeneratorFunction > "u") {
    var fe = getGeneratorFunc();
    GeneratorFunction = fe ? getProto(fe) : !1;
  }
  return getProto(ie) === GeneratorFunction;
}, fnToStr = Function.prototype.toString, reflectApply = typeof Reflect == "object" && Reflect !== null && Reflect.apply, badArrayLike, isCallableMarker;
if (typeof reflectApply == "function" && typeof Object.defineProperty == "function")
  try {
    badArrayLike = Object.defineProperty({}, "length", {
      get: function() {
        throw isCallableMarker;
      }
    }), isCallableMarker = {}, reflectApply(function() {
      throw 42;
    }, null, badArrayLike);
  } catch (ae) {
    ae !== isCallableMarker && (reflectApply = null);
  }
else
  reflectApply = null;
var constructorRegex = /^\s*class\b/, isES6ClassFn = function(ie) {
  try {
    var se = fnToStr.call(ie);
    return constructorRegex.test(se);
  } catch {
    return !1;
  }
}, tryFunctionObject = function(ie) {
  try {
    return isES6ClassFn(ie) ? !1 : (fnToStr.call(ie), !0);
  } catch {
    return !1;
  }
}, toStr$2 = Object.prototype.toString, objectClass = "[object Object]", fnClass = "[object Function]", genClass = "[object GeneratorFunction]", ddaClass = "[object HTMLAllCollection]", ddaClass2 = "[object HTML document.all class]", ddaClass3 = "[object HTMLCollection]", hasToStringTag$1 = typeof Symbol == "function" && !!Symbol.toStringTag, isIE68 = !(0 in [,]), isDDA = function() {
  return !1;
};
if (typeof document == "object") {
  var all = document.all;
  toStr$2.call(all) === toStr$2.call(document.all) && (isDDA = function(ie) {
    if ((isIE68 || !ie) && (typeof ie > "u" || typeof ie == "object"))
      try {
        var se = toStr$2.call(ie);
        return (se === ddaClass || se === ddaClass2 || se === ddaClass3 || se === objectClass) && ie("") == null;
      } catch {
      }
    return !1;
  });
}
var isCallable$1 = reflectApply ? function(ie) {
  if (isDDA(ie))
    return !0;
  if (!ie || typeof ie != "function" && typeof ie != "object")
    return !1;
  try {
    reflectApply(ie, null, badArrayLike);
  } catch (se) {
    if (se !== isCallableMarker)
      return !1;
  }
  return !isES6ClassFn(ie) && tryFunctionObject(ie);
} : function(ie) {
  if (isDDA(ie))
    return !0;
  if (!ie || typeof ie != "function" && typeof ie != "object")
    return !1;
  if (hasToStringTag$1)
    return tryFunctionObject(ie);
  if (isES6ClassFn(ie))
    return !1;
  var se = toStr$2.call(ie);
  return se !== fnClass && se !== genClass && !/^\[object HTML/.test(se) ? !1 : tryFunctionObject(ie);
}, isCallable = isCallable$1, toStr$1 = Object.prototype.toString, hasOwnProperty$1 = Object.prototype.hasOwnProperty, forEachArray = function(ie, se, fe) {
  for (var ue = 0, ce = ie.length; ue < ce; ue++)
    hasOwnProperty$1.call(ie, ue) && (fe == null ? se(ie[ue], ue, ie) : se.call(fe, ie[ue], ue, ie));
}, forEachString = function(ie, se, fe) {
  for (var ue = 0, ce = ie.length; ue < ce; ue++)
    fe == null ? se(ie.charAt(ue), ue, ie) : se.call(fe, ie.charAt(ue), ue, ie);
}, forEachObject = function(ie, se, fe) {
  for (var ue in ie)
    hasOwnProperty$1.call(ie, ue) && (fe == null ? se(ie[ue], ue, ie) : se.call(fe, ie[ue], ue, ie));
}, forEach$2 = function(ie, se, fe) {
  if (!isCallable(se))
    throw new TypeError("iterator must be a function");
  var ue;
  arguments.length >= 3 && (ue = fe), toStr$1.call(ie) === "[object Array]" ? forEachArray(ie, se, ue) : typeof ie == "string" ? forEachString(ie, se, ue) : forEachObject(ie, se, ue);
}, forEach_1 = forEach$2, possibleNames = [
  "BigInt64Array",
  "BigUint64Array",
  "Float32Array",
  "Float64Array",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "Uint16Array",
  "Uint32Array",
  "Uint8Array",
  "Uint8ClampedArray"
], g$9 = typeof globalThis > "u" ? commonjsGlobal : globalThis, availableTypedArrays$1 = function() {
  for (var ie = [], se = 0; se < possibleNames.length; se++)
    typeof g$9[possibleNames[se]] == "function" && (ie[ie.length] = possibleNames[se]);
  return ie;
}, forEach$1 = forEach_1, availableTypedArrays = availableTypedArrays$1, callBind = callBindExports, callBound = callBound$2, gOPD = gopd$1, $toString = callBound("Object.prototype.toString"), hasToStringTag = shams(), g$8 = typeof globalThis > "u" ? commonjsGlobal : globalThis, typedArrays = availableTypedArrays(), $slice = callBound("String.prototype.slice"), getPrototypeOf$2 = Object.getPrototypeOf, $indexOf = callBound("Array.prototype.indexOf", !0) || /** @type {(array: readonly unknown[], value: unknown) => keyof array} */
function(ie, se) {
  for (var fe = 0; fe < ie.length; fe += 1)
    if (ie[fe] === se)
      return fe;
  return -1;
}, cache = { __proto__: null };
hasToStringTag && gOPD && getPrototypeOf$2 ? forEach$1(typedArrays, function(ae) {
  var ie = new g$8[ae]();
  if (Symbol.toStringTag in ie) {
    var se = getPrototypeOf$2(ie), fe = gOPD(se, Symbol.toStringTag);
    if (!fe) {
      var ue = getPrototypeOf$2(se);
      fe = gOPD(ue, Symbol.toStringTag);
    }
    cache["$" + ae] = callBind(fe.get);
  }
}) : forEach$1(typedArrays, function(ae) {
  var ie = new g$8[ae](), se = ie.slice || ie.set;
  se && (cache["$" + ae] = callBind(se));
});
var tryTypedArrays = function(ie) {
  var se = !1;
  return forEach$1(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, typeof cache>} */
    /** @type {any} */
    cache,
    /** @type {(getter: typeof cache, name: `\$${TypedArrayName}`) => void} */
    function(fe, ue) {
      if (!se)
        try {
          "$" + fe(ie) === ue && (se = $slice(ue, 1));
        } catch {
        }
    }
  ), se;
}, trySlices = function(ie) {
  var se = !1;
  return forEach$1(
    // eslint-disable-next-line no-extra-parens
    /** @type {any} */
    cache,
    /** @type {(getter: typeof cache, name: `\$${TypedArrayName}`) => void} */
    function(fe, ue) {
      if (!se)
        try {
          fe(ie), se = $slice(ue, 1);
        } catch {
        }
    }
  ), se;
}, whichTypedArray$1 = function(ie) {
  if (!ie || typeof ie != "object")
    return !1;
  if (!hasToStringTag) {
    var se = $slice($toString(ie), 8, -1);
    return $indexOf(typedArrays, se) > -1 ? se : se !== "Object" ? !1 : trySlices(ie);
  }
  return gOPD ? tryTypedArrays(ie) : null;
}, whichTypedArray = whichTypedArray$1, isTypedArray$1 = function(ie) {
  return !!whichTypedArray(ie);
};
(function(ae) {
  var ie = isArguments, se = isGeneratorFunction, fe = whichTypedArray$1, ue = isTypedArray$1;
  function ce(wt) {
    return wt.call.bind(wt);
  }
  var de = typeof BigInt < "u", me = typeof Symbol < "u", we = ce(Object.prototype.toString), Ee = ce(Number.prototype.valueOf), Se = ce(String.prototype.valueOf), Be = ce(Boolean.prototype.valueOf);
  if (de)
    var Ce = ce(BigInt.prototype.valueOf);
  if (me)
    var Ie = ce(Symbol.prototype.valueOf);
  function Pe(wt, Hr) {
    if (typeof wt != "object")
      return !1;
    try {
      return Hr(wt), !0;
    } catch {
      return !1;
    }
  }
  ae.isArgumentsObject = ie, ae.isGeneratorFunction = se, ae.isTypedArray = ue;
  function Ne(wt) {
    return typeof Promise < "u" && wt instanceof Promise || wt !== null && typeof wt == "object" && typeof wt.then == "function" && typeof wt.catch == "function";
  }
  ae.isPromise = Ne;
  function ke(wt) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(wt) : ue(wt) || Re(wt);
  }
  ae.isArrayBufferView = ke;
  function He(wt) {
    return fe(wt) === "Uint8Array";
  }
  ae.isUint8Array = He;
  function De(wt) {
    return fe(wt) === "Uint8ClampedArray";
  }
  ae.isUint8ClampedArray = De;
  function Ge(wt) {
    return fe(wt) === "Uint16Array";
  }
  ae.isUint16Array = Ge;
  function Ye(wt) {
    return fe(wt) === "Uint32Array";
  }
  ae.isUint32Array = Ye;
  function st(wt) {
    return fe(wt) === "Int8Array";
  }
  ae.isInt8Array = st;
  function at(wt) {
    return fe(wt) === "Int16Array";
  }
  ae.isInt16Array = at;
  function mt(wt) {
    return fe(wt) === "Int32Array";
  }
  ae.isInt32Array = mt;
  function qe(wt) {
    return fe(wt) === "Float32Array";
  }
  ae.isFloat32Array = qe;
  function ze(wt) {
    return fe(wt) === "Float64Array";
  }
  ae.isFloat64Array = ze;
  function ot(wt) {
    return fe(wt) === "BigInt64Array";
  }
  ae.isBigInt64Array = ot;
  function $e(wt) {
    return fe(wt) === "BigUint64Array";
  }
  ae.isBigUint64Array = $e;
  function le(wt) {
    return we(wt) === "[object Map]";
  }
  le.working = typeof Map < "u" && le(/* @__PURE__ */ new Map());
  function pe(wt) {
    return typeof Map > "u" ? !1 : le.working ? le(wt) : wt instanceof Map;
  }
  ae.isMap = pe;
  function ge(wt) {
    return we(wt) === "[object Set]";
  }
  ge.working = typeof Set < "u" && ge(/* @__PURE__ */ new Set());
  function ye(wt) {
    return typeof Set > "u" ? !1 : ge.working ? ge(wt) : wt instanceof Set;
  }
  ae.isSet = ye;
  function xe(wt) {
    return we(wt) === "[object WeakMap]";
  }
  xe.working = typeof WeakMap < "u" && xe(/* @__PURE__ */ new WeakMap());
  function _e(wt) {
    return typeof WeakMap > "u" ? !1 : xe.working ? xe(wt) : wt instanceof WeakMap;
  }
  ae.isWeakMap = _e;
  function Ae(wt) {
    return we(wt) === "[object WeakSet]";
  }
  Ae.working = typeof WeakSet < "u" && Ae(/* @__PURE__ */ new WeakSet());
  function ve(wt) {
    return Ae(wt);
  }
  ae.isWeakSet = ve;
  function he(wt) {
    return we(wt) === "[object ArrayBuffer]";
  }
  he.working = typeof ArrayBuffer < "u" && he(new ArrayBuffer());
  function be(wt) {
    return typeof ArrayBuffer > "u" ? !1 : he.working ? he(wt) : wt instanceof ArrayBuffer;
  }
  ae.isArrayBuffer = be;
  function Me(wt) {
    return we(wt) === "[object DataView]";
  }
  Me.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && Me(new DataView(new ArrayBuffer(1), 0, 1));
  function Re(wt) {
    return typeof DataView > "u" ? !1 : Me.working ? Me(wt) : wt instanceof DataView;
  }
  ae.isDataView = Re;
  var Oe = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function Te(wt) {
    return we(wt) === "[object SharedArrayBuffer]";
  }
  function Fe(wt) {
    return typeof Oe > "u" ? !1 : (typeof Te.working > "u" && (Te.working = Te(new Oe())), Te.working ? Te(wt) : wt instanceof Oe);
  }
  ae.isSharedArrayBuffer = Fe;
  function je(wt) {
    return we(wt) === "[object AsyncFunction]";
  }
  ae.isAsyncFunction = je;
  function ct(wt) {
    return we(wt) === "[object Map Iterator]";
  }
  ae.isMapIterator = ct;
  function nt(wt) {
    return we(wt) === "[object Set Iterator]";
  }
  ae.isSetIterator = nt;
  function dt(wt) {
    return we(wt) === "[object Generator]";
  }
  ae.isGeneratorObject = dt;
  function it(wt) {
    return we(wt) === "[object WebAssembly.Module]";
  }
  ae.isWebAssemblyCompiledModule = it;
  function Je(wt) {
    return Pe(wt, Ee);
  }
  ae.isNumberObject = Je;
  function gt(wt) {
    return Pe(wt, Se);
  }
  ae.isStringObject = gt;
  function Ht(wt) {
    return Pe(wt, Be);
  }
  ae.isBooleanObject = Ht;
  function $t(wt) {
    return de && Pe(wt, Ce);
  }
  ae.isBigIntObject = $t;
  function Lt(wt) {
    return me && Pe(wt, Ie);
  }
  ae.isSymbolObject = Lt;
  function Tr(wt) {
    return Je(wt) || gt(wt) || Ht(wt) || $t(wt) || Lt(wt);
  }
  ae.isBoxedPrimitive = Tr;
  function Zt(wt) {
    return typeof Uint8Array < "u" && (be(wt) || Fe(wt));
  }
  ae.isAnyArrayBuffer = Zt, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(wt) {
    Object.defineProperty(ae, wt, {
      enumerable: !1,
      value: function() {
        throw new Error(wt + " is not supported in userland");
      }
    });
  });
})(types$1);
var isBufferBrowser = function(ie) {
  return ie && typeof ie == "object" && typeof ie.copy == "function" && typeof ie.fill == "function" && typeof ie.readUInt8 == "function";
};
(function(ae) {
  var ie = Object.getOwnPropertyDescriptors || function(Re) {
    for (var Oe = Object.keys(Re), Te = {}, Fe = 0; Fe < Oe.length; Fe++)
      Te[Oe[Fe]] = Object.getOwnPropertyDescriptor(Re, Oe[Fe]);
    return Te;
  }, se = /%[sdj%]/g;
  ae.format = function(Me) {
    if (!st(Me)) {
      for (var Re = [], Oe = 0; Oe < arguments.length; Oe++)
        Re.push(de(arguments[Oe]));
      return Re.join(" ");
    }
    for (var Oe = 1, Te = arguments, Fe = Te.length, je = String(Me).replace(se, function(nt) {
      if (nt === "%%")
        return "%";
      if (Oe >= Fe)
        return nt;
      switch (nt) {
        case "%s":
          return String(Te[Oe++]);
        case "%d":
          return Number(Te[Oe++]);
        case "%j":
          try {
            return JSON.stringify(Te[Oe++]);
          } catch {
            return "[Circular]";
          }
        default:
          return nt;
      }
    }), ct = Te[Oe]; Oe < Fe; ct = Te[++Oe])
      De(ct) || !ze(ct) ? je += " " + ct : je += " " + de(ct);
    return je;
  }, ae.deprecate = function(Me, Re) {
    if (typeof process$1 < "u" && process$1.noDeprecation === !0)
      return Me;
    if (typeof process$1 > "u")
      return function() {
        return ae.deprecate(Me, Re).apply(this, arguments);
      };
    var Oe = !1;
    function Te() {
      if (!Oe) {
        if (process$1.throwDeprecation)
          throw new Error(Re);
        process$1.traceDeprecation ? console.trace(Re) : console.error(Re), Oe = !0;
      }
      return Me.apply(this, arguments);
    }
    return Te;
  };
  var fe = {}, ue = /^$/;
  if (process$1.env.NODE_DEBUG) {
    var ce = process$1.env.NODE_DEBUG;
    ce = ce.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ue = new RegExp("^" + ce + "$", "i");
  }
  ae.debuglog = function(Me) {
    if (Me = Me.toUpperCase(), !fe[Me])
      if (ue.test(Me)) {
        var Re = process$1.pid;
        fe[Me] = function() {
          var Oe = ae.format.apply(ae, arguments);
          console.error("%s %d: %s", Me, Re, Oe);
        };
      } else
        fe[Me] = function() {
        };
    return fe[Me];
  };
  function de(Me, Re) {
    var Oe = {
      seen: [],
      stylize: we
    };
    return arguments.length >= 3 && (Oe.depth = arguments[2]), arguments.length >= 4 && (Oe.colors = arguments[3]), He(Re) ? Oe.showHidden = Re : Re && ae._extend(Oe, Re), mt(Oe.showHidden) && (Oe.showHidden = !1), mt(Oe.depth) && (Oe.depth = 2), mt(Oe.colors) && (Oe.colors = !1), mt(Oe.customInspect) && (Oe.customInspect = !0), Oe.colors && (Oe.stylize = me), Se(Oe, Me, Oe.depth);
  }
  ae.inspect = de, de.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, de.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function me(Me, Re) {
    var Oe = de.styles[Re];
    return Oe ? "\x1B[" + de.colors[Oe][0] + "m" + Me + "\x1B[" + de.colors[Oe][1] + "m" : Me;
  }
  function we(Me, Re) {
    return Me;
  }
  function Ee(Me) {
    var Re = {};
    return Me.forEach(function(Oe, Te) {
      Re[Oe] = !0;
    }), Re;
  }
  function Se(Me, Re, Oe) {
    if (Me.customInspect && Re && le(Re.inspect) && // Filter out the util module, it's inspect function is special
    Re.inspect !== ae.inspect && // Also filter out any prototype objects using the circular check.
    !(Re.constructor && Re.constructor.prototype === Re)) {
      var Te = Re.inspect(Oe, Me);
      return st(Te) || (Te = Se(Me, Te, Oe)), Te;
    }
    var Fe = Be(Me, Re);
    if (Fe)
      return Fe;
    var je = Object.keys(Re), ct = Ee(je);
    if (Me.showHidden && (je = Object.getOwnPropertyNames(Re)), $e(Re) && (je.indexOf("message") >= 0 || je.indexOf("description") >= 0))
      return Ce(Re);
    if (je.length === 0) {
      if (le(Re)) {
        var nt = Re.name ? ": " + Re.name : "";
        return Me.stylize("[Function" + nt + "]", "special");
      }
      if (qe(Re))
        return Me.stylize(RegExp.prototype.toString.call(Re), "regexp");
      if (ot(Re))
        return Me.stylize(Date.prototype.toString.call(Re), "date");
      if ($e(Re))
        return Ce(Re);
    }
    var dt = "", it = !1, Je = ["{", "}"];
    if (ke(Re) && (it = !0, Je = ["[", "]"]), le(Re)) {
      var gt = Re.name ? ": " + Re.name : "";
      dt = " [Function" + gt + "]";
    }
    if (qe(Re) && (dt = " " + RegExp.prototype.toString.call(Re)), ot(Re) && (dt = " " + Date.prototype.toUTCString.call(Re)), $e(Re) && (dt = " " + Ce(Re)), je.length === 0 && (!it || Re.length == 0))
      return Je[0] + dt + Je[1];
    if (Oe < 0)
      return qe(Re) ? Me.stylize(RegExp.prototype.toString.call(Re), "regexp") : Me.stylize("[Object]", "special");
    Me.seen.push(Re);
    var Ht;
    return it ? Ht = Ie(Me, Re, Oe, ct, je) : Ht = je.map(function($t) {
      return Pe(Me, Re, Oe, ct, $t, it);
    }), Me.seen.pop(), Ne(Ht, dt, Je);
  }
  function Be(Me, Re) {
    if (mt(Re))
      return Me.stylize("undefined", "undefined");
    if (st(Re)) {
      var Oe = "'" + JSON.stringify(Re).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return Me.stylize(Oe, "string");
    }
    if (Ye(Re))
      return Me.stylize("" + Re, "number");
    if (He(Re))
      return Me.stylize("" + Re, "boolean");
    if (De(Re))
      return Me.stylize("null", "null");
  }
  function Ce(Me) {
    return "[" + Error.prototype.toString.call(Me) + "]";
  }
  function Ie(Me, Re, Oe, Te, Fe) {
    for (var je = [], ct = 0, nt = Re.length; ct < nt; ++ct)
      Ae(Re, String(ct)) ? je.push(Pe(
        Me,
        Re,
        Oe,
        Te,
        String(ct),
        !0
      )) : je.push("");
    return Fe.forEach(function(dt) {
      dt.match(/^\d+$/) || je.push(Pe(
        Me,
        Re,
        Oe,
        Te,
        dt,
        !0
      ));
    }), je;
  }
  function Pe(Me, Re, Oe, Te, Fe, je) {
    var ct, nt, dt;
    if (dt = Object.getOwnPropertyDescriptor(Re, Fe) || { value: Re[Fe] }, dt.get ? dt.set ? nt = Me.stylize("[Getter/Setter]", "special") : nt = Me.stylize("[Getter]", "special") : dt.set && (nt = Me.stylize("[Setter]", "special")), Ae(Te, Fe) || (ct = "[" + Fe + "]"), nt || (Me.seen.indexOf(dt.value) < 0 ? (De(Oe) ? nt = Se(Me, dt.value, null) : nt = Se(Me, dt.value, Oe - 1), nt.indexOf(`
`) > -1 && (je ? nt = nt.split(`
`).map(function(it) {
      return "  " + it;
    }).join(`
`).slice(2) : nt = `
` + nt.split(`
`).map(function(it) {
      return "   " + it;
    }).join(`
`))) : nt = Me.stylize("[Circular]", "special")), mt(ct)) {
      if (je && Fe.match(/^\d+$/))
        return nt;
      ct = JSON.stringify("" + Fe), ct.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (ct = ct.slice(1, -1), ct = Me.stylize(ct, "name")) : (ct = ct.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), ct = Me.stylize(ct, "string"));
    }
    return ct + ": " + nt;
  }
  function Ne(Me, Re, Oe) {
    var Te = Me.reduce(function(Fe, je) {
      return je.indexOf(`
`) >= 0, Fe + je.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return Te > 60 ? Oe[0] + (Re === "" ? "" : Re + `
 `) + " " + Me.join(`,
  `) + " " + Oe[1] : Oe[0] + Re + " " + Me.join(", ") + " " + Oe[1];
  }
  ae.types = types$1;
  function ke(Me) {
    return Array.isArray(Me);
  }
  ae.isArray = ke;
  function He(Me) {
    return typeof Me == "boolean";
  }
  ae.isBoolean = He;
  function De(Me) {
    return Me === null;
  }
  ae.isNull = De;
  function Ge(Me) {
    return Me == null;
  }
  ae.isNullOrUndefined = Ge;
  function Ye(Me) {
    return typeof Me == "number";
  }
  ae.isNumber = Ye;
  function st(Me) {
    return typeof Me == "string";
  }
  ae.isString = st;
  function at(Me) {
    return typeof Me == "symbol";
  }
  ae.isSymbol = at;
  function mt(Me) {
    return Me === void 0;
  }
  ae.isUndefined = mt;
  function qe(Me) {
    return ze(Me) && ge(Me) === "[object RegExp]";
  }
  ae.isRegExp = qe, ae.types.isRegExp = qe;
  function ze(Me) {
    return typeof Me == "object" && Me !== null;
  }
  ae.isObject = ze;
  function ot(Me) {
    return ze(Me) && ge(Me) === "[object Date]";
  }
  ae.isDate = ot, ae.types.isDate = ot;
  function $e(Me) {
    return ze(Me) && (ge(Me) === "[object Error]" || Me instanceof Error);
  }
  ae.isError = $e, ae.types.isNativeError = $e;
  function le(Me) {
    return typeof Me == "function";
  }
  ae.isFunction = le;
  function pe(Me) {
    return Me === null || typeof Me == "boolean" || typeof Me == "number" || typeof Me == "string" || typeof Me == "symbol" || // ES6 symbol
    typeof Me > "u";
  }
  ae.isPrimitive = pe, ae.isBuffer = isBufferBrowser;
  function ge(Me) {
    return Object.prototype.toString.call(Me);
  }
  function ye(Me) {
    return Me < 10 ? "0" + Me.toString(10) : Me.toString(10);
  }
  var xe = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function _e() {
    var Me = /* @__PURE__ */ new Date(), Re = [
      ye(Me.getHours()),
      ye(Me.getMinutes()),
      ye(Me.getSeconds())
    ].join(":");
    return [Me.getDate(), xe[Me.getMonth()], Re].join(" ");
  }
  ae.log = function() {
    console.log("%s - %s", _e(), ae.format.apply(ae, arguments));
  }, ae.inherits = inherits_browserExports, ae._extend = function(Me, Re) {
    if (!Re || !ze(Re))
      return Me;
    for (var Oe = Object.keys(Re), Te = Oe.length; Te--; )
      Me[Oe[Te]] = Re[Oe[Te]];
    return Me;
  };
  function Ae(Me, Re) {
    return Object.prototype.hasOwnProperty.call(Me, Re);
  }
  var ve = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  ae.promisify = function(Re) {
    if (typeof Re != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (ve && Re[ve]) {
      var Oe = Re[ve];
      if (typeof Oe != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(Oe, ve, {
        value: Oe,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Oe;
    }
    function Oe() {
      for (var Te, Fe, je = new Promise(function(dt, it) {
        Te = dt, Fe = it;
      }), ct = [], nt = 0; nt < arguments.length; nt++)
        ct.push(arguments[nt]);
      ct.push(function(dt, it) {
        dt ? Fe(dt) : Te(it);
      });
      try {
        Re.apply(this, ct);
      } catch (dt) {
        Fe(dt);
      }
      return je;
    }
    return Object.setPrototypeOf(Oe, Object.getPrototypeOf(Re)), ve && Object.defineProperty(Oe, ve, {
      value: Oe,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), Object.defineProperties(
      Oe,
      ie(Re)
    );
  }, ae.promisify.custom = ve;
  function he(Me, Re) {
    if (!Me) {
      var Oe = new Error("Promise was rejected with a falsy value");
      Oe.reason = Me, Me = Oe;
    }
    return Re(Me);
  }
  function be(Me) {
    if (typeof Me != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function Re() {
      for (var Oe = [], Te = 0; Te < arguments.length; Te++)
        Oe.push(arguments[Te]);
      var Fe = Oe.pop();
      if (typeof Fe != "function")
        throw new TypeError("The last argument must be of type Function");
      var je = this, ct = function() {
        return Fe.apply(je, arguments);
      };
      Me.apply(this, Oe).then(
        function(nt) {
          process$1.nextTick(ct.bind(null, null, nt));
        },
        function(nt) {
          process$1.nextTick(he.bind(null, nt, ct));
        }
      );
    }
    return Object.setPrototypeOf(Re, Object.getPrototypeOf(Me)), Object.defineProperties(
      Re,
      ie(Me)
    ), Re;
  }
  ae.callbackify = be;
})(util);
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list)
    return buffer_list;
  hasRequiredBuffer_list = 1;
  function ae(Pe, Ne) {
    var ke = Object.keys(Pe);
    if (Object.getOwnPropertySymbols) {
      var He = Object.getOwnPropertySymbols(Pe);
      Ne && (He = He.filter(function(De) {
        return Object.getOwnPropertyDescriptor(Pe, De).enumerable;
      })), ke.push.apply(ke, He);
    }
    return ke;
  }
  function ie(Pe) {
    for (var Ne = 1; Ne < arguments.length; Ne++) {
      var ke = arguments[Ne] != null ? arguments[Ne] : {};
      Ne % 2 ? ae(Object(ke), !0).forEach(function(He) {
        se(Pe, He, ke[He]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(Pe, Object.getOwnPropertyDescriptors(ke)) : ae(Object(ke)).forEach(function(He) {
        Object.defineProperty(Pe, He, Object.getOwnPropertyDescriptor(ke, He));
      });
    }
    return Pe;
  }
  function se(Pe, Ne, ke) {
    return Ne = de(Ne), Ne in Pe ? Object.defineProperty(Pe, Ne, { value: ke, enumerable: !0, configurable: !0, writable: !0 }) : Pe[Ne] = ke, Pe;
  }
  function fe(Pe, Ne) {
    if (!(Pe instanceof Ne))
      throw new TypeError("Cannot call a class as a function");
  }
  function ue(Pe, Ne) {
    for (var ke = 0; ke < Ne.length; ke++) {
      var He = Ne[ke];
      He.enumerable = He.enumerable || !1, He.configurable = !0, "value" in He && (He.writable = !0), Object.defineProperty(Pe, de(He.key), He);
    }
  }
  function ce(Pe, Ne, ke) {
    return Ne && ue(Pe.prototype, Ne), ke && ue(Pe, ke), Object.defineProperty(Pe, "prototype", { writable: !1 }), Pe;
  }
  function de(Pe) {
    var Ne = me(Pe, "string");
    return typeof Ne == "symbol" ? Ne : String(Ne);
  }
  function me(Pe, Ne) {
    if (typeof Pe != "object" || Pe === null)
      return Pe;
    var ke = Pe[Symbol.toPrimitive];
    if (ke !== void 0) {
      var He = ke.call(Pe, Ne || "default");
      if (typeof He != "object")
        return He;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (Ne === "string" ? String : Number)(Pe);
  }
  var we = require$$0$2, Ee = we.Buffer, Se = util, Be = Se.inspect, Ce = Be && Be.custom || "inspect";
  function Ie(Pe, Ne, ke) {
    Ee.prototype.copy.call(Pe, Ne, ke);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function Pe() {
      fe(this, Pe), this.head = null, this.tail = null, this.length = 0;
    }
    return ce(Pe, [{
      key: "push",
      value: function(ke) {
        var He = {
          data: ke,
          next: null
        };
        this.length > 0 ? this.tail.next = He : this.head = He, this.tail = He, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(ke) {
        var He = {
          data: ke,
          next: this.head
        };
        this.length === 0 && (this.tail = He), this.head = He, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var ke = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, ke;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(ke) {
        if (this.length === 0)
          return "";
        for (var He = this.head, De = "" + He.data; He = He.next; )
          De += ke + He.data;
        return De;
      }
    }, {
      key: "concat",
      value: function(ke) {
        if (this.length === 0)
          return Ee.alloc(0);
        for (var He = Ee.allocUnsafe(ke >>> 0), De = this.head, Ge = 0; De; )
          Ie(De.data, He, Ge), Ge += De.data.length, De = De.next;
        return He;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(ke, He) {
        var De;
        return ke < this.head.data.length ? (De = this.head.data.slice(0, ke), this.head.data = this.head.data.slice(ke)) : ke === this.head.data.length ? De = this.shift() : De = He ? this._getString(ke) : this._getBuffer(ke), De;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(ke) {
        var He = this.head, De = 1, Ge = He.data;
        for (ke -= Ge.length; He = He.next; ) {
          var Ye = He.data, st = ke > Ye.length ? Ye.length : ke;
          if (st === Ye.length ? Ge += Ye : Ge += Ye.slice(0, ke), ke -= st, ke === 0) {
            st === Ye.length ? (++De, He.next ? this.head = He.next : this.head = this.tail = null) : (this.head = He, He.data = Ye.slice(st));
            break;
          }
          ++De;
        }
        return this.length -= De, Ge;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(ke) {
        var He = Ee.allocUnsafe(ke), De = this.head, Ge = 1;
        for (De.data.copy(He), ke -= De.data.length; De = De.next; ) {
          var Ye = De.data, st = ke > Ye.length ? Ye.length : ke;
          if (Ye.copy(He, He.length - ke, 0, st), ke -= st, ke === 0) {
            st === Ye.length ? (++Ge, De.next ? this.head = De.next : this.head = this.tail = null) : (this.head = De, De.data = Ye.slice(st));
            break;
          }
          ++Ge;
        }
        return this.length -= Ge, He;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: Ce,
      value: function(ke, He) {
        return Be(this, ie(ie({}, He), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), Pe;
  }(), buffer_list;
}
function destroy(ae, ie) {
  var se = this, fe = this._readableState && this._readableState.destroyed, ue = this._writableState && this._writableState.destroyed;
  return fe || ue ? (ie ? ie(ae) : ae && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(emitErrorNT, this, ae)) : process$1.nextTick(emitErrorNT, this, ae)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(ae || null, function(ce) {
    !ie && ce ? se._writableState ? se._writableState.errorEmitted ? process$1.nextTick(emitCloseNT, se) : (se._writableState.errorEmitted = !0, process$1.nextTick(emitErrorAndCloseNT, se, ce)) : process$1.nextTick(emitErrorAndCloseNT, se, ce) : ie ? (process$1.nextTick(emitCloseNT, se), ie(ce)) : process$1.nextTick(emitCloseNT, se);
  }), this);
}
function emitErrorAndCloseNT(ae, ie) {
  emitErrorNT(ae, ie), emitCloseNT(ae);
}
function emitCloseNT(ae) {
  ae._writableState && !ae._writableState.emitClose || ae._readableState && !ae._readableState.emitClose || ae.emit("close");
}
function undestroy() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function emitErrorNT(ae, ie) {
  ae.emit("error", ie);
}
function errorOrDestroy(ae, ie) {
  var se = ae._readableState, fe = ae._writableState;
  se && se.autoDestroy || fe && fe.autoDestroy ? ae.destroy(ie) : ae.emit("error", ie);
}
var destroy_1 = {
  destroy,
  undestroy,
  errorOrDestroy
}, errorsBrowser = {};
function _inheritsLoose(ae, ie) {
  ae.prototype = Object.create(ie.prototype), ae.prototype.constructor = ae, ae.__proto__ = ie;
}
var codes = {};
function createErrorType(ae, ie, se) {
  se || (se = Error);
  function fe(ce, de, me) {
    return typeof ie == "string" ? ie : ie(ce, de, me);
  }
  var ue = /* @__PURE__ */ function(ce) {
    _inheritsLoose(de, ce);
    function de(me, we, Ee) {
      return ce.call(this, fe(me, we, Ee)) || this;
    }
    return de;
  }(se);
  ue.prototype.name = se.name, ue.prototype.code = ae, codes[ae] = ue;
}
function oneOf(ae, ie) {
  if (Array.isArray(ae)) {
    var se = ae.length;
    return ae = ae.map(function(fe) {
      return String(fe);
    }), se > 2 ? "one of ".concat(ie, " ").concat(ae.slice(0, se - 1).join(", "), ", or ") + ae[se - 1] : se === 2 ? "one of ".concat(ie, " ").concat(ae[0], " or ").concat(ae[1]) : "of ".concat(ie, " ").concat(ae[0]);
  } else
    return "of ".concat(ie, " ").concat(String(ae));
}
function startsWith(ae, ie, se) {
  return ae.substr(!se || se < 0 ? 0 : +se, ie.length) === ie;
}
function endsWith$1(ae, ie, se) {
  return (se === void 0 || se > ae.length) && (se = ae.length), ae.substring(se - ie.length, se) === ie;
}
function includes(ae, ie, se) {
  return typeof se != "number" && (se = 0), se + ie.length > ae.length ? !1 : ae.indexOf(ie, se) !== -1;
}
createErrorType("ERR_INVALID_OPT_VALUE", function(ae, ie) {
  return 'The value "' + ie + '" is invalid for option "' + ae + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(ae, ie, se) {
  var fe;
  typeof ie == "string" && startsWith(ie, "not ") ? (fe = "must not be", ie = ie.replace(/^not /, "")) : fe = "must be";
  var ue;
  if (endsWith$1(ae, " argument"))
    ue = "The ".concat(ae, " ").concat(fe, " ").concat(oneOf(ie, "type"));
  else {
    var ce = includes(ae, ".") ? "property" : "argument";
    ue = 'The "'.concat(ae, '" ').concat(ce, " ").concat(fe, " ").concat(oneOf(ie, "type"));
  }
  return ue += ". Received type ".concat(typeof se), ue;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(ae) {
  return "The " + ae + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(ae) {
  return "Cannot call " + ae + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(ae) {
  return "Unknown encoding: " + ae;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
errorsBrowser.codes = codes;
var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(ae, ie, se) {
  return ae.highWaterMark != null ? ae.highWaterMark : ie ? ae[se] : null;
}
function getHighWaterMark(ae, ie, se, fe) {
  var ue = highWaterMarkFrom(ie, fe, se);
  if (ue != null) {
    if (!(isFinite(ue) && Math.floor(ue) === ue) || ue < 0) {
      var ce = fe ? se : "highWaterMark";
      throw new ERR_INVALID_OPT_VALUE(ce, ue);
    }
    return Math.floor(ue);
  }
  return ae.objectMode ? 16 : 16 * 1024;
}
var state = {
  getHighWaterMark
}, browser$c = deprecate;
function deprecate(ae, ie) {
  if (config("noDeprecation"))
    return ae;
  var se = !1;
  function fe() {
    if (!se) {
      if (config("throwDeprecation"))
        throw new Error(ie);
      config("traceDeprecation") ? console.trace(ie) : console.warn(ie), se = !0;
    }
    return ae.apply(this, arguments);
  }
  return fe;
}
function config(ae) {
  try {
    if (!commonjsGlobal.localStorage)
      return !1;
  } catch {
    return !1;
  }
  var ie = commonjsGlobal.localStorage[ae];
  return ie == null ? !1 : String(ie).toLowerCase() === "true";
}
var _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable)
    return _stream_writable;
  hasRequired_stream_writable = 1, _stream_writable = qe;
  function ae(Fe) {
    var je = this;
    this.next = null, this.entry = null, this.finish = function() {
      Te(je, Fe);
    };
  }
  var ie;
  qe.WritableState = at;
  var se = {
    deprecate: browser$c
  }, fe = streamBrowser, ue = require$$0$2.Buffer, ce = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function de(Fe) {
    return ue.from(Fe);
  }
  function me(Fe) {
    return ue.isBuffer(Fe) || Fe instanceof ce;
  }
  var we = destroy_1, Ee = state, Se = Ee.getHighWaterMark, Be = errorsBrowser.codes, Ce = Be.ERR_INVALID_ARG_TYPE, Ie = Be.ERR_METHOD_NOT_IMPLEMENTED, Pe = Be.ERR_MULTIPLE_CALLBACK, Ne = Be.ERR_STREAM_CANNOT_PIPE, ke = Be.ERR_STREAM_DESTROYED, He = Be.ERR_STREAM_NULL_VALUES, De = Be.ERR_STREAM_WRITE_AFTER_END, Ge = Be.ERR_UNKNOWN_ENCODING, Ye = we.errorOrDestroy;
  inherits_browserExports(qe, fe);
  function st() {
  }
  function at(Fe, je, ct) {
    ie = ie || require_stream_duplex(), Fe = Fe || {}, typeof ct != "boolean" && (ct = je instanceof ie), this.objectMode = !!Fe.objectMode, ct && (this.objectMode = this.objectMode || !!Fe.writableObjectMode), this.highWaterMark = Se(this, Fe, "writableHighWaterMark", ct), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var nt = Fe.decodeStrings === !1;
    this.decodeStrings = !nt, this.defaultEncoding = Fe.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(dt) {
      xe(je, dt);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = Fe.emitClose !== !1, this.autoDestroy = !!Fe.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new ae(this);
  }
  at.prototype.getBuffer = function() {
    for (var je = this.bufferedRequest, ct = []; je; )
      ct.push(je), je = je.next;
    return ct;
  }, function() {
    try {
      Object.defineProperty(at.prototype, "buffer", {
        get: se.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var mt;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (mt = Function.prototype[Symbol.hasInstance], Object.defineProperty(qe, Symbol.hasInstance, {
    value: function(je) {
      return mt.call(this, je) ? !0 : this !== qe ? !1 : je && je._writableState instanceof at;
    }
  })) : mt = function(je) {
    return je instanceof this;
  };
  function qe(Fe) {
    ie = ie || require_stream_duplex();
    var je = this instanceof ie;
    if (!je && !mt.call(qe, this))
      return new qe(Fe);
    this._writableState = new at(Fe, this, je), this.writable = !0, Fe && (typeof Fe.write == "function" && (this._write = Fe.write), typeof Fe.writev == "function" && (this._writev = Fe.writev), typeof Fe.destroy == "function" && (this._destroy = Fe.destroy), typeof Fe.final == "function" && (this._final = Fe.final)), fe.call(this);
  }
  qe.prototype.pipe = function() {
    Ye(this, new Ne());
  };
  function ze(Fe, je) {
    var ct = new De();
    Ye(Fe, ct), process$1.nextTick(je, ct);
  }
  function ot(Fe, je, ct, nt) {
    var dt;
    return ct === null ? dt = new He() : typeof ct != "string" && !je.objectMode && (dt = new Ce("chunk", ["string", "Buffer"], ct)), dt ? (Ye(Fe, dt), process$1.nextTick(nt, dt), !1) : !0;
  }
  qe.prototype.write = function(Fe, je, ct) {
    var nt = this._writableState, dt = !1, it = !nt.objectMode && me(Fe);
    return it && !ue.isBuffer(Fe) && (Fe = de(Fe)), typeof je == "function" && (ct = je, je = null), it ? je = "buffer" : je || (je = nt.defaultEncoding), typeof ct != "function" && (ct = st), nt.ending ? ze(this, ct) : (it || ot(this, nt, Fe, ct)) && (nt.pendingcb++, dt = le(this, nt, it, Fe, je, ct)), dt;
  }, qe.prototype.cork = function() {
    this._writableState.corked++;
  }, qe.prototype.uncork = function() {
    var Fe = this._writableState;
    Fe.corked && (Fe.corked--, !Fe.writing && !Fe.corked && !Fe.bufferProcessing && Fe.bufferedRequest && ve(this, Fe));
  }, qe.prototype.setDefaultEncoding = function(je) {
    if (typeof je == "string" && (je = je.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((je + "").toLowerCase()) > -1))
      throw new Ge(je);
    return this._writableState.defaultEncoding = je, this;
  }, Object.defineProperty(qe.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function $e(Fe, je, ct) {
    return !Fe.objectMode && Fe.decodeStrings !== !1 && typeof je == "string" && (je = ue.from(je, ct)), je;
  }
  Object.defineProperty(qe.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function le(Fe, je, ct, nt, dt, it) {
    if (!ct) {
      var Je = $e(je, nt, dt);
      nt !== Je && (ct = !0, dt = "buffer", nt = Je);
    }
    var gt = je.objectMode ? 1 : nt.length;
    je.length += gt;
    var Ht = je.length < je.highWaterMark;
    if (Ht || (je.needDrain = !0), je.writing || je.corked) {
      var $t = je.lastBufferedRequest;
      je.lastBufferedRequest = {
        chunk: nt,
        encoding: dt,
        isBuf: ct,
        callback: it,
        next: null
      }, $t ? $t.next = je.lastBufferedRequest : je.bufferedRequest = je.lastBufferedRequest, je.bufferedRequestCount += 1;
    } else
      pe(Fe, je, !1, gt, nt, dt, it);
    return Ht;
  }
  function pe(Fe, je, ct, nt, dt, it, Je) {
    je.writelen = nt, je.writecb = Je, je.writing = !0, je.sync = !0, je.destroyed ? je.onwrite(new ke("write")) : ct ? Fe._writev(dt, je.onwrite) : Fe._write(dt, it, je.onwrite), je.sync = !1;
  }
  function ge(Fe, je, ct, nt, dt) {
    --je.pendingcb, ct ? (process$1.nextTick(dt, nt), process$1.nextTick(Re, Fe, je), Fe._writableState.errorEmitted = !0, Ye(Fe, nt)) : (dt(nt), Fe._writableState.errorEmitted = !0, Ye(Fe, nt), Re(Fe, je));
  }
  function ye(Fe) {
    Fe.writing = !1, Fe.writecb = null, Fe.length -= Fe.writelen, Fe.writelen = 0;
  }
  function xe(Fe, je) {
    var ct = Fe._writableState, nt = ct.sync, dt = ct.writecb;
    if (typeof dt != "function")
      throw new Pe();
    if (ye(ct), je)
      ge(Fe, ct, nt, je, dt);
    else {
      var it = he(ct) || Fe.destroyed;
      !it && !ct.corked && !ct.bufferProcessing && ct.bufferedRequest && ve(Fe, ct), nt ? process$1.nextTick(_e, Fe, ct, it, dt) : _e(Fe, ct, it, dt);
    }
  }
  function _e(Fe, je, ct, nt) {
    ct || Ae(Fe, je), je.pendingcb--, nt(), Re(Fe, je);
  }
  function Ae(Fe, je) {
    je.length === 0 && je.needDrain && (je.needDrain = !1, Fe.emit("drain"));
  }
  function ve(Fe, je) {
    je.bufferProcessing = !0;
    var ct = je.bufferedRequest;
    if (Fe._writev && ct && ct.next) {
      var nt = je.bufferedRequestCount, dt = new Array(nt), it = je.corkedRequestsFree;
      it.entry = ct;
      for (var Je = 0, gt = !0; ct; )
        dt[Je] = ct, ct.isBuf || (gt = !1), ct = ct.next, Je += 1;
      dt.allBuffers = gt, pe(Fe, je, !0, je.length, dt, "", it.finish), je.pendingcb++, je.lastBufferedRequest = null, it.next ? (je.corkedRequestsFree = it.next, it.next = null) : je.corkedRequestsFree = new ae(je), je.bufferedRequestCount = 0;
    } else {
      for (; ct; ) {
        var Ht = ct.chunk, $t = ct.encoding, Lt = ct.callback, Tr = je.objectMode ? 1 : Ht.length;
        if (pe(Fe, je, !1, Tr, Ht, $t, Lt), ct = ct.next, je.bufferedRequestCount--, je.writing)
          break;
      }
      ct === null && (je.lastBufferedRequest = null);
    }
    je.bufferedRequest = ct, je.bufferProcessing = !1;
  }
  qe.prototype._write = function(Fe, je, ct) {
    ct(new Ie("_write()"));
  }, qe.prototype._writev = null, qe.prototype.end = function(Fe, je, ct) {
    var nt = this._writableState;
    return typeof Fe == "function" ? (ct = Fe, Fe = null, je = null) : typeof je == "function" && (ct = je, je = null), Fe != null && this.write(Fe, je), nt.corked && (nt.corked = 1, this.uncork()), nt.ending || Oe(this, nt, ct), this;
  }, Object.defineProperty(qe.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function he(Fe) {
    return Fe.ending && Fe.length === 0 && Fe.bufferedRequest === null && !Fe.finished && !Fe.writing;
  }
  function be(Fe, je) {
    Fe._final(function(ct) {
      je.pendingcb--, ct && Ye(Fe, ct), je.prefinished = !0, Fe.emit("prefinish"), Re(Fe, je);
    });
  }
  function Me(Fe, je) {
    !je.prefinished && !je.finalCalled && (typeof Fe._final == "function" && !je.destroyed ? (je.pendingcb++, je.finalCalled = !0, process$1.nextTick(be, Fe, je)) : (je.prefinished = !0, Fe.emit("prefinish")));
  }
  function Re(Fe, je) {
    var ct = he(je);
    if (ct && (Me(Fe, je), je.pendingcb === 0 && (je.finished = !0, Fe.emit("finish"), je.autoDestroy))) {
      var nt = Fe._readableState;
      (!nt || nt.autoDestroy && nt.endEmitted) && Fe.destroy();
    }
    return ct;
  }
  function Oe(Fe, je, ct) {
    je.ending = !0, Re(Fe, je), ct && (je.finished ? process$1.nextTick(ct) : Fe.once("finish", ct)), je.ended = !0, Fe.writable = !1;
  }
  function Te(Fe, je, ct) {
    var nt = Fe.entry;
    for (Fe.entry = null; nt; ) {
      var dt = nt.callback;
      je.pendingcb--, dt(ct), nt = nt.next;
    }
    je.corkedRequestsFree.next = Fe;
  }
  return Object.defineProperty(qe.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(je) {
      this._writableState && (this._writableState.destroyed = je);
    }
  }), qe.prototype.destroy = we.destroy, qe.prototype._undestroy = we.undestroy, qe.prototype._destroy = function(Fe, je) {
    je(Fe);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex)
    return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var ae = Object.keys || function(Ee) {
    var Se = [];
    for (var Be in Ee)
      Se.push(Be);
    return Se;
  };
  _stream_duplex = de;
  var ie = require_stream_readable(), se = require_stream_writable();
  inherits_browserExports(de, ie);
  for (var fe = ae(se.prototype), ue = 0; ue < fe.length; ue++) {
    var ce = fe[ue];
    de.prototype[ce] || (de.prototype[ce] = se.prototype[ce]);
  }
  function de(Ee) {
    if (!(this instanceof de))
      return new de(Ee);
    ie.call(this, Ee), se.call(this, Ee), this.allowHalfOpen = !0, Ee && (Ee.readable === !1 && (this.readable = !1), Ee.writable === !1 && (this.writable = !1), Ee.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", me)));
  }
  Object.defineProperty(de.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(de.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(de.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function me() {
    this._writableState.ended || process$1.nextTick(we, this);
  }
  function we(Ee) {
    Ee.end();
  }
  return Object.defineProperty(de.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(Se) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = Se, this._writableState.destroyed = Se);
    }
  }), _stream_duplex;
}
var string_decoder = {}, Buffer$D = safeBufferExports.Buffer, isEncoding = Buffer$D.isEncoding || function(ae) {
  switch (ae = "" + ae, ae && ae.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return !0;
    default:
      return !1;
  }
};
function _normalizeEncoding(ae) {
  if (!ae)
    return "utf8";
  for (var ie; ; )
    switch (ae) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return ae;
      default:
        if (ie)
          return;
        ae = ("" + ae).toLowerCase(), ie = !0;
    }
}
function normalizeEncoding(ae) {
  var ie = _normalizeEncoding(ae);
  if (typeof ie != "string" && (Buffer$D.isEncoding === isEncoding || !isEncoding(ae)))
    throw new Error("Unknown encoding: " + ae);
  return ie || ae;
}
string_decoder.StringDecoder = StringDecoder$1;
function StringDecoder$1(ae) {
  this.encoding = normalizeEncoding(ae);
  var ie;
  switch (this.encoding) {
    case "utf16le":
      this.text = utf16Text, this.end = utf16End, ie = 4;
      break;
    case "utf8":
      this.fillLast = utf8FillLast, ie = 4;
      break;
    case "base64":
      this.text = base64Text, this.end = base64End, ie = 3;
      break;
    default:
      this.write = simpleWrite, this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer$D.allocUnsafe(ie);
}
StringDecoder$1.prototype.write = function(ae) {
  if (ae.length === 0)
    return "";
  var ie, se;
  if (this.lastNeed) {
    if (ie = this.fillLast(ae), ie === void 0)
      return "";
    se = this.lastNeed, this.lastNeed = 0;
  } else
    se = 0;
  return se < ae.length ? ie ? ie + this.text(ae, se) : this.text(ae, se) : ie || "";
};
StringDecoder$1.prototype.end = utf8End;
StringDecoder$1.prototype.text = utf8Text;
StringDecoder$1.prototype.fillLast = function(ae) {
  if (this.lastNeed <= ae.length)
    return ae.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  ae.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, ae.length), this.lastNeed -= ae.length;
};
function utf8CheckByte(ae) {
  return ae <= 127 ? 0 : ae >> 5 === 6 ? 2 : ae >> 4 === 14 ? 3 : ae >> 3 === 30 ? 4 : ae >> 6 === 2 ? -1 : -2;
}
function utf8CheckIncomplete(ae, ie, se) {
  var fe = ie.length - 1;
  if (fe < se)
    return 0;
  var ue = utf8CheckByte(ie[fe]);
  return ue >= 0 ? (ue > 0 && (ae.lastNeed = ue - 1), ue) : --fe < se || ue === -2 ? 0 : (ue = utf8CheckByte(ie[fe]), ue >= 0 ? (ue > 0 && (ae.lastNeed = ue - 2), ue) : --fe < se || ue === -2 ? 0 : (ue = utf8CheckByte(ie[fe]), ue >= 0 ? (ue > 0 && (ue === 2 ? ue = 0 : ae.lastNeed = ue - 3), ue) : 0));
}
function utf8CheckExtraBytes(ae, ie, se) {
  if ((ie[0] & 192) !== 128)
    return ae.lastNeed = 0, "";
  if (ae.lastNeed > 1 && ie.length > 1) {
    if ((ie[1] & 192) !== 128)
      return ae.lastNeed = 1, "";
    if (ae.lastNeed > 2 && ie.length > 2 && (ie[2] & 192) !== 128)
      return ae.lastNeed = 2, "";
  }
}
function utf8FillLast(ae) {
  var ie = this.lastTotal - this.lastNeed, se = utf8CheckExtraBytes(this, ae);
  if (se !== void 0)
    return se;
  if (this.lastNeed <= ae.length)
    return ae.copy(this.lastChar, ie, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  ae.copy(this.lastChar, ie, 0, ae.length), this.lastNeed -= ae.length;
}
function utf8Text(ae, ie) {
  var se = utf8CheckIncomplete(this, ae, ie);
  if (!this.lastNeed)
    return ae.toString("utf8", ie);
  this.lastTotal = se;
  var fe = ae.length - (se - this.lastNeed);
  return ae.copy(this.lastChar, 0, fe), ae.toString("utf8", ie, fe);
}
function utf8End(ae) {
  var ie = ae && ae.length ? this.write(ae) : "";
  return this.lastNeed ? ie + "" : ie;
}
function utf16Text(ae, ie) {
  if ((ae.length - ie) % 2 === 0) {
    var se = ae.toString("utf16le", ie);
    if (se) {
      var fe = se.charCodeAt(se.length - 1);
      if (fe >= 55296 && fe <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = ae[ae.length - 2], this.lastChar[1] = ae[ae.length - 1], se.slice(0, -1);
    }
    return se;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = ae[ae.length - 1], ae.toString("utf16le", ie, ae.length - 1);
}
function utf16End(ae) {
  var ie = ae && ae.length ? this.write(ae) : "";
  if (this.lastNeed) {
    var se = this.lastTotal - this.lastNeed;
    return ie + this.lastChar.toString("utf16le", 0, se);
  }
  return ie;
}
function base64Text(ae, ie) {
  var se = (ae.length - ie) % 3;
  return se === 0 ? ae.toString("base64", ie) : (this.lastNeed = 3 - se, this.lastTotal = 3, se === 1 ? this.lastChar[0] = ae[ae.length - 1] : (this.lastChar[0] = ae[ae.length - 2], this.lastChar[1] = ae[ae.length - 1]), ae.toString("base64", ie, ae.length - se));
}
function base64End(ae) {
  var ie = ae && ae.length ? this.write(ae) : "";
  return this.lastNeed ? ie + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : ie;
}
function simpleWrite(ae) {
  return ae.toString(this.encoding);
}
function simpleEnd(ae) {
  return ae && ae.length ? this.write(ae) : "";
}
var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;
function once$1(ae) {
  var ie = !1;
  return function() {
    if (!ie) {
      ie = !0;
      for (var se = arguments.length, fe = new Array(se), ue = 0; ue < se; ue++)
        fe[ue] = arguments[ue];
      ae.apply(this, fe);
    }
  };
}
function noop$2() {
}
function isRequest$1(ae) {
  return ae.setHeader && typeof ae.abort == "function";
}
function eos$1(ae, ie, se) {
  if (typeof ie == "function")
    return eos$1(ae, null, ie);
  ie || (ie = {}), se = once$1(se || noop$2);
  var fe = ie.readable || ie.readable !== !1 && ae.readable, ue = ie.writable || ie.writable !== !1 && ae.writable, ce = function() {
    ae.writable || me();
  }, de = ae._writableState && ae._writableState.finished, me = function() {
    ue = !1, de = !0, fe || se.call(ae);
  }, we = ae._readableState && ae._readableState.endEmitted, Ee = function() {
    fe = !1, we = !0, ue || se.call(ae);
  }, Se = function(Pe) {
    se.call(ae, Pe);
  }, Be = function() {
    var Pe;
    if (fe && !we)
      return (!ae._readableState || !ae._readableState.ended) && (Pe = new ERR_STREAM_PREMATURE_CLOSE()), se.call(ae, Pe);
    if (ue && !de)
      return (!ae._writableState || !ae._writableState.ended) && (Pe = new ERR_STREAM_PREMATURE_CLOSE()), se.call(ae, Pe);
  }, Ce = function() {
    ae.req.on("finish", me);
  };
  return isRequest$1(ae) ? (ae.on("complete", me), ae.on("abort", Be), ae.req ? Ce() : ae.on("request", Ce)) : ue && !ae._writableState && (ae.on("end", ce), ae.on("close", ce)), ae.on("end", Ee), ae.on("finish", me), ie.error !== !1 && ae.on("error", Se), ae.on("close", Be), function() {
    ae.removeListener("complete", me), ae.removeListener("abort", Be), ae.removeListener("request", Ce), ae.req && ae.req.removeListener("finish", me), ae.removeListener("end", ce), ae.removeListener("close", ce), ae.removeListener("finish", me), ae.removeListener("end", Ee), ae.removeListener("error", Se), ae.removeListener("close", Be);
  };
}
var endOfStream = eos$1, async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator)
    return async_iterator;
  hasRequiredAsync_iterator = 1;
  var ae;
  function ie(Ge, Ye, st) {
    return Ye = se(Ye), Ye in Ge ? Object.defineProperty(Ge, Ye, { value: st, enumerable: !0, configurable: !0, writable: !0 }) : Ge[Ye] = st, Ge;
  }
  function se(Ge) {
    var Ye = fe(Ge, "string");
    return typeof Ye == "symbol" ? Ye : String(Ye);
  }
  function fe(Ge, Ye) {
    if (typeof Ge != "object" || Ge === null)
      return Ge;
    var st = Ge[Symbol.toPrimitive];
    if (st !== void 0) {
      var at = st.call(Ge, Ye || "default");
      if (typeof at != "object")
        return at;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (Ye === "string" ? String : Number)(Ge);
  }
  var ue = endOfStream, ce = Symbol("lastResolve"), de = Symbol("lastReject"), me = Symbol("error"), we = Symbol("ended"), Ee = Symbol("lastPromise"), Se = Symbol("handlePromise"), Be = Symbol("stream");
  function Ce(Ge, Ye) {
    return {
      value: Ge,
      done: Ye
    };
  }
  function Ie(Ge) {
    var Ye = Ge[ce];
    if (Ye !== null) {
      var st = Ge[Be].read();
      st !== null && (Ge[Ee] = null, Ge[ce] = null, Ge[de] = null, Ye(Ce(st, !1)));
    }
  }
  function Pe(Ge) {
    process$1.nextTick(Ie, Ge);
  }
  function Ne(Ge, Ye) {
    return function(st, at) {
      Ge.then(function() {
        if (Ye[we]) {
          st(Ce(void 0, !0));
          return;
        }
        Ye[Se](st, at);
      }, at);
    };
  }
  var ke = Object.getPrototypeOf(function() {
  }), He = Object.setPrototypeOf((ae = {
    get stream() {
      return this[Be];
    },
    next: function() {
      var Ye = this, st = this[me];
      if (st !== null)
        return Promise.reject(st);
      if (this[we])
        return Promise.resolve(Ce(void 0, !0));
      if (this[Be].destroyed)
        return new Promise(function(ze, ot) {
          process$1.nextTick(function() {
            Ye[me] ? ot(Ye[me]) : ze(Ce(void 0, !0));
          });
        });
      var at = this[Ee], mt;
      if (at)
        mt = new Promise(Ne(at, this));
      else {
        var qe = this[Be].read();
        if (qe !== null)
          return Promise.resolve(Ce(qe, !1));
        mt = new Promise(this[Se]);
      }
      return this[Ee] = mt, mt;
    }
  }, ie(ae, Symbol.asyncIterator, function() {
    return this;
  }), ie(ae, "return", function() {
    var Ye = this;
    return new Promise(function(st, at) {
      Ye[Be].destroy(null, function(mt) {
        if (mt) {
          at(mt);
          return;
        }
        st(Ce(void 0, !0));
      });
    });
  }), ae), ke), De = function(Ye) {
    var st, at = Object.create(He, (st = {}, ie(st, Be, {
      value: Ye,
      writable: !0
    }), ie(st, ce, {
      value: null,
      writable: !0
    }), ie(st, de, {
      value: null,
      writable: !0
    }), ie(st, me, {
      value: null,
      writable: !0
    }), ie(st, we, {
      value: Ye._readableState.endEmitted,
      writable: !0
    }), ie(st, Se, {
      value: function(qe, ze) {
        var ot = at[Be].read();
        ot ? (at[Ee] = null, at[ce] = null, at[de] = null, qe(Ce(ot, !1))) : (at[ce] = qe, at[de] = ze);
      },
      writable: !0
    }), st));
    return at[Ee] = null, ue(Ye, function(mt) {
      if (mt && mt.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var qe = at[de];
        qe !== null && (at[Ee] = null, at[ce] = null, at[de] = null, qe(mt)), at[me] = mt;
        return;
      }
      var ze = at[ce];
      ze !== null && (at[Ee] = null, at[ce] = null, at[de] = null, ze(Ce(void 0, !0))), at[we] = !0;
    }), Ye.on("readable", Pe.bind(null, at)), at;
  };
  return async_iterator = De, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable)
    return _stream_readable;
  hasRequired_stream_readable = 1, _stream_readable = ze;
  var ae;
  ze.ReadableState = qe, eventsExports.EventEmitter;
  var ie = function(Je, gt) {
    return Je.listeners(gt).length;
  }, se = streamBrowser, fe = require$$0$2.Buffer, ue = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function ce(it) {
    return fe.from(it);
  }
  function de(it) {
    return fe.isBuffer(it) || it instanceof ue;
  }
  var me = util, we;
  me && me.debuglog ? we = me.debuglog("stream") : we = function() {
  };
  var Ee = requireBuffer_list(), Se = destroy_1, Be = state, Ce = Be.getHighWaterMark, Ie = errorsBrowser.codes, Pe = Ie.ERR_INVALID_ARG_TYPE, Ne = Ie.ERR_STREAM_PUSH_AFTER_EOF, ke = Ie.ERR_METHOD_NOT_IMPLEMENTED, He = Ie.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, De, Ge, Ye;
  inherits_browserExports(ze, se);
  var st = Se.errorOrDestroy, at = ["error", "close", "destroy", "pause", "resume"];
  function mt(it, Je, gt) {
    if (typeof it.prependListener == "function")
      return it.prependListener(Je, gt);
    !it._events || !it._events[Je] ? it.on(Je, gt) : Array.isArray(it._events[Je]) ? it._events[Je].unshift(gt) : it._events[Je] = [gt, it._events[Je]];
  }
  function qe(it, Je, gt) {
    ae = ae || require_stream_duplex(), it = it || {}, typeof gt != "boolean" && (gt = Je instanceof ae), this.objectMode = !!it.objectMode, gt && (this.objectMode = this.objectMode || !!it.readableObjectMode), this.highWaterMark = Ce(this, it, "readableHighWaterMark", gt), this.buffer = new Ee(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = it.emitClose !== !1, this.autoDestroy = !!it.autoDestroy, this.destroyed = !1, this.defaultEncoding = it.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, it.encoding && (De || (De = string_decoder.StringDecoder), this.decoder = new De(it.encoding), this.encoding = it.encoding);
  }
  function ze(it) {
    if (ae = ae || require_stream_duplex(), !(this instanceof ze))
      return new ze(it);
    var Je = this instanceof ae;
    this._readableState = new qe(it, this, Je), this.readable = !0, it && (typeof it.read == "function" && (this._read = it.read), typeof it.destroy == "function" && (this._destroy = it.destroy)), se.call(this);
  }
  Object.defineProperty(ze.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Je) {
      this._readableState && (this._readableState.destroyed = Je);
    }
  }), ze.prototype.destroy = Se.destroy, ze.prototype._undestroy = Se.undestroy, ze.prototype._destroy = function(it, Je) {
    Je(it);
  }, ze.prototype.push = function(it, Je) {
    var gt = this._readableState, Ht;
    return gt.objectMode ? Ht = !0 : typeof it == "string" && (Je = Je || gt.defaultEncoding, Je !== gt.encoding && (it = fe.from(it, Je), Je = ""), Ht = !0), ot(this, it, Je, !1, Ht);
  }, ze.prototype.unshift = function(it) {
    return ot(this, it, null, !0, !1);
  };
  function ot(it, Je, gt, Ht, $t) {
    we("readableAddChunk", Je);
    var Lt = it._readableState;
    if (Je === null)
      Lt.reading = !1, xe(it, Lt);
    else {
      var Tr;
      if ($t || (Tr = le(Lt, Je)), Tr)
        st(it, Tr);
      else if (Lt.objectMode || Je && Je.length > 0)
        if (typeof Je != "string" && !Lt.objectMode && Object.getPrototypeOf(Je) !== fe.prototype && (Je = ce(Je)), Ht)
          Lt.endEmitted ? st(it, new He()) : $e(it, Lt, Je, !0);
        else if (Lt.ended)
          st(it, new Ne());
        else {
          if (Lt.destroyed)
            return !1;
          Lt.reading = !1, Lt.decoder && !gt ? (Je = Lt.decoder.write(Je), Lt.objectMode || Je.length !== 0 ? $e(it, Lt, Je, !1) : ve(it, Lt)) : $e(it, Lt, Je, !1);
        }
      else
        Ht || (Lt.reading = !1, ve(it, Lt));
    }
    return !Lt.ended && (Lt.length < Lt.highWaterMark || Lt.length === 0);
  }
  function $e(it, Je, gt, Ht) {
    Je.flowing && Je.length === 0 && !Je.sync ? (Je.awaitDrain = 0, it.emit("data", gt)) : (Je.length += Je.objectMode ? 1 : gt.length, Ht ? Je.buffer.unshift(gt) : Je.buffer.push(gt), Je.needReadable && _e(it)), ve(it, Je);
  }
  function le(it, Je) {
    var gt;
    return !de(Je) && typeof Je != "string" && Je !== void 0 && !it.objectMode && (gt = new Pe("chunk", ["string", "Buffer", "Uint8Array"], Je)), gt;
  }
  ze.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, ze.prototype.setEncoding = function(it) {
    De || (De = string_decoder.StringDecoder);
    var Je = new De(it);
    this._readableState.decoder = Je, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var gt = this._readableState.buffer.head, Ht = ""; gt !== null; )
      Ht += Je.write(gt.data), gt = gt.next;
    return this._readableState.buffer.clear(), Ht !== "" && this._readableState.buffer.push(Ht), this._readableState.length = Ht.length, this;
  };
  var pe = 1073741824;
  function ge(it) {
    return it >= pe ? it = pe : (it--, it |= it >>> 1, it |= it >>> 2, it |= it >>> 4, it |= it >>> 8, it |= it >>> 16, it++), it;
  }
  function ye(it, Je) {
    return it <= 0 || Je.length === 0 && Je.ended ? 0 : Je.objectMode ? 1 : it !== it ? Je.flowing && Je.length ? Je.buffer.head.data.length : Je.length : (it > Je.highWaterMark && (Je.highWaterMark = ge(it)), it <= Je.length ? it : Je.ended ? Je.length : (Je.needReadable = !0, 0));
  }
  ze.prototype.read = function(it) {
    we("read", it), it = parseInt(it, 10);
    var Je = this._readableState, gt = it;
    if (it !== 0 && (Je.emittedReadable = !1), it === 0 && Je.needReadable && ((Je.highWaterMark !== 0 ? Je.length >= Je.highWaterMark : Je.length > 0) || Je.ended))
      return we("read: emitReadable", Je.length, Je.ended), Je.length === 0 && Je.ended ? ct(this) : _e(this), null;
    if (it = ye(it, Je), it === 0 && Je.ended)
      return Je.length === 0 && ct(this), null;
    var Ht = Je.needReadable;
    we("need readable", Ht), (Je.length === 0 || Je.length - it < Je.highWaterMark) && (Ht = !0, we("length less than watermark", Ht)), Je.ended || Je.reading ? (Ht = !1, we("reading or ended", Ht)) : Ht && (we("do read"), Je.reading = !0, Je.sync = !0, Je.length === 0 && (Je.needReadable = !0), this._read(Je.highWaterMark), Je.sync = !1, Je.reading || (it = ye(gt, Je)));
    var $t;
    return it > 0 ? $t = je(it, Je) : $t = null, $t === null ? (Je.needReadable = Je.length <= Je.highWaterMark, it = 0) : (Je.length -= it, Je.awaitDrain = 0), Je.length === 0 && (Je.ended || (Je.needReadable = !0), gt !== it && Je.ended && ct(this)), $t !== null && this.emit("data", $t), $t;
  };
  function xe(it, Je) {
    if (we("onEofChunk"), !Je.ended) {
      if (Je.decoder) {
        var gt = Je.decoder.end();
        gt && gt.length && (Je.buffer.push(gt), Je.length += Je.objectMode ? 1 : gt.length);
      }
      Je.ended = !0, Je.sync ? _e(it) : (Je.needReadable = !1, Je.emittedReadable || (Je.emittedReadable = !0, Ae(it)));
    }
  }
  function _e(it) {
    var Je = it._readableState;
    we("emitReadable", Je.needReadable, Je.emittedReadable), Je.needReadable = !1, Je.emittedReadable || (we("emitReadable", Je.flowing), Je.emittedReadable = !0, process$1.nextTick(Ae, it));
  }
  function Ae(it) {
    var Je = it._readableState;
    we("emitReadable_", Je.destroyed, Je.length, Je.ended), !Je.destroyed && (Je.length || Je.ended) && (it.emit("readable"), Je.emittedReadable = !1), Je.needReadable = !Je.flowing && !Je.ended && Je.length <= Je.highWaterMark, Fe(it);
  }
  function ve(it, Je) {
    Je.readingMore || (Je.readingMore = !0, process$1.nextTick(he, it, Je));
  }
  function he(it, Je) {
    for (; !Je.reading && !Je.ended && (Je.length < Je.highWaterMark || Je.flowing && Je.length === 0); ) {
      var gt = Je.length;
      if (we("maybeReadMore read 0"), it.read(0), gt === Je.length)
        break;
    }
    Je.readingMore = !1;
  }
  ze.prototype._read = function(it) {
    st(this, new ke("_read()"));
  }, ze.prototype.pipe = function(it, Je) {
    var gt = this, Ht = this._readableState;
    switch (Ht.pipesCount) {
      case 0:
        Ht.pipes = it;
        break;
      case 1:
        Ht.pipes = [Ht.pipes, it];
        break;
      default:
        Ht.pipes.push(it);
        break;
    }
    Ht.pipesCount += 1, we("pipe count=%d opts=%j", Ht.pipesCount, Je);
    var $t = (!Je || Je.end !== !1) && it !== process$1.stdout && it !== process$1.stderr, Lt = $t ? Zt : Dr;
    Ht.endEmitted ? process$1.nextTick(Lt) : gt.once("end", Lt), it.on("unpipe", Tr);
    function Tr(Jt, ir) {
      we("onunpipe"), Jt === gt && ir && ir.hasUnpiped === !1 && (ir.hasUnpiped = !0, tr());
    }
    function Zt() {
      we("onend"), it.end();
    }
    var wt = be(gt);
    it.on("drain", wt);
    var Hr = !1;
    function tr() {
      we("cleanup"), it.removeListener("close", Wt), it.removeListener("finish", ar), it.removeListener("drain", wt), it.removeListener("error", qr), it.removeListener("unpipe", Tr), gt.removeListener("end", Zt), gt.removeListener("end", Dr), gt.removeListener("data", cr), Hr = !0, Ht.awaitDrain && (!it._writableState || it._writableState.needDrain) && wt();
    }
    gt.on("data", cr);
    function cr(Jt) {
      we("ondata");
      var ir = it.write(Jt);
      we("dest.write", ir), ir === !1 && ((Ht.pipesCount === 1 && Ht.pipes === it || Ht.pipesCount > 1 && dt(Ht.pipes, it) !== -1) && !Hr && (we("false write response, pause", Ht.awaitDrain), Ht.awaitDrain++), gt.pause());
    }
    function qr(Jt) {
      we("onerror", Jt), Dr(), it.removeListener("error", qr), ie(it, "error") === 0 && st(it, Jt);
    }
    mt(it, "error", qr);
    function Wt() {
      it.removeListener("finish", ar), Dr();
    }
    it.once("close", Wt);
    function ar() {
      we("onfinish"), it.removeListener("close", Wt), Dr();
    }
    it.once("finish", ar);
    function Dr() {
      we("unpipe"), gt.unpipe(it);
    }
    return it.emit("pipe", gt), Ht.flowing || (we("pipe resume"), gt.resume()), it;
  };
  function be(it) {
    return function() {
      var gt = it._readableState;
      we("pipeOnDrain", gt.awaitDrain), gt.awaitDrain && gt.awaitDrain--, gt.awaitDrain === 0 && ie(it, "data") && (gt.flowing = !0, Fe(it));
    };
  }
  ze.prototype.unpipe = function(it) {
    var Je = this._readableState, gt = {
      hasUnpiped: !1
    };
    if (Je.pipesCount === 0)
      return this;
    if (Je.pipesCount === 1)
      return it && it !== Je.pipes ? this : (it || (it = Je.pipes), Je.pipes = null, Je.pipesCount = 0, Je.flowing = !1, it && it.emit("unpipe", this, gt), this);
    if (!it) {
      var Ht = Je.pipes, $t = Je.pipesCount;
      Je.pipes = null, Je.pipesCount = 0, Je.flowing = !1;
      for (var Lt = 0; Lt < $t; Lt++)
        Ht[Lt].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var Tr = dt(Je.pipes, it);
    return Tr === -1 ? this : (Je.pipes.splice(Tr, 1), Je.pipesCount -= 1, Je.pipesCount === 1 && (Je.pipes = Je.pipes[0]), it.emit("unpipe", this, gt), this);
  }, ze.prototype.on = function(it, Je) {
    var gt = se.prototype.on.call(this, it, Je), Ht = this._readableState;
    return it === "data" ? (Ht.readableListening = this.listenerCount("readable") > 0, Ht.flowing !== !1 && this.resume()) : it === "readable" && !Ht.endEmitted && !Ht.readableListening && (Ht.readableListening = Ht.needReadable = !0, Ht.flowing = !1, Ht.emittedReadable = !1, we("on readable", Ht.length, Ht.reading), Ht.length ? _e(this) : Ht.reading || process$1.nextTick(Re, this)), gt;
  }, ze.prototype.addListener = ze.prototype.on, ze.prototype.removeListener = function(it, Je) {
    var gt = se.prototype.removeListener.call(this, it, Je);
    return it === "readable" && process$1.nextTick(Me, this), gt;
  }, ze.prototype.removeAllListeners = function(it) {
    var Je = se.prototype.removeAllListeners.apply(this, arguments);
    return (it === "readable" || it === void 0) && process$1.nextTick(Me, this), Je;
  };
  function Me(it) {
    var Je = it._readableState;
    Je.readableListening = it.listenerCount("readable") > 0, Je.resumeScheduled && !Je.paused ? Je.flowing = !0 : it.listenerCount("data") > 0 && it.resume();
  }
  function Re(it) {
    we("readable nexttick read 0"), it.read(0);
  }
  ze.prototype.resume = function() {
    var it = this._readableState;
    return it.flowing || (we("resume"), it.flowing = !it.readableListening, Oe(this, it)), it.paused = !1, this;
  };
  function Oe(it, Je) {
    Je.resumeScheduled || (Je.resumeScheduled = !0, process$1.nextTick(Te, it, Je));
  }
  function Te(it, Je) {
    we("resume", Je.reading), Je.reading || it.read(0), Je.resumeScheduled = !1, it.emit("resume"), Fe(it), Je.flowing && !Je.reading && it.read(0);
  }
  ze.prototype.pause = function() {
    return we("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (we("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function Fe(it) {
    var Je = it._readableState;
    for (we("flow", Je.flowing); Je.flowing && it.read() !== null; )
      ;
  }
  ze.prototype.wrap = function(it) {
    var Je = this, gt = this._readableState, Ht = !1;
    it.on("end", function() {
      if (we("wrapped end"), gt.decoder && !gt.ended) {
        var Tr = gt.decoder.end();
        Tr && Tr.length && Je.push(Tr);
      }
      Je.push(null);
    }), it.on("data", function(Tr) {
      if (we("wrapped data"), gt.decoder && (Tr = gt.decoder.write(Tr)), !(gt.objectMode && Tr == null) && !(!gt.objectMode && (!Tr || !Tr.length))) {
        var Zt = Je.push(Tr);
        Zt || (Ht = !0, it.pause());
      }
    });
    for (var $t in it)
      this[$t] === void 0 && typeof it[$t] == "function" && (this[$t] = /* @__PURE__ */ function(Zt) {
        return function() {
          return it[Zt].apply(it, arguments);
        };
      }($t));
    for (var Lt = 0; Lt < at.length; Lt++)
      it.on(at[Lt], this.emit.bind(this, at[Lt]));
    return this._read = function(Tr) {
      we("wrapped _read", Tr), Ht && (Ht = !1, it.resume());
    }, this;
  }, typeof Symbol == "function" && (ze.prototype[Symbol.asyncIterator] = function() {
    return Ge === void 0 && (Ge = requireAsync_iterator()), Ge(this);
  }), Object.defineProperty(ze.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(ze.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(ze.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(Je) {
      this._readableState && (this._readableState.flowing = Je);
    }
  }), ze._fromList = je, Object.defineProperty(ze.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function je(it, Je) {
    if (Je.length === 0)
      return null;
    var gt;
    return Je.objectMode ? gt = Je.buffer.shift() : !it || it >= Je.length ? (Je.decoder ? gt = Je.buffer.join("") : Je.buffer.length === 1 ? gt = Je.buffer.first() : gt = Je.buffer.concat(Je.length), Je.buffer.clear()) : gt = Je.buffer.consume(it, Je.decoder), gt;
  }
  function ct(it) {
    var Je = it._readableState;
    we("endReadable", Je.endEmitted), Je.endEmitted || (Je.ended = !0, process$1.nextTick(nt, Je, it));
  }
  function nt(it, Je) {
    if (we("endReadableNT", it.endEmitted, it.length), !it.endEmitted && it.length === 0 && (it.endEmitted = !0, Je.readable = !1, Je.emit("end"), it.autoDestroy)) {
      var gt = Je._writableState;
      (!gt || gt.autoDestroy && gt.finished) && Je.destroy();
    }
  }
  typeof Symbol == "function" && (ze.from = function(it, Je) {
    return Ye === void 0 && (Ye = requireFromBrowser()), Ye(ze, it, Je);
  });
  function dt(it, Je) {
    for (var gt = 0, Ht = it.length; gt < Ht; gt++)
      if (it[gt] === Je)
        return gt;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform = Transform$9, _require$codes$1 = errorsBrowser.codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0, Duplex = require_stream_duplex();
inherits_browserExports(Transform$9, Duplex);
function afterTransform(ae, ie) {
  var se = this._transformState;
  se.transforming = !1;
  var fe = se.writecb;
  if (fe === null)
    return this.emit("error", new ERR_MULTIPLE_CALLBACK());
  se.writechunk = null, se.writecb = null, ie != null && this.push(ie), fe(ae);
  var ue = this._readableState;
  ue.reading = !1, (ue.needReadable || ue.length < ue.highWaterMark) && this._read(ue.highWaterMark);
}
function Transform$9(ae) {
  if (!(this instanceof Transform$9))
    return new Transform$9(ae);
  Duplex.call(this, ae), this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, ae && (typeof ae.transform == "function" && (this._transform = ae.transform), typeof ae.flush == "function" && (this._flush = ae.flush)), this.on("prefinish", prefinish);
}
function prefinish() {
  var ae = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(ie, se) {
    done(ae, ie, se);
  }) : done(this, null, null);
}
Transform$9.prototype.push = function(ae, ie) {
  return this._transformState.needTransform = !1, Duplex.prototype.push.call(this, ae, ie);
};
Transform$9.prototype._transform = function(ae, ie, se) {
  se(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
Transform$9.prototype._write = function(ae, ie, se) {
  var fe = this._transformState;
  if (fe.writecb = se, fe.writechunk = ae, fe.writeencoding = ie, !fe.transforming) {
    var ue = this._readableState;
    (fe.needTransform || ue.needReadable || ue.length < ue.highWaterMark) && this._read(ue.highWaterMark);
  }
};
Transform$9.prototype._read = function(ae) {
  var ie = this._transformState;
  ie.writechunk !== null && !ie.transforming ? (ie.transforming = !0, this._transform(ie.writechunk, ie.writeencoding, ie.afterTransform)) : ie.needTransform = !0;
};
Transform$9.prototype._destroy = function(ae, ie) {
  Duplex.prototype._destroy.call(this, ae, function(se) {
    ie(se);
  });
};
function done(ae, ie, se) {
  if (ie)
    return ae.emit("error", ie);
  if (se != null && ae.push(se), ae._writableState.length)
    throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (ae._transformState.transforming)
    throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return ae.push(null);
}
var _stream_passthrough = PassThrough, Transform$8 = _stream_transform;
inherits_browserExports(PassThrough, Transform$8);
function PassThrough(ae) {
  if (!(this instanceof PassThrough))
    return new PassThrough(ae);
  Transform$8.call(this, ae);
}
PassThrough.prototype._transform = function(ae, ie, se) {
  se(null, ae);
};
var eos;
function once(ae) {
  var ie = !1;
  return function() {
    ie || (ie = !0, ae.apply(void 0, arguments));
  };
}
var _require$codes = errorsBrowser.codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop$1(ae) {
  if (ae)
    throw ae;
}
function isRequest(ae) {
  return ae.setHeader && typeof ae.abort == "function";
}
function destroyer(ae, ie, se, fe) {
  fe = once(fe);
  var ue = !1;
  ae.on("close", function() {
    ue = !0;
  }), eos === void 0 && (eos = endOfStream), eos(ae, {
    readable: ie,
    writable: se
  }, function(de) {
    if (de)
      return fe(de);
    ue = !0, fe();
  });
  var ce = !1;
  return function(de) {
    if (!ue && !ce) {
      if (ce = !0, isRequest(ae))
        return ae.abort();
      if (typeof ae.destroy == "function")
        return ae.destroy();
      fe(de || new ERR_STREAM_DESTROYED("pipe"));
    }
  };
}
function call(ae) {
  ae();
}
function pipe(ae, ie) {
  return ae.pipe(ie);
}
function popCallback(ae) {
  return !ae.length || typeof ae[ae.length - 1] != "function" ? noop$1 : ae.pop();
}
function pipeline() {
  for (var ae = arguments.length, ie = new Array(ae), se = 0; se < ae; se++)
    ie[se] = arguments[se];
  var fe = popCallback(ie);
  if (Array.isArray(ie[0]) && (ie = ie[0]), ie.length < 2)
    throw new ERR_MISSING_ARGS("streams");
  var ue, ce = ie.map(function(de, me) {
    var we = me < ie.length - 1, Ee = me > 0;
    return destroyer(de, we, Ee, function(Se) {
      ue || (ue = Se), Se && ce.forEach(call), !we && (ce.forEach(call), fe(ue));
    });
  });
  return ie.reduce(pipe);
}
var pipeline_1 = pipeline;
(function(ae, ie) {
  ie = ae.exports = require_stream_readable(), ie.Stream = ie, ie.Readable = ie, ie.Writable = require_stream_writable(), ie.Duplex = require_stream_duplex(), ie.Transform = _stream_transform, ie.PassThrough = _stream_passthrough, ie.finished = endOfStream, ie.pipeline = pipeline_1;
})(readableBrowser, readableBrowser.exports);
var readableBrowserExports = readableBrowser.exports, Buffer$C = safeBufferExports.Buffer, Transform$7 = readableBrowserExports.Transform, inherits$x = inherits_browserExports;
function throwIfNotStringOrBuffer(ae, ie) {
  if (!Buffer$C.isBuffer(ae) && typeof ae != "string")
    throw new TypeError(ie + " must be a string or a buffer");
}
function HashBase$2(ae) {
  Transform$7.call(this), this._block = Buffer$C.allocUnsafe(ae), this._blockSize = ae, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
}
inherits$x(HashBase$2, Transform$7);
HashBase$2.prototype._transform = function(ae, ie, se) {
  var fe = null;
  try {
    this.update(ae, ie);
  } catch (ue) {
    fe = ue;
  }
  se(fe);
};
HashBase$2.prototype._flush = function(ae) {
  var ie = null;
  try {
    this.push(this.digest());
  } catch (se) {
    ie = se;
  }
  ae(ie);
};
HashBase$2.prototype.update = function(ae, ie) {
  if (throwIfNotStringOrBuffer(ae, "Data"), this._finalized)
    throw new Error("Digest already called");
  Buffer$C.isBuffer(ae) || (ae = Buffer$C.from(ae, ie));
  for (var se = this._block, fe = 0; this._blockOffset + ae.length - fe >= this._blockSize; ) {
    for (var ue = this._blockOffset; ue < this._blockSize; )
      se[ue++] = ae[fe++];
    this._update(), this._blockOffset = 0;
  }
  for (; fe < ae.length; )
    se[this._blockOffset++] = ae[fe++];
  for (var ce = 0, de = ae.length * 8; de > 0; ++ce)
    this._length[ce] += de, de = this._length[ce] / 4294967296 | 0, de > 0 && (this._length[ce] -= 4294967296 * de);
  return this;
};
HashBase$2.prototype._update = function() {
  throw new Error("_update is not implemented");
};
HashBase$2.prototype.digest = function(ae) {
  if (this._finalized)
    throw new Error("Digest already called");
  this._finalized = !0;
  var ie = this._digest();
  ae !== void 0 && (ie = ie.toString(ae)), this._block.fill(0), this._blockOffset = 0;
  for (var se = 0; se < 4; ++se)
    this._length[se] = 0;
  return ie;
};
HashBase$2.prototype._digest = function() {
  throw new Error("_digest is not implemented");
};
var hashBase = HashBase$2, inherits$w = inherits_browserExports, HashBase$1 = hashBase, Buffer$B = safeBufferExports.Buffer, ARRAY16$1 = new Array(16);
function MD5$3() {
  HashBase$1.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
}
inherits$w(MD5$3, HashBase$1);
MD5$3.prototype._update = function() {
  for (var ae = ARRAY16$1, ie = 0; ie < 16; ++ie)
    ae[ie] = this._block.readInt32LE(ie * 4);
  var se = this._a, fe = this._b, ue = this._c, ce = this._d;
  se = fnF(se, fe, ue, ce, ae[0], 3614090360, 7), ce = fnF(ce, se, fe, ue, ae[1], 3905402710, 12), ue = fnF(ue, ce, se, fe, ae[2], 606105819, 17), fe = fnF(fe, ue, ce, se, ae[3], 3250441966, 22), se = fnF(se, fe, ue, ce, ae[4], 4118548399, 7), ce = fnF(ce, se, fe, ue, ae[5], 1200080426, 12), ue = fnF(ue, ce, se, fe, ae[6], 2821735955, 17), fe = fnF(fe, ue, ce, se, ae[7], 4249261313, 22), se = fnF(se, fe, ue, ce, ae[8], 1770035416, 7), ce = fnF(ce, se, fe, ue, ae[9], 2336552879, 12), ue = fnF(ue, ce, se, fe, ae[10], 4294925233, 17), fe = fnF(fe, ue, ce, se, ae[11], 2304563134, 22), se = fnF(se, fe, ue, ce, ae[12], 1804603682, 7), ce = fnF(ce, se, fe, ue, ae[13], 4254626195, 12), ue = fnF(ue, ce, se, fe, ae[14], 2792965006, 17), fe = fnF(fe, ue, ce, se, ae[15], 1236535329, 22), se = fnG(se, fe, ue, ce, ae[1], 4129170786, 5), ce = fnG(ce, se, fe, ue, ae[6], 3225465664, 9), ue = fnG(ue, ce, se, fe, ae[11], 643717713, 14), fe = fnG(fe, ue, ce, se, ae[0], 3921069994, 20), se = fnG(se, fe, ue, ce, ae[5], 3593408605, 5), ce = fnG(ce, se, fe, ue, ae[10], 38016083, 9), ue = fnG(ue, ce, se, fe, ae[15], 3634488961, 14), fe = fnG(fe, ue, ce, se, ae[4], 3889429448, 20), se = fnG(se, fe, ue, ce, ae[9], 568446438, 5), ce = fnG(ce, se, fe, ue, ae[14], 3275163606, 9), ue = fnG(ue, ce, se, fe, ae[3], 4107603335, 14), fe = fnG(fe, ue, ce, se, ae[8], 1163531501, 20), se = fnG(se, fe, ue, ce, ae[13], 2850285829, 5), ce = fnG(ce, se, fe, ue, ae[2], 4243563512, 9), ue = fnG(ue, ce, se, fe, ae[7], 1735328473, 14), fe = fnG(fe, ue, ce, se, ae[12], 2368359562, 20), se = fnH(se, fe, ue, ce, ae[5], 4294588738, 4), ce = fnH(ce, se, fe, ue, ae[8], 2272392833, 11), ue = fnH(ue, ce, se, fe, ae[11], 1839030562, 16), fe = fnH(fe, ue, ce, se, ae[14], 4259657740, 23), se = fnH(se, fe, ue, ce, ae[1], 2763975236, 4), ce = fnH(ce, se, fe, ue, ae[4], 1272893353, 11), ue = fnH(ue, ce, se, fe, ae[7], 4139469664, 16), fe = fnH(fe, ue, ce, se, ae[10], 3200236656, 23), se = fnH(se, fe, ue, ce, ae[13], 681279174, 4), ce = fnH(ce, se, fe, ue, ae[0], 3936430074, 11), ue = fnH(ue, ce, se, fe, ae[3], 3572445317, 16), fe = fnH(fe, ue, ce, se, ae[6], 76029189, 23), se = fnH(se, fe, ue, ce, ae[9], 3654602809, 4), ce = fnH(ce, se, fe, ue, ae[12], 3873151461, 11), ue = fnH(ue, ce, se, fe, ae[15], 530742520, 16), fe = fnH(fe, ue, ce, se, ae[2], 3299628645, 23), se = fnI(se, fe, ue, ce, ae[0], 4096336452, 6), ce = fnI(ce, se, fe, ue, ae[7], 1126891415, 10), ue = fnI(ue, ce, se, fe, ae[14], 2878612391, 15), fe = fnI(fe, ue, ce, se, ae[5], 4237533241, 21), se = fnI(se, fe, ue, ce, ae[12], 1700485571, 6), ce = fnI(ce, se, fe, ue, ae[3], 2399980690, 10), ue = fnI(ue, ce, se, fe, ae[10], 4293915773, 15), fe = fnI(fe, ue, ce, se, ae[1], 2240044497, 21), se = fnI(se, fe, ue, ce, ae[8], 1873313359, 6), ce = fnI(ce, se, fe, ue, ae[15], 4264355552, 10), ue = fnI(ue, ce, se, fe, ae[6], 2734768916, 15), fe = fnI(fe, ue, ce, se, ae[13], 1309151649, 21), se = fnI(se, fe, ue, ce, ae[4], 4149444226, 6), ce = fnI(ce, se, fe, ue, ae[11], 3174756917, 10), ue = fnI(ue, ce, se, fe, ae[2], 718787259, 15), fe = fnI(fe, ue, ce, se, ae[9], 3951481745, 21), this._a = this._a + se | 0, this._b = this._b + fe | 0, this._c = this._c + ue | 0, this._d = this._d + ce | 0;
};
MD5$3.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var ae = Buffer$B.allocUnsafe(16);
  return ae.writeInt32LE(this._a, 0), ae.writeInt32LE(this._b, 4), ae.writeInt32LE(this._c, 8), ae.writeInt32LE(this._d, 12), ae;
};
function rotl$2(ae, ie) {
  return ae << ie | ae >>> 32 - ie;
}
function fnF(ae, ie, se, fe, ue, ce, de) {
  return rotl$2(ae + (ie & se | ~ie & fe) + ue + ce | 0, de) + ie | 0;
}
function fnG(ae, ie, se, fe, ue, ce, de) {
  return rotl$2(ae + (ie & fe | se & ~fe) + ue + ce | 0, de) + ie | 0;
}
function fnH(ae, ie, se, fe, ue, ce, de) {
  return rotl$2(ae + (ie ^ se ^ fe) + ue + ce | 0, de) + ie | 0;
}
function fnI(ae, ie, se, fe, ue, ce, de) {
  return rotl$2(ae + (se ^ (ie | ~fe)) + ue + ce | 0, de) + ie | 0;
}
var md5_js = MD5$3, Buffer$A = require$$0$2.Buffer, inherits$v = inherits_browserExports, HashBase = hashBase, ARRAY16 = new Array(16), zl = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], zr = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], sl = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sr = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], hl = [0, 1518500249, 1859775393, 2400959708, 2840853838], hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
function RIPEMD160$5() {
  HashBase.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
}
inherits$v(RIPEMD160$5, HashBase);
RIPEMD160$5.prototype._update = function() {
  for (var ae = ARRAY16, ie = 0; ie < 16; ++ie)
    ae[ie] = this._block.readInt32LE(ie * 4);
  for (var se = this._a | 0, fe = this._b | 0, ue = this._c | 0, ce = this._d | 0, de = this._e | 0, me = this._a | 0, we = this._b | 0, Ee = this._c | 0, Se = this._d | 0, Be = this._e | 0, Ce = 0; Ce < 80; Ce += 1) {
    var Ie, Pe;
    Ce < 16 ? (Ie = fn1(se, fe, ue, ce, de, ae[zl[Ce]], hl[0], sl[Ce]), Pe = fn5(me, we, Ee, Se, Be, ae[zr[Ce]], hr[0], sr[Ce])) : Ce < 32 ? (Ie = fn2(se, fe, ue, ce, de, ae[zl[Ce]], hl[1], sl[Ce]), Pe = fn4(me, we, Ee, Se, Be, ae[zr[Ce]], hr[1], sr[Ce])) : Ce < 48 ? (Ie = fn3(se, fe, ue, ce, de, ae[zl[Ce]], hl[2], sl[Ce]), Pe = fn3(me, we, Ee, Se, Be, ae[zr[Ce]], hr[2], sr[Ce])) : Ce < 64 ? (Ie = fn4(se, fe, ue, ce, de, ae[zl[Ce]], hl[3], sl[Ce]), Pe = fn2(me, we, Ee, Se, Be, ae[zr[Ce]], hr[3], sr[Ce])) : (Ie = fn5(se, fe, ue, ce, de, ae[zl[Ce]], hl[4], sl[Ce]), Pe = fn1(me, we, Ee, Se, Be, ae[zr[Ce]], hr[4], sr[Ce])), se = de, de = ce, ce = rotl$1(ue, 10), ue = fe, fe = Ie, me = Be, Be = Se, Se = rotl$1(Ee, 10), Ee = we, we = Pe;
  }
  var Ne = this._b + ue + Se | 0;
  this._b = this._c + ce + Be | 0, this._c = this._d + de + me | 0, this._d = this._e + se + we | 0, this._e = this._a + fe + Ee | 0, this._a = Ne;
};
RIPEMD160$5.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var ae = Buffer$A.alloc ? Buffer$A.alloc(20) : new Buffer$A(20);
  return ae.writeInt32LE(this._a, 0), ae.writeInt32LE(this._b, 4), ae.writeInt32LE(this._c, 8), ae.writeInt32LE(this._d, 12), ae.writeInt32LE(this._e, 16), ae;
};
function rotl$1(ae, ie) {
  return ae << ie | ae >>> 32 - ie;
}
function fn1(ae, ie, se, fe, ue, ce, de, me) {
  return rotl$1(ae + (ie ^ se ^ fe) + ce + de | 0, me) + ue | 0;
}
function fn2(ae, ie, se, fe, ue, ce, de, me) {
  return rotl$1(ae + (ie & se | ~ie & fe) + ce + de | 0, me) + ue | 0;
}
function fn3(ae, ie, se, fe, ue, ce, de, me) {
  return rotl$1(ae + ((ie | ~se) ^ fe) + ce + de | 0, me) + ue | 0;
}
function fn4(ae, ie, se, fe, ue, ce, de, me) {
  return rotl$1(ae + (ie & fe | se & ~fe) + ce + de | 0, me) + ue | 0;
}
function fn5(ae, ie, se, fe, ue, ce, de, me) {
  return rotl$1(ae + (ie ^ (se | ~fe)) + ce + de | 0, me) + ue | 0;
}
var ripemd160$2 = RIPEMD160$5, sha_js = { exports: {} }, Buffer$z = safeBufferExports.Buffer;
function Hash$8(ae, ie) {
  this._block = Buffer$z.alloc(ae), this._finalSize = ie, this._blockSize = ae, this._len = 0;
}
Hash$8.prototype.update = function(ae, ie) {
  typeof ae == "string" && (ie = ie || "utf8", ae = Buffer$z.from(ae, ie));
  for (var se = this._block, fe = this._blockSize, ue = ae.length, ce = this._len, de = 0; de < ue; ) {
    for (var me = ce % fe, we = Math.min(ue - de, fe - me), Ee = 0; Ee < we; Ee++)
      se[me + Ee] = ae[de + Ee];
    ce += we, de += we, ce % fe === 0 && this._update(se);
  }
  return this._len += ue, this;
};
Hash$8.prototype.digest = function(ae) {
  var ie = this._len % this._blockSize;
  this._block[ie] = 128, this._block.fill(0, ie + 1), ie >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var se = this._len * 8;
  if (se <= 4294967295)
    this._block.writeUInt32BE(se, this._blockSize - 4);
  else {
    var fe = (se & 4294967295) >>> 0, ue = (se - fe) / 4294967296;
    this._block.writeUInt32BE(ue, this._blockSize - 8), this._block.writeUInt32BE(fe, this._blockSize - 4);
  }
  this._update(this._block);
  var ce = this._hash();
  return ae ? ce.toString(ae) : ce;
};
Hash$8.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var hash$5 = Hash$8, inherits$u = inherits_browserExports, Hash$7 = hash$5, Buffer$y = safeBufferExports.Buffer, K$7 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], W$8 = new Array(80);
function Sha() {
  this.init(), this._w = W$8, Hash$7.call(this, 64, 56);
}
inherits$u(Sha, Hash$7);
Sha.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function rotl5$1(ae) {
  return ae << 5 | ae >>> 27;
}
function rotl30$1(ae) {
  return ae << 30 | ae >>> 2;
}
function ft$1(ae, ie, se, fe) {
  return ae === 0 ? ie & se | ~ie & fe : ae === 2 ? ie & se | ie & fe | se & fe : ie ^ se ^ fe;
}
Sha.prototype._update = function(ae) {
  for (var ie = this._w, se = this._a | 0, fe = this._b | 0, ue = this._c | 0, ce = this._d | 0, de = this._e | 0, me = 0; me < 16; ++me)
    ie[me] = ae.readInt32BE(me * 4);
  for (; me < 80; ++me)
    ie[me] = ie[me - 3] ^ ie[me - 8] ^ ie[me - 14] ^ ie[me - 16];
  for (var we = 0; we < 80; ++we) {
    var Ee = ~~(we / 20), Se = rotl5$1(se) + ft$1(Ee, fe, ue, ce) + de + ie[we] + K$7[Ee] | 0;
    de = ce, ce = ue, ue = rotl30$1(fe), fe = se, se = Se;
  }
  this._a = se + this._a | 0, this._b = fe + this._b | 0, this._c = ue + this._c | 0, this._d = ce + this._d | 0, this._e = de + this._e | 0;
};
Sha.prototype._hash = function() {
  var ae = Buffer$y.allocUnsafe(20);
  return ae.writeInt32BE(this._a | 0, 0), ae.writeInt32BE(this._b | 0, 4), ae.writeInt32BE(this._c | 0, 8), ae.writeInt32BE(this._d | 0, 12), ae.writeInt32BE(this._e | 0, 16), ae;
};
var sha$4 = Sha, inherits$t = inherits_browserExports, Hash$6 = hash$5, Buffer$x = safeBufferExports.Buffer, K$6 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], W$7 = new Array(80);
function Sha1() {
  this.init(), this._w = W$7, Hash$6.call(this, 64, 56);
}
inherits$t(Sha1, Hash$6);
Sha1.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function rotl1(ae) {
  return ae << 1 | ae >>> 31;
}
function rotl5(ae) {
  return ae << 5 | ae >>> 27;
}
function rotl30(ae) {
  return ae << 30 | ae >>> 2;
}
function ft(ae, ie, se, fe) {
  return ae === 0 ? ie & se | ~ie & fe : ae === 2 ? ie & se | ie & fe | se & fe : ie ^ se ^ fe;
}
Sha1.prototype._update = function(ae) {
  for (var ie = this._w, se = this._a | 0, fe = this._b | 0, ue = this._c | 0, ce = this._d | 0, de = this._e | 0, me = 0; me < 16; ++me)
    ie[me] = ae.readInt32BE(me * 4);
  for (; me < 80; ++me)
    ie[me] = rotl1(ie[me - 3] ^ ie[me - 8] ^ ie[me - 14] ^ ie[me - 16]);
  for (var we = 0; we < 80; ++we) {
    var Ee = ~~(we / 20), Se = rotl5(se) + ft(Ee, fe, ue, ce) + de + ie[we] + K$6[Ee] | 0;
    de = ce, ce = ue, ue = rotl30(fe), fe = se, se = Se;
  }
  this._a = se + this._a | 0, this._b = fe + this._b | 0, this._c = ue + this._c | 0, this._d = ce + this._d | 0, this._e = de + this._e | 0;
};
Sha1.prototype._hash = function() {
  var ae = Buffer$x.allocUnsafe(20);
  return ae.writeInt32BE(this._a | 0, 0), ae.writeInt32BE(this._b | 0, 4), ae.writeInt32BE(this._c | 0, 8), ae.writeInt32BE(this._d | 0, 12), ae.writeInt32BE(this._e | 0, 16), ae;
};
var sha1$1 = Sha1, inherits$s = inherits_browserExports, Hash$5 = hash$5, Buffer$w = safeBufferExports.Buffer, K$5 = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
], W$6 = new Array(64);
function Sha256$1() {
  this.init(), this._w = W$6, Hash$5.call(this, 64, 56);
}
inherits$s(Sha256$1, Hash$5);
Sha256$1.prototype.init = function() {
  return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
};
function ch(ae, ie, se) {
  return se ^ ae & (ie ^ se);
}
function maj$1(ae, ie, se) {
  return ae & ie | se & (ae | ie);
}
function sigma0$1(ae) {
  return (ae >>> 2 | ae << 30) ^ (ae >>> 13 | ae << 19) ^ (ae >>> 22 | ae << 10);
}
function sigma1$1(ae) {
  return (ae >>> 6 | ae << 26) ^ (ae >>> 11 | ae << 21) ^ (ae >>> 25 | ae << 7);
}
function gamma0(ae) {
  return (ae >>> 7 | ae << 25) ^ (ae >>> 18 | ae << 14) ^ ae >>> 3;
}
function gamma1(ae) {
  return (ae >>> 17 | ae << 15) ^ (ae >>> 19 | ae << 13) ^ ae >>> 10;
}
Sha256$1.prototype._update = function(ae) {
  for (var ie = this._w, se = this._a | 0, fe = this._b | 0, ue = this._c | 0, ce = this._d | 0, de = this._e | 0, me = this._f | 0, we = this._g | 0, Ee = this._h | 0, Se = 0; Se < 16; ++Se)
    ie[Se] = ae.readInt32BE(Se * 4);
  for (; Se < 64; ++Se)
    ie[Se] = gamma1(ie[Se - 2]) + ie[Se - 7] + gamma0(ie[Se - 15]) + ie[Se - 16] | 0;
  for (var Be = 0; Be < 64; ++Be) {
    var Ce = Ee + sigma1$1(de) + ch(de, me, we) + K$5[Be] + ie[Be] | 0, Ie = sigma0$1(se) + maj$1(se, fe, ue) | 0;
    Ee = we, we = me, me = de, de = ce + Ce | 0, ce = ue, ue = fe, fe = se, se = Ce + Ie | 0;
  }
  this._a = se + this._a | 0, this._b = fe + this._b | 0, this._c = ue + this._c | 0, this._d = ce + this._d | 0, this._e = de + this._e | 0, this._f = me + this._f | 0, this._g = we + this._g | 0, this._h = Ee + this._h | 0;
};
Sha256$1.prototype._hash = function() {
  var ae = Buffer$w.allocUnsafe(32);
  return ae.writeInt32BE(this._a, 0), ae.writeInt32BE(this._b, 4), ae.writeInt32BE(this._c, 8), ae.writeInt32BE(this._d, 12), ae.writeInt32BE(this._e, 16), ae.writeInt32BE(this._f, 20), ae.writeInt32BE(this._g, 24), ae.writeInt32BE(this._h, 28), ae;
};
var sha256$4 = Sha256$1, inherits$r = inherits_browserExports, Sha256 = sha256$4, Hash$4 = hash$5, Buffer$v = safeBufferExports.Buffer, W$5 = new Array(64);
function Sha224() {
  this.init(), this._w = W$5, Hash$4.call(this, 64, 56);
}
inherits$r(Sha224, Sha256);
Sha224.prototype.init = function() {
  return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
};
Sha224.prototype._hash = function() {
  var ae = Buffer$v.allocUnsafe(28);
  return ae.writeInt32BE(this._a, 0), ae.writeInt32BE(this._b, 4), ae.writeInt32BE(this._c, 8), ae.writeInt32BE(this._d, 12), ae.writeInt32BE(this._e, 16), ae.writeInt32BE(this._f, 20), ae.writeInt32BE(this._g, 24), ae;
};
var sha224$1 = Sha224, inherits$q = inherits_browserExports, Hash$3 = hash$5, Buffer$u = safeBufferExports.Buffer, K$4 = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
], W$4 = new Array(160);
function Sha512() {
  this.init(), this._w = W$4, Hash$3.call(this, 128, 112);
}
inherits$q(Sha512, Hash$3);
Sha512.prototype.init = function() {
  return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
};
function Ch(ae, ie, se) {
  return se ^ ae & (ie ^ se);
}
function maj(ae, ie, se) {
  return ae & ie | se & (ae | ie);
}
function sigma0(ae, ie) {
  return (ae >>> 28 | ie << 4) ^ (ie >>> 2 | ae << 30) ^ (ie >>> 7 | ae << 25);
}
function sigma1(ae, ie) {
  return (ae >>> 14 | ie << 18) ^ (ae >>> 18 | ie << 14) ^ (ie >>> 9 | ae << 23);
}
function Gamma0(ae, ie) {
  return (ae >>> 1 | ie << 31) ^ (ae >>> 8 | ie << 24) ^ ae >>> 7;
}
function Gamma0l(ae, ie) {
  return (ae >>> 1 | ie << 31) ^ (ae >>> 8 | ie << 24) ^ (ae >>> 7 | ie << 25);
}
function Gamma1(ae, ie) {
  return (ae >>> 19 | ie << 13) ^ (ie >>> 29 | ae << 3) ^ ae >>> 6;
}
function Gamma1l(ae, ie) {
  return (ae >>> 19 | ie << 13) ^ (ie >>> 29 | ae << 3) ^ (ae >>> 6 | ie << 26);
}
function getCarry(ae, ie) {
  return ae >>> 0 < ie >>> 0 ? 1 : 0;
}
Sha512.prototype._update = function(ae) {
  for (var ie = this._w, se = this._ah | 0, fe = this._bh | 0, ue = this._ch | 0, ce = this._dh | 0, de = this._eh | 0, me = this._fh | 0, we = this._gh | 0, Ee = this._hh | 0, Se = this._al | 0, Be = this._bl | 0, Ce = this._cl | 0, Ie = this._dl | 0, Pe = this._el | 0, Ne = this._fl | 0, ke = this._gl | 0, He = this._hl | 0, De = 0; De < 32; De += 2)
    ie[De] = ae.readInt32BE(De * 4), ie[De + 1] = ae.readInt32BE(De * 4 + 4);
  for (; De < 160; De += 2) {
    var Ge = ie[De - 30], Ye = ie[De - 15 * 2 + 1], st = Gamma0(Ge, Ye), at = Gamma0l(Ye, Ge);
    Ge = ie[De - 2 * 2], Ye = ie[De - 2 * 2 + 1];
    var mt = Gamma1(Ge, Ye), qe = Gamma1l(Ye, Ge), ze = ie[De - 7 * 2], ot = ie[De - 7 * 2 + 1], $e = ie[De - 16 * 2], le = ie[De - 16 * 2 + 1], pe = at + ot | 0, ge = st + ze + getCarry(pe, at) | 0;
    pe = pe + qe | 0, ge = ge + mt + getCarry(pe, qe) | 0, pe = pe + le | 0, ge = ge + $e + getCarry(pe, le) | 0, ie[De] = ge, ie[De + 1] = pe;
  }
  for (var ye = 0; ye < 160; ye += 2) {
    ge = ie[ye], pe = ie[ye + 1];
    var xe = maj(se, fe, ue), _e = maj(Se, Be, Ce), Ae = sigma0(se, Se), ve = sigma0(Se, se), he = sigma1(de, Pe), be = sigma1(Pe, de), Me = K$4[ye], Re = K$4[ye + 1], Oe = Ch(de, me, we), Te = Ch(Pe, Ne, ke), Fe = He + be | 0, je = Ee + he + getCarry(Fe, He) | 0;
    Fe = Fe + Te | 0, je = je + Oe + getCarry(Fe, Te) | 0, Fe = Fe + Re | 0, je = je + Me + getCarry(Fe, Re) | 0, Fe = Fe + pe | 0, je = je + ge + getCarry(Fe, pe) | 0;
    var ct = ve + _e | 0, nt = Ae + xe + getCarry(ct, ve) | 0;
    Ee = we, He = ke, we = me, ke = Ne, me = de, Ne = Pe, Pe = Ie + Fe | 0, de = ce + je + getCarry(Pe, Ie) | 0, ce = ue, Ie = Ce, ue = fe, Ce = Be, fe = se, Be = Se, Se = Fe + ct | 0, se = je + nt + getCarry(Se, Fe) | 0;
  }
  this._al = this._al + Se | 0, this._bl = this._bl + Be | 0, this._cl = this._cl + Ce | 0, this._dl = this._dl + Ie | 0, this._el = this._el + Pe | 0, this._fl = this._fl + Ne | 0, this._gl = this._gl + ke | 0, this._hl = this._hl + He | 0, this._ah = this._ah + se + getCarry(this._al, Se) | 0, this._bh = this._bh + fe + getCarry(this._bl, Be) | 0, this._ch = this._ch + ue + getCarry(this._cl, Ce) | 0, this._dh = this._dh + ce + getCarry(this._dl, Ie) | 0, this._eh = this._eh + de + getCarry(this._el, Pe) | 0, this._fh = this._fh + me + getCarry(this._fl, Ne) | 0, this._gh = this._gh + we + getCarry(this._gl, ke) | 0, this._hh = this._hh + Ee + getCarry(this._hl, He) | 0;
};
Sha512.prototype._hash = function() {
  var ae = Buffer$u.allocUnsafe(64);
  function ie(se, fe, ue) {
    ae.writeInt32BE(se, ue), ae.writeInt32BE(fe, ue + 4);
  }
  return ie(this._ah, this._al, 0), ie(this._bh, this._bl, 8), ie(this._ch, this._cl, 16), ie(this._dh, this._dl, 24), ie(this._eh, this._el, 32), ie(this._fh, this._fl, 40), ie(this._gh, this._gl, 48), ie(this._hh, this._hl, 56), ae;
};
var sha512$2 = Sha512, inherits$p = inherits_browserExports, SHA512$3 = sha512$2, Hash$2 = hash$5, Buffer$t = safeBufferExports.Buffer, W$3 = new Array(160);
function Sha384() {
  this.init(), this._w = W$3, Hash$2.call(this, 128, 112);
}
inherits$p(Sha384, SHA512$3);
Sha384.prototype.init = function() {
  return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
};
Sha384.prototype._hash = function() {
  var ae = Buffer$t.allocUnsafe(48);
  function ie(se, fe, ue) {
    ae.writeInt32BE(se, ue), ae.writeInt32BE(fe, ue + 4);
  }
  return ie(this._ah, this._al, 0), ie(this._bh, this._bl, 8), ie(this._ch, this._cl, 16), ie(this._dh, this._dl, 24), ie(this._eh, this._el, 32), ie(this._fh, this._fl, 40), ae;
};
var sha384$1 = Sha384, exports = sha_js.exports = function(ie) {
  ie = ie.toLowerCase();
  var se = exports[ie];
  if (!se)
    throw new Error(ie + " is not supported (we accept pull requests)");
  return new se();
};
exports.sha = sha$4;
exports.sha1 = sha1$1;
exports.sha224 = sha224$1;
exports.sha256 = sha256$4;
exports.sha384 = sha384$1;
exports.sha512 = sha512$2;
var sha_jsExports = sha_js.exports, streamBrowserify = Stream$1, EE = eventsExports.EventEmitter, inherits$o = inherits_browserExports;
inherits$o(Stream$1, EE);
Stream$1.Readable = require_stream_readable();
Stream$1.Writable = require_stream_writable();
Stream$1.Duplex = require_stream_duplex();
Stream$1.Transform = _stream_transform;
Stream$1.PassThrough = _stream_passthrough;
Stream$1.finished = endOfStream;
Stream$1.pipeline = pipeline_1;
Stream$1.Stream = Stream$1;
function Stream$1() {
  EE.call(this);
}
Stream$1.prototype.pipe = function(ae, ie) {
  var se = this;
  function fe(Se) {
    ae.writable && ae.write(Se) === !1 && se.pause && se.pause();
  }
  se.on("data", fe);
  function ue() {
    se.readable && se.resume && se.resume();
  }
  ae.on("drain", ue), !ae._isStdio && (!ie || ie.end !== !1) && (se.on("end", de), se.on("close", me));
  var ce = !1;
  function de() {
    ce || (ce = !0, ae.end());
  }
  function me() {
    ce || (ce = !0, typeof ae.destroy == "function" && ae.destroy());
  }
  function we(Se) {
    if (Ee(), EE.listenerCount(this, "error") === 0)
      throw Se;
  }
  se.on("error", we), ae.on("error", we);
  function Ee() {
    se.removeListener("data", fe), ae.removeListener("drain", ue), se.removeListener("end", de), se.removeListener("close", me), se.removeListener("error", we), ae.removeListener("error", we), se.removeListener("end", Ee), se.removeListener("close", Ee), ae.removeListener("close", Ee);
  }
  return se.on("end", Ee), se.on("close", Ee), ae.on("close", Ee), ae.emit("pipe", se), ae;
};
var Buffer$s = safeBufferExports.Buffer, Transform$6 = streamBrowserify.Transform, StringDecoder = string_decoder.StringDecoder, inherits$n = inherits_browserExports;
function CipherBase$1(ae) {
  Transform$6.call(this), this.hashMode = typeof ae == "string", this.hashMode ? this[ae] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
}
inherits$n(CipherBase$1, Transform$6);
CipherBase$1.prototype.update = function(ae, ie, se) {
  typeof ae == "string" && (ae = Buffer$s.from(ae, ie));
  var fe = this._update(ae);
  return this.hashMode ? this : (se && (fe = this._toString(fe, se)), fe);
};
CipherBase$1.prototype.setAutoPadding = function() {
};
CipherBase$1.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
CipherBase$1.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
CipherBase$1.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
CipherBase$1.prototype._transform = function(ae, ie, se) {
  var fe;
  try {
    this.hashMode ? this._update(ae) : this.push(this._update(ae));
  } catch (ue) {
    fe = ue;
  } finally {
    se(fe);
  }
};
CipherBase$1.prototype._flush = function(ae) {
  var ie;
  try {
    this.push(this.__final());
  } catch (se) {
    ie = se;
  }
  ae(ie);
};
CipherBase$1.prototype._finalOrDigest = function(ae) {
  var ie = this.__final() || Buffer$s.alloc(0);
  return ae && (ie = this._toString(ie, ae, !0)), ie;
};
CipherBase$1.prototype._toString = function(ae, ie, se) {
  if (this._decoder || (this._decoder = new StringDecoder(ie), this._encoding = ie), this._encoding !== ie)
    throw new Error("can't switch encodings");
  var fe = this._decoder.write(ae);
  return se && (fe += this._decoder.end()), fe;
};
var cipherBase = CipherBase$1, inherits$m = inherits_browserExports, MD5$2 = md5_js, RIPEMD160$4 = ripemd160$2, sha$3 = sha_jsExports, Base$5 = cipherBase;
function Hash$1(ae) {
  Base$5.call(this, "digest"), this._hash = ae;
}
inherits$m(Hash$1, Base$5);
Hash$1.prototype._update = function(ae) {
  this._hash.update(ae);
};
Hash$1.prototype._final = function() {
  return this._hash.digest();
};
var browser$b = function(ie) {
  return ie = ie.toLowerCase(), ie === "md5" ? new MD5$2() : ie === "rmd160" || ie === "ripemd160" ? new RIPEMD160$4() : new Hash$1(sha$3(ie));
}, inherits$l = inherits_browserExports, Buffer$r = safeBufferExports.Buffer, Base$4 = cipherBase, ZEROS$2 = Buffer$r.alloc(128), blocksize = 64;
function Hmac$3(ae, ie) {
  Base$4.call(this, "digest"), typeof ie == "string" && (ie = Buffer$r.from(ie)), this._alg = ae, this._key = ie, ie.length > blocksize ? ie = ae(ie) : ie.length < blocksize && (ie = Buffer$r.concat([ie, ZEROS$2], blocksize));
  for (var se = this._ipad = Buffer$r.allocUnsafe(blocksize), fe = this._opad = Buffer$r.allocUnsafe(blocksize), ue = 0; ue < blocksize; ue++)
    se[ue] = ie[ue] ^ 54, fe[ue] = ie[ue] ^ 92;
  this._hash = [se];
}
inherits$l(Hmac$3, Base$4);
Hmac$3.prototype._update = function(ae) {
  this._hash.push(ae);
};
Hmac$3.prototype._final = function() {
  var ae = this._alg(Buffer$r.concat(this._hash));
  return this._alg(Buffer$r.concat([this._opad, ae]));
};
var legacy = Hmac$3, MD5$1 = md5_js, md5$3 = function(ae) {
  return new MD5$1().update(ae).digest();
}, inherits$k = inherits_browserExports, Legacy = legacy, Base$3 = cipherBase, Buffer$q = safeBufferExports.Buffer, md5$2 = md5$3, RIPEMD160$3 = ripemd160$2, sha$2 = sha_jsExports, ZEROS$1 = Buffer$q.alloc(128);
function Hmac$2(ae, ie) {
  Base$3.call(this, "digest"), typeof ie == "string" && (ie = Buffer$q.from(ie));
  var se = ae === "sha512" || ae === "sha384" ? 128 : 64;
  if (this._alg = ae, this._key = ie, ie.length > se) {
    var fe = ae === "rmd160" ? new RIPEMD160$3() : sha$2(ae);
    ie = fe.update(ie).digest();
  } else
    ie.length < se && (ie = Buffer$q.concat([ie, ZEROS$1], se));
  for (var ue = this._ipad = Buffer$q.allocUnsafe(se), ce = this._opad = Buffer$q.allocUnsafe(se), de = 0; de < se; de++)
    ue[de] = ie[de] ^ 54, ce[de] = ie[de] ^ 92;
  this._hash = ae === "rmd160" ? new RIPEMD160$3() : sha$2(ae), this._hash.update(ue);
}
inherits$k(Hmac$2, Base$3);
Hmac$2.prototype._update = function(ae) {
  this._hash.update(ae);
};
Hmac$2.prototype._final = function() {
  var ae = this._hash.digest(), ie = this._alg === "rmd160" ? new RIPEMD160$3() : sha$2(this._alg);
  return ie.update(this._opad).update(ae).digest();
};
var browser$a = function(ie, se) {
  return ie = ie.toLowerCase(), ie === "rmd160" || ie === "ripemd160" ? new Hmac$2("rmd160", se) : ie === "md5" ? new Legacy(md5$2, se) : new Hmac$2(ie, se);
};
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256$3 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512$1 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: sha256$3,
  sha224,
  sha384,
  sha512: sha512$1,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos = require$$6, browser$9 = {}, MAX_ALLOC = Math.pow(2, 30) - 1, precondition = function(ae, ie) {
  if (typeof ae != "number")
    throw new TypeError("Iterations not a number");
  if (ae < 0)
    throw new TypeError("Bad iterations");
  if (typeof ie != "number")
    throw new TypeError("Key length not a number");
  if (ie < 0 || ie > MAX_ALLOC || ie !== ie)
    throw new TypeError("Bad key length");
}, defaultEncoding$2;
if (commonjsGlobal.process && commonjsGlobal.process.browser)
  defaultEncoding$2 = "utf-8";
else if (commonjsGlobal.process && commonjsGlobal.process.version) {
  var pVersionMajor = parseInt(process$1.version.split(".")[0].slice(1), 10);
  defaultEncoding$2 = pVersionMajor >= 6 ? "utf-8" : "binary";
} else
  defaultEncoding$2 = "utf-8";
var defaultEncoding_1 = defaultEncoding$2, Buffer$p = safeBufferExports.Buffer, toBuffer$5 = function(ae, ie, se) {
  if (Buffer$p.isBuffer(ae))
    return ae;
  if (typeof ae == "string")
    return Buffer$p.from(ae, ie);
  if (ArrayBuffer.isView(ae))
    return Buffer$p.from(ae.buffer);
  throw new TypeError(se + " must be a string, a Buffer, a typed array or a DataView");
}, md5$1 = md5$3, RIPEMD160$2 = ripemd160$2, sha$1 = sha_jsExports, Buffer$o = safeBufferExports.Buffer, checkParameters$1 = precondition, defaultEncoding$1 = defaultEncoding_1, toBuffer$4 = toBuffer$5, ZEROS = Buffer$o.alloc(128), sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
};
function Hmac$1(ae, ie, se) {
  var fe = getDigest(ae), ue = ae === "sha512" || ae === "sha384" ? 128 : 64;
  ie.length > ue ? ie = fe(ie) : ie.length < ue && (ie = Buffer$o.concat([ie, ZEROS], ue));
  for (var ce = Buffer$o.allocUnsafe(ue + sizes[ae]), de = Buffer$o.allocUnsafe(ue + sizes[ae]), me = 0; me < ue; me++)
    ce[me] = ie[me] ^ 54, de[me] = ie[me] ^ 92;
  var we = Buffer$o.allocUnsafe(ue + se + 4);
  ce.copy(we, 0, 0, ue), this.ipad1 = we, this.ipad2 = ce, this.opad = de, this.alg = ae, this.blocksize = ue, this.hash = fe, this.size = sizes[ae];
}
Hmac$1.prototype.run = function(ae, ie) {
  ae.copy(ie, this.blocksize);
  var se = this.hash(ie);
  return se.copy(this.opad, this.blocksize), this.hash(this.opad);
};
function getDigest(ae) {
  function ie(fe) {
    return sha$1(ae).update(fe).digest();
  }
  function se(fe) {
    return new RIPEMD160$2().update(fe).digest();
  }
  return ae === "rmd160" || ae === "ripemd160" ? se : ae === "md5" ? md5$1 : ie;
}
function pbkdf2$3(ae, ie, se, fe, ue) {
  checkParameters$1(se, fe), ae = toBuffer$4(ae, defaultEncoding$1, "Password"), ie = toBuffer$4(ie, defaultEncoding$1, "Salt"), ue = ue || "sha1";
  var ce = new Hmac$1(ue, ae, ie.length), de = Buffer$o.allocUnsafe(fe), me = Buffer$o.allocUnsafe(ie.length + 4);
  ie.copy(me, 0, 0, ie.length);
  for (var we = 0, Ee = sizes[ue], Se = Math.ceil(fe / Ee), Be = 1; Be <= Se; Be++) {
    me.writeUInt32BE(Be, ie.length);
    for (var Ce = ce.run(me, ce.ipad1), Ie = Ce, Pe = 1; Pe < se; Pe++) {
      Ie = ce.run(Ie, ce.ipad2);
      for (var Ne = 0; Ne < Ee; Ne++)
        Ce[Ne] ^= Ie[Ne];
    }
    Ce.copy(de, we), we += Ee;
  }
  return de;
}
var syncBrowser = pbkdf2$3, Buffer$n = safeBufferExports.Buffer, checkParameters = precondition, defaultEncoding = defaultEncoding_1, sync = syncBrowser, toBuffer$3 = toBuffer$5, ZERO_BUF, subtle = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, toBrowser = {
  sha: "SHA-1",
  "sha-1": "SHA-1",
  sha1: "SHA-1",
  sha256: "SHA-256",
  "sha-256": "SHA-256",
  sha384: "SHA-384",
  "sha-384": "SHA-384",
  "sha-512": "SHA-512",
  sha512: "SHA-512"
}, checks = [];
function checkNative(ae) {
  if (commonjsGlobal.process && !commonjsGlobal.process.browser || !subtle || !subtle.importKey || !subtle.deriveBits)
    return Promise.resolve(!1);
  if (checks[ae] !== void 0)
    return checks[ae];
  ZERO_BUF = ZERO_BUF || Buffer$n.alloc(8);
  var ie = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, ae).then(function() {
    return !0;
  }).catch(function() {
    return !1;
  });
  return checks[ae] = ie, ie;
}
var nextTick;
function getNextTick() {
  return nextTick || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? nextTick = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? nextTick = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? nextTick = commonjsGlobal.setImmediate : nextTick = commonjsGlobal.setTimeout, nextTick);
}
function browserPbkdf2(ae, ie, se, fe, ue) {
  return subtle.importKey(
    "raw",
    ae,
    { name: "PBKDF2" },
    !1,
    ["deriveBits"]
  ).then(function(ce) {
    return subtle.deriveBits({
      name: "PBKDF2",
      salt: ie,
      iterations: se,
      hash: {
        name: ue
      }
    }, ce, fe << 3);
  }).then(function(ce) {
    return Buffer$n.from(ce);
  });
}
function resolvePromise(ae, ie) {
  ae.then(function(se) {
    getNextTick()(function() {
      ie(null, se);
    });
  }, function(se) {
    getNextTick()(function() {
      ie(se);
    });
  });
}
var async = function(ae, ie, se, fe, ue, ce) {
  typeof ue == "function" && (ce = ue, ue = void 0), ue = ue || "sha1";
  var de = toBrowser[ue.toLowerCase()];
  if (!de || typeof commonjsGlobal.Promise != "function") {
    getNextTick()(function() {
      var me;
      try {
        me = sync(ae, ie, se, fe, ue);
      } catch (we) {
        return ce(we);
      }
      ce(null, me);
    });
    return;
  }
  if (checkParameters(se, fe), ae = toBuffer$3(ae, defaultEncoding, "Password"), ie = toBuffer$3(ie, defaultEncoding, "Salt"), typeof ce != "function")
    throw new Error("No callback provided to pbkdf2");
  resolvePromise(checkNative(de).then(function(me) {
    return me ? browserPbkdf2(ae, ie, se, fe, de) : sync(ae, ie, se, fe, ue);
  }), ce);
};
browser$9.pbkdf2 = async;
browser$9.pbkdf2Sync = syncBrowser;
var browser$8 = {}, des$2 = {}, utils$r = {};
utils$r.readUInt32BE = function(ie, se) {
  var fe = ie[0 + se] << 24 | ie[1 + se] << 16 | ie[2 + se] << 8 | ie[3 + se];
  return fe >>> 0;
};
utils$r.writeUInt32BE = function(ie, se, fe) {
  ie[0 + fe] = se >>> 24, ie[1 + fe] = se >>> 16 & 255, ie[2 + fe] = se >>> 8 & 255, ie[3 + fe] = se & 255;
};
utils$r.ip = function(ie, se, fe, ue) {
  for (var ce = 0, de = 0, me = 6; me >= 0; me -= 2) {
    for (var we = 0; we <= 24; we += 8)
      ce <<= 1, ce |= se >>> we + me & 1;
    for (var we = 0; we <= 24; we += 8)
      ce <<= 1, ce |= ie >>> we + me & 1;
  }
  for (var me = 6; me >= 0; me -= 2) {
    for (var we = 1; we <= 25; we += 8)
      de <<= 1, de |= se >>> we + me & 1;
    for (var we = 1; we <= 25; we += 8)
      de <<= 1, de |= ie >>> we + me & 1;
  }
  fe[ue + 0] = ce >>> 0, fe[ue + 1] = de >>> 0;
};
utils$r.rip = function(ie, se, fe, ue) {
  for (var ce = 0, de = 0, me = 0; me < 4; me++)
    for (var we = 24; we >= 0; we -= 8)
      ce <<= 1, ce |= se >>> we + me & 1, ce <<= 1, ce |= ie >>> we + me & 1;
  for (var me = 4; me < 8; me++)
    for (var we = 24; we >= 0; we -= 8)
      de <<= 1, de |= se >>> we + me & 1, de <<= 1, de |= ie >>> we + me & 1;
  fe[ue + 0] = ce >>> 0, fe[ue + 1] = de >>> 0;
};
utils$r.pc1 = function(ie, se, fe, ue) {
  for (var ce = 0, de = 0, me = 7; me >= 5; me--) {
    for (var we = 0; we <= 24; we += 8)
      ce <<= 1, ce |= se >> we + me & 1;
    for (var we = 0; we <= 24; we += 8)
      ce <<= 1, ce |= ie >> we + me & 1;
  }
  for (var we = 0; we <= 24; we += 8)
    ce <<= 1, ce |= se >> we + me & 1;
  for (var me = 1; me <= 3; me++) {
    for (var we = 0; we <= 24; we += 8)
      de <<= 1, de |= se >> we + me & 1;
    for (var we = 0; we <= 24; we += 8)
      de <<= 1, de |= ie >> we + me & 1;
  }
  for (var we = 0; we <= 24; we += 8)
    de <<= 1, de |= ie >> we + me & 1;
  fe[ue + 0] = ce >>> 0, fe[ue + 1] = de >>> 0;
};
utils$r.r28shl = function(ie, se) {
  return ie << se & 268435455 | ie >>> 28 - se;
};
var pc2table = [
  // inL => outL
  14,
  11,
  17,
  4,
  27,
  23,
  25,
  0,
  13,
  22,
  7,
  18,
  5,
  9,
  16,
  24,
  2,
  20,
  12,
  21,
  1,
  8,
  15,
  26,
  // inR => outR
  15,
  4,
  25,
  19,
  9,
  1,
  26,
  16,
  5,
  11,
  23,
  8,
  12,
  7,
  17,
  0,
  22,
  3,
  10,
  14,
  6,
  20,
  27,
  24
];
utils$r.pc2 = function(ie, se, fe, ue) {
  for (var ce = 0, de = 0, me = pc2table.length >>> 1, we = 0; we < me; we++)
    ce <<= 1, ce |= ie >>> pc2table[we] & 1;
  for (var we = me; we < pc2table.length; we++)
    de <<= 1, de |= se >>> pc2table[we] & 1;
  fe[ue + 0] = ce >>> 0, fe[ue + 1] = de >>> 0;
};
utils$r.expand = function(ie, se, fe) {
  var ue = 0, ce = 0;
  ue = (ie & 1) << 5 | ie >>> 27;
  for (var de = 23; de >= 15; de -= 4)
    ue <<= 6, ue |= ie >>> de & 63;
  for (var de = 11; de >= 3; de -= 4)
    ce |= ie >>> de & 63, ce <<= 6;
  ce |= (ie & 31) << 1 | ie >>> 31, se[fe + 0] = ue >>> 0, se[fe + 1] = ce >>> 0;
};
var sTable = [
  14,
  0,
  4,
  15,
  13,
  7,
  1,
  4,
  2,
  14,
  15,
  2,
  11,
  13,
  8,
  1,
  3,
  10,
  10,
  6,
  6,
  12,
  12,
  11,
  5,
  9,
  9,
  5,
  0,
  3,
  7,
  8,
  4,
  15,
  1,
  12,
  14,
  8,
  8,
  2,
  13,
  4,
  6,
  9,
  2,
  1,
  11,
  7,
  15,
  5,
  12,
  11,
  9,
  3,
  7,
  14,
  3,
  10,
  10,
  0,
  5,
  6,
  0,
  13,
  15,
  3,
  1,
  13,
  8,
  4,
  14,
  7,
  6,
  15,
  11,
  2,
  3,
  8,
  4,
  14,
  9,
  12,
  7,
  0,
  2,
  1,
  13,
  10,
  12,
  6,
  0,
  9,
  5,
  11,
  10,
  5,
  0,
  13,
  14,
  8,
  7,
  10,
  11,
  1,
  10,
  3,
  4,
  15,
  13,
  4,
  1,
  2,
  5,
  11,
  8,
  6,
  12,
  7,
  6,
  12,
  9,
  0,
  3,
  5,
  2,
  14,
  15,
  9,
  10,
  13,
  0,
  7,
  9,
  0,
  14,
  9,
  6,
  3,
  3,
  4,
  15,
  6,
  5,
  10,
  1,
  2,
  13,
  8,
  12,
  5,
  7,
  14,
  11,
  12,
  4,
  11,
  2,
  15,
  8,
  1,
  13,
  1,
  6,
  10,
  4,
  13,
  9,
  0,
  8,
  6,
  15,
  9,
  3,
  8,
  0,
  7,
  11,
  4,
  1,
  15,
  2,
  14,
  12,
  3,
  5,
  11,
  10,
  5,
  14,
  2,
  7,
  12,
  7,
  13,
  13,
  8,
  14,
  11,
  3,
  5,
  0,
  6,
  6,
  15,
  9,
  0,
  10,
  3,
  1,
  4,
  2,
  7,
  8,
  2,
  5,
  12,
  11,
  1,
  12,
  10,
  4,
  14,
  15,
  9,
  10,
  3,
  6,
  15,
  9,
  0,
  0,
  6,
  12,
  10,
  11,
  1,
  7,
  13,
  13,
  8,
  15,
  9,
  1,
  4,
  3,
  5,
  14,
  11,
  5,
  12,
  2,
  7,
  8,
  2,
  4,
  14,
  2,
  14,
  12,
  11,
  4,
  2,
  1,
  12,
  7,
  4,
  10,
  7,
  11,
  13,
  6,
  1,
  8,
  5,
  5,
  0,
  3,
  15,
  15,
  10,
  13,
  3,
  0,
  9,
  14,
  8,
  9,
  6,
  4,
  11,
  2,
  8,
  1,
  12,
  11,
  7,
  10,
  1,
  13,
  14,
  7,
  2,
  8,
  13,
  15,
  6,
  9,
  15,
  12,
  0,
  5,
  9,
  6,
  10,
  3,
  4,
  0,
  5,
  14,
  3,
  12,
  10,
  1,
  15,
  10,
  4,
  15,
  2,
  9,
  7,
  2,
  12,
  6,
  9,
  8,
  5,
  0,
  6,
  13,
  1,
  3,
  13,
  4,
  14,
  14,
  0,
  7,
  11,
  5,
  3,
  11,
  8,
  9,
  4,
  14,
  3,
  15,
  2,
  5,
  12,
  2,
  9,
  8,
  5,
  12,
  15,
  3,
  10,
  7,
  11,
  0,
  14,
  4,
  1,
  10,
  7,
  1,
  6,
  13,
  0,
  11,
  8,
  6,
  13,
  4,
  13,
  11,
  0,
  2,
  11,
  14,
  7,
  15,
  4,
  0,
  9,
  8,
  1,
  13,
  10,
  3,
  14,
  12,
  3,
  9,
  5,
  7,
  12,
  5,
  2,
  10,
  15,
  6,
  8,
  1,
  6,
  1,
  6,
  4,
  11,
  11,
  13,
  13,
  8,
  12,
  1,
  3,
  4,
  7,
  10,
  14,
  7,
  10,
  9,
  15,
  5,
  6,
  0,
  8,
  15,
  0,
  14,
  5,
  2,
  9,
  3,
  2,
  12,
  13,
  1,
  2,
  15,
  8,
  13,
  4,
  8,
  6,
  10,
  15,
  3,
  11,
  7,
  1,
  4,
  10,
  12,
  9,
  5,
  3,
  6,
  14,
  11,
  5,
  0,
  0,
  14,
  12,
  9,
  7,
  2,
  7,
  2,
  11,
  1,
  4,
  14,
  1,
  7,
  9,
  4,
  12,
  10,
  14,
  8,
  2,
  13,
  0,
  15,
  6,
  12,
  10,
  9,
  13,
  0,
  15,
  3,
  3,
  5,
  5,
  6,
  8,
  11
];
utils$r.substitute = function(ie, se) {
  for (var fe = 0, ue = 0; ue < 4; ue++) {
    var ce = ie >>> 18 - ue * 6 & 63, de = sTable[ue * 64 + ce];
    fe <<= 4, fe |= de;
  }
  for (var ue = 0; ue < 4; ue++) {
    var ce = se >>> 18 - ue * 6 & 63, de = sTable[4 * 64 + ue * 64 + ce];
    fe <<= 4, fe |= de;
  }
  return fe >>> 0;
};
var permuteTable = [
  16,
  25,
  12,
  11,
  3,
  20,
  4,
  15,
  31,
  17,
  9,
  6,
  27,
  14,
  1,
  22,
  30,
  24,
  8,
  18,
  0,
  5,
  29,
  23,
  13,
  19,
  2,
  26,
  10,
  21,
  28,
  7
];
utils$r.permute = function(ie) {
  for (var se = 0, fe = 0; fe < permuteTable.length; fe++)
    se <<= 1, se |= ie >>> permuteTable[fe] & 1;
  return se >>> 0;
};
utils$r.padSplit = function(ie, se, fe) {
  for (var ue = ie.toString(2); ue.length < se; )
    ue = "0" + ue;
  for (var ce = [], de = 0; de < se; de += fe)
    ce.push(ue.slice(de, de + fe));
  return ce.join(" ");
};
var minimalisticAssert$1 = assert$p;
function assert$p(ae, ie) {
  if (!ae)
    throw new Error(ie || "Assertion failed");
}
assert$p.equal = function(ie, se, fe) {
  if (ie != se)
    throw new Error(fe || "Assertion failed: " + ie + " != " + se);
};
var assert$o = minimalisticAssert$1;
function Cipher$3(ae) {
  this.options = ae, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = ae.padding !== !1;
}
var cipher = Cipher$3;
Cipher$3.prototype._init = function() {
};
Cipher$3.prototype.update = function(ie) {
  return ie.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(ie) : this._updateEncrypt(ie);
};
Cipher$3.prototype._buffer = function(ie, se) {
  for (var fe = Math.min(this.buffer.length - this.bufferOff, ie.length - se), ue = 0; ue < fe; ue++)
    this.buffer[this.bufferOff + ue] = ie[se + ue];
  return this.bufferOff += fe, fe;
};
Cipher$3.prototype._flushBuffer = function(ie, se) {
  return this._update(this.buffer, 0, ie, se), this.bufferOff = 0, this.blockSize;
};
Cipher$3.prototype._updateEncrypt = function(ie) {
  var se = 0, fe = 0, ue = (this.bufferOff + ie.length) / this.blockSize | 0, ce = new Array(ue * this.blockSize);
  this.bufferOff !== 0 && (se += this._buffer(ie, se), this.bufferOff === this.buffer.length && (fe += this._flushBuffer(ce, fe)));
  for (var de = ie.length - (ie.length - se) % this.blockSize; se < de; se += this.blockSize)
    this._update(ie, se, ce, fe), fe += this.blockSize;
  for (; se < ie.length; se++, this.bufferOff++)
    this.buffer[this.bufferOff] = ie[se];
  return ce;
};
Cipher$3.prototype._updateDecrypt = function(ie) {
  for (var se = 0, fe = 0, ue = Math.ceil((this.bufferOff + ie.length) / this.blockSize) - 1, ce = new Array(ue * this.blockSize); ue > 0; ue--)
    se += this._buffer(ie, se), fe += this._flushBuffer(ce, fe);
  return se += this._buffer(ie, se), ce;
};
Cipher$3.prototype.final = function(ie) {
  var se;
  ie && (se = this.update(ie));
  var fe;
  return this.type === "encrypt" ? fe = this._finalEncrypt() : fe = this._finalDecrypt(), se ? se.concat(fe) : fe;
};
Cipher$3.prototype._pad = function(ie, se) {
  if (se === 0)
    return !1;
  for (; se < ie.length; )
    ie[se++] = 0;
  return !0;
};
Cipher$3.prototype._finalEncrypt = function() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];
  var ie = new Array(this.blockSize);
  return this._update(this.buffer, 0, ie, 0), ie;
};
Cipher$3.prototype._unpad = function(ie) {
  return ie;
};
Cipher$3.prototype._finalDecrypt = function() {
  assert$o.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
  var ie = new Array(this.blockSize);
  return this._flushBuffer(ie, 0), this._unpad(ie);
};
var assert$n = minimalisticAssert$1, inherits$j = inherits_browserExports, utils$q = utils$r, Cipher$2 = cipher;
function DESState() {
  this.tmp = new Array(2), this.keys = null;
}
function DES$3(ae) {
  Cipher$2.call(this, ae);
  var ie = new DESState();
  this._desState = ie, this.deriveKeys(ie, ae.key);
}
inherits$j(DES$3, Cipher$2);
var des$1 = DES$3;
DES$3.create = function(ie) {
  return new DES$3(ie);
};
var shiftTable = [
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1
];
DES$3.prototype.deriveKeys = function(ie, se) {
  ie.keys = new Array(16 * 2), assert$n.equal(se.length, this.blockSize, "Invalid key length");
  var fe = utils$q.readUInt32BE(se, 0), ue = utils$q.readUInt32BE(se, 4);
  utils$q.pc1(fe, ue, ie.tmp, 0), fe = ie.tmp[0], ue = ie.tmp[1];
  for (var ce = 0; ce < ie.keys.length; ce += 2) {
    var de = shiftTable[ce >>> 1];
    fe = utils$q.r28shl(fe, de), ue = utils$q.r28shl(ue, de), utils$q.pc2(fe, ue, ie.keys, ce);
  }
};
DES$3.prototype._update = function(ie, se, fe, ue) {
  var ce = this._desState, de = utils$q.readUInt32BE(ie, se), me = utils$q.readUInt32BE(ie, se + 4);
  utils$q.ip(de, me, ce.tmp, 0), de = ce.tmp[0], me = ce.tmp[1], this.type === "encrypt" ? this._encrypt(ce, de, me, ce.tmp, 0) : this._decrypt(ce, de, me, ce.tmp, 0), de = ce.tmp[0], me = ce.tmp[1], utils$q.writeUInt32BE(fe, de, ue), utils$q.writeUInt32BE(fe, me, ue + 4);
};
DES$3.prototype._pad = function(ie, se) {
  if (this.padding === !1)
    return !1;
  for (var fe = ie.length - se, ue = se; ue < ie.length; ue++)
    ie[ue] = fe;
  return !0;
};
DES$3.prototype._unpad = function(ie) {
  if (this.padding === !1)
    return ie;
  for (var se = ie[ie.length - 1], fe = ie.length - se; fe < ie.length; fe++)
    assert$n.equal(ie[fe], se);
  return ie.slice(0, ie.length - se);
};
DES$3.prototype._encrypt = function(ie, se, fe, ue, ce) {
  for (var de = se, me = fe, we = 0; we < ie.keys.length; we += 2) {
    var Ee = ie.keys[we], Se = ie.keys[we + 1];
    utils$q.expand(me, ie.tmp, 0), Ee ^= ie.tmp[0], Se ^= ie.tmp[1];
    var Be = utils$q.substitute(Ee, Se), Ce = utils$q.permute(Be), Ie = me;
    me = (de ^ Ce) >>> 0, de = Ie;
  }
  utils$q.rip(me, de, ue, ce);
};
DES$3.prototype._decrypt = function(ie, se, fe, ue, ce) {
  for (var de = fe, me = se, we = ie.keys.length - 2; we >= 0; we -= 2) {
    var Ee = ie.keys[we], Se = ie.keys[we + 1];
    utils$q.expand(de, ie.tmp, 0), Ee ^= ie.tmp[0], Se ^= ie.tmp[1];
    var Be = utils$q.substitute(Ee, Se), Ce = utils$q.permute(Be), Ie = de;
    de = (me ^ Ce) >>> 0, me = Ie;
  }
  utils$q.rip(de, me, ue, ce);
};
var cbc$1 = {}, assert$m = minimalisticAssert$1, inherits$i = inherits_browserExports, proto = {};
function CBCState(ae) {
  assert$m.equal(ae.length, 8, "Invalid IV length"), this.iv = new Array(8);
  for (var ie = 0; ie < this.iv.length; ie++)
    this.iv[ie] = ae[ie];
}
function instantiate(ae) {
  function ie(ce) {
    ae.call(this, ce), this._cbcInit();
  }
  inherits$i(ie, ae);
  for (var se = Object.keys(proto), fe = 0; fe < se.length; fe++) {
    var ue = se[fe];
    ie.prototype[ue] = proto[ue];
  }
  return ie.create = function(de) {
    return new ie(de);
  }, ie;
}
cbc$1.instantiate = instantiate;
proto._cbcInit = function() {
  var ie = new CBCState(this.options.iv);
  this._cbcState = ie;
};
proto._update = function(ie, se, fe, ue) {
  var ce = this._cbcState, de = this.constructor.super_.prototype, me = ce.iv;
  if (this.type === "encrypt") {
    for (var we = 0; we < this.blockSize; we++)
      me[we] ^= ie[se + we];
    de._update.call(this, me, 0, fe, ue);
    for (var we = 0; we < this.blockSize; we++)
      me[we] = fe[ue + we];
  } else {
    de._update.call(this, ie, se, fe, ue);
    for (var we = 0; we < this.blockSize; we++)
      fe[ue + we] ^= me[we];
    for (var we = 0; we < this.blockSize; we++)
      me[we] = ie[se + we];
  }
};
var assert$l = minimalisticAssert$1, inherits$h = inherits_browserExports, Cipher$1 = cipher, DES$2 = des$1;
function EDEState(ae, ie) {
  assert$l.equal(ie.length, 24, "Invalid key length");
  var se = ie.slice(0, 8), fe = ie.slice(8, 16), ue = ie.slice(16, 24);
  ae === "encrypt" ? this.ciphers = [
    DES$2.create({ type: "encrypt", key: se }),
    DES$2.create({ type: "decrypt", key: fe }),
    DES$2.create({ type: "encrypt", key: ue })
  ] : this.ciphers = [
    DES$2.create({ type: "decrypt", key: ue }),
    DES$2.create({ type: "encrypt", key: fe }),
    DES$2.create({ type: "decrypt", key: se })
  ];
}
function EDE(ae) {
  Cipher$1.call(this, ae);
  var ie = new EDEState(this.type, this.options.key);
  this._edeState = ie;
}
inherits$h(EDE, Cipher$1);
var ede = EDE;
EDE.create = function(ie) {
  return new EDE(ie);
};
EDE.prototype._update = function(ie, se, fe, ue) {
  var ce = this._edeState;
  ce.ciphers[0]._update(ie, se, fe, ue), ce.ciphers[1]._update(fe, ue, fe, ue), ce.ciphers[2]._update(fe, ue, fe, ue);
};
EDE.prototype._pad = DES$2.prototype._pad;
EDE.prototype._unpad = DES$2.prototype._unpad;
des$2.utils = utils$r;
des$2.Cipher = cipher;
des$2.DES = des$1;
des$2.CBC = cbc$1;
des$2.EDE = ede;
var CipherBase = cipherBase, des = des$2, inherits$g = inherits_browserExports, Buffer$m = safeBufferExports.Buffer, modes$3 = {
  "des-ede3-cbc": des.CBC.instantiate(des.EDE),
  "des-ede3": des.EDE,
  "des-ede-cbc": des.CBC.instantiate(des.EDE),
  "des-ede": des.EDE,
  "des-cbc": des.CBC.instantiate(des.DES),
  "des-ecb": des.DES
};
modes$3.des = modes$3["des-cbc"];
modes$3.des3 = modes$3["des-ede3-cbc"];
var browserifyDes = DES$1;
inherits$g(DES$1, CipherBase);
function DES$1(ae) {
  CipherBase.call(this);
  var ie = ae.mode.toLowerCase(), se = modes$3[ie], fe;
  ae.decrypt ? fe = "decrypt" : fe = "encrypt";
  var ue = ae.key;
  Buffer$m.isBuffer(ue) || (ue = Buffer$m.from(ue)), (ie === "des-ede" || ie === "des-ede-cbc") && (ue = Buffer$m.concat([ue, ue.slice(0, 8)]));
  var ce = ae.iv;
  Buffer$m.isBuffer(ce) || (ce = Buffer$m.from(ce)), this._des = se.create({
    key: ue,
    iv: ce,
    type: fe
  });
}
DES$1.prototype._update = function(ae) {
  return Buffer$m.from(this._des.update(ae));
};
DES$1.prototype._final = function() {
  return Buffer$m.from(this._des.final());
};
var browser$7 = {}, encrypter = {}, ecb = {};
ecb.encrypt = function(ae, ie) {
  return ae._cipher.encryptBlock(ie);
};
ecb.decrypt = function(ae, ie) {
  return ae._cipher.decryptBlock(ie);
};
var cbc = {}, bufferXor = function(ie, se) {
  for (var fe = Math.min(ie.length, se.length), ue = new Buffer$F(fe), ce = 0; ce < fe; ++ce)
    ue[ce] = ie[ce] ^ se[ce];
  return ue;
}, xor$7 = bufferXor;
cbc.encrypt = function(ae, ie) {
  var se = xor$7(ie, ae._prev);
  return ae._prev = ae._cipher.encryptBlock(se), ae._prev;
};
cbc.decrypt = function(ae, ie) {
  var se = ae._prev;
  ae._prev = ie;
  var fe = ae._cipher.decryptBlock(ie);
  return xor$7(fe, se);
};
var cfb = {}, Buffer$l = safeBufferExports.Buffer, xor$6 = bufferXor;
function encryptStart(ae, ie, se) {
  var fe = ie.length, ue = xor$6(ie, ae._cache);
  return ae._cache = ae._cache.slice(fe), ae._prev = Buffer$l.concat([ae._prev, se ? ie : ue]), ue;
}
cfb.encrypt = function(ae, ie, se) {
  for (var fe = Buffer$l.allocUnsafe(0), ue; ie.length; )
    if (ae._cache.length === 0 && (ae._cache = ae._cipher.encryptBlock(ae._prev), ae._prev = Buffer$l.allocUnsafe(0)), ae._cache.length <= ie.length)
      ue = ae._cache.length, fe = Buffer$l.concat([fe, encryptStart(ae, ie.slice(0, ue), se)]), ie = ie.slice(ue);
    else {
      fe = Buffer$l.concat([fe, encryptStart(ae, ie, se)]);
      break;
    }
  return fe;
};
var cfb8 = {}, Buffer$k = safeBufferExports.Buffer;
function encryptByte$1(ae, ie, se) {
  var fe = ae._cipher.encryptBlock(ae._prev), ue = fe[0] ^ ie;
  return ae._prev = Buffer$k.concat([
    ae._prev.slice(1),
    Buffer$k.from([se ? ie : ue])
  ]), ue;
}
cfb8.encrypt = function(ae, ie, se) {
  for (var fe = ie.length, ue = Buffer$k.allocUnsafe(fe), ce = -1; ++ce < fe; )
    ue[ce] = encryptByte$1(ae, ie[ce], se);
  return ue;
};
var cfb1 = {}, Buffer$j = safeBufferExports.Buffer;
function encryptByte(ae, ie, se) {
  for (var fe, ue = -1, ce = 8, de = 0, me, we; ++ue < ce; )
    fe = ae._cipher.encryptBlock(ae._prev), me = ie & 1 << 7 - ue ? 128 : 0, we = fe[0] ^ me, de += (we & 128) >> ue % 8, ae._prev = shiftIn(ae._prev, se ? me : we);
  return de;
}
function shiftIn(ae, ie) {
  var se = ae.length, fe = -1, ue = Buffer$j.allocUnsafe(ae.length);
  for (ae = Buffer$j.concat([ae, Buffer$j.from([ie])]); ++fe < se; )
    ue[fe] = ae[fe] << 1 | ae[fe + 1] >> 7;
  return ue;
}
cfb1.encrypt = function(ae, ie, se) {
  for (var fe = ie.length, ue = Buffer$j.allocUnsafe(fe), ce = -1; ++ce < fe; )
    ue[ce] = encryptByte(ae, ie[ce], se);
  return ue;
};
var ofb = {}, xor$5 = bufferXor;
function getBlock$1(ae) {
  return ae._prev = ae._cipher.encryptBlock(ae._prev), ae._prev;
}
ofb.encrypt = function(ae, ie) {
  for (; ae._cache.length < ie.length; )
    ae._cache = Buffer$F.concat([ae._cache, getBlock$1(ae)]);
  var se = ae._cache.slice(0, ie.length);
  return ae._cache = ae._cache.slice(ie.length), xor$5(ie, se);
};
var ctr = {};
function incr32$2(ae) {
  for (var ie = ae.length, se; ie--; )
    if (se = ae.readUInt8(ie), se === 255)
      ae.writeUInt8(0, ie);
    else {
      se++, ae.writeUInt8(se, ie);
      break;
    }
}
var incr32_1 = incr32$2, xor$4 = bufferXor, Buffer$i = safeBufferExports.Buffer, incr32$1 = incr32_1;
function getBlock(ae) {
  var ie = ae._cipher.encryptBlockRaw(ae._prev);
  return incr32$1(ae._prev), ie;
}
var blockSize = 16;
ctr.encrypt = function(ae, ie) {
  var se = Math.ceil(ie.length / blockSize), fe = ae._cache.length;
  ae._cache = Buffer$i.concat([
    ae._cache,
    Buffer$i.allocUnsafe(se * blockSize)
  ]);
  for (var ue = 0; ue < se; ue++) {
    var ce = getBlock(ae), de = fe + ue * blockSize;
    ae._cache.writeUInt32BE(ce[0], de + 0), ae._cache.writeUInt32BE(ce[1], de + 4), ae._cache.writeUInt32BE(ce[2], de + 8), ae._cache.writeUInt32BE(ce[3], de + 12);
  }
  var me = ae._cache.slice(0, ie.length);
  return ae._cache = ae._cache.slice(ie.length), xor$4(ie, me);
};
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2$1 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modeModules = {
  ECB: ecb,
  CBC: cbc,
  CFB: cfb,
  CFB8: cfb8,
  CFB1: cfb1,
  OFB: ofb,
  CTR: ctr,
  GCM: ctr
}, modes$2 = require$$2$1;
for (var key$4 in modes$2)
  modes$2[key$4].module = modeModules[modes$2[key$4].mode];
var modes_1 = modes$2, aes$6 = {}, Buffer$h = safeBufferExports.Buffer;
function asUInt32Array(ae) {
  Buffer$h.isBuffer(ae) || (ae = Buffer$h.from(ae));
  for (var ie = ae.length / 4 | 0, se = new Array(ie), fe = 0; fe < ie; fe++)
    se[fe] = ae.readUInt32BE(fe * 4);
  return se;
}
function scrubVec(ae) {
  for (var ie = 0; ie < ae.length; ae++)
    ae[ie] = 0;
}
function cryptBlock(ae, ie, se, fe, ue) {
  for (var ce = se[0], de = se[1], me = se[2], we = se[3], Ee = ae[0] ^ ie[0], Se = ae[1] ^ ie[1], Be = ae[2] ^ ie[2], Ce = ae[3] ^ ie[3], Ie, Pe, Ne, ke, He = 4, De = 1; De < ue; De++)
    Ie = ce[Ee >>> 24] ^ de[Se >>> 16 & 255] ^ me[Be >>> 8 & 255] ^ we[Ce & 255] ^ ie[He++], Pe = ce[Se >>> 24] ^ de[Be >>> 16 & 255] ^ me[Ce >>> 8 & 255] ^ we[Ee & 255] ^ ie[He++], Ne = ce[Be >>> 24] ^ de[Ce >>> 16 & 255] ^ me[Ee >>> 8 & 255] ^ we[Se & 255] ^ ie[He++], ke = ce[Ce >>> 24] ^ de[Ee >>> 16 & 255] ^ me[Se >>> 8 & 255] ^ we[Be & 255] ^ ie[He++], Ee = Ie, Se = Pe, Be = Ne, Ce = ke;
  return Ie = (fe[Ee >>> 24] << 24 | fe[Se >>> 16 & 255] << 16 | fe[Be >>> 8 & 255] << 8 | fe[Ce & 255]) ^ ie[He++], Pe = (fe[Se >>> 24] << 24 | fe[Be >>> 16 & 255] << 16 | fe[Ce >>> 8 & 255] << 8 | fe[Ee & 255]) ^ ie[He++], Ne = (fe[Be >>> 24] << 24 | fe[Ce >>> 16 & 255] << 16 | fe[Ee >>> 8 & 255] << 8 | fe[Se & 255]) ^ ie[He++], ke = (fe[Ce >>> 24] << 24 | fe[Ee >>> 16 & 255] << 16 | fe[Se >>> 8 & 255] << 8 | fe[Be & 255]) ^ ie[He++], Ie = Ie >>> 0, Pe = Pe >>> 0, Ne = Ne >>> 0, ke = ke >>> 0, [Ie, Pe, Ne, ke];
}
var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], G$7 = function() {
  for (var ae = new Array(256), ie = 0; ie < 256; ie++)
    ie < 128 ? ae[ie] = ie << 1 : ae[ie] = ie << 1 ^ 283;
  for (var se = [], fe = [], ue = [[], [], [], []], ce = [[], [], [], []], de = 0, me = 0, we = 0; we < 256; ++we) {
    var Ee = me ^ me << 1 ^ me << 2 ^ me << 3 ^ me << 4;
    Ee = Ee >>> 8 ^ Ee & 255 ^ 99, se[de] = Ee, fe[Ee] = de;
    var Se = ae[de], Be = ae[Se], Ce = ae[Be], Ie = ae[Ee] * 257 ^ Ee * 16843008;
    ue[0][de] = Ie << 24 | Ie >>> 8, ue[1][de] = Ie << 16 | Ie >>> 16, ue[2][de] = Ie << 8 | Ie >>> 24, ue[3][de] = Ie, Ie = Ce * 16843009 ^ Be * 65537 ^ Se * 257 ^ de * 16843008, ce[0][Ee] = Ie << 24 | Ie >>> 8, ce[1][Ee] = Ie << 16 | Ie >>> 16, ce[2][Ee] = Ie << 8 | Ie >>> 24, ce[3][Ee] = Ie, de === 0 ? de = me = 1 : (de = Se ^ ae[ae[ae[Ce ^ Se]]], me ^= ae[ae[me]]);
  }
  return {
    SBOX: se,
    INV_SBOX: fe,
    SUB_MIX: ue,
    INV_SUB_MIX: ce
  };
}();
function AES(ae) {
  this._key = asUInt32Array(ae), this._reset();
}
AES.blockSize = 4 * 4;
AES.keySize = 256 / 8;
AES.prototype.blockSize = AES.blockSize;
AES.prototype.keySize = AES.keySize;
AES.prototype._reset = function() {
  for (var ae = this._key, ie = ae.length, se = ie + 6, fe = (se + 1) * 4, ue = [], ce = 0; ce < ie; ce++)
    ue[ce] = ae[ce];
  for (ce = ie; ce < fe; ce++) {
    var de = ue[ce - 1];
    ce % ie === 0 ? (de = de << 8 | de >>> 24, de = G$7.SBOX[de >>> 24] << 24 | G$7.SBOX[de >>> 16 & 255] << 16 | G$7.SBOX[de >>> 8 & 255] << 8 | G$7.SBOX[de & 255], de ^= RCON[ce / ie | 0] << 24) : ie > 6 && ce % ie === 4 && (de = G$7.SBOX[de >>> 24] << 24 | G$7.SBOX[de >>> 16 & 255] << 16 | G$7.SBOX[de >>> 8 & 255] << 8 | G$7.SBOX[de & 255]), ue[ce] = ue[ce - ie] ^ de;
  }
  for (var me = [], we = 0; we < fe; we++) {
    var Ee = fe - we, Se = ue[Ee - (we % 4 ? 0 : 4)];
    we < 4 || Ee <= 4 ? me[we] = Se : me[we] = G$7.INV_SUB_MIX[0][G$7.SBOX[Se >>> 24]] ^ G$7.INV_SUB_MIX[1][G$7.SBOX[Se >>> 16 & 255]] ^ G$7.INV_SUB_MIX[2][G$7.SBOX[Se >>> 8 & 255]] ^ G$7.INV_SUB_MIX[3][G$7.SBOX[Se & 255]];
  }
  this._nRounds = se, this._keySchedule = ue, this._invKeySchedule = me;
};
AES.prototype.encryptBlockRaw = function(ae) {
  return ae = asUInt32Array(ae), cryptBlock(ae, this._keySchedule, G$7.SUB_MIX, G$7.SBOX, this._nRounds);
};
AES.prototype.encryptBlock = function(ae) {
  var ie = this.encryptBlockRaw(ae), se = Buffer$h.allocUnsafe(16);
  return se.writeUInt32BE(ie[0], 0), se.writeUInt32BE(ie[1], 4), se.writeUInt32BE(ie[2], 8), se.writeUInt32BE(ie[3], 12), se;
};
AES.prototype.decryptBlock = function(ae) {
  ae = asUInt32Array(ae);
  var ie = ae[1];
  ae[1] = ae[3], ae[3] = ie;
  var se = cryptBlock(ae, this._invKeySchedule, G$7.INV_SUB_MIX, G$7.INV_SBOX, this._nRounds), fe = Buffer$h.allocUnsafe(16);
  return fe.writeUInt32BE(se[0], 0), fe.writeUInt32BE(se[3], 4), fe.writeUInt32BE(se[2], 8), fe.writeUInt32BE(se[1], 12), fe;
};
AES.prototype.scrub = function() {
  scrubVec(this._keySchedule), scrubVec(this._invKeySchedule), scrubVec(this._key);
};
aes$6.AES = AES;
var Buffer$g = safeBufferExports.Buffer, ZEROES = Buffer$g.alloc(16, 0);
function toArray$2(ae) {
  return [
    ae.readUInt32BE(0),
    ae.readUInt32BE(4),
    ae.readUInt32BE(8),
    ae.readUInt32BE(12)
  ];
}
function fromArray(ae) {
  var ie = Buffer$g.allocUnsafe(16);
  return ie.writeUInt32BE(ae[0] >>> 0, 0), ie.writeUInt32BE(ae[1] >>> 0, 4), ie.writeUInt32BE(ae[2] >>> 0, 8), ie.writeUInt32BE(ae[3] >>> 0, 12), ie;
}
function GHASH$1(ae) {
  this.h = ae, this.state = Buffer$g.alloc(16, 0), this.cache = Buffer$g.allocUnsafe(0);
}
GHASH$1.prototype.ghash = function(ae) {
  for (var ie = -1; ++ie < ae.length; )
    this.state[ie] ^= ae[ie];
  this._multiply();
};
GHASH$1.prototype._multiply = function() {
  for (var ae = toArray$2(this.h), ie = [0, 0, 0, 0], se, fe, ue, ce = -1; ++ce < 128; ) {
    for (fe = (this.state[~~(ce / 8)] & 1 << 7 - ce % 8) !== 0, fe && (ie[0] ^= ae[0], ie[1] ^= ae[1], ie[2] ^= ae[2], ie[3] ^= ae[3]), ue = (ae[3] & 1) !== 0, se = 3; se > 0; se--)
      ae[se] = ae[se] >>> 1 | (ae[se - 1] & 1) << 31;
    ae[0] = ae[0] >>> 1, ue && (ae[0] = ae[0] ^ 225 << 24);
  }
  this.state = fromArray(ie);
};
GHASH$1.prototype.update = function(ae) {
  this.cache = Buffer$g.concat([this.cache, ae]);
  for (var ie; this.cache.length >= 16; )
    ie = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(ie);
};
GHASH$1.prototype.final = function(ae, ie) {
  return this.cache.length && this.ghash(Buffer$g.concat([this.cache, ZEROES], 16)), this.ghash(fromArray([0, ae, 0, ie])), this.state;
};
var ghash = GHASH$1, aes$5 = aes$6, Buffer$f = safeBufferExports.Buffer, Transform$5 = cipherBase, inherits$f = inherits_browserExports, GHASH = ghash, xor$3 = bufferXor, incr32 = incr32_1;
function xorTest(ae, ie) {
  var se = 0;
  ae.length !== ie.length && se++;
  for (var fe = Math.min(ae.length, ie.length), ue = 0; ue < fe; ++ue)
    se += ae[ue] ^ ie[ue];
  return se;
}
function calcIv(ae, ie, se) {
  if (ie.length === 12)
    return ae._finID = Buffer$f.concat([ie, Buffer$f.from([0, 0, 0, 1])]), Buffer$f.concat([ie, Buffer$f.from([0, 0, 0, 2])]);
  var fe = new GHASH(se), ue = ie.length, ce = ue % 16;
  fe.update(ie), ce && (ce = 16 - ce, fe.update(Buffer$f.alloc(ce, 0))), fe.update(Buffer$f.alloc(8, 0));
  var de = ue * 8, me = Buffer$f.alloc(8);
  me.writeUIntBE(de, 0, 8), fe.update(me), ae._finID = fe.state;
  var we = Buffer$f.from(ae._finID);
  return incr32(we), we;
}
function StreamCipher$3(ae, ie, se, fe) {
  Transform$5.call(this);
  var ue = Buffer$f.alloc(4, 0);
  this._cipher = new aes$5.AES(ie);
  var ce = this._cipher.encryptBlock(ue);
  this._ghash = new GHASH(ce), se = calcIv(this, se, ce), this._prev = Buffer$f.from(se), this._cache = Buffer$f.allocUnsafe(0), this._secCache = Buffer$f.allocUnsafe(0), this._decrypt = fe, this._alen = 0, this._len = 0, this._mode = ae, this._authTag = null, this._called = !1;
}
inherits$f(StreamCipher$3, Transform$5);
StreamCipher$3.prototype._update = function(ae) {
  if (!this._called && this._alen) {
    var ie = 16 - this._alen % 16;
    ie < 16 && (ie = Buffer$f.alloc(ie, 0), this._ghash.update(ie));
  }
  this._called = !0;
  var se = this._mode.encrypt(this, ae);
  return this._decrypt ? this._ghash.update(ae) : this._ghash.update(se), this._len += ae.length, se;
};
StreamCipher$3.prototype._final = function() {
  if (this._decrypt && !this._authTag)
    throw new Error("Unsupported state or unable to authenticate data");
  var ae = xor$3(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
  if (this._decrypt && xorTest(ae, this._authTag))
    throw new Error("Unsupported state or unable to authenticate data");
  this._authTag = ae, this._cipher.scrub();
};
StreamCipher$3.prototype.getAuthTag = function() {
  if (this._decrypt || !Buffer$f.isBuffer(this._authTag))
    throw new Error("Attempting to get auth tag in unsupported state");
  return this._authTag;
};
StreamCipher$3.prototype.setAuthTag = function(ie) {
  if (!this._decrypt)
    throw new Error("Attempting to set auth tag in unsupported state");
  this._authTag = ie;
};
StreamCipher$3.prototype.setAAD = function(ie) {
  if (this._called)
    throw new Error("Attempting to set AAD in unsupported state");
  this._ghash.update(ie), this._alen += ie.length;
};
var authCipher = StreamCipher$3, aes$4 = aes$6, Buffer$e = safeBufferExports.Buffer, Transform$4 = cipherBase, inherits$e = inherits_browserExports;
function StreamCipher$2(ae, ie, se, fe) {
  Transform$4.call(this), this._cipher = new aes$4.AES(ie), this._prev = Buffer$e.from(se), this._cache = Buffer$e.allocUnsafe(0), this._secCache = Buffer$e.allocUnsafe(0), this._decrypt = fe, this._mode = ae;
}
inherits$e(StreamCipher$2, Transform$4);
StreamCipher$2.prototype._update = function(ae) {
  return this._mode.encrypt(this, ae, this._decrypt);
};
StreamCipher$2.prototype._final = function() {
  this._cipher.scrub();
};
var streamCipher = StreamCipher$2, Buffer$d = safeBufferExports.Buffer, MD5 = md5_js;
function EVP_BytesToKey(ae, ie, se, fe) {
  if (Buffer$d.isBuffer(ae) || (ae = Buffer$d.from(ae, "binary")), ie && (Buffer$d.isBuffer(ie) || (ie = Buffer$d.from(ie, "binary")), ie.length !== 8))
    throw new RangeError("salt should be Buffer with 8 byte length");
  for (var ue = se / 8, ce = Buffer$d.alloc(ue), de = Buffer$d.alloc(fe || 0), me = Buffer$d.alloc(0); ue > 0 || fe > 0; ) {
    var we = new MD5();
    we.update(me), we.update(ae), ie && we.update(ie), me = we.digest();
    var Ee = 0;
    if (ue > 0) {
      var Se = ce.length - ue;
      Ee = Math.min(ue, me.length), me.copy(ce, Se, 0, Ee), ue -= Ee;
    }
    if (Ee < me.length && fe > 0) {
      var Be = de.length - fe, Ce = Math.min(fe, me.length - Ee);
      me.copy(de, Be, Ee, Ee + Ce), fe -= Ce;
    }
  }
  return me.fill(0), { key: ce, iv: de };
}
var evp_bytestokey = EVP_BytesToKey, MODES$1 = modes_1, AuthCipher$1 = authCipher, Buffer$c = safeBufferExports.Buffer, StreamCipher$1 = streamCipher, Transform$3 = cipherBase, aes$3 = aes$6, ebtk$2 = evp_bytestokey, inherits$d = inherits_browserExports;
function Cipher(ae, ie, se) {
  Transform$3.call(this), this._cache = new Splitter$1(), this._cipher = new aes$3.AES(ie), this._prev = Buffer$c.from(se), this._mode = ae, this._autopadding = !0;
}
inherits$d(Cipher, Transform$3);
Cipher.prototype._update = function(ae) {
  this._cache.add(ae);
  for (var ie, se, fe = []; ie = this._cache.get(); )
    se = this._mode.encrypt(this, ie), fe.push(se);
  return Buffer$c.concat(fe);
};
var PADDING = Buffer$c.alloc(16, 16);
Cipher.prototype._final = function() {
  var ae = this._cache.flush();
  if (this._autopadding)
    return ae = this._mode.encrypt(this, ae), this._cipher.scrub(), ae;
  if (!ae.equals(PADDING))
    throw this._cipher.scrub(), new Error("data not multiple of block length");
};
Cipher.prototype.setAutoPadding = function(ae) {
  return this._autopadding = !!ae, this;
};
function Splitter$1() {
  this.cache = Buffer$c.allocUnsafe(0);
}
Splitter$1.prototype.add = function(ae) {
  this.cache = Buffer$c.concat([this.cache, ae]);
};
Splitter$1.prototype.get = function() {
  if (this.cache.length > 15) {
    var ae = this.cache.slice(0, 16);
    return this.cache = this.cache.slice(16), ae;
  }
  return null;
};
Splitter$1.prototype.flush = function() {
  for (var ae = 16 - this.cache.length, ie = Buffer$c.allocUnsafe(ae), se = -1; ++se < ae; )
    ie.writeUInt8(ae, se);
  return Buffer$c.concat([this.cache, ie]);
};
function createCipheriv$1(ae, ie, se) {
  var fe = MODES$1[ae.toLowerCase()];
  if (!fe)
    throw new TypeError("invalid suite type");
  if (typeof ie == "string" && (ie = Buffer$c.from(ie)), ie.length !== fe.key / 8)
    throw new TypeError("invalid key length " + ie.length);
  if (typeof se == "string" && (se = Buffer$c.from(se)), fe.mode !== "GCM" && se.length !== fe.iv)
    throw new TypeError("invalid iv length " + se.length);
  return fe.type === "stream" ? new StreamCipher$1(fe.module, ie, se) : fe.type === "auth" ? new AuthCipher$1(fe.module, ie, se) : new Cipher(fe.module, ie, se);
}
function createCipher$1(ae, ie) {
  var se = MODES$1[ae.toLowerCase()];
  if (!se)
    throw new TypeError("invalid suite type");
  var fe = ebtk$2(ie, !1, se.key, se.iv);
  return createCipheriv$1(ae, fe.key, fe.iv);
}
encrypter.createCipheriv = createCipheriv$1;
encrypter.createCipher = createCipher$1;
var decrypter = {}, AuthCipher = authCipher, Buffer$b = safeBufferExports.Buffer, MODES = modes_1, StreamCipher = streamCipher, Transform$2 = cipherBase, aes$2 = aes$6, ebtk$1 = evp_bytestokey, inherits$c = inherits_browserExports;
function Decipher(ae, ie, se) {
  Transform$2.call(this), this._cache = new Splitter(), this._last = void 0, this._cipher = new aes$2.AES(ie), this._prev = Buffer$b.from(se), this._mode = ae, this._autopadding = !0;
}
inherits$c(Decipher, Transform$2);
Decipher.prototype._update = function(ae) {
  this._cache.add(ae);
  for (var ie, se, fe = []; ie = this._cache.get(this._autopadding); )
    se = this._mode.decrypt(this, ie), fe.push(se);
  return Buffer$b.concat(fe);
};
Decipher.prototype._final = function() {
  var ae = this._cache.flush();
  if (this._autopadding)
    return unpad(this._mode.decrypt(this, ae));
  if (ae)
    throw new Error("data not multiple of block length");
};
Decipher.prototype.setAutoPadding = function(ae) {
  return this._autopadding = !!ae, this;
};
function Splitter() {
  this.cache = Buffer$b.allocUnsafe(0);
}
Splitter.prototype.add = function(ae) {
  this.cache = Buffer$b.concat([this.cache, ae]);
};
Splitter.prototype.get = function(ae) {
  var ie;
  if (ae) {
    if (this.cache.length > 16)
      return ie = this.cache.slice(0, 16), this.cache = this.cache.slice(16), ie;
  } else if (this.cache.length >= 16)
    return ie = this.cache.slice(0, 16), this.cache = this.cache.slice(16), ie;
  return null;
};
Splitter.prototype.flush = function() {
  if (this.cache.length)
    return this.cache;
};
function unpad(ae) {
  var ie = ae[15];
  if (ie < 1 || ie > 16)
    throw new Error("unable to decrypt data");
  for (var se = -1; ++se < ie; )
    if (ae[se + (16 - ie)] !== ie)
      throw new Error("unable to decrypt data");
  if (ie !== 16)
    return ae.slice(0, 16 - ie);
}
function createDecipheriv$1(ae, ie, se) {
  var fe = MODES[ae.toLowerCase()];
  if (!fe)
    throw new TypeError("invalid suite type");
  if (typeof se == "string" && (se = Buffer$b.from(se)), fe.mode !== "GCM" && se.length !== fe.iv)
    throw new TypeError("invalid iv length " + se.length);
  if (typeof ie == "string" && (ie = Buffer$b.from(ie)), ie.length !== fe.key / 8)
    throw new TypeError("invalid key length " + ie.length);
  return fe.type === "stream" ? new StreamCipher(fe.module, ie, se, !0) : fe.type === "auth" ? new AuthCipher(fe.module, ie, se, !0) : new Decipher(fe.module, ie, se);
}
function createDecipher$1(ae, ie) {
  var se = MODES[ae.toLowerCase()];
  if (!se)
    throw new TypeError("invalid suite type");
  var fe = ebtk$1(ie, !1, se.key, se.iv);
  return createDecipheriv$1(ae, fe.key, fe.iv);
}
decrypter.createDecipher = createDecipher$1;
decrypter.createDecipheriv = createDecipheriv$1;
var ciphers$2 = encrypter, deciphers = decrypter, modes$1 = require$$2$1;
function getCiphers$1() {
  return Object.keys(modes$1);
}
browser$7.createCipher = browser$7.Cipher = ciphers$2.createCipher;
browser$7.createCipheriv = browser$7.Cipheriv = ciphers$2.createCipheriv;
browser$7.createDecipher = browser$7.Decipher = deciphers.createDecipher;
browser$7.createDecipheriv = browser$7.Decipheriv = deciphers.createDecipheriv;
browser$7.listCiphers = browser$7.getCiphers = getCiphers$1;
var modes = {};
(function(ae) {
  ae["des-ecb"] = {
    key: 8,
    iv: 0
  }, ae["des-cbc"] = ae.des = {
    key: 8,
    iv: 8
  }, ae["des-ede3-cbc"] = ae.des3 = {
    key: 24,
    iv: 8
  }, ae["des-ede3"] = {
    key: 24,
    iv: 0
  }, ae["des-ede-cbc"] = {
    key: 16,
    iv: 8
  }, ae["des-ede"] = {
    key: 16,
    iv: 0
  };
})(modes);
var DES = browserifyDes, aes$1 = browser$7, aesModes = modes_1, desModes = modes, ebtk = evp_bytestokey;
function createCipher(ae, ie) {
  ae = ae.toLowerCase();
  var se, fe;
  if (aesModes[ae])
    se = aesModes[ae].key, fe = aesModes[ae].iv;
  else if (desModes[ae])
    se = desModes[ae].key * 8, fe = desModes[ae].iv;
  else
    throw new TypeError("invalid suite type");
  var ue = ebtk(ie, !1, se, fe);
  return createCipheriv(ae, ue.key, ue.iv);
}
function createDecipher(ae, ie) {
  ae = ae.toLowerCase();
  var se, fe;
  if (aesModes[ae])
    se = aesModes[ae].key, fe = aesModes[ae].iv;
  else if (desModes[ae])
    se = desModes[ae].key * 8, fe = desModes[ae].iv;
  else
    throw new TypeError("invalid suite type");
  var ue = ebtk(ie, !1, se, fe);
  return createDecipheriv(ae, ue.key, ue.iv);
}
function createCipheriv(ae, ie, se) {
  if (ae = ae.toLowerCase(), aesModes[ae])
    return aes$1.createCipheriv(ae, ie, se);
  if (desModes[ae])
    return new DES({ key: ie, iv: se, mode: ae });
  throw new TypeError("invalid suite type");
}
function createDecipheriv(ae, ie, se) {
  if (ae = ae.toLowerCase(), aesModes[ae])
    return aes$1.createDecipheriv(ae, ie, se);
  if (desModes[ae])
    return new DES({ key: ie, iv: se, mode: ae, decrypt: !0 });
  throw new TypeError("invalid suite type");
}
function getCiphers() {
  return Object.keys(desModes).concat(aes$1.getCiphers());
}
browser$8.createCipher = browser$8.Cipher = createCipher;
browser$8.createCipheriv = browser$8.Cipheriv = createCipheriv;
browser$8.createDecipher = browser$8.Decipher = createDecipher;
browser$8.createDecipheriv = browser$8.Decipheriv = createDecipheriv;
browser$8.listCiphers = browser$8.getCiphers = getCiphers;
var browser$6 = {}, bn$6 = { exports: {} };
bn$6.exports;
(function(ae) {
  (function(ie, se) {
    function fe($e, le) {
      if (!$e)
        throw new Error(le || "Assertion failed");
    }
    function ue($e, le) {
      $e.super_ = le;
      var pe = function() {
      };
      pe.prototype = le.prototype, $e.prototype = new pe(), $e.prototype.constructor = $e;
    }
    function ce($e, le, pe) {
      if (ce.isBN($e))
        return $e;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, $e !== null && ((le === "le" || le === "be") && (pe = le, le = 10), this._init($e || 0, le || 10, pe || "be"));
    }
    typeof ie == "object" ? ie.exports = ce : se.BN = ce, ce.BN = ce, ce.wordSize = 26;
    var de;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? de = window.Buffer : de = require$$0$2.Buffer;
    } catch {
    }
    ce.isBN = function(le) {
      return le instanceof ce ? !0 : le !== null && typeof le == "object" && le.constructor.wordSize === ce.wordSize && Array.isArray(le.words);
    }, ce.max = function(le, pe) {
      return le.cmp(pe) > 0 ? le : pe;
    }, ce.min = function(le, pe) {
      return le.cmp(pe) < 0 ? le : pe;
    }, ce.prototype._init = function(le, pe, ge) {
      if (typeof le == "number")
        return this._initNumber(le, pe, ge);
      if (typeof le == "object")
        return this._initArray(le, pe, ge);
      pe === "hex" && (pe = 16), fe(pe === (pe | 0) && pe >= 2 && pe <= 36), le = le.toString().replace(/\s+/g, "");
      var ye = 0;
      le[0] === "-" && (ye++, this.negative = 1), ye < le.length && (pe === 16 ? this._parseHex(le, ye, ge) : (this._parseBase(le, pe, ye), ge === "le" && this._initArray(this.toArray(), pe, ge)));
    }, ce.prototype._initNumber = function(le, pe, ge) {
      le < 0 && (this.negative = 1, le = -le), le < 67108864 ? (this.words = [le & 67108863], this.length = 1) : le < 4503599627370496 ? (this.words = [
        le & 67108863,
        le / 67108864 & 67108863
      ], this.length = 2) : (fe(le < 9007199254740992), this.words = [
        le & 67108863,
        le / 67108864 & 67108863,
        1
      ], this.length = 3), ge === "le" && this._initArray(this.toArray(), pe, ge);
    }, ce.prototype._initArray = function(le, pe, ge) {
      if (fe(typeof le.length == "number"), le.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(le.length / 3), this.words = new Array(this.length);
      for (var ye = 0; ye < this.length; ye++)
        this.words[ye] = 0;
      var xe, _e, Ae = 0;
      if (ge === "be")
        for (ye = le.length - 1, xe = 0; ye >= 0; ye -= 3)
          _e = le[ye] | le[ye - 1] << 8 | le[ye - 2] << 16, this.words[xe] |= _e << Ae & 67108863, this.words[xe + 1] = _e >>> 26 - Ae & 67108863, Ae += 24, Ae >= 26 && (Ae -= 26, xe++);
      else if (ge === "le")
        for (ye = 0, xe = 0; ye < le.length; ye += 3)
          _e = le[ye] | le[ye + 1] << 8 | le[ye + 2] << 16, this.words[xe] |= _e << Ae & 67108863, this.words[xe + 1] = _e >>> 26 - Ae & 67108863, Ae += 24, Ae >= 26 && (Ae -= 26, xe++);
      return this.strip();
    };
    function me($e, le) {
      var pe = $e.charCodeAt(le);
      return pe >= 65 && pe <= 70 ? pe - 55 : pe >= 97 && pe <= 102 ? pe - 87 : pe - 48 & 15;
    }
    function we($e, le, pe) {
      var ge = me($e, pe);
      return pe - 1 >= le && (ge |= me($e, pe - 1) << 4), ge;
    }
    ce.prototype._parseHex = function(le, pe, ge) {
      this.length = Math.ceil((le.length - pe) / 6), this.words = new Array(this.length);
      for (var ye = 0; ye < this.length; ye++)
        this.words[ye] = 0;
      var xe = 0, _e = 0, Ae;
      if (ge === "be")
        for (ye = le.length - 1; ye >= pe; ye -= 2)
          Ae = we(le, pe, ye) << xe, this.words[_e] |= Ae & 67108863, xe >= 18 ? (xe -= 18, _e += 1, this.words[_e] |= Ae >>> 26) : xe += 8;
      else {
        var ve = le.length - pe;
        for (ye = ve % 2 === 0 ? pe + 1 : pe; ye < le.length; ye += 2)
          Ae = we(le, pe, ye) << xe, this.words[_e] |= Ae & 67108863, xe >= 18 ? (xe -= 18, _e += 1, this.words[_e] |= Ae >>> 26) : xe += 8;
      }
      this.strip();
    };
    function Ee($e, le, pe, ge) {
      for (var ye = 0, xe = Math.min($e.length, pe), _e = le; _e < xe; _e++) {
        var Ae = $e.charCodeAt(_e) - 48;
        ye *= ge, Ae >= 49 ? ye += Ae - 49 + 10 : Ae >= 17 ? ye += Ae - 17 + 10 : ye += Ae;
      }
      return ye;
    }
    ce.prototype._parseBase = function(le, pe, ge) {
      this.words = [0], this.length = 1;
      for (var ye = 0, xe = 1; xe <= 67108863; xe *= pe)
        ye++;
      ye--, xe = xe / pe | 0;
      for (var _e = le.length - ge, Ae = _e % ye, ve = Math.min(_e, _e - Ae) + ge, he = 0, be = ge; be < ve; be += ye)
        he = Ee(le, be, be + ye, pe), this.imuln(xe), this.words[0] + he < 67108864 ? this.words[0] += he : this._iaddn(he);
      if (Ae !== 0) {
        var Me = 1;
        for (he = Ee(le, be, le.length, pe), be = 0; be < Ae; be++)
          Me *= pe;
        this.imuln(Me), this.words[0] + he < 67108864 ? this.words[0] += he : this._iaddn(he);
      }
      this.strip();
    }, ce.prototype.copy = function(le) {
      le.words = new Array(this.length);
      for (var pe = 0; pe < this.length; pe++)
        le.words[pe] = this.words[pe];
      le.length = this.length, le.negative = this.negative, le.red = this.red;
    }, ce.prototype.clone = function() {
      var le = new ce(null);
      return this.copy(le), le;
    }, ce.prototype._expand = function(le) {
      for (; this.length < le; )
        this.words[this.length++] = 0;
      return this;
    }, ce.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, ce.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, ce.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var Se = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], Be = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], Ce = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    ce.prototype.toString = function(le, pe) {
      le = le || 10, pe = pe | 0 || 1;
      var ge;
      if (le === 16 || le === "hex") {
        ge = "";
        for (var ye = 0, xe = 0, _e = 0; _e < this.length; _e++) {
          var Ae = this.words[_e], ve = ((Ae << ye | xe) & 16777215).toString(16);
          xe = Ae >>> 24 - ye & 16777215, xe !== 0 || _e !== this.length - 1 ? ge = Se[6 - ve.length] + ve + ge : ge = ve + ge, ye += 2, ye >= 26 && (ye -= 26, _e--);
        }
        for (xe !== 0 && (ge = xe.toString(16) + ge); ge.length % pe !== 0; )
          ge = "0" + ge;
        return this.negative !== 0 && (ge = "-" + ge), ge;
      }
      if (le === (le | 0) && le >= 2 && le <= 36) {
        var he = Be[le], be = Ce[le];
        ge = "";
        var Me = this.clone();
        for (Me.negative = 0; !Me.isZero(); ) {
          var Re = Me.modn(be).toString(le);
          Me = Me.idivn(be), Me.isZero() ? ge = Re + ge : ge = Se[he - Re.length] + Re + ge;
        }
        for (this.isZero() && (ge = "0" + ge); ge.length % pe !== 0; )
          ge = "0" + ge;
        return this.negative !== 0 && (ge = "-" + ge), ge;
      }
      fe(!1, "Base should be between 2 and 36");
    }, ce.prototype.toNumber = function() {
      var le = this.words[0];
      return this.length === 2 ? le += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? le += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && fe(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -le : le;
    }, ce.prototype.toJSON = function() {
      return this.toString(16);
    }, ce.prototype.toBuffer = function(le, pe) {
      return fe(typeof de < "u"), this.toArrayLike(de, le, pe);
    }, ce.prototype.toArray = function(le, pe) {
      return this.toArrayLike(Array, le, pe);
    }, ce.prototype.toArrayLike = function(le, pe, ge) {
      var ye = this.byteLength(), xe = ge || Math.max(1, ye);
      fe(ye <= xe, "byte array longer than desired length"), fe(xe > 0, "Requested array length <= 0"), this.strip();
      var _e = pe === "le", Ae = new le(xe), ve, he, be = this.clone();
      if (_e) {
        for (he = 0; !be.isZero(); he++)
          ve = be.andln(255), be.iushrn(8), Ae[he] = ve;
        for (; he < xe; he++)
          Ae[he] = 0;
      } else {
        for (he = 0; he < xe - ye; he++)
          Ae[he] = 0;
        for (he = 0; !be.isZero(); he++)
          ve = be.andln(255), be.iushrn(8), Ae[xe - he - 1] = ve;
      }
      return Ae;
    }, Math.clz32 ? ce.prototype._countBits = function(le) {
      return 32 - Math.clz32(le);
    } : ce.prototype._countBits = function(le) {
      var pe = le, ge = 0;
      return pe >= 4096 && (ge += 13, pe >>>= 13), pe >= 64 && (ge += 7, pe >>>= 7), pe >= 8 && (ge += 4, pe >>>= 4), pe >= 2 && (ge += 2, pe >>>= 2), ge + pe;
    }, ce.prototype._zeroBits = function(le) {
      if (le === 0)
        return 26;
      var pe = le, ge = 0;
      return pe & 8191 || (ge += 13, pe >>>= 13), pe & 127 || (ge += 7, pe >>>= 7), pe & 15 || (ge += 4, pe >>>= 4), pe & 3 || (ge += 2, pe >>>= 2), pe & 1 || ge++, ge;
    }, ce.prototype.bitLength = function() {
      var le = this.words[this.length - 1], pe = this._countBits(le);
      return (this.length - 1) * 26 + pe;
    };
    function Ie($e) {
      for (var le = new Array($e.bitLength()), pe = 0; pe < le.length; pe++) {
        var ge = pe / 26 | 0, ye = pe % 26;
        le[pe] = ($e.words[ge] & 1 << ye) >>> ye;
      }
      return le;
    }
    ce.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var le = 0, pe = 0; pe < this.length; pe++) {
        var ge = this._zeroBits(this.words[pe]);
        if (le += ge, ge !== 26)
          break;
      }
      return le;
    }, ce.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, ce.prototype.toTwos = function(le) {
      return this.negative !== 0 ? this.abs().inotn(le).iaddn(1) : this.clone();
    }, ce.prototype.fromTwos = function(le) {
      return this.testn(le - 1) ? this.notn(le).iaddn(1).ineg() : this.clone();
    }, ce.prototype.isNeg = function() {
      return this.negative !== 0;
    }, ce.prototype.neg = function() {
      return this.clone().ineg();
    }, ce.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, ce.prototype.iuor = function(le) {
      for (; this.length < le.length; )
        this.words[this.length++] = 0;
      for (var pe = 0; pe < le.length; pe++)
        this.words[pe] = this.words[pe] | le.words[pe];
      return this.strip();
    }, ce.prototype.ior = function(le) {
      return fe((this.negative | le.negative) === 0), this.iuor(le);
    }, ce.prototype.or = function(le) {
      return this.length > le.length ? this.clone().ior(le) : le.clone().ior(this);
    }, ce.prototype.uor = function(le) {
      return this.length > le.length ? this.clone().iuor(le) : le.clone().iuor(this);
    }, ce.prototype.iuand = function(le) {
      var pe;
      this.length > le.length ? pe = le : pe = this;
      for (var ge = 0; ge < pe.length; ge++)
        this.words[ge] = this.words[ge] & le.words[ge];
      return this.length = pe.length, this.strip();
    }, ce.prototype.iand = function(le) {
      return fe((this.negative | le.negative) === 0), this.iuand(le);
    }, ce.prototype.and = function(le) {
      return this.length > le.length ? this.clone().iand(le) : le.clone().iand(this);
    }, ce.prototype.uand = function(le) {
      return this.length > le.length ? this.clone().iuand(le) : le.clone().iuand(this);
    }, ce.prototype.iuxor = function(le) {
      var pe, ge;
      this.length > le.length ? (pe = this, ge = le) : (pe = le, ge = this);
      for (var ye = 0; ye < ge.length; ye++)
        this.words[ye] = pe.words[ye] ^ ge.words[ye];
      if (this !== pe)
        for (; ye < pe.length; ye++)
          this.words[ye] = pe.words[ye];
      return this.length = pe.length, this.strip();
    }, ce.prototype.ixor = function(le) {
      return fe((this.negative | le.negative) === 0), this.iuxor(le);
    }, ce.prototype.xor = function(le) {
      return this.length > le.length ? this.clone().ixor(le) : le.clone().ixor(this);
    }, ce.prototype.uxor = function(le) {
      return this.length > le.length ? this.clone().iuxor(le) : le.clone().iuxor(this);
    }, ce.prototype.inotn = function(le) {
      fe(typeof le == "number" && le >= 0);
      var pe = Math.ceil(le / 26) | 0, ge = le % 26;
      this._expand(pe), ge > 0 && pe--;
      for (var ye = 0; ye < pe; ye++)
        this.words[ye] = ~this.words[ye] & 67108863;
      return ge > 0 && (this.words[ye] = ~this.words[ye] & 67108863 >> 26 - ge), this.strip();
    }, ce.prototype.notn = function(le) {
      return this.clone().inotn(le);
    }, ce.prototype.setn = function(le, pe) {
      fe(typeof le == "number" && le >= 0);
      var ge = le / 26 | 0, ye = le % 26;
      return this._expand(ge + 1), pe ? this.words[ge] = this.words[ge] | 1 << ye : this.words[ge] = this.words[ge] & ~(1 << ye), this.strip();
    }, ce.prototype.iadd = function(le) {
      var pe;
      if (this.negative !== 0 && le.negative === 0)
        return this.negative = 0, pe = this.isub(le), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && le.negative !== 0)
        return le.negative = 0, pe = this.isub(le), le.negative = 1, pe._normSign();
      var ge, ye;
      this.length > le.length ? (ge = this, ye = le) : (ge = le, ye = this);
      for (var xe = 0, _e = 0; _e < ye.length; _e++)
        pe = (ge.words[_e] | 0) + (ye.words[_e] | 0) + xe, this.words[_e] = pe & 67108863, xe = pe >>> 26;
      for (; xe !== 0 && _e < ge.length; _e++)
        pe = (ge.words[_e] | 0) + xe, this.words[_e] = pe & 67108863, xe = pe >>> 26;
      if (this.length = ge.length, xe !== 0)
        this.words[this.length] = xe, this.length++;
      else if (ge !== this)
        for (; _e < ge.length; _e++)
          this.words[_e] = ge.words[_e];
      return this;
    }, ce.prototype.add = function(le) {
      var pe;
      return le.negative !== 0 && this.negative === 0 ? (le.negative = 0, pe = this.sub(le), le.negative ^= 1, pe) : le.negative === 0 && this.negative !== 0 ? (this.negative = 0, pe = le.sub(this), this.negative = 1, pe) : this.length > le.length ? this.clone().iadd(le) : le.clone().iadd(this);
    }, ce.prototype.isub = function(le) {
      if (le.negative !== 0) {
        le.negative = 0;
        var pe = this.iadd(le);
        return le.negative = 1, pe._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(le), this.negative = 1, this._normSign();
      var ge = this.cmp(le);
      if (ge === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var ye, xe;
      ge > 0 ? (ye = this, xe = le) : (ye = le, xe = this);
      for (var _e = 0, Ae = 0; Ae < xe.length; Ae++)
        pe = (ye.words[Ae] | 0) - (xe.words[Ae] | 0) + _e, _e = pe >> 26, this.words[Ae] = pe & 67108863;
      for (; _e !== 0 && Ae < ye.length; Ae++)
        pe = (ye.words[Ae] | 0) + _e, _e = pe >> 26, this.words[Ae] = pe & 67108863;
      if (_e === 0 && Ae < ye.length && ye !== this)
        for (; Ae < ye.length; Ae++)
          this.words[Ae] = ye.words[Ae];
      return this.length = Math.max(this.length, Ae), ye !== this && (this.negative = 1), this.strip();
    }, ce.prototype.sub = function(le) {
      return this.clone().isub(le);
    };
    function Pe($e, le, pe) {
      pe.negative = le.negative ^ $e.negative;
      var ge = $e.length + le.length | 0;
      pe.length = ge, ge = ge - 1 | 0;
      var ye = $e.words[0] | 0, xe = le.words[0] | 0, _e = ye * xe, Ae = _e & 67108863, ve = _e / 67108864 | 0;
      pe.words[0] = Ae;
      for (var he = 1; he < ge; he++) {
        for (var be = ve >>> 26, Me = ve & 67108863, Re = Math.min(he, le.length - 1), Oe = Math.max(0, he - $e.length + 1); Oe <= Re; Oe++) {
          var Te = he - Oe | 0;
          ye = $e.words[Te] | 0, xe = le.words[Oe] | 0, _e = ye * xe + Me, be += _e / 67108864 | 0, Me = _e & 67108863;
        }
        pe.words[he] = Me | 0, ve = be | 0;
      }
      return ve !== 0 ? pe.words[he] = ve | 0 : pe.length--, pe.strip();
    }
    var Ne = function(le, pe, ge) {
      var ye = le.words, xe = pe.words, _e = ge.words, Ae = 0, ve, he, be, Me = ye[0] | 0, Re = Me & 8191, Oe = Me >>> 13, Te = ye[1] | 0, Fe = Te & 8191, je = Te >>> 13, ct = ye[2] | 0, nt = ct & 8191, dt = ct >>> 13, it = ye[3] | 0, Je = it & 8191, gt = it >>> 13, Ht = ye[4] | 0, $t = Ht & 8191, Lt = Ht >>> 13, Tr = ye[5] | 0, Zt = Tr & 8191, wt = Tr >>> 13, Hr = ye[6] | 0, tr = Hr & 8191, cr = Hr >>> 13, qr = ye[7] | 0, Wt = qr & 8191, ar = qr >>> 13, Dr = ye[8] | 0, Jt = Dr & 8191, ir = Dr >>> 13, Gr = ye[9] | 0, We = Gr & 8191, Le = Gr >>> 13, Ke = xe[0] | 0, rt = Ke & 8191, lt = Ke >>> 13, It = xe[1] | 0, yt = It & 8191, jt = It >>> 13, Lr = xe[2] | 0, zt = Lr & 8191, rr = Lr >>> 13, Cr = xe[3] | 0, fr = Cr & 8191, pr = Cr >>> 13, jr = xe[4] | 0, nr = jr & 8191, ur = jr >>> 13, Wr = xe[5] | 0, or = Wr & 8191, lr = Wr >>> 13, Zr = xe[6] | 0, Xt = Zr & 8191, dr = Zr >>> 13, Ve = xe[7] | 0, Ze = Ve & 8191, Xe = Ve >>> 13, Ue = xe[8] | 0, Qe = Ue & 8191, pt = Ue >>> 13, Ct = xe[9] | 0, bt = Ct & 8191, Tt = Ct >>> 13;
      ge.negative = le.negative ^ pe.negative, ge.length = 19, ve = Math.imul(Re, rt), he = Math.imul(Re, lt), he = he + Math.imul(Oe, rt) | 0, be = Math.imul(Oe, lt);
      var br = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (br >>> 26) | 0, br &= 67108863, ve = Math.imul(Fe, rt), he = Math.imul(Fe, lt), he = he + Math.imul(je, rt) | 0, be = Math.imul(je, lt), ve = ve + Math.imul(Re, yt) | 0, he = he + Math.imul(Re, jt) | 0, he = he + Math.imul(Oe, yt) | 0, be = be + Math.imul(Oe, jt) | 0;
      var gr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (gr >>> 26) | 0, gr &= 67108863, ve = Math.imul(nt, rt), he = Math.imul(nt, lt), he = he + Math.imul(dt, rt) | 0, be = Math.imul(dt, lt), ve = ve + Math.imul(Fe, yt) | 0, he = he + Math.imul(Fe, jt) | 0, he = he + Math.imul(je, yt) | 0, be = be + Math.imul(je, jt) | 0, ve = ve + Math.imul(Re, zt) | 0, he = he + Math.imul(Re, rr) | 0, he = he + Math.imul(Oe, zt) | 0, be = be + Math.imul(Oe, rr) | 0;
      var Fr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, ve = Math.imul(Je, rt), he = Math.imul(Je, lt), he = he + Math.imul(gt, rt) | 0, be = Math.imul(gt, lt), ve = ve + Math.imul(nt, yt) | 0, he = he + Math.imul(nt, jt) | 0, he = he + Math.imul(dt, yt) | 0, be = be + Math.imul(dt, jt) | 0, ve = ve + Math.imul(Fe, zt) | 0, he = he + Math.imul(Fe, rr) | 0, he = he + Math.imul(je, zt) | 0, be = be + Math.imul(je, rr) | 0, ve = ve + Math.imul(Re, fr) | 0, he = he + Math.imul(Re, pr) | 0, he = he + Math.imul(Oe, fr) | 0, be = be + Math.imul(Oe, pr) | 0;
      var wr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (wr >>> 26) | 0, wr &= 67108863, ve = Math.imul($t, rt), he = Math.imul($t, lt), he = he + Math.imul(Lt, rt) | 0, be = Math.imul(Lt, lt), ve = ve + Math.imul(Je, yt) | 0, he = he + Math.imul(Je, jt) | 0, he = he + Math.imul(gt, yt) | 0, be = be + Math.imul(gt, jt) | 0, ve = ve + Math.imul(nt, zt) | 0, he = he + Math.imul(nt, rr) | 0, he = he + Math.imul(dt, zt) | 0, be = be + Math.imul(dt, rr) | 0, ve = ve + Math.imul(Fe, fr) | 0, he = he + Math.imul(Fe, pr) | 0, he = he + Math.imul(je, fr) | 0, be = be + Math.imul(je, pr) | 0, ve = ve + Math.imul(Re, nr) | 0, he = he + Math.imul(Re, ur) | 0, he = he + Math.imul(Oe, nr) | 0, be = be + Math.imul(Oe, ur) | 0;
      var Rr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Rr >>> 26) | 0, Rr &= 67108863, ve = Math.imul(Zt, rt), he = Math.imul(Zt, lt), he = he + Math.imul(wt, rt) | 0, be = Math.imul(wt, lt), ve = ve + Math.imul($t, yt) | 0, he = he + Math.imul($t, jt) | 0, he = he + Math.imul(Lt, yt) | 0, be = be + Math.imul(Lt, jt) | 0, ve = ve + Math.imul(Je, zt) | 0, he = he + Math.imul(Je, rr) | 0, he = he + Math.imul(gt, zt) | 0, be = be + Math.imul(gt, rr) | 0, ve = ve + Math.imul(nt, fr) | 0, he = he + Math.imul(nt, pr) | 0, he = he + Math.imul(dt, fr) | 0, be = be + Math.imul(dt, pr) | 0, ve = ve + Math.imul(Fe, nr) | 0, he = he + Math.imul(Fe, ur) | 0, he = he + Math.imul(je, nr) | 0, be = be + Math.imul(je, ur) | 0, ve = ve + Math.imul(Re, or) | 0, he = he + Math.imul(Re, lr) | 0, he = he + Math.imul(Oe, or) | 0, be = be + Math.imul(Oe, lr) | 0;
      var kr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (kr >>> 26) | 0, kr &= 67108863, ve = Math.imul(tr, rt), he = Math.imul(tr, lt), he = he + Math.imul(cr, rt) | 0, be = Math.imul(cr, lt), ve = ve + Math.imul(Zt, yt) | 0, he = he + Math.imul(Zt, jt) | 0, he = he + Math.imul(wt, yt) | 0, be = be + Math.imul(wt, jt) | 0, ve = ve + Math.imul($t, zt) | 0, he = he + Math.imul($t, rr) | 0, he = he + Math.imul(Lt, zt) | 0, be = be + Math.imul(Lt, rr) | 0, ve = ve + Math.imul(Je, fr) | 0, he = he + Math.imul(Je, pr) | 0, he = he + Math.imul(gt, fr) | 0, be = be + Math.imul(gt, pr) | 0, ve = ve + Math.imul(nt, nr) | 0, he = he + Math.imul(nt, ur) | 0, he = he + Math.imul(dt, nr) | 0, be = be + Math.imul(dt, ur) | 0, ve = ve + Math.imul(Fe, or) | 0, he = he + Math.imul(Fe, lr) | 0, he = he + Math.imul(je, or) | 0, be = be + Math.imul(je, lr) | 0, ve = ve + Math.imul(Re, Xt) | 0, he = he + Math.imul(Re, dr) | 0, he = he + Math.imul(Oe, Xt) | 0, be = be + Math.imul(Oe, dr) | 0;
      var Pr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, ve = Math.imul(Wt, rt), he = Math.imul(Wt, lt), he = he + Math.imul(ar, rt) | 0, be = Math.imul(ar, lt), ve = ve + Math.imul(tr, yt) | 0, he = he + Math.imul(tr, jt) | 0, he = he + Math.imul(cr, yt) | 0, be = be + Math.imul(cr, jt) | 0, ve = ve + Math.imul(Zt, zt) | 0, he = he + Math.imul(Zt, rr) | 0, he = he + Math.imul(wt, zt) | 0, be = be + Math.imul(wt, rr) | 0, ve = ve + Math.imul($t, fr) | 0, he = he + Math.imul($t, pr) | 0, he = he + Math.imul(Lt, fr) | 0, be = be + Math.imul(Lt, pr) | 0, ve = ve + Math.imul(Je, nr) | 0, he = he + Math.imul(Je, ur) | 0, he = he + Math.imul(gt, nr) | 0, be = be + Math.imul(gt, ur) | 0, ve = ve + Math.imul(nt, or) | 0, he = he + Math.imul(nt, lr) | 0, he = he + Math.imul(dt, or) | 0, be = be + Math.imul(dt, lr) | 0, ve = ve + Math.imul(Fe, Xt) | 0, he = he + Math.imul(Fe, dr) | 0, he = he + Math.imul(je, Xt) | 0, be = be + Math.imul(je, dr) | 0, ve = ve + Math.imul(Re, Ze) | 0, he = he + Math.imul(Re, Xe) | 0, he = he + Math.imul(Oe, Ze) | 0, be = be + Math.imul(Oe, Xe) | 0;
      var Ur = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, ve = Math.imul(Jt, rt), he = Math.imul(Jt, lt), he = he + Math.imul(ir, rt) | 0, be = Math.imul(ir, lt), ve = ve + Math.imul(Wt, yt) | 0, he = he + Math.imul(Wt, jt) | 0, he = he + Math.imul(ar, yt) | 0, be = be + Math.imul(ar, jt) | 0, ve = ve + Math.imul(tr, zt) | 0, he = he + Math.imul(tr, rr) | 0, he = he + Math.imul(cr, zt) | 0, be = be + Math.imul(cr, rr) | 0, ve = ve + Math.imul(Zt, fr) | 0, he = he + Math.imul(Zt, pr) | 0, he = he + Math.imul(wt, fr) | 0, be = be + Math.imul(wt, pr) | 0, ve = ve + Math.imul($t, nr) | 0, he = he + Math.imul($t, ur) | 0, he = he + Math.imul(Lt, nr) | 0, be = be + Math.imul(Lt, ur) | 0, ve = ve + Math.imul(Je, or) | 0, he = he + Math.imul(Je, lr) | 0, he = he + Math.imul(gt, or) | 0, be = be + Math.imul(gt, lr) | 0, ve = ve + Math.imul(nt, Xt) | 0, he = he + Math.imul(nt, dr) | 0, he = he + Math.imul(dt, Xt) | 0, be = be + Math.imul(dt, dr) | 0, ve = ve + Math.imul(Fe, Ze) | 0, he = he + Math.imul(Fe, Xe) | 0, he = he + Math.imul(je, Ze) | 0, be = be + Math.imul(je, Xe) | 0, ve = ve + Math.imul(Re, Qe) | 0, he = he + Math.imul(Re, pt) | 0, he = he + Math.imul(Oe, Qe) | 0, be = be + Math.imul(Oe, pt) | 0;
      var Ir = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Ir >>> 26) | 0, Ir &= 67108863, ve = Math.imul(We, rt), he = Math.imul(We, lt), he = he + Math.imul(Le, rt) | 0, be = Math.imul(Le, lt), ve = ve + Math.imul(Jt, yt) | 0, he = he + Math.imul(Jt, jt) | 0, he = he + Math.imul(ir, yt) | 0, be = be + Math.imul(ir, jt) | 0, ve = ve + Math.imul(Wt, zt) | 0, he = he + Math.imul(Wt, rr) | 0, he = he + Math.imul(ar, zt) | 0, be = be + Math.imul(ar, rr) | 0, ve = ve + Math.imul(tr, fr) | 0, he = he + Math.imul(tr, pr) | 0, he = he + Math.imul(cr, fr) | 0, be = be + Math.imul(cr, pr) | 0, ve = ve + Math.imul(Zt, nr) | 0, he = he + Math.imul(Zt, ur) | 0, he = he + Math.imul(wt, nr) | 0, be = be + Math.imul(wt, ur) | 0, ve = ve + Math.imul($t, or) | 0, he = he + Math.imul($t, lr) | 0, he = he + Math.imul(Lt, or) | 0, be = be + Math.imul(Lt, lr) | 0, ve = ve + Math.imul(Je, Xt) | 0, he = he + Math.imul(Je, dr) | 0, he = he + Math.imul(gt, Xt) | 0, be = be + Math.imul(gt, dr) | 0, ve = ve + Math.imul(nt, Ze) | 0, he = he + Math.imul(nt, Xe) | 0, he = he + Math.imul(dt, Ze) | 0, be = be + Math.imul(dt, Xe) | 0, ve = ve + Math.imul(Fe, Qe) | 0, he = he + Math.imul(Fe, pt) | 0, he = he + Math.imul(je, Qe) | 0, be = be + Math.imul(je, pt) | 0, ve = ve + Math.imul(Re, bt) | 0, he = he + Math.imul(Re, Tt) | 0, he = he + Math.imul(Oe, bt) | 0, be = be + Math.imul(Oe, Tt) | 0;
      var Or = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Or >>> 26) | 0, Or &= 67108863, ve = Math.imul(We, yt), he = Math.imul(We, jt), he = he + Math.imul(Le, yt) | 0, be = Math.imul(Le, jt), ve = ve + Math.imul(Jt, zt) | 0, he = he + Math.imul(Jt, rr) | 0, he = he + Math.imul(ir, zt) | 0, be = be + Math.imul(ir, rr) | 0, ve = ve + Math.imul(Wt, fr) | 0, he = he + Math.imul(Wt, pr) | 0, he = he + Math.imul(ar, fr) | 0, be = be + Math.imul(ar, pr) | 0, ve = ve + Math.imul(tr, nr) | 0, he = he + Math.imul(tr, ur) | 0, he = he + Math.imul(cr, nr) | 0, be = be + Math.imul(cr, ur) | 0, ve = ve + Math.imul(Zt, or) | 0, he = he + Math.imul(Zt, lr) | 0, he = he + Math.imul(wt, or) | 0, be = be + Math.imul(wt, lr) | 0, ve = ve + Math.imul($t, Xt) | 0, he = he + Math.imul($t, dr) | 0, he = he + Math.imul(Lt, Xt) | 0, be = be + Math.imul(Lt, dr) | 0, ve = ve + Math.imul(Je, Ze) | 0, he = he + Math.imul(Je, Xe) | 0, he = he + Math.imul(gt, Ze) | 0, be = be + Math.imul(gt, Xe) | 0, ve = ve + Math.imul(nt, Qe) | 0, he = he + Math.imul(nt, pt) | 0, he = he + Math.imul(dt, Qe) | 0, be = be + Math.imul(dt, pt) | 0, ve = ve + Math.imul(Fe, bt) | 0, he = he + Math.imul(Fe, Tt) | 0, he = he + Math.imul(je, bt) | 0, be = be + Math.imul(je, Tt) | 0;
      var Nr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Nr >>> 26) | 0, Nr &= 67108863, ve = Math.imul(We, zt), he = Math.imul(We, rr), he = he + Math.imul(Le, zt) | 0, be = Math.imul(Le, rr), ve = ve + Math.imul(Jt, fr) | 0, he = he + Math.imul(Jt, pr) | 0, he = he + Math.imul(ir, fr) | 0, be = be + Math.imul(ir, pr) | 0, ve = ve + Math.imul(Wt, nr) | 0, he = he + Math.imul(Wt, ur) | 0, he = he + Math.imul(ar, nr) | 0, be = be + Math.imul(ar, ur) | 0, ve = ve + Math.imul(tr, or) | 0, he = he + Math.imul(tr, lr) | 0, he = he + Math.imul(cr, or) | 0, be = be + Math.imul(cr, lr) | 0, ve = ve + Math.imul(Zt, Xt) | 0, he = he + Math.imul(Zt, dr) | 0, he = he + Math.imul(wt, Xt) | 0, be = be + Math.imul(wt, dr) | 0, ve = ve + Math.imul($t, Ze) | 0, he = he + Math.imul($t, Xe) | 0, he = he + Math.imul(Lt, Ze) | 0, be = be + Math.imul(Lt, Xe) | 0, ve = ve + Math.imul(Je, Qe) | 0, he = he + Math.imul(Je, pt) | 0, he = he + Math.imul(gt, Qe) | 0, be = be + Math.imul(gt, pt) | 0, ve = ve + Math.imul(nt, bt) | 0, he = he + Math.imul(nt, Tt) | 0, he = he + Math.imul(dt, bt) | 0, be = be + Math.imul(dt, Tt) | 0;
      var Er = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, ve = Math.imul(We, fr), he = Math.imul(We, pr), he = he + Math.imul(Le, fr) | 0, be = Math.imul(Le, pr), ve = ve + Math.imul(Jt, nr) | 0, he = he + Math.imul(Jt, ur) | 0, he = he + Math.imul(ir, nr) | 0, be = be + Math.imul(ir, ur) | 0, ve = ve + Math.imul(Wt, or) | 0, he = he + Math.imul(Wt, lr) | 0, he = he + Math.imul(ar, or) | 0, be = be + Math.imul(ar, lr) | 0, ve = ve + Math.imul(tr, Xt) | 0, he = he + Math.imul(tr, dr) | 0, he = he + Math.imul(cr, Xt) | 0, be = be + Math.imul(cr, dr) | 0, ve = ve + Math.imul(Zt, Ze) | 0, he = he + Math.imul(Zt, Xe) | 0, he = he + Math.imul(wt, Ze) | 0, be = be + Math.imul(wt, Xe) | 0, ve = ve + Math.imul($t, Qe) | 0, he = he + Math.imul($t, pt) | 0, he = he + Math.imul(Lt, Qe) | 0, be = be + Math.imul(Lt, pt) | 0, ve = ve + Math.imul(Je, bt) | 0, he = he + Math.imul(Je, Tt) | 0, he = he + Math.imul(gt, bt) | 0, be = be + Math.imul(gt, Tt) | 0;
      var Br = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Br >>> 26) | 0, Br &= 67108863, ve = Math.imul(We, nr), he = Math.imul(We, ur), he = he + Math.imul(Le, nr) | 0, be = Math.imul(Le, ur), ve = ve + Math.imul(Jt, or) | 0, he = he + Math.imul(Jt, lr) | 0, he = he + Math.imul(ir, or) | 0, be = be + Math.imul(ir, lr) | 0, ve = ve + Math.imul(Wt, Xt) | 0, he = he + Math.imul(Wt, dr) | 0, he = he + Math.imul(ar, Xt) | 0, be = be + Math.imul(ar, dr) | 0, ve = ve + Math.imul(tr, Ze) | 0, he = he + Math.imul(tr, Xe) | 0, he = he + Math.imul(cr, Ze) | 0, be = be + Math.imul(cr, Xe) | 0, ve = ve + Math.imul(Zt, Qe) | 0, he = he + Math.imul(Zt, pt) | 0, he = he + Math.imul(wt, Qe) | 0, be = be + Math.imul(wt, pt) | 0, ve = ve + Math.imul($t, bt) | 0, he = he + Math.imul($t, Tt) | 0, he = he + Math.imul(Lt, bt) | 0, be = be + Math.imul(Lt, Tt) | 0;
      var _r = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (_r >>> 26) | 0, _r &= 67108863, ve = Math.imul(We, or), he = Math.imul(We, lr), he = he + Math.imul(Le, or) | 0, be = Math.imul(Le, lr), ve = ve + Math.imul(Jt, Xt) | 0, he = he + Math.imul(Jt, dr) | 0, he = he + Math.imul(ir, Xt) | 0, be = be + Math.imul(ir, dr) | 0, ve = ve + Math.imul(Wt, Ze) | 0, he = he + Math.imul(Wt, Xe) | 0, he = he + Math.imul(ar, Ze) | 0, be = be + Math.imul(ar, Xe) | 0, ve = ve + Math.imul(tr, Qe) | 0, he = he + Math.imul(tr, pt) | 0, he = he + Math.imul(cr, Qe) | 0, be = be + Math.imul(cr, pt) | 0, ve = ve + Math.imul(Zt, bt) | 0, he = he + Math.imul(Zt, Tt) | 0, he = he + Math.imul(wt, bt) | 0, be = be + Math.imul(wt, Tt) | 0;
      var Sr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Sr >>> 26) | 0, Sr &= 67108863, ve = Math.imul(We, Xt), he = Math.imul(We, dr), he = he + Math.imul(Le, Xt) | 0, be = Math.imul(Le, dr), ve = ve + Math.imul(Jt, Ze) | 0, he = he + Math.imul(Jt, Xe) | 0, he = he + Math.imul(ir, Ze) | 0, be = be + Math.imul(ir, Xe) | 0, ve = ve + Math.imul(Wt, Qe) | 0, he = he + Math.imul(Wt, pt) | 0, he = he + Math.imul(ar, Qe) | 0, be = be + Math.imul(ar, pt) | 0, ve = ve + Math.imul(tr, bt) | 0, he = he + Math.imul(tr, Tt) | 0, he = he + Math.imul(cr, bt) | 0, be = be + Math.imul(cr, Tt) | 0;
      var Mr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Mr >>> 26) | 0, Mr &= 67108863, ve = Math.imul(We, Ze), he = Math.imul(We, Xe), he = he + Math.imul(Le, Ze) | 0, be = Math.imul(Le, Xe), ve = ve + Math.imul(Jt, Qe) | 0, he = he + Math.imul(Jt, pt) | 0, he = he + Math.imul(ir, Qe) | 0, be = be + Math.imul(ir, pt) | 0, ve = ve + Math.imul(Wt, bt) | 0, he = he + Math.imul(Wt, Tt) | 0, he = he + Math.imul(ar, bt) | 0, be = be + Math.imul(ar, Tt) | 0;
      var $r = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + ($r >>> 26) | 0, $r &= 67108863, ve = Math.imul(We, Qe), he = Math.imul(We, pt), he = he + Math.imul(Le, Qe) | 0, be = Math.imul(Le, pt), ve = ve + Math.imul(Jt, bt) | 0, he = he + Math.imul(Jt, Tt) | 0, he = he + Math.imul(ir, bt) | 0, be = be + Math.imul(ir, Tt) | 0;
      var Yt = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Yt >>> 26) | 0, Yt &= 67108863, ve = Math.imul(We, bt), he = Math.imul(We, Tt), he = he + Math.imul(Le, bt) | 0, be = Math.imul(Le, Tt);
      var er = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      return Ae = (be + (he >>> 13) | 0) + (er >>> 26) | 0, er &= 67108863, _e[0] = br, _e[1] = gr, _e[2] = Fr, _e[3] = wr, _e[4] = Rr, _e[5] = kr, _e[6] = Pr, _e[7] = Ur, _e[8] = Ir, _e[9] = Or, _e[10] = Nr, _e[11] = Er, _e[12] = Br, _e[13] = _r, _e[14] = Sr, _e[15] = Mr, _e[16] = $r, _e[17] = Yt, _e[18] = er, Ae !== 0 && (_e[19] = Ae, ge.length++), ge;
    };
    Math.imul || (Ne = Pe);
    function ke($e, le, pe) {
      pe.negative = le.negative ^ $e.negative, pe.length = $e.length + le.length;
      for (var ge = 0, ye = 0, xe = 0; xe < pe.length - 1; xe++) {
        var _e = ye;
        ye = 0;
        for (var Ae = ge & 67108863, ve = Math.min(xe, le.length - 1), he = Math.max(0, xe - $e.length + 1); he <= ve; he++) {
          var be = xe - he, Me = $e.words[be] | 0, Re = le.words[he] | 0, Oe = Me * Re, Te = Oe & 67108863;
          _e = _e + (Oe / 67108864 | 0) | 0, Te = Te + Ae | 0, Ae = Te & 67108863, _e = _e + (Te >>> 26) | 0, ye += _e >>> 26, _e &= 67108863;
        }
        pe.words[xe] = Ae, ge = _e, _e = ye;
      }
      return ge !== 0 ? pe.words[xe] = ge : pe.length--, pe.strip();
    }
    function He($e, le, pe) {
      var ge = new De();
      return ge.mulp($e, le, pe);
    }
    ce.prototype.mulTo = function(le, pe) {
      var ge, ye = this.length + le.length;
      return this.length === 10 && le.length === 10 ? ge = Ne(this, le, pe) : ye < 63 ? ge = Pe(this, le, pe) : ye < 1024 ? ge = ke(this, le, pe) : ge = He(this, le, pe), ge;
    };
    function De($e, le) {
      this.x = $e, this.y = le;
    }
    De.prototype.makeRBT = function(le) {
      for (var pe = new Array(le), ge = ce.prototype._countBits(le) - 1, ye = 0; ye < le; ye++)
        pe[ye] = this.revBin(ye, ge, le);
      return pe;
    }, De.prototype.revBin = function(le, pe, ge) {
      if (le === 0 || le === ge - 1)
        return le;
      for (var ye = 0, xe = 0; xe < pe; xe++)
        ye |= (le & 1) << pe - xe - 1, le >>= 1;
      return ye;
    }, De.prototype.permute = function(le, pe, ge, ye, xe, _e) {
      for (var Ae = 0; Ae < _e; Ae++)
        ye[Ae] = pe[le[Ae]], xe[Ae] = ge[le[Ae]];
    }, De.prototype.transform = function(le, pe, ge, ye, xe, _e) {
      this.permute(_e, le, pe, ge, ye, xe);
      for (var Ae = 1; Ae < xe; Ae <<= 1)
        for (var ve = Ae << 1, he = Math.cos(2 * Math.PI / ve), be = Math.sin(2 * Math.PI / ve), Me = 0; Me < xe; Me += ve)
          for (var Re = he, Oe = be, Te = 0; Te < Ae; Te++) {
            var Fe = ge[Me + Te], je = ye[Me + Te], ct = ge[Me + Te + Ae], nt = ye[Me + Te + Ae], dt = Re * ct - Oe * nt;
            nt = Re * nt + Oe * ct, ct = dt, ge[Me + Te] = Fe + ct, ye[Me + Te] = je + nt, ge[Me + Te + Ae] = Fe - ct, ye[Me + Te + Ae] = je - nt, Te !== ve && (dt = he * Re - be * Oe, Oe = he * Oe + be * Re, Re = dt);
          }
    }, De.prototype.guessLen13b = function(le, pe) {
      var ge = Math.max(pe, le) | 1, ye = ge & 1, xe = 0;
      for (ge = ge / 2 | 0; ge; ge = ge >>> 1)
        xe++;
      return 1 << xe + 1 + ye;
    }, De.prototype.conjugate = function(le, pe, ge) {
      if (!(ge <= 1))
        for (var ye = 0; ye < ge / 2; ye++) {
          var xe = le[ye];
          le[ye] = le[ge - ye - 1], le[ge - ye - 1] = xe, xe = pe[ye], pe[ye] = -pe[ge - ye - 1], pe[ge - ye - 1] = -xe;
        }
    }, De.prototype.normalize13b = function(le, pe) {
      for (var ge = 0, ye = 0; ye < pe / 2; ye++) {
        var xe = Math.round(le[2 * ye + 1] / pe) * 8192 + Math.round(le[2 * ye] / pe) + ge;
        le[ye] = xe & 67108863, xe < 67108864 ? ge = 0 : ge = xe / 67108864 | 0;
      }
      return le;
    }, De.prototype.convert13b = function(le, pe, ge, ye) {
      for (var xe = 0, _e = 0; _e < pe; _e++)
        xe = xe + (le[_e] | 0), ge[2 * _e] = xe & 8191, xe = xe >>> 13, ge[2 * _e + 1] = xe & 8191, xe = xe >>> 13;
      for (_e = 2 * pe; _e < ye; ++_e)
        ge[_e] = 0;
      fe(xe === 0), fe((xe & -8192) === 0);
    }, De.prototype.stub = function(le) {
      for (var pe = new Array(le), ge = 0; ge < le; ge++)
        pe[ge] = 0;
      return pe;
    }, De.prototype.mulp = function(le, pe, ge) {
      var ye = 2 * this.guessLen13b(le.length, pe.length), xe = this.makeRBT(ye), _e = this.stub(ye), Ae = new Array(ye), ve = new Array(ye), he = new Array(ye), be = new Array(ye), Me = new Array(ye), Re = new Array(ye), Oe = ge.words;
      Oe.length = ye, this.convert13b(le.words, le.length, Ae, ye), this.convert13b(pe.words, pe.length, be, ye), this.transform(Ae, _e, ve, he, ye, xe), this.transform(be, _e, Me, Re, ye, xe);
      for (var Te = 0; Te < ye; Te++) {
        var Fe = ve[Te] * Me[Te] - he[Te] * Re[Te];
        he[Te] = ve[Te] * Re[Te] + he[Te] * Me[Te], ve[Te] = Fe;
      }
      return this.conjugate(ve, he, ye), this.transform(ve, he, Oe, _e, ye, xe), this.conjugate(Oe, _e, ye), this.normalize13b(Oe, ye), ge.negative = le.negative ^ pe.negative, ge.length = le.length + pe.length, ge.strip();
    }, ce.prototype.mul = function(le) {
      var pe = new ce(null);
      return pe.words = new Array(this.length + le.length), this.mulTo(le, pe);
    }, ce.prototype.mulf = function(le) {
      var pe = new ce(null);
      return pe.words = new Array(this.length + le.length), He(this, le, pe);
    }, ce.prototype.imul = function(le) {
      return this.clone().mulTo(le, this);
    }, ce.prototype.imuln = function(le) {
      fe(typeof le == "number"), fe(le < 67108864);
      for (var pe = 0, ge = 0; ge < this.length; ge++) {
        var ye = (this.words[ge] | 0) * le, xe = (ye & 67108863) + (pe & 67108863);
        pe >>= 26, pe += ye / 67108864 | 0, pe += xe >>> 26, this.words[ge] = xe & 67108863;
      }
      return pe !== 0 && (this.words[ge] = pe, this.length++), this;
    }, ce.prototype.muln = function(le) {
      return this.clone().imuln(le);
    }, ce.prototype.sqr = function() {
      return this.mul(this);
    }, ce.prototype.isqr = function() {
      return this.imul(this.clone());
    }, ce.prototype.pow = function(le) {
      var pe = Ie(le);
      if (pe.length === 0)
        return new ce(1);
      for (var ge = this, ye = 0; ye < pe.length && pe[ye] === 0; ye++, ge = ge.sqr())
        ;
      if (++ye < pe.length)
        for (var xe = ge.sqr(); ye < pe.length; ye++, xe = xe.sqr())
          pe[ye] !== 0 && (ge = ge.mul(xe));
      return ge;
    }, ce.prototype.iushln = function(le) {
      fe(typeof le == "number" && le >= 0);
      var pe = le % 26, ge = (le - pe) / 26, ye = 67108863 >>> 26 - pe << 26 - pe, xe;
      if (pe !== 0) {
        var _e = 0;
        for (xe = 0; xe < this.length; xe++) {
          var Ae = this.words[xe] & ye, ve = (this.words[xe] | 0) - Ae << pe;
          this.words[xe] = ve | _e, _e = Ae >>> 26 - pe;
        }
        _e && (this.words[xe] = _e, this.length++);
      }
      if (ge !== 0) {
        for (xe = this.length - 1; xe >= 0; xe--)
          this.words[xe + ge] = this.words[xe];
        for (xe = 0; xe < ge; xe++)
          this.words[xe] = 0;
        this.length += ge;
      }
      return this.strip();
    }, ce.prototype.ishln = function(le) {
      return fe(this.negative === 0), this.iushln(le);
    }, ce.prototype.iushrn = function(le, pe, ge) {
      fe(typeof le == "number" && le >= 0);
      var ye;
      pe ? ye = (pe - pe % 26) / 26 : ye = 0;
      var xe = le % 26, _e = Math.min((le - xe) / 26, this.length), Ae = 67108863 ^ 67108863 >>> xe << xe, ve = ge;
      if (ye -= _e, ye = Math.max(0, ye), ve) {
        for (var he = 0; he < _e; he++)
          ve.words[he] = this.words[he];
        ve.length = _e;
      }
      if (_e !== 0)
        if (this.length > _e)
          for (this.length -= _e, he = 0; he < this.length; he++)
            this.words[he] = this.words[he + _e];
        else
          this.words[0] = 0, this.length = 1;
      var be = 0;
      for (he = this.length - 1; he >= 0 && (be !== 0 || he >= ye); he--) {
        var Me = this.words[he] | 0;
        this.words[he] = be << 26 - xe | Me >>> xe, be = Me & Ae;
      }
      return ve && be !== 0 && (ve.words[ve.length++] = be), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, ce.prototype.ishrn = function(le, pe, ge) {
      return fe(this.negative === 0), this.iushrn(le, pe, ge);
    }, ce.prototype.shln = function(le) {
      return this.clone().ishln(le);
    }, ce.prototype.ushln = function(le) {
      return this.clone().iushln(le);
    }, ce.prototype.shrn = function(le) {
      return this.clone().ishrn(le);
    }, ce.prototype.ushrn = function(le) {
      return this.clone().iushrn(le);
    }, ce.prototype.testn = function(le) {
      fe(typeof le == "number" && le >= 0);
      var pe = le % 26, ge = (le - pe) / 26, ye = 1 << pe;
      if (this.length <= ge)
        return !1;
      var xe = this.words[ge];
      return !!(xe & ye);
    }, ce.prototype.imaskn = function(le) {
      fe(typeof le == "number" && le >= 0);
      var pe = le % 26, ge = (le - pe) / 26;
      if (fe(this.negative === 0, "imaskn works only with positive numbers"), this.length <= ge)
        return this;
      if (pe !== 0 && ge++, this.length = Math.min(ge, this.length), pe !== 0) {
        var ye = 67108863 ^ 67108863 >>> pe << pe;
        this.words[this.length - 1] &= ye;
      }
      return this.strip();
    }, ce.prototype.maskn = function(le) {
      return this.clone().imaskn(le);
    }, ce.prototype.iaddn = function(le) {
      return fe(typeof le == "number"), fe(le < 67108864), le < 0 ? this.isubn(-le) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < le ? (this.words[0] = le - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(le), this.negative = 1, this) : this._iaddn(le);
    }, ce.prototype._iaddn = function(le) {
      this.words[0] += le;
      for (var pe = 0; pe < this.length && this.words[pe] >= 67108864; pe++)
        this.words[pe] -= 67108864, pe === this.length - 1 ? this.words[pe + 1] = 1 : this.words[pe + 1]++;
      return this.length = Math.max(this.length, pe + 1), this;
    }, ce.prototype.isubn = function(le) {
      if (fe(typeof le == "number"), fe(le < 67108864), le < 0)
        return this.iaddn(-le);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(le), this.negative = 1, this;
      if (this.words[0] -= le, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var pe = 0; pe < this.length && this.words[pe] < 0; pe++)
          this.words[pe] += 67108864, this.words[pe + 1] -= 1;
      return this.strip();
    }, ce.prototype.addn = function(le) {
      return this.clone().iaddn(le);
    }, ce.prototype.subn = function(le) {
      return this.clone().isubn(le);
    }, ce.prototype.iabs = function() {
      return this.negative = 0, this;
    }, ce.prototype.abs = function() {
      return this.clone().iabs();
    }, ce.prototype._ishlnsubmul = function(le, pe, ge) {
      var ye = le.length + ge, xe;
      this._expand(ye);
      var _e, Ae = 0;
      for (xe = 0; xe < le.length; xe++) {
        _e = (this.words[xe + ge] | 0) + Ae;
        var ve = (le.words[xe] | 0) * pe;
        _e -= ve & 67108863, Ae = (_e >> 26) - (ve / 67108864 | 0), this.words[xe + ge] = _e & 67108863;
      }
      for (; xe < this.length - ge; xe++)
        _e = (this.words[xe + ge] | 0) + Ae, Ae = _e >> 26, this.words[xe + ge] = _e & 67108863;
      if (Ae === 0)
        return this.strip();
      for (fe(Ae === -1), Ae = 0, xe = 0; xe < this.length; xe++)
        _e = -(this.words[xe] | 0) + Ae, Ae = _e >> 26, this.words[xe] = _e & 67108863;
      return this.negative = 1, this.strip();
    }, ce.prototype._wordDiv = function(le, pe) {
      var ge = this.length - le.length, ye = this.clone(), xe = le, _e = xe.words[xe.length - 1] | 0, Ae = this._countBits(_e);
      ge = 26 - Ae, ge !== 0 && (xe = xe.ushln(ge), ye.iushln(ge), _e = xe.words[xe.length - 1] | 0);
      var ve = ye.length - xe.length, he;
      if (pe !== "mod") {
        he = new ce(null), he.length = ve + 1, he.words = new Array(he.length);
        for (var be = 0; be < he.length; be++)
          he.words[be] = 0;
      }
      var Me = ye.clone()._ishlnsubmul(xe, 1, ve);
      Me.negative === 0 && (ye = Me, he && (he.words[ve] = 1));
      for (var Re = ve - 1; Re >= 0; Re--) {
        var Oe = (ye.words[xe.length + Re] | 0) * 67108864 + (ye.words[xe.length + Re - 1] | 0);
        for (Oe = Math.min(Oe / _e | 0, 67108863), ye._ishlnsubmul(xe, Oe, Re); ye.negative !== 0; )
          Oe--, ye.negative = 0, ye._ishlnsubmul(xe, 1, Re), ye.isZero() || (ye.negative ^= 1);
        he && (he.words[Re] = Oe);
      }
      return he && he.strip(), ye.strip(), pe !== "div" && ge !== 0 && ye.iushrn(ge), {
        div: he || null,
        mod: ye
      };
    }, ce.prototype.divmod = function(le, pe, ge) {
      if (fe(!le.isZero()), this.isZero())
        return {
          div: new ce(0),
          mod: new ce(0)
        };
      var ye, xe, _e;
      return this.negative !== 0 && le.negative === 0 ? (_e = this.neg().divmod(le, pe), pe !== "mod" && (ye = _e.div.neg()), pe !== "div" && (xe = _e.mod.neg(), ge && xe.negative !== 0 && xe.iadd(le)), {
        div: ye,
        mod: xe
      }) : this.negative === 0 && le.negative !== 0 ? (_e = this.divmod(le.neg(), pe), pe !== "mod" && (ye = _e.div.neg()), {
        div: ye,
        mod: _e.mod
      }) : this.negative & le.negative ? (_e = this.neg().divmod(le.neg(), pe), pe !== "div" && (xe = _e.mod.neg(), ge && xe.negative !== 0 && xe.isub(le)), {
        div: _e.div,
        mod: xe
      }) : le.length > this.length || this.cmp(le) < 0 ? {
        div: new ce(0),
        mod: this
      } : le.length === 1 ? pe === "div" ? {
        div: this.divn(le.words[0]),
        mod: null
      } : pe === "mod" ? {
        div: null,
        mod: new ce(this.modn(le.words[0]))
      } : {
        div: this.divn(le.words[0]),
        mod: new ce(this.modn(le.words[0]))
      } : this._wordDiv(le, pe);
    }, ce.prototype.div = function(le) {
      return this.divmod(le, "div", !1).div;
    }, ce.prototype.mod = function(le) {
      return this.divmod(le, "mod", !1).mod;
    }, ce.prototype.umod = function(le) {
      return this.divmod(le, "mod", !0).mod;
    }, ce.prototype.divRound = function(le) {
      var pe = this.divmod(le);
      if (pe.mod.isZero())
        return pe.div;
      var ge = pe.div.negative !== 0 ? pe.mod.isub(le) : pe.mod, ye = le.ushrn(1), xe = le.andln(1), _e = ge.cmp(ye);
      return _e < 0 || xe === 1 && _e === 0 ? pe.div : pe.div.negative !== 0 ? pe.div.isubn(1) : pe.div.iaddn(1);
    }, ce.prototype.modn = function(le) {
      fe(le <= 67108863);
      for (var pe = (1 << 26) % le, ge = 0, ye = this.length - 1; ye >= 0; ye--)
        ge = (pe * ge + (this.words[ye] | 0)) % le;
      return ge;
    }, ce.prototype.idivn = function(le) {
      fe(le <= 67108863);
      for (var pe = 0, ge = this.length - 1; ge >= 0; ge--) {
        var ye = (this.words[ge] | 0) + pe * 67108864;
        this.words[ge] = ye / le | 0, pe = ye % le;
      }
      return this.strip();
    }, ce.prototype.divn = function(le) {
      return this.clone().idivn(le);
    }, ce.prototype.egcd = function(le) {
      fe(le.negative === 0), fe(!le.isZero());
      var pe = this, ge = le.clone();
      pe.negative !== 0 ? pe = pe.umod(le) : pe = pe.clone();
      for (var ye = new ce(1), xe = new ce(0), _e = new ce(0), Ae = new ce(1), ve = 0; pe.isEven() && ge.isEven(); )
        pe.iushrn(1), ge.iushrn(1), ++ve;
      for (var he = ge.clone(), be = pe.clone(); !pe.isZero(); ) {
        for (var Me = 0, Re = 1; !(pe.words[0] & Re) && Me < 26; ++Me, Re <<= 1)
          ;
        if (Me > 0)
          for (pe.iushrn(Me); Me-- > 0; )
            (ye.isOdd() || xe.isOdd()) && (ye.iadd(he), xe.isub(be)), ye.iushrn(1), xe.iushrn(1);
        for (var Oe = 0, Te = 1; !(ge.words[0] & Te) && Oe < 26; ++Oe, Te <<= 1)
          ;
        if (Oe > 0)
          for (ge.iushrn(Oe); Oe-- > 0; )
            (_e.isOdd() || Ae.isOdd()) && (_e.iadd(he), Ae.isub(be)), _e.iushrn(1), Ae.iushrn(1);
        pe.cmp(ge) >= 0 ? (pe.isub(ge), ye.isub(_e), xe.isub(Ae)) : (ge.isub(pe), _e.isub(ye), Ae.isub(xe));
      }
      return {
        a: _e,
        b: Ae,
        gcd: ge.iushln(ve)
      };
    }, ce.prototype._invmp = function(le) {
      fe(le.negative === 0), fe(!le.isZero());
      var pe = this, ge = le.clone();
      pe.negative !== 0 ? pe = pe.umod(le) : pe = pe.clone();
      for (var ye = new ce(1), xe = new ce(0), _e = ge.clone(); pe.cmpn(1) > 0 && ge.cmpn(1) > 0; ) {
        for (var Ae = 0, ve = 1; !(pe.words[0] & ve) && Ae < 26; ++Ae, ve <<= 1)
          ;
        if (Ae > 0)
          for (pe.iushrn(Ae); Ae-- > 0; )
            ye.isOdd() && ye.iadd(_e), ye.iushrn(1);
        for (var he = 0, be = 1; !(ge.words[0] & be) && he < 26; ++he, be <<= 1)
          ;
        if (he > 0)
          for (ge.iushrn(he); he-- > 0; )
            xe.isOdd() && xe.iadd(_e), xe.iushrn(1);
        pe.cmp(ge) >= 0 ? (pe.isub(ge), ye.isub(xe)) : (ge.isub(pe), xe.isub(ye));
      }
      var Me;
      return pe.cmpn(1) === 0 ? Me = ye : Me = xe, Me.cmpn(0) < 0 && Me.iadd(le), Me;
    }, ce.prototype.gcd = function(le) {
      if (this.isZero())
        return le.abs();
      if (le.isZero())
        return this.abs();
      var pe = this.clone(), ge = le.clone();
      pe.negative = 0, ge.negative = 0;
      for (var ye = 0; pe.isEven() && ge.isEven(); ye++)
        pe.iushrn(1), ge.iushrn(1);
      do {
        for (; pe.isEven(); )
          pe.iushrn(1);
        for (; ge.isEven(); )
          ge.iushrn(1);
        var xe = pe.cmp(ge);
        if (xe < 0) {
          var _e = pe;
          pe = ge, ge = _e;
        } else if (xe === 0 || ge.cmpn(1) === 0)
          break;
        pe.isub(ge);
      } while (!0);
      return ge.iushln(ye);
    }, ce.prototype.invm = function(le) {
      return this.egcd(le).a.umod(le);
    }, ce.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, ce.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, ce.prototype.andln = function(le) {
      return this.words[0] & le;
    }, ce.prototype.bincn = function(le) {
      fe(typeof le == "number");
      var pe = le % 26, ge = (le - pe) / 26, ye = 1 << pe;
      if (this.length <= ge)
        return this._expand(ge + 1), this.words[ge] |= ye, this;
      for (var xe = ye, _e = ge; xe !== 0 && _e < this.length; _e++) {
        var Ae = this.words[_e] | 0;
        Ae += xe, xe = Ae >>> 26, Ae &= 67108863, this.words[_e] = Ae;
      }
      return xe !== 0 && (this.words[_e] = xe, this.length++), this;
    }, ce.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, ce.prototype.cmpn = function(le) {
      var pe = le < 0;
      if (this.negative !== 0 && !pe)
        return -1;
      if (this.negative === 0 && pe)
        return 1;
      this.strip();
      var ge;
      if (this.length > 1)
        ge = 1;
      else {
        pe && (le = -le), fe(le <= 67108863, "Number is too big");
        var ye = this.words[0] | 0;
        ge = ye === le ? 0 : ye < le ? -1 : 1;
      }
      return this.negative !== 0 ? -ge | 0 : ge;
    }, ce.prototype.cmp = function(le) {
      if (this.negative !== 0 && le.negative === 0)
        return -1;
      if (this.negative === 0 && le.negative !== 0)
        return 1;
      var pe = this.ucmp(le);
      return this.negative !== 0 ? -pe | 0 : pe;
    }, ce.prototype.ucmp = function(le) {
      if (this.length > le.length)
        return 1;
      if (this.length < le.length)
        return -1;
      for (var pe = 0, ge = this.length - 1; ge >= 0; ge--) {
        var ye = this.words[ge] | 0, xe = le.words[ge] | 0;
        if (ye !== xe) {
          ye < xe ? pe = -1 : ye > xe && (pe = 1);
          break;
        }
      }
      return pe;
    }, ce.prototype.gtn = function(le) {
      return this.cmpn(le) === 1;
    }, ce.prototype.gt = function(le) {
      return this.cmp(le) === 1;
    }, ce.prototype.gten = function(le) {
      return this.cmpn(le) >= 0;
    }, ce.prototype.gte = function(le) {
      return this.cmp(le) >= 0;
    }, ce.prototype.ltn = function(le) {
      return this.cmpn(le) === -1;
    }, ce.prototype.lt = function(le) {
      return this.cmp(le) === -1;
    }, ce.prototype.lten = function(le) {
      return this.cmpn(le) <= 0;
    }, ce.prototype.lte = function(le) {
      return this.cmp(le) <= 0;
    }, ce.prototype.eqn = function(le) {
      return this.cmpn(le) === 0;
    }, ce.prototype.eq = function(le) {
      return this.cmp(le) === 0;
    }, ce.red = function(le) {
      return new ze(le);
    }, ce.prototype.toRed = function(le) {
      return fe(!this.red, "Already a number in reduction context"), fe(this.negative === 0, "red works only with positives"), le.convertTo(this)._forceRed(le);
    }, ce.prototype.fromRed = function() {
      return fe(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, ce.prototype._forceRed = function(le) {
      return this.red = le, this;
    }, ce.prototype.forceRed = function(le) {
      return fe(!this.red, "Already a number in reduction context"), this._forceRed(le);
    }, ce.prototype.redAdd = function(le) {
      return fe(this.red, "redAdd works only with red numbers"), this.red.add(this, le);
    }, ce.prototype.redIAdd = function(le) {
      return fe(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, le);
    }, ce.prototype.redSub = function(le) {
      return fe(this.red, "redSub works only with red numbers"), this.red.sub(this, le);
    }, ce.prototype.redISub = function(le) {
      return fe(this.red, "redISub works only with red numbers"), this.red.isub(this, le);
    }, ce.prototype.redShl = function(le) {
      return fe(this.red, "redShl works only with red numbers"), this.red.shl(this, le);
    }, ce.prototype.redMul = function(le) {
      return fe(this.red, "redMul works only with red numbers"), this.red._verify2(this, le), this.red.mul(this, le);
    }, ce.prototype.redIMul = function(le) {
      return fe(this.red, "redMul works only with red numbers"), this.red._verify2(this, le), this.red.imul(this, le);
    }, ce.prototype.redSqr = function() {
      return fe(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, ce.prototype.redISqr = function() {
      return fe(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, ce.prototype.redSqrt = function() {
      return fe(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, ce.prototype.redInvm = function() {
      return fe(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, ce.prototype.redNeg = function() {
      return fe(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, ce.prototype.redPow = function(le) {
      return fe(this.red && !le.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, le);
    };
    var Ge = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Ye($e, le) {
      this.name = $e, this.p = new ce(le, 16), this.n = this.p.bitLength(), this.k = new ce(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Ye.prototype._tmp = function() {
      var le = new ce(null);
      return le.words = new Array(Math.ceil(this.n / 13)), le;
    }, Ye.prototype.ireduce = function(le) {
      var pe = le, ge;
      do
        this.split(pe, this.tmp), pe = this.imulK(pe), pe = pe.iadd(this.tmp), ge = pe.bitLength();
      while (ge > this.n);
      var ye = ge < this.n ? -1 : pe.ucmp(this.p);
      return ye === 0 ? (pe.words[0] = 0, pe.length = 1) : ye > 0 ? pe.isub(this.p) : pe.strip !== void 0 ? pe.strip() : pe._strip(), pe;
    }, Ye.prototype.split = function(le, pe) {
      le.iushrn(this.n, 0, pe);
    }, Ye.prototype.imulK = function(le) {
      return le.imul(this.k);
    };
    function st() {
      Ye.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    ue(st, Ye), st.prototype.split = function(le, pe) {
      for (var ge = 4194303, ye = Math.min(le.length, 9), xe = 0; xe < ye; xe++)
        pe.words[xe] = le.words[xe];
      if (pe.length = ye, le.length <= 9) {
        le.words[0] = 0, le.length = 1;
        return;
      }
      var _e = le.words[9];
      for (pe.words[pe.length++] = _e & ge, xe = 10; xe < le.length; xe++) {
        var Ae = le.words[xe] | 0;
        le.words[xe - 10] = (Ae & ge) << 4 | _e >>> 22, _e = Ae;
      }
      _e >>>= 22, le.words[xe - 10] = _e, _e === 0 && le.length > 10 ? le.length -= 10 : le.length -= 9;
    }, st.prototype.imulK = function(le) {
      le.words[le.length] = 0, le.words[le.length + 1] = 0, le.length += 2;
      for (var pe = 0, ge = 0; ge < le.length; ge++) {
        var ye = le.words[ge] | 0;
        pe += ye * 977, le.words[ge] = pe & 67108863, pe = ye * 64 + (pe / 67108864 | 0);
      }
      return le.words[le.length - 1] === 0 && (le.length--, le.words[le.length - 1] === 0 && le.length--), le;
    };
    function at() {
      Ye.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    ue(at, Ye);
    function mt() {
      Ye.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    ue(mt, Ye);
    function qe() {
      Ye.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    ue(qe, Ye), qe.prototype.imulK = function(le) {
      for (var pe = 0, ge = 0; ge < le.length; ge++) {
        var ye = (le.words[ge] | 0) * 19 + pe, xe = ye & 67108863;
        ye >>>= 26, le.words[ge] = xe, pe = ye;
      }
      return pe !== 0 && (le.words[le.length++] = pe), le;
    }, ce._prime = function(le) {
      if (Ge[le])
        return Ge[le];
      var pe;
      if (le === "k256")
        pe = new st();
      else if (le === "p224")
        pe = new at();
      else if (le === "p192")
        pe = new mt();
      else if (le === "p25519")
        pe = new qe();
      else
        throw new Error("Unknown prime " + le);
      return Ge[le] = pe, pe;
    };
    function ze($e) {
      if (typeof $e == "string") {
        var le = ce._prime($e);
        this.m = le.p, this.prime = le;
      } else
        fe($e.gtn(1), "modulus must be greater than 1"), this.m = $e, this.prime = null;
    }
    ze.prototype._verify1 = function(le) {
      fe(le.negative === 0, "red works only with positives"), fe(le.red, "red works only with red numbers");
    }, ze.prototype._verify2 = function(le, pe) {
      fe((le.negative | pe.negative) === 0, "red works only with positives"), fe(
        le.red && le.red === pe.red,
        "red works only with red numbers"
      );
    }, ze.prototype.imod = function(le) {
      return this.prime ? this.prime.ireduce(le)._forceRed(this) : le.umod(this.m)._forceRed(this);
    }, ze.prototype.neg = function(le) {
      return le.isZero() ? le.clone() : this.m.sub(le)._forceRed(this);
    }, ze.prototype.add = function(le, pe) {
      this._verify2(le, pe);
      var ge = le.add(pe);
      return ge.cmp(this.m) >= 0 && ge.isub(this.m), ge._forceRed(this);
    }, ze.prototype.iadd = function(le, pe) {
      this._verify2(le, pe);
      var ge = le.iadd(pe);
      return ge.cmp(this.m) >= 0 && ge.isub(this.m), ge;
    }, ze.prototype.sub = function(le, pe) {
      this._verify2(le, pe);
      var ge = le.sub(pe);
      return ge.cmpn(0) < 0 && ge.iadd(this.m), ge._forceRed(this);
    }, ze.prototype.isub = function(le, pe) {
      this._verify2(le, pe);
      var ge = le.isub(pe);
      return ge.cmpn(0) < 0 && ge.iadd(this.m), ge;
    }, ze.prototype.shl = function(le, pe) {
      return this._verify1(le), this.imod(le.ushln(pe));
    }, ze.prototype.imul = function(le, pe) {
      return this._verify2(le, pe), this.imod(le.imul(pe));
    }, ze.prototype.mul = function(le, pe) {
      return this._verify2(le, pe), this.imod(le.mul(pe));
    }, ze.prototype.isqr = function(le) {
      return this.imul(le, le.clone());
    }, ze.prototype.sqr = function(le) {
      return this.mul(le, le);
    }, ze.prototype.sqrt = function(le) {
      if (le.isZero())
        return le.clone();
      var pe = this.m.andln(3);
      if (fe(pe % 2 === 1), pe === 3) {
        var ge = this.m.add(new ce(1)).iushrn(2);
        return this.pow(le, ge);
      }
      for (var ye = this.m.subn(1), xe = 0; !ye.isZero() && ye.andln(1) === 0; )
        xe++, ye.iushrn(1);
      fe(!ye.isZero());
      var _e = new ce(1).toRed(this), Ae = _e.redNeg(), ve = this.m.subn(1).iushrn(1), he = this.m.bitLength();
      for (he = new ce(2 * he * he).toRed(this); this.pow(he, ve).cmp(Ae) !== 0; )
        he.redIAdd(Ae);
      for (var be = this.pow(he, ye), Me = this.pow(le, ye.addn(1).iushrn(1)), Re = this.pow(le, ye), Oe = xe; Re.cmp(_e) !== 0; ) {
        for (var Te = Re, Fe = 0; Te.cmp(_e) !== 0; Fe++)
          Te = Te.redSqr();
        fe(Fe < Oe);
        var je = this.pow(be, new ce(1).iushln(Oe - Fe - 1));
        Me = Me.redMul(je), be = je.redSqr(), Re = Re.redMul(be), Oe = Fe;
      }
      return Me;
    }, ze.prototype.invm = function(le) {
      var pe = le._invmp(this.m);
      return pe.negative !== 0 ? (pe.negative = 0, this.imod(pe).redNeg()) : this.imod(pe);
    }, ze.prototype.pow = function(le, pe) {
      if (pe.isZero())
        return new ce(1).toRed(this);
      if (pe.cmpn(1) === 0)
        return le.clone();
      var ge = 4, ye = new Array(1 << ge);
      ye[0] = new ce(1).toRed(this), ye[1] = le;
      for (var xe = 2; xe < ye.length; xe++)
        ye[xe] = this.mul(ye[xe - 1], le);
      var _e = ye[0], Ae = 0, ve = 0, he = pe.bitLength() % 26;
      for (he === 0 && (he = 26), xe = pe.length - 1; xe >= 0; xe--) {
        for (var be = pe.words[xe], Me = he - 1; Me >= 0; Me--) {
          var Re = be >> Me & 1;
          if (_e !== ye[0] && (_e = this.sqr(_e)), Re === 0 && Ae === 0) {
            ve = 0;
            continue;
          }
          Ae <<= 1, Ae |= Re, ve++, !(ve !== ge && (xe !== 0 || Me !== 0)) && (_e = this.mul(_e, ye[Ae]), ve = 0, Ae = 0);
        }
        he = 26;
      }
      return _e;
    }, ze.prototype.convertTo = function(le) {
      var pe = le.umod(this.m);
      return pe === le ? pe.clone() : pe;
    }, ze.prototype.convertFrom = function(le) {
      var pe = le.clone();
      return pe.red = null, pe;
    }, ce.mont = function(le) {
      return new ot(le);
    };
    function ot($e) {
      ze.call(this, $e), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new ce(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    ue(ot, ze), ot.prototype.convertTo = function(le) {
      return this.imod(le.ushln(this.shift));
    }, ot.prototype.convertFrom = function(le) {
      var pe = this.imod(le.mul(this.rinv));
      return pe.red = null, pe;
    }, ot.prototype.imul = function(le, pe) {
      if (le.isZero() || pe.isZero())
        return le.words[0] = 0, le.length = 1, le;
      var ge = le.imul(pe), ye = ge.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), xe = ge.isub(ye).iushrn(this.shift), _e = xe;
      return xe.cmp(this.m) >= 0 ? _e = xe.isub(this.m) : xe.cmpn(0) < 0 && (_e = xe.iadd(this.m)), _e._forceRed(this);
    }, ot.prototype.mul = function(le, pe) {
      if (le.isZero() || pe.isZero())
        return new ce(0)._forceRed(this);
      var ge = le.mul(pe), ye = ge.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), xe = ge.isub(ye).iushrn(this.shift), _e = xe;
      return xe.cmp(this.m) >= 0 ? _e = xe.isub(this.m) : xe.cmpn(0) < 0 && (_e = xe.iadd(this.m)), _e._forceRed(this);
    }, ot.prototype.invm = function(le) {
      var pe = this.imod(le._invmp(this.m).mul(this.r2));
      return pe._forceRed(this);
    };
  })(ae, commonjsGlobal);
})(bn$6);
var bnExports$6 = bn$6.exports, bn$5 = { exports: {} };
bn$5.exports;
(function(ae) {
  (function(ie, se) {
    function fe($e, le) {
      if (!$e)
        throw new Error(le || "Assertion failed");
    }
    function ue($e, le) {
      $e.super_ = le;
      var pe = function() {
      };
      pe.prototype = le.prototype, $e.prototype = new pe(), $e.prototype.constructor = $e;
    }
    function ce($e, le, pe) {
      if (ce.isBN($e))
        return $e;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, $e !== null && ((le === "le" || le === "be") && (pe = le, le = 10), this._init($e || 0, le || 10, pe || "be"));
    }
    typeof ie == "object" ? ie.exports = ce : se.BN = ce, ce.BN = ce, ce.wordSize = 26;
    var de;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? de = window.Buffer : de = require$$0$2.Buffer;
    } catch {
    }
    ce.isBN = function(le) {
      return le instanceof ce ? !0 : le !== null && typeof le == "object" && le.constructor.wordSize === ce.wordSize && Array.isArray(le.words);
    }, ce.max = function(le, pe) {
      return le.cmp(pe) > 0 ? le : pe;
    }, ce.min = function(le, pe) {
      return le.cmp(pe) < 0 ? le : pe;
    }, ce.prototype._init = function(le, pe, ge) {
      if (typeof le == "number")
        return this._initNumber(le, pe, ge);
      if (typeof le == "object")
        return this._initArray(le, pe, ge);
      pe === "hex" && (pe = 16), fe(pe === (pe | 0) && pe >= 2 && pe <= 36), le = le.toString().replace(/\s+/g, "");
      var ye = 0;
      le[0] === "-" && (ye++, this.negative = 1), ye < le.length && (pe === 16 ? this._parseHex(le, ye, ge) : (this._parseBase(le, pe, ye), ge === "le" && this._initArray(this.toArray(), pe, ge)));
    }, ce.prototype._initNumber = function(le, pe, ge) {
      le < 0 && (this.negative = 1, le = -le), le < 67108864 ? (this.words = [le & 67108863], this.length = 1) : le < 4503599627370496 ? (this.words = [
        le & 67108863,
        le / 67108864 & 67108863
      ], this.length = 2) : (fe(le < 9007199254740992), this.words = [
        le & 67108863,
        le / 67108864 & 67108863,
        1
      ], this.length = 3), ge === "le" && this._initArray(this.toArray(), pe, ge);
    }, ce.prototype._initArray = function(le, pe, ge) {
      if (fe(typeof le.length == "number"), le.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(le.length / 3), this.words = new Array(this.length);
      for (var ye = 0; ye < this.length; ye++)
        this.words[ye] = 0;
      var xe, _e, Ae = 0;
      if (ge === "be")
        for (ye = le.length - 1, xe = 0; ye >= 0; ye -= 3)
          _e = le[ye] | le[ye - 1] << 8 | le[ye - 2] << 16, this.words[xe] |= _e << Ae & 67108863, this.words[xe + 1] = _e >>> 26 - Ae & 67108863, Ae += 24, Ae >= 26 && (Ae -= 26, xe++);
      else if (ge === "le")
        for (ye = 0, xe = 0; ye < le.length; ye += 3)
          _e = le[ye] | le[ye + 1] << 8 | le[ye + 2] << 16, this.words[xe] |= _e << Ae & 67108863, this.words[xe + 1] = _e >>> 26 - Ae & 67108863, Ae += 24, Ae >= 26 && (Ae -= 26, xe++);
      return this.strip();
    };
    function me($e, le) {
      var pe = $e.charCodeAt(le);
      return pe >= 65 && pe <= 70 ? pe - 55 : pe >= 97 && pe <= 102 ? pe - 87 : pe - 48 & 15;
    }
    function we($e, le, pe) {
      var ge = me($e, pe);
      return pe - 1 >= le && (ge |= me($e, pe - 1) << 4), ge;
    }
    ce.prototype._parseHex = function(le, pe, ge) {
      this.length = Math.ceil((le.length - pe) / 6), this.words = new Array(this.length);
      for (var ye = 0; ye < this.length; ye++)
        this.words[ye] = 0;
      var xe = 0, _e = 0, Ae;
      if (ge === "be")
        for (ye = le.length - 1; ye >= pe; ye -= 2)
          Ae = we(le, pe, ye) << xe, this.words[_e] |= Ae & 67108863, xe >= 18 ? (xe -= 18, _e += 1, this.words[_e] |= Ae >>> 26) : xe += 8;
      else {
        var ve = le.length - pe;
        for (ye = ve % 2 === 0 ? pe + 1 : pe; ye < le.length; ye += 2)
          Ae = we(le, pe, ye) << xe, this.words[_e] |= Ae & 67108863, xe >= 18 ? (xe -= 18, _e += 1, this.words[_e] |= Ae >>> 26) : xe += 8;
      }
      this.strip();
    };
    function Ee($e, le, pe, ge) {
      for (var ye = 0, xe = Math.min($e.length, pe), _e = le; _e < xe; _e++) {
        var Ae = $e.charCodeAt(_e) - 48;
        ye *= ge, Ae >= 49 ? ye += Ae - 49 + 10 : Ae >= 17 ? ye += Ae - 17 + 10 : ye += Ae;
      }
      return ye;
    }
    ce.prototype._parseBase = function(le, pe, ge) {
      this.words = [0], this.length = 1;
      for (var ye = 0, xe = 1; xe <= 67108863; xe *= pe)
        ye++;
      ye--, xe = xe / pe | 0;
      for (var _e = le.length - ge, Ae = _e % ye, ve = Math.min(_e, _e - Ae) + ge, he = 0, be = ge; be < ve; be += ye)
        he = Ee(le, be, be + ye, pe), this.imuln(xe), this.words[0] + he < 67108864 ? this.words[0] += he : this._iaddn(he);
      if (Ae !== 0) {
        var Me = 1;
        for (he = Ee(le, be, le.length, pe), be = 0; be < Ae; be++)
          Me *= pe;
        this.imuln(Me), this.words[0] + he < 67108864 ? this.words[0] += he : this._iaddn(he);
      }
      this.strip();
    }, ce.prototype.copy = function(le) {
      le.words = new Array(this.length);
      for (var pe = 0; pe < this.length; pe++)
        le.words[pe] = this.words[pe];
      le.length = this.length, le.negative = this.negative, le.red = this.red;
    }, ce.prototype.clone = function() {
      var le = new ce(null);
      return this.copy(le), le;
    }, ce.prototype._expand = function(le) {
      for (; this.length < le; )
        this.words[this.length++] = 0;
      return this;
    }, ce.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, ce.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, ce.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var Se = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], Be = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], Ce = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    ce.prototype.toString = function(le, pe) {
      le = le || 10, pe = pe | 0 || 1;
      var ge;
      if (le === 16 || le === "hex") {
        ge = "";
        for (var ye = 0, xe = 0, _e = 0; _e < this.length; _e++) {
          var Ae = this.words[_e], ve = ((Ae << ye | xe) & 16777215).toString(16);
          xe = Ae >>> 24 - ye & 16777215, xe !== 0 || _e !== this.length - 1 ? ge = Se[6 - ve.length] + ve + ge : ge = ve + ge, ye += 2, ye >= 26 && (ye -= 26, _e--);
        }
        for (xe !== 0 && (ge = xe.toString(16) + ge); ge.length % pe !== 0; )
          ge = "0" + ge;
        return this.negative !== 0 && (ge = "-" + ge), ge;
      }
      if (le === (le | 0) && le >= 2 && le <= 36) {
        var he = Be[le], be = Ce[le];
        ge = "";
        var Me = this.clone();
        for (Me.negative = 0; !Me.isZero(); ) {
          var Re = Me.modn(be).toString(le);
          Me = Me.idivn(be), Me.isZero() ? ge = Re + ge : ge = Se[he - Re.length] + Re + ge;
        }
        for (this.isZero() && (ge = "0" + ge); ge.length % pe !== 0; )
          ge = "0" + ge;
        return this.negative !== 0 && (ge = "-" + ge), ge;
      }
      fe(!1, "Base should be between 2 and 36");
    }, ce.prototype.toNumber = function() {
      var le = this.words[0];
      return this.length === 2 ? le += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? le += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && fe(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -le : le;
    }, ce.prototype.toJSON = function() {
      return this.toString(16);
    }, ce.prototype.toBuffer = function(le, pe) {
      return fe(typeof de < "u"), this.toArrayLike(de, le, pe);
    }, ce.prototype.toArray = function(le, pe) {
      return this.toArrayLike(Array, le, pe);
    }, ce.prototype.toArrayLike = function(le, pe, ge) {
      var ye = this.byteLength(), xe = ge || Math.max(1, ye);
      fe(ye <= xe, "byte array longer than desired length"), fe(xe > 0, "Requested array length <= 0"), this.strip();
      var _e = pe === "le", Ae = new le(xe), ve, he, be = this.clone();
      if (_e) {
        for (he = 0; !be.isZero(); he++)
          ve = be.andln(255), be.iushrn(8), Ae[he] = ve;
        for (; he < xe; he++)
          Ae[he] = 0;
      } else {
        for (he = 0; he < xe - ye; he++)
          Ae[he] = 0;
        for (he = 0; !be.isZero(); he++)
          ve = be.andln(255), be.iushrn(8), Ae[xe - he - 1] = ve;
      }
      return Ae;
    }, Math.clz32 ? ce.prototype._countBits = function(le) {
      return 32 - Math.clz32(le);
    } : ce.prototype._countBits = function(le) {
      var pe = le, ge = 0;
      return pe >= 4096 && (ge += 13, pe >>>= 13), pe >= 64 && (ge += 7, pe >>>= 7), pe >= 8 && (ge += 4, pe >>>= 4), pe >= 2 && (ge += 2, pe >>>= 2), ge + pe;
    }, ce.prototype._zeroBits = function(le) {
      if (le === 0)
        return 26;
      var pe = le, ge = 0;
      return pe & 8191 || (ge += 13, pe >>>= 13), pe & 127 || (ge += 7, pe >>>= 7), pe & 15 || (ge += 4, pe >>>= 4), pe & 3 || (ge += 2, pe >>>= 2), pe & 1 || ge++, ge;
    }, ce.prototype.bitLength = function() {
      var le = this.words[this.length - 1], pe = this._countBits(le);
      return (this.length - 1) * 26 + pe;
    };
    function Ie($e) {
      for (var le = new Array($e.bitLength()), pe = 0; pe < le.length; pe++) {
        var ge = pe / 26 | 0, ye = pe % 26;
        le[pe] = ($e.words[ge] & 1 << ye) >>> ye;
      }
      return le;
    }
    ce.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var le = 0, pe = 0; pe < this.length; pe++) {
        var ge = this._zeroBits(this.words[pe]);
        if (le += ge, ge !== 26)
          break;
      }
      return le;
    }, ce.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, ce.prototype.toTwos = function(le) {
      return this.negative !== 0 ? this.abs().inotn(le).iaddn(1) : this.clone();
    }, ce.prototype.fromTwos = function(le) {
      return this.testn(le - 1) ? this.notn(le).iaddn(1).ineg() : this.clone();
    }, ce.prototype.isNeg = function() {
      return this.negative !== 0;
    }, ce.prototype.neg = function() {
      return this.clone().ineg();
    }, ce.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, ce.prototype.iuor = function(le) {
      for (; this.length < le.length; )
        this.words[this.length++] = 0;
      for (var pe = 0; pe < le.length; pe++)
        this.words[pe] = this.words[pe] | le.words[pe];
      return this.strip();
    }, ce.prototype.ior = function(le) {
      return fe((this.negative | le.negative) === 0), this.iuor(le);
    }, ce.prototype.or = function(le) {
      return this.length > le.length ? this.clone().ior(le) : le.clone().ior(this);
    }, ce.prototype.uor = function(le) {
      return this.length > le.length ? this.clone().iuor(le) : le.clone().iuor(this);
    }, ce.prototype.iuand = function(le) {
      var pe;
      this.length > le.length ? pe = le : pe = this;
      for (var ge = 0; ge < pe.length; ge++)
        this.words[ge] = this.words[ge] & le.words[ge];
      return this.length = pe.length, this.strip();
    }, ce.prototype.iand = function(le) {
      return fe((this.negative | le.negative) === 0), this.iuand(le);
    }, ce.prototype.and = function(le) {
      return this.length > le.length ? this.clone().iand(le) : le.clone().iand(this);
    }, ce.prototype.uand = function(le) {
      return this.length > le.length ? this.clone().iuand(le) : le.clone().iuand(this);
    }, ce.prototype.iuxor = function(le) {
      var pe, ge;
      this.length > le.length ? (pe = this, ge = le) : (pe = le, ge = this);
      for (var ye = 0; ye < ge.length; ye++)
        this.words[ye] = pe.words[ye] ^ ge.words[ye];
      if (this !== pe)
        for (; ye < pe.length; ye++)
          this.words[ye] = pe.words[ye];
      return this.length = pe.length, this.strip();
    }, ce.prototype.ixor = function(le) {
      return fe((this.negative | le.negative) === 0), this.iuxor(le);
    }, ce.prototype.xor = function(le) {
      return this.length > le.length ? this.clone().ixor(le) : le.clone().ixor(this);
    }, ce.prototype.uxor = function(le) {
      return this.length > le.length ? this.clone().iuxor(le) : le.clone().iuxor(this);
    }, ce.prototype.inotn = function(le) {
      fe(typeof le == "number" && le >= 0);
      var pe = Math.ceil(le / 26) | 0, ge = le % 26;
      this._expand(pe), ge > 0 && pe--;
      for (var ye = 0; ye < pe; ye++)
        this.words[ye] = ~this.words[ye] & 67108863;
      return ge > 0 && (this.words[ye] = ~this.words[ye] & 67108863 >> 26 - ge), this.strip();
    }, ce.prototype.notn = function(le) {
      return this.clone().inotn(le);
    }, ce.prototype.setn = function(le, pe) {
      fe(typeof le == "number" && le >= 0);
      var ge = le / 26 | 0, ye = le % 26;
      return this._expand(ge + 1), pe ? this.words[ge] = this.words[ge] | 1 << ye : this.words[ge] = this.words[ge] & ~(1 << ye), this.strip();
    }, ce.prototype.iadd = function(le) {
      var pe;
      if (this.negative !== 0 && le.negative === 0)
        return this.negative = 0, pe = this.isub(le), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && le.negative !== 0)
        return le.negative = 0, pe = this.isub(le), le.negative = 1, pe._normSign();
      var ge, ye;
      this.length > le.length ? (ge = this, ye = le) : (ge = le, ye = this);
      for (var xe = 0, _e = 0; _e < ye.length; _e++)
        pe = (ge.words[_e] | 0) + (ye.words[_e] | 0) + xe, this.words[_e] = pe & 67108863, xe = pe >>> 26;
      for (; xe !== 0 && _e < ge.length; _e++)
        pe = (ge.words[_e] | 0) + xe, this.words[_e] = pe & 67108863, xe = pe >>> 26;
      if (this.length = ge.length, xe !== 0)
        this.words[this.length] = xe, this.length++;
      else if (ge !== this)
        for (; _e < ge.length; _e++)
          this.words[_e] = ge.words[_e];
      return this;
    }, ce.prototype.add = function(le) {
      var pe;
      return le.negative !== 0 && this.negative === 0 ? (le.negative = 0, pe = this.sub(le), le.negative ^= 1, pe) : le.negative === 0 && this.negative !== 0 ? (this.negative = 0, pe = le.sub(this), this.negative = 1, pe) : this.length > le.length ? this.clone().iadd(le) : le.clone().iadd(this);
    }, ce.prototype.isub = function(le) {
      if (le.negative !== 0) {
        le.negative = 0;
        var pe = this.iadd(le);
        return le.negative = 1, pe._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(le), this.negative = 1, this._normSign();
      var ge = this.cmp(le);
      if (ge === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var ye, xe;
      ge > 0 ? (ye = this, xe = le) : (ye = le, xe = this);
      for (var _e = 0, Ae = 0; Ae < xe.length; Ae++)
        pe = (ye.words[Ae] | 0) - (xe.words[Ae] | 0) + _e, _e = pe >> 26, this.words[Ae] = pe & 67108863;
      for (; _e !== 0 && Ae < ye.length; Ae++)
        pe = (ye.words[Ae] | 0) + _e, _e = pe >> 26, this.words[Ae] = pe & 67108863;
      if (_e === 0 && Ae < ye.length && ye !== this)
        for (; Ae < ye.length; Ae++)
          this.words[Ae] = ye.words[Ae];
      return this.length = Math.max(this.length, Ae), ye !== this && (this.negative = 1), this.strip();
    }, ce.prototype.sub = function(le) {
      return this.clone().isub(le);
    };
    function Pe($e, le, pe) {
      pe.negative = le.negative ^ $e.negative;
      var ge = $e.length + le.length | 0;
      pe.length = ge, ge = ge - 1 | 0;
      var ye = $e.words[0] | 0, xe = le.words[0] | 0, _e = ye * xe, Ae = _e & 67108863, ve = _e / 67108864 | 0;
      pe.words[0] = Ae;
      for (var he = 1; he < ge; he++) {
        for (var be = ve >>> 26, Me = ve & 67108863, Re = Math.min(he, le.length - 1), Oe = Math.max(0, he - $e.length + 1); Oe <= Re; Oe++) {
          var Te = he - Oe | 0;
          ye = $e.words[Te] | 0, xe = le.words[Oe] | 0, _e = ye * xe + Me, be += _e / 67108864 | 0, Me = _e & 67108863;
        }
        pe.words[he] = Me | 0, ve = be | 0;
      }
      return ve !== 0 ? pe.words[he] = ve | 0 : pe.length--, pe.strip();
    }
    var Ne = function(le, pe, ge) {
      var ye = le.words, xe = pe.words, _e = ge.words, Ae = 0, ve, he, be, Me = ye[0] | 0, Re = Me & 8191, Oe = Me >>> 13, Te = ye[1] | 0, Fe = Te & 8191, je = Te >>> 13, ct = ye[2] | 0, nt = ct & 8191, dt = ct >>> 13, it = ye[3] | 0, Je = it & 8191, gt = it >>> 13, Ht = ye[4] | 0, $t = Ht & 8191, Lt = Ht >>> 13, Tr = ye[5] | 0, Zt = Tr & 8191, wt = Tr >>> 13, Hr = ye[6] | 0, tr = Hr & 8191, cr = Hr >>> 13, qr = ye[7] | 0, Wt = qr & 8191, ar = qr >>> 13, Dr = ye[8] | 0, Jt = Dr & 8191, ir = Dr >>> 13, Gr = ye[9] | 0, We = Gr & 8191, Le = Gr >>> 13, Ke = xe[0] | 0, rt = Ke & 8191, lt = Ke >>> 13, It = xe[1] | 0, yt = It & 8191, jt = It >>> 13, Lr = xe[2] | 0, zt = Lr & 8191, rr = Lr >>> 13, Cr = xe[3] | 0, fr = Cr & 8191, pr = Cr >>> 13, jr = xe[4] | 0, nr = jr & 8191, ur = jr >>> 13, Wr = xe[5] | 0, or = Wr & 8191, lr = Wr >>> 13, Zr = xe[6] | 0, Xt = Zr & 8191, dr = Zr >>> 13, Ve = xe[7] | 0, Ze = Ve & 8191, Xe = Ve >>> 13, Ue = xe[8] | 0, Qe = Ue & 8191, pt = Ue >>> 13, Ct = xe[9] | 0, bt = Ct & 8191, Tt = Ct >>> 13;
      ge.negative = le.negative ^ pe.negative, ge.length = 19, ve = Math.imul(Re, rt), he = Math.imul(Re, lt), he = he + Math.imul(Oe, rt) | 0, be = Math.imul(Oe, lt);
      var br = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (br >>> 26) | 0, br &= 67108863, ve = Math.imul(Fe, rt), he = Math.imul(Fe, lt), he = he + Math.imul(je, rt) | 0, be = Math.imul(je, lt), ve = ve + Math.imul(Re, yt) | 0, he = he + Math.imul(Re, jt) | 0, he = he + Math.imul(Oe, yt) | 0, be = be + Math.imul(Oe, jt) | 0;
      var gr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (gr >>> 26) | 0, gr &= 67108863, ve = Math.imul(nt, rt), he = Math.imul(nt, lt), he = he + Math.imul(dt, rt) | 0, be = Math.imul(dt, lt), ve = ve + Math.imul(Fe, yt) | 0, he = he + Math.imul(Fe, jt) | 0, he = he + Math.imul(je, yt) | 0, be = be + Math.imul(je, jt) | 0, ve = ve + Math.imul(Re, zt) | 0, he = he + Math.imul(Re, rr) | 0, he = he + Math.imul(Oe, zt) | 0, be = be + Math.imul(Oe, rr) | 0;
      var Fr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, ve = Math.imul(Je, rt), he = Math.imul(Je, lt), he = he + Math.imul(gt, rt) | 0, be = Math.imul(gt, lt), ve = ve + Math.imul(nt, yt) | 0, he = he + Math.imul(nt, jt) | 0, he = he + Math.imul(dt, yt) | 0, be = be + Math.imul(dt, jt) | 0, ve = ve + Math.imul(Fe, zt) | 0, he = he + Math.imul(Fe, rr) | 0, he = he + Math.imul(je, zt) | 0, be = be + Math.imul(je, rr) | 0, ve = ve + Math.imul(Re, fr) | 0, he = he + Math.imul(Re, pr) | 0, he = he + Math.imul(Oe, fr) | 0, be = be + Math.imul(Oe, pr) | 0;
      var wr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (wr >>> 26) | 0, wr &= 67108863, ve = Math.imul($t, rt), he = Math.imul($t, lt), he = he + Math.imul(Lt, rt) | 0, be = Math.imul(Lt, lt), ve = ve + Math.imul(Je, yt) | 0, he = he + Math.imul(Je, jt) | 0, he = he + Math.imul(gt, yt) | 0, be = be + Math.imul(gt, jt) | 0, ve = ve + Math.imul(nt, zt) | 0, he = he + Math.imul(nt, rr) | 0, he = he + Math.imul(dt, zt) | 0, be = be + Math.imul(dt, rr) | 0, ve = ve + Math.imul(Fe, fr) | 0, he = he + Math.imul(Fe, pr) | 0, he = he + Math.imul(je, fr) | 0, be = be + Math.imul(je, pr) | 0, ve = ve + Math.imul(Re, nr) | 0, he = he + Math.imul(Re, ur) | 0, he = he + Math.imul(Oe, nr) | 0, be = be + Math.imul(Oe, ur) | 0;
      var Rr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Rr >>> 26) | 0, Rr &= 67108863, ve = Math.imul(Zt, rt), he = Math.imul(Zt, lt), he = he + Math.imul(wt, rt) | 0, be = Math.imul(wt, lt), ve = ve + Math.imul($t, yt) | 0, he = he + Math.imul($t, jt) | 0, he = he + Math.imul(Lt, yt) | 0, be = be + Math.imul(Lt, jt) | 0, ve = ve + Math.imul(Je, zt) | 0, he = he + Math.imul(Je, rr) | 0, he = he + Math.imul(gt, zt) | 0, be = be + Math.imul(gt, rr) | 0, ve = ve + Math.imul(nt, fr) | 0, he = he + Math.imul(nt, pr) | 0, he = he + Math.imul(dt, fr) | 0, be = be + Math.imul(dt, pr) | 0, ve = ve + Math.imul(Fe, nr) | 0, he = he + Math.imul(Fe, ur) | 0, he = he + Math.imul(je, nr) | 0, be = be + Math.imul(je, ur) | 0, ve = ve + Math.imul(Re, or) | 0, he = he + Math.imul(Re, lr) | 0, he = he + Math.imul(Oe, or) | 0, be = be + Math.imul(Oe, lr) | 0;
      var kr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (kr >>> 26) | 0, kr &= 67108863, ve = Math.imul(tr, rt), he = Math.imul(tr, lt), he = he + Math.imul(cr, rt) | 0, be = Math.imul(cr, lt), ve = ve + Math.imul(Zt, yt) | 0, he = he + Math.imul(Zt, jt) | 0, he = he + Math.imul(wt, yt) | 0, be = be + Math.imul(wt, jt) | 0, ve = ve + Math.imul($t, zt) | 0, he = he + Math.imul($t, rr) | 0, he = he + Math.imul(Lt, zt) | 0, be = be + Math.imul(Lt, rr) | 0, ve = ve + Math.imul(Je, fr) | 0, he = he + Math.imul(Je, pr) | 0, he = he + Math.imul(gt, fr) | 0, be = be + Math.imul(gt, pr) | 0, ve = ve + Math.imul(nt, nr) | 0, he = he + Math.imul(nt, ur) | 0, he = he + Math.imul(dt, nr) | 0, be = be + Math.imul(dt, ur) | 0, ve = ve + Math.imul(Fe, or) | 0, he = he + Math.imul(Fe, lr) | 0, he = he + Math.imul(je, or) | 0, be = be + Math.imul(je, lr) | 0, ve = ve + Math.imul(Re, Xt) | 0, he = he + Math.imul(Re, dr) | 0, he = he + Math.imul(Oe, Xt) | 0, be = be + Math.imul(Oe, dr) | 0;
      var Pr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, ve = Math.imul(Wt, rt), he = Math.imul(Wt, lt), he = he + Math.imul(ar, rt) | 0, be = Math.imul(ar, lt), ve = ve + Math.imul(tr, yt) | 0, he = he + Math.imul(tr, jt) | 0, he = he + Math.imul(cr, yt) | 0, be = be + Math.imul(cr, jt) | 0, ve = ve + Math.imul(Zt, zt) | 0, he = he + Math.imul(Zt, rr) | 0, he = he + Math.imul(wt, zt) | 0, be = be + Math.imul(wt, rr) | 0, ve = ve + Math.imul($t, fr) | 0, he = he + Math.imul($t, pr) | 0, he = he + Math.imul(Lt, fr) | 0, be = be + Math.imul(Lt, pr) | 0, ve = ve + Math.imul(Je, nr) | 0, he = he + Math.imul(Je, ur) | 0, he = he + Math.imul(gt, nr) | 0, be = be + Math.imul(gt, ur) | 0, ve = ve + Math.imul(nt, or) | 0, he = he + Math.imul(nt, lr) | 0, he = he + Math.imul(dt, or) | 0, be = be + Math.imul(dt, lr) | 0, ve = ve + Math.imul(Fe, Xt) | 0, he = he + Math.imul(Fe, dr) | 0, he = he + Math.imul(je, Xt) | 0, be = be + Math.imul(je, dr) | 0, ve = ve + Math.imul(Re, Ze) | 0, he = he + Math.imul(Re, Xe) | 0, he = he + Math.imul(Oe, Ze) | 0, be = be + Math.imul(Oe, Xe) | 0;
      var Ur = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, ve = Math.imul(Jt, rt), he = Math.imul(Jt, lt), he = he + Math.imul(ir, rt) | 0, be = Math.imul(ir, lt), ve = ve + Math.imul(Wt, yt) | 0, he = he + Math.imul(Wt, jt) | 0, he = he + Math.imul(ar, yt) | 0, be = be + Math.imul(ar, jt) | 0, ve = ve + Math.imul(tr, zt) | 0, he = he + Math.imul(tr, rr) | 0, he = he + Math.imul(cr, zt) | 0, be = be + Math.imul(cr, rr) | 0, ve = ve + Math.imul(Zt, fr) | 0, he = he + Math.imul(Zt, pr) | 0, he = he + Math.imul(wt, fr) | 0, be = be + Math.imul(wt, pr) | 0, ve = ve + Math.imul($t, nr) | 0, he = he + Math.imul($t, ur) | 0, he = he + Math.imul(Lt, nr) | 0, be = be + Math.imul(Lt, ur) | 0, ve = ve + Math.imul(Je, or) | 0, he = he + Math.imul(Je, lr) | 0, he = he + Math.imul(gt, or) | 0, be = be + Math.imul(gt, lr) | 0, ve = ve + Math.imul(nt, Xt) | 0, he = he + Math.imul(nt, dr) | 0, he = he + Math.imul(dt, Xt) | 0, be = be + Math.imul(dt, dr) | 0, ve = ve + Math.imul(Fe, Ze) | 0, he = he + Math.imul(Fe, Xe) | 0, he = he + Math.imul(je, Ze) | 0, be = be + Math.imul(je, Xe) | 0, ve = ve + Math.imul(Re, Qe) | 0, he = he + Math.imul(Re, pt) | 0, he = he + Math.imul(Oe, Qe) | 0, be = be + Math.imul(Oe, pt) | 0;
      var Ir = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Ir >>> 26) | 0, Ir &= 67108863, ve = Math.imul(We, rt), he = Math.imul(We, lt), he = he + Math.imul(Le, rt) | 0, be = Math.imul(Le, lt), ve = ve + Math.imul(Jt, yt) | 0, he = he + Math.imul(Jt, jt) | 0, he = he + Math.imul(ir, yt) | 0, be = be + Math.imul(ir, jt) | 0, ve = ve + Math.imul(Wt, zt) | 0, he = he + Math.imul(Wt, rr) | 0, he = he + Math.imul(ar, zt) | 0, be = be + Math.imul(ar, rr) | 0, ve = ve + Math.imul(tr, fr) | 0, he = he + Math.imul(tr, pr) | 0, he = he + Math.imul(cr, fr) | 0, be = be + Math.imul(cr, pr) | 0, ve = ve + Math.imul(Zt, nr) | 0, he = he + Math.imul(Zt, ur) | 0, he = he + Math.imul(wt, nr) | 0, be = be + Math.imul(wt, ur) | 0, ve = ve + Math.imul($t, or) | 0, he = he + Math.imul($t, lr) | 0, he = he + Math.imul(Lt, or) | 0, be = be + Math.imul(Lt, lr) | 0, ve = ve + Math.imul(Je, Xt) | 0, he = he + Math.imul(Je, dr) | 0, he = he + Math.imul(gt, Xt) | 0, be = be + Math.imul(gt, dr) | 0, ve = ve + Math.imul(nt, Ze) | 0, he = he + Math.imul(nt, Xe) | 0, he = he + Math.imul(dt, Ze) | 0, be = be + Math.imul(dt, Xe) | 0, ve = ve + Math.imul(Fe, Qe) | 0, he = he + Math.imul(Fe, pt) | 0, he = he + Math.imul(je, Qe) | 0, be = be + Math.imul(je, pt) | 0, ve = ve + Math.imul(Re, bt) | 0, he = he + Math.imul(Re, Tt) | 0, he = he + Math.imul(Oe, bt) | 0, be = be + Math.imul(Oe, Tt) | 0;
      var Or = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Or >>> 26) | 0, Or &= 67108863, ve = Math.imul(We, yt), he = Math.imul(We, jt), he = he + Math.imul(Le, yt) | 0, be = Math.imul(Le, jt), ve = ve + Math.imul(Jt, zt) | 0, he = he + Math.imul(Jt, rr) | 0, he = he + Math.imul(ir, zt) | 0, be = be + Math.imul(ir, rr) | 0, ve = ve + Math.imul(Wt, fr) | 0, he = he + Math.imul(Wt, pr) | 0, he = he + Math.imul(ar, fr) | 0, be = be + Math.imul(ar, pr) | 0, ve = ve + Math.imul(tr, nr) | 0, he = he + Math.imul(tr, ur) | 0, he = he + Math.imul(cr, nr) | 0, be = be + Math.imul(cr, ur) | 0, ve = ve + Math.imul(Zt, or) | 0, he = he + Math.imul(Zt, lr) | 0, he = he + Math.imul(wt, or) | 0, be = be + Math.imul(wt, lr) | 0, ve = ve + Math.imul($t, Xt) | 0, he = he + Math.imul($t, dr) | 0, he = he + Math.imul(Lt, Xt) | 0, be = be + Math.imul(Lt, dr) | 0, ve = ve + Math.imul(Je, Ze) | 0, he = he + Math.imul(Je, Xe) | 0, he = he + Math.imul(gt, Ze) | 0, be = be + Math.imul(gt, Xe) | 0, ve = ve + Math.imul(nt, Qe) | 0, he = he + Math.imul(nt, pt) | 0, he = he + Math.imul(dt, Qe) | 0, be = be + Math.imul(dt, pt) | 0, ve = ve + Math.imul(Fe, bt) | 0, he = he + Math.imul(Fe, Tt) | 0, he = he + Math.imul(je, bt) | 0, be = be + Math.imul(je, Tt) | 0;
      var Nr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Nr >>> 26) | 0, Nr &= 67108863, ve = Math.imul(We, zt), he = Math.imul(We, rr), he = he + Math.imul(Le, zt) | 0, be = Math.imul(Le, rr), ve = ve + Math.imul(Jt, fr) | 0, he = he + Math.imul(Jt, pr) | 0, he = he + Math.imul(ir, fr) | 0, be = be + Math.imul(ir, pr) | 0, ve = ve + Math.imul(Wt, nr) | 0, he = he + Math.imul(Wt, ur) | 0, he = he + Math.imul(ar, nr) | 0, be = be + Math.imul(ar, ur) | 0, ve = ve + Math.imul(tr, or) | 0, he = he + Math.imul(tr, lr) | 0, he = he + Math.imul(cr, or) | 0, be = be + Math.imul(cr, lr) | 0, ve = ve + Math.imul(Zt, Xt) | 0, he = he + Math.imul(Zt, dr) | 0, he = he + Math.imul(wt, Xt) | 0, be = be + Math.imul(wt, dr) | 0, ve = ve + Math.imul($t, Ze) | 0, he = he + Math.imul($t, Xe) | 0, he = he + Math.imul(Lt, Ze) | 0, be = be + Math.imul(Lt, Xe) | 0, ve = ve + Math.imul(Je, Qe) | 0, he = he + Math.imul(Je, pt) | 0, he = he + Math.imul(gt, Qe) | 0, be = be + Math.imul(gt, pt) | 0, ve = ve + Math.imul(nt, bt) | 0, he = he + Math.imul(nt, Tt) | 0, he = he + Math.imul(dt, bt) | 0, be = be + Math.imul(dt, Tt) | 0;
      var Er = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, ve = Math.imul(We, fr), he = Math.imul(We, pr), he = he + Math.imul(Le, fr) | 0, be = Math.imul(Le, pr), ve = ve + Math.imul(Jt, nr) | 0, he = he + Math.imul(Jt, ur) | 0, he = he + Math.imul(ir, nr) | 0, be = be + Math.imul(ir, ur) | 0, ve = ve + Math.imul(Wt, or) | 0, he = he + Math.imul(Wt, lr) | 0, he = he + Math.imul(ar, or) | 0, be = be + Math.imul(ar, lr) | 0, ve = ve + Math.imul(tr, Xt) | 0, he = he + Math.imul(tr, dr) | 0, he = he + Math.imul(cr, Xt) | 0, be = be + Math.imul(cr, dr) | 0, ve = ve + Math.imul(Zt, Ze) | 0, he = he + Math.imul(Zt, Xe) | 0, he = he + Math.imul(wt, Ze) | 0, be = be + Math.imul(wt, Xe) | 0, ve = ve + Math.imul($t, Qe) | 0, he = he + Math.imul($t, pt) | 0, he = he + Math.imul(Lt, Qe) | 0, be = be + Math.imul(Lt, pt) | 0, ve = ve + Math.imul(Je, bt) | 0, he = he + Math.imul(Je, Tt) | 0, he = he + Math.imul(gt, bt) | 0, be = be + Math.imul(gt, Tt) | 0;
      var Br = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Br >>> 26) | 0, Br &= 67108863, ve = Math.imul(We, nr), he = Math.imul(We, ur), he = he + Math.imul(Le, nr) | 0, be = Math.imul(Le, ur), ve = ve + Math.imul(Jt, or) | 0, he = he + Math.imul(Jt, lr) | 0, he = he + Math.imul(ir, or) | 0, be = be + Math.imul(ir, lr) | 0, ve = ve + Math.imul(Wt, Xt) | 0, he = he + Math.imul(Wt, dr) | 0, he = he + Math.imul(ar, Xt) | 0, be = be + Math.imul(ar, dr) | 0, ve = ve + Math.imul(tr, Ze) | 0, he = he + Math.imul(tr, Xe) | 0, he = he + Math.imul(cr, Ze) | 0, be = be + Math.imul(cr, Xe) | 0, ve = ve + Math.imul(Zt, Qe) | 0, he = he + Math.imul(Zt, pt) | 0, he = he + Math.imul(wt, Qe) | 0, be = be + Math.imul(wt, pt) | 0, ve = ve + Math.imul($t, bt) | 0, he = he + Math.imul($t, Tt) | 0, he = he + Math.imul(Lt, bt) | 0, be = be + Math.imul(Lt, Tt) | 0;
      var _r = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (_r >>> 26) | 0, _r &= 67108863, ve = Math.imul(We, or), he = Math.imul(We, lr), he = he + Math.imul(Le, or) | 0, be = Math.imul(Le, lr), ve = ve + Math.imul(Jt, Xt) | 0, he = he + Math.imul(Jt, dr) | 0, he = he + Math.imul(ir, Xt) | 0, be = be + Math.imul(ir, dr) | 0, ve = ve + Math.imul(Wt, Ze) | 0, he = he + Math.imul(Wt, Xe) | 0, he = he + Math.imul(ar, Ze) | 0, be = be + Math.imul(ar, Xe) | 0, ve = ve + Math.imul(tr, Qe) | 0, he = he + Math.imul(tr, pt) | 0, he = he + Math.imul(cr, Qe) | 0, be = be + Math.imul(cr, pt) | 0, ve = ve + Math.imul(Zt, bt) | 0, he = he + Math.imul(Zt, Tt) | 0, he = he + Math.imul(wt, bt) | 0, be = be + Math.imul(wt, Tt) | 0;
      var Sr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Sr >>> 26) | 0, Sr &= 67108863, ve = Math.imul(We, Xt), he = Math.imul(We, dr), he = he + Math.imul(Le, Xt) | 0, be = Math.imul(Le, dr), ve = ve + Math.imul(Jt, Ze) | 0, he = he + Math.imul(Jt, Xe) | 0, he = he + Math.imul(ir, Ze) | 0, be = be + Math.imul(ir, Xe) | 0, ve = ve + Math.imul(Wt, Qe) | 0, he = he + Math.imul(Wt, pt) | 0, he = he + Math.imul(ar, Qe) | 0, be = be + Math.imul(ar, pt) | 0, ve = ve + Math.imul(tr, bt) | 0, he = he + Math.imul(tr, Tt) | 0, he = he + Math.imul(cr, bt) | 0, be = be + Math.imul(cr, Tt) | 0;
      var Mr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Mr >>> 26) | 0, Mr &= 67108863, ve = Math.imul(We, Ze), he = Math.imul(We, Xe), he = he + Math.imul(Le, Ze) | 0, be = Math.imul(Le, Xe), ve = ve + Math.imul(Jt, Qe) | 0, he = he + Math.imul(Jt, pt) | 0, he = he + Math.imul(ir, Qe) | 0, be = be + Math.imul(ir, pt) | 0, ve = ve + Math.imul(Wt, bt) | 0, he = he + Math.imul(Wt, Tt) | 0, he = he + Math.imul(ar, bt) | 0, be = be + Math.imul(ar, Tt) | 0;
      var $r = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + ($r >>> 26) | 0, $r &= 67108863, ve = Math.imul(We, Qe), he = Math.imul(We, pt), he = he + Math.imul(Le, Qe) | 0, be = Math.imul(Le, pt), ve = ve + Math.imul(Jt, bt) | 0, he = he + Math.imul(Jt, Tt) | 0, he = he + Math.imul(ir, bt) | 0, be = be + Math.imul(ir, Tt) | 0;
      var Yt = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Yt >>> 26) | 0, Yt &= 67108863, ve = Math.imul(We, bt), he = Math.imul(We, Tt), he = he + Math.imul(Le, bt) | 0, be = Math.imul(Le, Tt);
      var er = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      return Ae = (be + (he >>> 13) | 0) + (er >>> 26) | 0, er &= 67108863, _e[0] = br, _e[1] = gr, _e[2] = Fr, _e[3] = wr, _e[4] = Rr, _e[5] = kr, _e[6] = Pr, _e[7] = Ur, _e[8] = Ir, _e[9] = Or, _e[10] = Nr, _e[11] = Er, _e[12] = Br, _e[13] = _r, _e[14] = Sr, _e[15] = Mr, _e[16] = $r, _e[17] = Yt, _e[18] = er, Ae !== 0 && (_e[19] = Ae, ge.length++), ge;
    };
    Math.imul || (Ne = Pe);
    function ke($e, le, pe) {
      pe.negative = le.negative ^ $e.negative, pe.length = $e.length + le.length;
      for (var ge = 0, ye = 0, xe = 0; xe < pe.length - 1; xe++) {
        var _e = ye;
        ye = 0;
        for (var Ae = ge & 67108863, ve = Math.min(xe, le.length - 1), he = Math.max(0, xe - $e.length + 1); he <= ve; he++) {
          var be = xe - he, Me = $e.words[be] | 0, Re = le.words[he] | 0, Oe = Me * Re, Te = Oe & 67108863;
          _e = _e + (Oe / 67108864 | 0) | 0, Te = Te + Ae | 0, Ae = Te & 67108863, _e = _e + (Te >>> 26) | 0, ye += _e >>> 26, _e &= 67108863;
        }
        pe.words[xe] = Ae, ge = _e, _e = ye;
      }
      return ge !== 0 ? pe.words[xe] = ge : pe.length--, pe.strip();
    }
    function He($e, le, pe) {
      var ge = new De();
      return ge.mulp($e, le, pe);
    }
    ce.prototype.mulTo = function(le, pe) {
      var ge, ye = this.length + le.length;
      return this.length === 10 && le.length === 10 ? ge = Ne(this, le, pe) : ye < 63 ? ge = Pe(this, le, pe) : ye < 1024 ? ge = ke(this, le, pe) : ge = He(this, le, pe), ge;
    };
    function De($e, le) {
      this.x = $e, this.y = le;
    }
    De.prototype.makeRBT = function(le) {
      for (var pe = new Array(le), ge = ce.prototype._countBits(le) - 1, ye = 0; ye < le; ye++)
        pe[ye] = this.revBin(ye, ge, le);
      return pe;
    }, De.prototype.revBin = function(le, pe, ge) {
      if (le === 0 || le === ge - 1)
        return le;
      for (var ye = 0, xe = 0; xe < pe; xe++)
        ye |= (le & 1) << pe - xe - 1, le >>= 1;
      return ye;
    }, De.prototype.permute = function(le, pe, ge, ye, xe, _e) {
      for (var Ae = 0; Ae < _e; Ae++)
        ye[Ae] = pe[le[Ae]], xe[Ae] = ge[le[Ae]];
    }, De.prototype.transform = function(le, pe, ge, ye, xe, _e) {
      this.permute(_e, le, pe, ge, ye, xe);
      for (var Ae = 1; Ae < xe; Ae <<= 1)
        for (var ve = Ae << 1, he = Math.cos(2 * Math.PI / ve), be = Math.sin(2 * Math.PI / ve), Me = 0; Me < xe; Me += ve)
          for (var Re = he, Oe = be, Te = 0; Te < Ae; Te++) {
            var Fe = ge[Me + Te], je = ye[Me + Te], ct = ge[Me + Te + Ae], nt = ye[Me + Te + Ae], dt = Re * ct - Oe * nt;
            nt = Re * nt + Oe * ct, ct = dt, ge[Me + Te] = Fe + ct, ye[Me + Te] = je + nt, ge[Me + Te + Ae] = Fe - ct, ye[Me + Te + Ae] = je - nt, Te !== ve && (dt = he * Re - be * Oe, Oe = he * Oe + be * Re, Re = dt);
          }
    }, De.prototype.guessLen13b = function(le, pe) {
      var ge = Math.max(pe, le) | 1, ye = ge & 1, xe = 0;
      for (ge = ge / 2 | 0; ge; ge = ge >>> 1)
        xe++;
      return 1 << xe + 1 + ye;
    }, De.prototype.conjugate = function(le, pe, ge) {
      if (!(ge <= 1))
        for (var ye = 0; ye < ge / 2; ye++) {
          var xe = le[ye];
          le[ye] = le[ge - ye - 1], le[ge - ye - 1] = xe, xe = pe[ye], pe[ye] = -pe[ge - ye - 1], pe[ge - ye - 1] = -xe;
        }
    }, De.prototype.normalize13b = function(le, pe) {
      for (var ge = 0, ye = 0; ye < pe / 2; ye++) {
        var xe = Math.round(le[2 * ye + 1] / pe) * 8192 + Math.round(le[2 * ye] / pe) + ge;
        le[ye] = xe & 67108863, xe < 67108864 ? ge = 0 : ge = xe / 67108864 | 0;
      }
      return le;
    }, De.prototype.convert13b = function(le, pe, ge, ye) {
      for (var xe = 0, _e = 0; _e < pe; _e++)
        xe = xe + (le[_e] | 0), ge[2 * _e] = xe & 8191, xe = xe >>> 13, ge[2 * _e + 1] = xe & 8191, xe = xe >>> 13;
      for (_e = 2 * pe; _e < ye; ++_e)
        ge[_e] = 0;
      fe(xe === 0), fe((xe & -8192) === 0);
    }, De.prototype.stub = function(le) {
      for (var pe = new Array(le), ge = 0; ge < le; ge++)
        pe[ge] = 0;
      return pe;
    }, De.prototype.mulp = function(le, pe, ge) {
      var ye = 2 * this.guessLen13b(le.length, pe.length), xe = this.makeRBT(ye), _e = this.stub(ye), Ae = new Array(ye), ve = new Array(ye), he = new Array(ye), be = new Array(ye), Me = new Array(ye), Re = new Array(ye), Oe = ge.words;
      Oe.length = ye, this.convert13b(le.words, le.length, Ae, ye), this.convert13b(pe.words, pe.length, be, ye), this.transform(Ae, _e, ve, he, ye, xe), this.transform(be, _e, Me, Re, ye, xe);
      for (var Te = 0; Te < ye; Te++) {
        var Fe = ve[Te] * Me[Te] - he[Te] * Re[Te];
        he[Te] = ve[Te] * Re[Te] + he[Te] * Me[Te], ve[Te] = Fe;
      }
      return this.conjugate(ve, he, ye), this.transform(ve, he, Oe, _e, ye, xe), this.conjugate(Oe, _e, ye), this.normalize13b(Oe, ye), ge.negative = le.negative ^ pe.negative, ge.length = le.length + pe.length, ge.strip();
    }, ce.prototype.mul = function(le) {
      var pe = new ce(null);
      return pe.words = new Array(this.length + le.length), this.mulTo(le, pe);
    }, ce.prototype.mulf = function(le) {
      var pe = new ce(null);
      return pe.words = new Array(this.length + le.length), He(this, le, pe);
    }, ce.prototype.imul = function(le) {
      return this.clone().mulTo(le, this);
    }, ce.prototype.imuln = function(le) {
      fe(typeof le == "number"), fe(le < 67108864);
      for (var pe = 0, ge = 0; ge < this.length; ge++) {
        var ye = (this.words[ge] | 0) * le, xe = (ye & 67108863) + (pe & 67108863);
        pe >>= 26, pe += ye / 67108864 | 0, pe += xe >>> 26, this.words[ge] = xe & 67108863;
      }
      return pe !== 0 && (this.words[ge] = pe, this.length++), this;
    }, ce.prototype.muln = function(le) {
      return this.clone().imuln(le);
    }, ce.prototype.sqr = function() {
      return this.mul(this);
    }, ce.prototype.isqr = function() {
      return this.imul(this.clone());
    }, ce.prototype.pow = function(le) {
      var pe = Ie(le);
      if (pe.length === 0)
        return new ce(1);
      for (var ge = this, ye = 0; ye < pe.length && pe[ye] === 0; ye++, ge = ge.sqr())
        ;
      if (++ye < pe.length)
        for (var xe = ge.sqr(); ye < pe.length; ye++, xe = xe.sqr())
          pe[ye] !== 0 && (ge = ge.mul(xe));
      return ge;
    }, ce.prototype.iushln = function(le) {
      fe(typeof le == "number" && le >= 0);
      var pe = le % 26, ge = (le - pe) / 26, ye = 67108863 >>> 26 - pe << 26 - pe, xe;
      if (pe !== 0) {
        var _e = 0;
        for (xe = 0; xe < this.length; xe++) {
          var Ae = this.words[xe] & ye, ve = (this.words[xe] | 0) - Ae << pe;
          this.words[xe] = ve | _e, _e = Ae >>> 26 - pe;
        }
        _e && (this.words[xe] = _e, this.length++);
      }
      if (ge !== 0) {
        for (xe = this.length - 1; xe >= 0; xe--)
          this.words[xe + ge] = this.words[xe];
        for (xe = 0; xe < ge; xe++)
          this.words[xe] = 0;
        this.length += ge;
      }
      return this.strip();
    }, ce.prototype.ishln = function(le) {
      return fe(this.negative === 0), this.iushln(le);
    }, ce.prototype.iushrn = function(le, pe, ge) {
      fe(typeof le == "number" && le >= 0);
      var ye;
      pe ? ye = (pe - pe % 26) / 26 : ye = 0;
      var xe = le % 26, _e = Math.min((le - xe) / 26, this.length), Ae = 67108863 ^ 67108863 >>> xe << xe, ve = ge;
      if (ye -= _e, ye = Math.max(0, ye), ve) {
        for (var he = 0; he < _e; he++)
          ve.words[he] = this.words[he];
        ve.length = _e;
      }
      if (_e !== 0)
        if (this.length > _e)
          for (this.length -= _e, he = 0; he < this.length; he++)
            this.words[he] = this.words[he + _e];
        else
          this.words[0] = 0, this.length = 1;
      var be = 0;
      for (he = this.length - 1; he >= 0 && (be !== 0 || he >= ye); he--) {
        var Me = this.words[he] | 0;
        this.words[he] = be << 26 - xe | Me >>> xe, be = Me & Ae;
      }
      return ve && be !== 0 && (ve.words[ve.length++] = be), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, ce.prototype.ishrn = function(le, pe, ge) {
      return fe(this.negative === 0), this.iushrn(le, pe, ge);
    }, ce.prototype.shln = function(le) {
      return this.clone().ishln(le);
    }, ce.prototype.ushln = function(le) {
      return this.clone().iushln(le);
    }, ce.prototype.shrn = function(le) {
      return this.clone().ishrn(le);
    }, ce.prototype.ushrn = function(le) {
      return this.clone().iushrn(le);
    }, ce.prototype.testn = function(le) {
      fe(typeof le == "number" && le >= 0);
      var pe = le % 26, ge = (le - pe) / 26, ye = 1 << pe;
      if (this.length <= ge)
        return !1;
      var xe = this.words[ge];
      return !!(xe & ye);
    }, ce.prototype.imaskn = function(le) {
      fe(typeof le == "number" && le >= 0);
      var pe = le % 26, ge = (le - pe) / 26;
      if (fe(this.negative === 0, "imaskn works only with positive numbers"), this.length <= ge)
        return this;
      if (pe !== 0 && ge++, this.length = Math.min(ge, this.length), pe !== 0) {
        var ye = 67108863 ^ 67108863 >>> pe << pe;
        this.words[this.length - 1] &= ye;
      }
      return this.strip();
    }, ce.prototype.maskn = function(le) {
      return this.clone().imaskn(le);
    }, ce.prototype.iaddn = function(le) {
      return fe(typeof le == "number"), fe(le < 67108864), le < 0 ? this.isubn(-le) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < le ? (this.words[0] = le - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(le), this.negative = 1, this) : this._iaddn(le);
    }, ce.prototype._iaddn = function(le) {
      this.words[0] += le;
      for (var pe = 0; pe < this.length && this.words[pe] >= 67108864; pe++)
        this.words[pe] -= 67108864, pe === this.length - 1 ? this.words[pe + 1] = 1 : this.words[pe + 1]++;
      return this.length = Math.max(this.length, pe + 1), this;
    }, ce.prototype.isubn = function(le) {
      if (fe(typeof le == "number"), fe(le < 67108864), le < 0)
        return this.iaddn(-le);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(le), this.negative = 1, this;
      if (this.words[0] -= le, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var pe = 0; pe < this.length && this.words[pe] < 0; pe++)
          this.words[pe] += 67108864, this.words[pe + 1] -= 1;
      return this.strip();
    }, ce.prototype.addn = function(le) {
      return this.clone().iaddn(le);
    }, ce.prototype.subn = function(le) {
      return this.clone().isubn(le);
    }, ce.prototype.iabs = function() {
      return this.negative = 0, this;
    }, ce.prototype.abs = function() {
      return this.clone().iabs();
    }, ce.prototype._ishlnsubmul = function(le, pe, ge) {
      var ye = le.length + ge, xe;
      this._expand(ye);
      var _e, Ae = 0;
      for (xe = 0; xe < le.length; xe++) {
        _e = (this.words[xe + ge] | 0) + Ae;
        var ve = (le.words[xe] | 0) * pe;
        _e -= ve & 67108863, Ae = (_e >> 26) - (ve / 67108864 | 0), this.words[xe + ge] = _e & 67108863;
      }
      for (; xe < this.length - ge; xe++)
        _e = (this.words[xe + ge] | 0) + Ae, Ae = _e >> 26, this.words[xe + ge] = _e & 67108863;
      if (Ae === 0)
        return this.strip();
      for (fe(Ae === -1), Ae = 0, xe = 0; xe < this.length; xe++)
        _e = -(this.words[xe] | 0) + Ae, Ae = _e >> 26, this.words[xe] = _e & 67108863;
      return this.negative = 1, this.strip();
    }, ce.prototype._wordDiv = function(le, pe) {
      var ge = this.length - le.length, ye = this.clone(), xe = le, _e = xe.words[xe.length - 1] | 0, Ae = this._countBits(_e);
      ge = 26 - Ae, ge !== 0 && (xe = xe.ushln(ge), ye.iushln(ge), _e = xe.words[xe.length - 1] | 0);
      var ve = ye.length - xe.length, he;
      if (pe !== "mod") {
        he = new ce(null), he.length = ve + 1, he.words = new Array(he.length);
        for (var be = 0; be < he.length; be++)
          he.words[be] = 0;
      }
      var Me = ye.clone()._ishlnsubmul(xe, 1, ve);
      Me.negative === 0 && (ye = Me, he && (he.words[ve] = 1));
      for (var Re = ve - 1; Re >= 0; Re--) {
        var Oe = (ye.words[xe.length + Re] | 0) * 67108864 + (ye.words[xe.length + Re - 1] | 0);
        for (Oe = Math.min(Oe / _e | 0, 67108863), ye._ishlnsubmul(xe, Oe, Re); ye.negative !== 0; )
          Oe--, ye.negative = 0, ye._ishlnsubmul(xe, 1, Re), ye.isZero() || (ye.negative ^= 1);
        he && (he.words[Re] = Oe);
      }
      return he && he.strip(), ye.strip(), pe !== "div" && ge !== 0 && ye.iushrn(ge), {
        div: he || null,
        mod: ye
      };
    }, ce.prototype.divmod = function(le, pe, ge) {
      if (fe(!le.isZero()), this.isZero())
        return {
          div: new ce(0),
          mod: new ce(0)
        };
      var ye, xe, _e;
      return this.negative !== 0 && le.negative === 0 ? (_e = this.neg().divmod(le, pe), pe !== "mod" && (ye = _e.div.neg()), pe !== "div" && (xe = _e.mod.neg(), ge && xe.negative !== 0 && xe.iadd(le)), {
        div: ye,
        mod: xe
      }) : this.negative === 0 && le.negative !== 0 ? (_e = this.divmod(le.neg(), pe), pe !== "mod" && (ye = _e.div.neg()), {
        div: ye,
        mod: _e.mod
      }) : this.negative & le.negative ? (_e = this.neg().divmod(le.neg(), pe), pe !== "div" && (xe = _e.mod.neg(), ge && xe.negative !== 0 && xe.isub(le)), {
        div: _e.div,
        mod: xe
      }) : le.length > this.length || this.cmp(le) < 0 ? {
        div: new ce(0),
        mod: this
      } : le.length === 1 ? pe === "div" ? {
        div: this.divn(le.words[0]),
        mod: null
      } : pe === "mod" ? {
        div: null,
        mod: new ce(this.modn(le.words[0]))
      } : {
        div: this.divn(le.words[0]),
        mod: new ce(this.modn(le.words[0]))
      } : this._wordDiv(le, pe);
    }, ce.prototype.div = function(le) {
      return this.divmod(le, "div", !1).div;
    }, ce.prototype.mod = function(le) {
      return this.divmod(le, "mod", !1).mod;
    }, ce.prototype.umod = function(le) {
      return this.divmod(le, "mod", !0).mod;
    }, ce.prototype.divRound = function(le) {
      var pe = this.divmod(le);
      if (pe.mod.isZero())
        return pe.div;
      var ge = pe.div.negative !== 0 ? pe.mod.isub(le) : pe.mod, ye = le.ushrn(1), xe = le.andln(1), _e = ge.cmp(ye);
      return _e < 0 || xe === 1 && _e === 0 ? pe.div : pe.div.negative !== 0 ? pe.div.isubn(1) : pe.div.iaddn(1);
    }, ce.prototype.modn = function(le) {
      fe(le <= 67108863);
      for (var pe = (1 << 26) % le, ge = 0, ye = this.length - 1; ye >= 0; ye--)
        ge = (pe * ge + (this.words[ye] | 0)) % le;
      return ge;
    }, ce.prototype.idivn = function(le) {
      fe(le <= 67108863);
      for (var pe = 0, ge = this.length - 1; ge >= 0; ge--) {
        var ye = (this.words[ge] | 0) + pe * 67108864;
        this.words[ge] = ye / le | 0, pe = ye % le;
      }
      return this.strip();
    }, ce.prototype.divn = function(le) {
      return this.clone().idivn(le);
    }, ce.prototype.egcd = function(le) {
      fe(le.negative === 0), fe(!le.isZero());
      var pe = this, ge = le.clone();
      pe.negative !== 0 ? pe = pe.umod(le) : pe = pe.clone();
      for (var ye = new ce(1), xe = new ce(0), _e = new ce(0), Ae = new ce(1), ve = 0; pe.isEven() && ge.isEven(); )
        pe.iushrn(1), ge.iushrn(1), ++ve;
      for (var he = ge.clone(), be = pe.clone(); !pe.isZero(); ) {
        for (var Me = 0, Re = 1; !(pe.words[0] & Re) && Me < 26; ++Me, Re <<= 1)
          ;
        if (Me > 0)
          for (pe.iushrn(Me); Me-- > 0; )
            (ye.isOdd() || xe.isOdd()) && (ye.iadd(he), xe.isub(be)), ye.iushrn(1), xe.iushrn(1);
        for (var Oe = 0, Te = 1; !(ge.words[0] & Te) && Oe < 26; ++Oe, Te <<= 1)
          ;
        if (Oe > 0)
          for (ge.iushrn(Oe); Oe-- > 0; )
            (_e.isOdd() || Ae.isOdd()) && (_e.iadd(he), Ae.isub(be)), _e.iushrn(1), Ae.iushrn(1);
        pe.cmp(ge) >= 0 ? (pe.isub(ge), ye.isub(_e), xe.isub(Ae)) : (ge.isub(pe), _e.isub(ye), Ae.isub(xe));
      }
      return {
        a: _e,
        b: Ae,
        gcd: ge.iushln(ve)
      };
    }, ce.prototype._invmp = function(le) {
      fe(le.negative === 0), fe(!le.isZero());
      var pe = this, ge = le.clone();
      pe.negative !== 0 ? pe = pe.umod(le) : pe = pe.clone();
      for (var ye = new ce(1), xe = new ce(0), _e = ge.clone(); pe.cmpn(1) > 0 && ge.cmpn(1) > 0; ) {
        for (var Ae = 0, ve = 1; !(pe.words[0] & ve) && Ae < 26; ++Ae, ve <<= 1)
          ;
        if (Ae > 0)
          for (pe.iushrn(Ae); Ae-- > 0; )
            ye.isOdd() && ye.iadd(_e), ye.iushrn(1);
        for (var he = 0, be = 1; !(ge.words[0] & be) && he < 26; ++he, be <<= 1)
          ;
        if (he > 0)
          for (ge.iushrn(he); he-- > 0; )
            xe.isOdd() && xe.iadd(_e), xe.iushrn(1);
        pe.cmp(ge) >= 0 ? (pe.isub(ge), ye.isub(xe)) : (ge.isub(pe), xe.isub(ye));
      }
      var Me;
      return pe.cmpn(1) === 0 ? Me = ye : Me = xe, Me.cmpn(0) < 0 && Me.iadd(le), Me;
    }, ce.prototype.gcd = function(le) {
      if (this.isZero())
        return le.abs();
      if (le.isZero())
        return this.abs();
      var pe = this.clone(), ge = le.clone();
      pe.negative = 0, ge.negative = 0;
      for (var ye = 0; pe.isEven() && ge.isEven(); ye++)
        pe.iushrn(1), ge.iushrn(1);
      do {
        for (; pe.isEven(); )
          pe.iushrn(1);
        for (; ge.isEven(); )
          ge.iushrn(1);
        var xe = pe.cmp(ge);
        if (xe < 0) {
          var _e = pe;
          pe = ge, ge = _e;
        } else if (xe === 0 || ge.cmpn(1) === 0)
          break;
        pe.isub(ge);
      } while (!0);
      return ge.iushln(ye);
    }, ce.prototype.invm = function(le) {
      return this.egcd(le).a.umod(le);
    }, ce.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, ce.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, ce.prototype.andln = function(le) {
      return this.words[0] & le;
    }, ce.prototype.bincn = function(le) {
      fe(typeof le == "number");
      var pe = le % 26, ge = (le - pe) / 26, ye = 1 << pe;
      if (this.length <= ge)
        return this._expand(ge + 1), this.words[ge] |= ye, this;
      for (var xe = ye, _e = ge; xe !== 0 && _e < this.length; _e++) {
        var Ae = this.words[_e] | 0;
        Ae += xe, xe = Ae >>> 26, Ae &= 67108863, this.words[_e] = Ae;
      }
      return xe !== 0 && (this.words[_e] = xe, this.length++), this;
    }, ce.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, ce.prototype.cmpn = function(le) {
      var pe = le < 0;
      if (this.negative !== 0 && !pe)
        return -1;
      if (this.negative === 0 && pe)
        return 1;
      this.strip();
      var ge;
      if (this.length > 1)
        ge = 1;
      else {
        pe && (le = -le), fe(le <= 67108863, "Number is too big");
        var ye = this.words[0] | 0;
        ge = ye === le ? 0 : ye < le ? -1 : 1;
      }
      return this.negative !== 0 ? -ge | 0 : ge;
    }, ce.prototype.cmp = function(le) {
      if (this.negative !== 0 && le.negative === 0)
        return -1;
      if (this.negative === 0 && le.negative !== 0)
        return 1;
      var pe = this.ucmp(le);
      return this.negative !== 0 ? -pe | 0 : pe;
    }, ce.prototype.ucmp = function(le) {
      if (this.length > le.length)
        return 1;
      if (this.length < le.length)
        return -1;
      for (var pe = 0, ge = this.length - 1; ge >= 0; ge--) {
        var ye = this.words[ge] | 0, xe = le.words[ge] | 0;
        if (ye !== xe) {
          ye < xe ? pe = -1 : ye > xe && (pe = 1);
          break;
        }
      }
      return pe;
    }, ce.prototype.gtn = function(le) {
      return this.cmpn(le) === 1;
    }, ce.prototype.gt = function(le) {
      return this.cmp(le) === 1;
    }, ce.prototype.gten = function(le) {
      return this.cmpn(le) >= 0;
    }, ce.prototype.gte = function(le) {
      return this.cmp(le) >= 0;
    }, ce.prototype.ltn = function(le) {
      return this.cmpn(le) === -1;
    }, ce.prototype.lt = function(le) {
      return this.cmp(le) === -1;
    }, ce.prototype.lten = function(le) {
      return this.cmpn(le) <= 0;
    }, ce.prototype.lte = function(le) {
      return this.cmp(le) <= 0;
    }, ce.prototype.eqn = function(le) {
      return this.cmpn(le) === 0;
    }, ce.prototype.eq = function(le) {
      return this.cmp(le) === 0;
    }, ce.red = function(le) {
      return new ze(le);
    }, ce.prototype.toRed = function(le) {
      return fe(!this.red, "Already a number in reduction context"), fe(this.negative === 0, "red works only with positives"), le.convertTo(this)._forceRed(le);
    }, ce.prototype.fromRed = function() {
      return fe(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, ce.prototype._forceRed = function(le) {
      return this.red = le, this;
    }, ce.prototype.forceRed = function(le) {
      return fe(!this.red, "Already a number in reduction context"), this._forceRed(le);
    }, ce.prototype.redAdd = function(le) {
      return fe(this.red, "redAdd works only with red numbers"), this.red.add(this, le);
    }, ce.prototype.redIAdd = function(le) {
      return fe(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, le);
    }, ce.prototype.redSub = function(le) {
      return fe(this.red, "redSub works only with red numbers"), this.red.sub(this, le);
    }, ce.prototype.redISub = function(le) {
      return fe(this.red, "redISub works only with red numbers"), this.red.isub(this, le);
    }, ce.prototype.redShl = function(le) {
      return fe(this.red, "redShl works only with red numbers"), this.red.shl(this, le);
    }, ce.prototype.redMul = function(le) {
      return fe(this.red, "redMul works only with red numbers"), this.red._verify2(this, le), this.red.mul(this, le);
    }, ce.prototype.redIMul = function(le) {
      return fe(this.red, "redMul works only with red numbers"), this.red._verify2(this, le), this.red.imul(this, le);
    }, ce.prototype.redSqr = function() {
      return fe(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, ce.prototype.redISqr = function() {
      return fe(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, ce.prototype.redSqrt = function() {
      return fe(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, ce.prototype.redInvm = function() {
      return fe(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, ce.prototype.redNeg = function() {
      return fe(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, ce.prototype.redPow = function(le) {
      return fe(this.red && !le.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, le);
    };
    var Ge = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Ye($e, le) {
      this.name = $e, this.p = new ce(le, 16), this.n = this.p.bitLength(), this.k = new ce(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Ye.prototype._tmp = function() {
      var le = new ce(null);
      return le.words = new Array(Math.ceil(this.n / 13)), le;
    }, Ye.prototype.ireduce = function(le) {
      var pe = le, ge;
      do
        this.split(pe, this.tmp), pe = this.imulK(pe), pe = pe.iadd(this.tmp), ge = pe.bitLength();
      while (ge > this.n);
      var ye = ge < this.n ? -1 : pe.ucmp(this.p);
      return ye === 0 ? (pe.words[0] = 0, pe.length = 1) : ye > 0 ? pe.isub(this.p) : pe.strip !== void 0 ? pe.strip() : pe._strip(), pe;
    }, Ye.prototype.split = function(le, pe) {
      le.iushrn(this.n, 0, pe);
    }, Ye.prototype.imulK = function(le) {
      return le.imul(this.k);
    };
    function st() {
      Ye.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    ue(st, Ye), st.prototype.split = function(le, pe) {
      for (var ge = 4194303, ye = Math.min(le.length, 9), xe = 0; xe < ye; xe++)
        pe.words[xe] = le.words[xe];
      if (pe.length = ye, le.length <= 9) {
        le.words[0] = 0, le.length = 1;
        return;
      }
      var _e = le.words[9];
      for (pe.words[pe.length++] = _e & ge, xe = 10; xe < le.length; xe++) {
        var Ae = le.words[xe] | 0;
        le.words[xe - 10] = (Ae & ge) << 4 | _e >>> 22, _e = Ae;
      }
      _e >>>= 22, le.words[xe - 10] = _e, _e === 0 && le.length > 10 ? le.length -= 10 : le.length -= 9;
    }, st.prototype.imulK = function(le) {
      le.words[le.length] = 0, le.words[le.length + 1] = 0, le.length += 2;
      for (var pe = 0, ge = 0; ge < le.length; ge++) {
        var ye = le.words[ge] | 0;
        pe += ye * 977, le.words[ge] = pe & 67108863, pe = ye * 64 + (pe / 67108864 | 0);
      }
      return le.words[le.length - 1] === 0 && (le.length--, le.words[le.length - 1] === 0 && le.length--), le;
    };
    function at() {
      Ye.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    ue(at, Ye);
    function mt() {
      Ye.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    ue(mt, Ye);
    function qe() {
      Ye.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    ue(qe, Ye), qe.prototype.imulK = function(le) {
      for (var pe = 0, ge = 0; ge < le.length; ge++) {
        var ye = (le.words[ge] | 0) * 19 + pe, xe = ye & 67108863;
        ye >>>= 26, le.words[ge] = xe, pe = ye;
      }
      return pe !== 0 && (le.words[le.length++] = pe), le;
    }, ce._prime = function(le) {
      if (Ge[le])
        return Ge[le];
      var pe;
      if (le === "k256")
        pe = new st();
      else if (le === "p224")
        pe = new at();
      else if (le === "p192")
        pe = new mt();
      else if (le === "p25519")
        pe = new qe();
      else
        throw new Error("Unknown prime " + le);
      return Ge[le] = pe, pe;
    };
    function ze($e) {
      if (typeof $e == "string") {
        var le = ce._prime($e);
        this.m = le.p, this.prime = le;
      } else
        fe($e.gtn(1), "modulus must be greater than 1"), this.m = $e, this.prime = null;
    }
    ze.prototype._verify1 = function(le) {
      fe(le.negative === 0, "red works only with positives"), fe(le.red, "red works only with red numbers");
    }, ze.prototype._verify2 = function(le, pe) {
      fe((le.negative | pe.negative) === 0, "red works only with positives"), fe(
        le.red && le.red === pe.red,
        "red works only with red numbers"
      );
    }, ze.prototype.imod = function(le) {
      return this.prime ? this.prime.ireduce(le)._forceRed(this) : le.umod(this.m)._forceRed(this);
    }, ze.prototype.neg = function(le) {
      return le.isZero() ? le.clone() : this.m.sub(le)._forceRed(this);
    }, ze.prototype.add = function(le, pe) {
      this._verify2(le, pe);
      var ge = le.add(pe);
      return ge.cmp(this.m) >= 0 && ge.isub(this.m), ge._forceRed(this);
    }, ze.prototype.iadd = function(le, pe) {
      this._verify2(le, pe);
      var ge = le.iadd(pe);
      return ge.cmp(this.m) >= 0 && ge.isub(this.m), ge;
    }, ze.prototype.sub = function(le, pe) {
      this._verify2(le, pe);
      var ge = le.sub(pe);
      return ge.cmpn(0) < 0 && ge.iadd(this.m), ge._forceRed(this);
    }, ze.prototype.isub = function(le, pe) {
      this._verify2(le, pe);
      var ge = le.isub(pe);
      return ge.cmpn(0) < 0 && ge.iadd(this.m), ge;
    }, ze.prototype.shl = function(le, pe) {
      return this._verify1(le), this.imod(le.ushln(pe));
    }, ze.prototype.imul = function(le, pe) {
      return this._verify2(le, pe), this.imod(le.imul(pe));
    }, ze.prototype.mul = function(le, pe) {
      return this._verify2(le, pe), this.imod(le.mul(pe));
    }, ze.prototype.isqr = function(le) {
      return this.imul(le, le.clone());
    }, ze.prototype.sqr = function(le) {
      return this.mul(le, le);
    }, ze.prototype.sqrt = function(le) {
      if (le.isZero())
        return le.clone();
      var pe = this.m.andln(3);
      if (fe(pe % 2 === 1), pe === 3) {
        var ge = this.m.add(new ce(1)).iushrn(2);
        return this.pow(le, ge);
      }
      for (var ye = this.m.subn(1), xe = 0; !ye.isZero() && ye.andln(1) === 0; )
        xe++, ye.iushrn(1);
      fe(!ye.isZero());
      var _e = new ce(1).toRed(this), Ae = _e.redNeg(), ve = this.m.subn(1).iushrn(1), he = this.m.bitLength();
      for (he = new ce(2 * he * he).toRed(this); this.pow(he, ve).cmp(Ae) !== 0; )
        he.redIAdd(Ae);
      for (var be = this.pow(he, ye), Me = this.pow(le, ye.addn(1).iushrn(1)), Re = this.pow(le, ye), Oe = xe; Re.cmp(_e) !== 0; ) {
        for (var Te = Re, Fe = 0; Te.cmp(_e) !== 0; Fe++)
          Te = Te.redSqr();
        fe(Fe < Oe);
        var je = this.pow(be, new ce(1).iushln(Oe - Fe - 1));
        Me = Me.redMul(je), be = je.redSqr(), Re = Re.redMul(be), Oe = Fe;
      }
      return Me;
    }, ze.prototype.invm = function(le) {
      var pe = le._invmp(this.m);
      return pe.negative !== 0 ? (pe.negative = 0, this.imod(pe).redNeg()) : this.imod(pe);
    }, ze.prototype.pow = function(le, pe) {
      if (pe.isZero())
        return new ce(1).toRed(this);
      if (pe.cmpn(1) === 0)
        return le.clone();
      var ge = 4, ye = new Array(1 << ge);
      ye[0] = new ce(1).toRed(this), ye[1] = le;
      for (var xe = 2; xe < ye.length; xe++)
        ye[xe] = this.mul(ye[xe - 1], le);
      var _e = ye[0], Ae = 0, ve = 0, he = pe.bitLength() % 26;
      for (he === 0 && (he = 26), xe = pe.length - 1; xe >= 0; xe--) {
        for (var be = pe.words[xe], Me = he - 1; Me >= 0; Me--) {
          var Re = be >> Me & 1;
          if (_e !== ye[0] && (_e = this.sqr(_e)), Re === 0 && Ae === 0) {
            ve = 0;
            continue;
          }
          Ae <<= 1, Ae |= Re, ve++, !(ve !== ge && (xe !== 0 || Me !== 0)) && (_e = this.mul(_e, ye[Ae]), ve = 0, Ae = 0);
        }
        he = 26;
      }
      return _e;
    }, ze.prototype.convertTo = function(le) {
      var pe = le.umod(this.m);
      return pe === le ? pe.clone() : pe;
    }, ze.prototype.convertFrom = function(le) {
      var pe = le.clone();
      return pe.red = null, pe;
    }, ce.mont = function(le) {
      return new ot(le);
    };
    function ot($e) {
      ze.call(this, $e), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new ce(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    ue(ot, ze), ot.prototype.convertTo = function(le) {
      return this.imod(le.ushln(this.shift));
    }, ot.prototype.convertFrom = function(le) {
      var pe = this.imod(le.mul(this.rinv));
      return pe.red = null, pe;
    }, ot.prototype.imul = function(le, pe) {
      if (le.isZero() || pe.isZero())
        return le.words[0] = 0, le.length = 1, le;
      var ge = le.imul(pe), ye = ge.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), xe = ge.isub(ye).iushrn(this.shift), _e = xe;
      return xe.cmp(this.m) >= 0 ? _e = xe.isub(this.m) : xe.cmpn(0) < 0 && (_e = xe.iadd(this.m)), _e._forceRed(this);
    }, ot.prototype.mul = function(le, pe) {
      if (le.isZero() || pe.isZero())
        return new ce(0)._forceRed(this);
      var ge = le.mul(pe), ye = ge.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), xe = ge.isub(ye).iushrn(this.shift), _e = xe;
      return xe.cmp(this.m) >= 0 ? _e = xe.isub(this.m) : xe.cmpn(0) < 0 && (_e = xe.iadd(this.m)), _e._forceRed(this);
    }, ot.prototype.invm = function(le) {
      var pe = this.imod(le._invmp(this.m).mul(this.r2));
      return pe._forceRed(this);
    };
  })(ae, commonjsGlobal);
})(bn$5);
var bnExports$5 = bn$5.exports, brorand = { exports: {} }, hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand)
    return brorand.exports;
  hasRequiredBrorand = 1;
  var ae;
  brorand.exports = function(ue) {
    return ae || (ae = new ie(null)), ae.generate(ue);
  };
  function ie(fe) {
    this.rand = fe;
  }
  if (brorand.exports.Rand = ie, ie.prototype.generate = function(ue) {
    return this._rand(ue);
  }, ie.prototype._rand = function(ue) {
    if (this.rand.getBytes)
      return this.rand.getBytes(ue);
    for (var ce = new Uint8Array(ue), de = 0; de < ce.length; de++)
      ce[de] = this.rand.getByte();
    return ce;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? ie.prototype._rand = function(ue) {
      var ce = new Uint8Array(ue);
      return self.crypto.getRandomValues(ce), ce;
    } : self.msCrypto && self.msCrypto.getRandomValues ? ie.prototype._rand = function(ue) {
      var ce = new Uint8Array(ue);
      return self.msCrypto.getRandomValues(ce), ce;
    } : typeof window == "object" && (ie.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var se = requireCryptoBrowserify();
      if (typeof se.randomBytes != "function")
        throw new Error("Not supported");
      ie.prototype._rand = function(ue) {
        return se.randomBytes(ue);
      };
    } catch {
    }
  return brorand.exports;
}
var mr, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr)
    return mr;
  hasRequiredMr = 1;
  var ae = bnExports$5, ie = requireBrorand();
  function se(fe) {
    this.rand = fe || new ie.Rand();
  }
  return mr = se, se.create = function(ue) {
    return new se(ue);
  }, se.prototype._randbelow = function(ue) {
    var ce = ue.bitLength(), de = Math.ceil(ce / 8);
    do
      var me = new ae(this.rand.generate(de));
    while (me.cmp(ue) >= 0);
    return me;
  }, se.prototype._randrange = function(ue, ce) {
    var de = ce.sub(ue);
    return ue.add(this._randbelow(de));
  }, se.prototype.test = function(ue, ce, de) {
    var me = ue.bitLength(), we = ae.mont(ue), Ee = new ae(1).toRed(we);
    ce || (ce = Math.max(1, me / 48 | 0));
    for (var Se = ue.subn(1), Be = 0; !Se.testn(Be); Be++)
      ;
    for (var Ce = ue.shrn(Be), Ie = Se.toRed(we), Pe = !0; ce > 0; ce--) {
      var Ne = this._randrange(new ae(2), Se);
      de && de(Ne);
      var ke = Ne.toRed(we).redPow(Ce);
      if (!(ke.cmp(Ee) === 0 || ke.cmp(Ie) === 0)) {
        for (var He = 1; He < Be; He++) {
          if (ke = ke.redSqr(), ke.cmp(Ee) === 0)
            return !1;
          if (ke.cmp(Ie) === 0)
            break;
        }
        if (He === Be)
          return !1;
      }
    }
    return Pe;
  }, se.prototype.getDivisor = function(ue, ce) {
    var de = ue.bitLength(), me = ae.mont(ue), we = new ae(1).toRed(me);
    ce || (ce = Math.max(1, de / 48 | 0));
    for (var Ee = ue.subn(1), Se = 0; !Ee.testn(Se); Se++)
      ;
    for (var Be = ue.shrn(Se), Ce = Ee.toRed(me); ce > 0; ce--) {
      var Ie = this._randrange(new ae(2), Ee), Pe = ue.gcd(Ie);
      if (Pe.cmpn(1) !== 0)
        return Pe;
      var Ne = Ie.toRed(me).redPow(Be);
      if (!(Ne.cmp(we) === 0 || Ne.cmp(Ce) === 0)) {
        for (var ke = 1; ke < Se; ke++) {
          if (Ne = Ne.redSqr(), Ne.cmp(we) === 0)
            return Ne.fromRed().subn(1).gcd(ue);
          if (Ne.cmp(Ce) === 0)
            break;
        }
        if (ke === Se)
          return Ne = Ne.redSqr(), Ne.fromRed().subn(1).gcd(ue);
      }
    }
    return !1;
  }, mr;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime)
    return generatePrime;
  hasRequiredGeneratePrime = 1;
  var ae = browserExports;
  generatePrime = ke, ke.simpleSieve = Pe, ke.fermatTest = Ne;
  var ie = bnExports$6, se = new ie(24), fe = requireMr(), ue = new fe(), ce = new ie(1), de = new ie(2), me = new ie(5);
  new ie(16), new ie(8);
  var we = new ie(10), Ee = new ie(3);
  new ie(7);
  var Se = new ie(11), Be = new ie(4);
  new ie(12);
  var Ce = null;
  function Ie() {
    if (Ce !== null)
      return Ce;
    var He = 1048576, De = [];
    De[0] = 2;
    for (var Ge = 1, Ye = 3; Ye < He; Ye += 2) {
      for (var st = Math.ceil(Math.sqrt(Ye)), at = 0; at < Ge && De[at] <= st && Ye % De[at] !== 0; at++)
        ;
      Ge !== at && De[at] <= st || (De[Ge++] = Ye);
    }
    return Ce = De, De;
  }
  function Pe(He) {
    for (var De = Ie(), Ge = 0; Ge < De.length; Ge++)
      if (He.modn(De[Ge]) === 0)
        return He.cmpn(De[Ge]) === 0;
    return !0;
  }
  function Ne(He) {
    var De = ie.mont(He);
    return de.toRed(De).redPow(He.subn(1)).fromRed().cmpn(1) === 0;
  }
  function ke(He, De) {
    if (He < 16)
      return De === 2 || De === 5 ? new ie([140, 123]) : new ie([140, 39]);
    De = new ie(De);
    for (var Ge, Ye; ; ) {
      for (Ge = new ie(ae(Math.ceil(He / 8))); Ge.bitLength() > He; )
        Ge.ishrn(1);
      if (Ge.isEven() && Ge.iadd(ce), Ge.testn(1) || Ge.iadd(de), De.cmp(de)) {
        if (!De.cmp(me))
          for (; Ge.mod(we).cmp(Ee); )
            Ge.iadd(Be);
      } else
        for (; Ge.mod(se).cmp(Se); )
          Ge.iadd(Be);
      if (Ye = Ge.shrn(1), Pe(Ye) && Pe(Ge) && Ne(Ye) && Ne(Ge) && ue.test(Ye) && ue.test(Ge))
        return Ge;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh)
    return dh;
  hasRequiredDh = 1;
  var ae = bnExports$6, ie = requireMr(), se = new ie(), fe = new ae(24), ue = new ae(11), ce = new ae(10), de = new ae(3), me = new ae(7), we = requireGeneratePrime(), Ee = browserExports;
  dh = Pe;
  function Se(ke, He) {
    return He = He || "utf8", Buffer$F.isBuffer(ke) || (ke = new Buffer$F(ke, He)), this._pub = new ae(ke), this;
  }
  function Be(ke, He) {
    return He = He || "utf8", Buffer$F.isBuffer(ke) || (ke = new Buffer$F(ke, He)), this._priv = new ae(ke), this;
  }
  var Ce = {};
  function Ie(ke, He) {
    var De = He.toString("hex"), Ge = [De, ke.toString(16)].join("_");
    if (Ge in Ce)
      return Ce[Ge];
    var Ye = 0;
    if (ke.isEven() || !we.simpleSieve || !we.fermatTest(ke) || !se.test(ke))
      return Ye += 1, De === "02" || De === "05" ? Ye += 8 : Ye += 4, Ce[Ge] = Ye, Ye;
    se.test(ke.shrn(1)) || (Ye += 2);
    var st;
    switch (De) {
      case "02":
        ke.mod(fe).cmp(ue) && (Ye += 8);
        break;
      case "05":
        st = ke.mod(ce), st.cmp(de) && st.cmp(me) && (Ye += 8);
        break;
      default:
        Ye += 4;
    }
    return Ce[Ge] = Ye, Ye;
  }
  function Pe(ke, He, De) {
    this.setGenerator(He), this.__prime = new ae(ke), this._prime = ae.mont(this.__prime), this._primeLen = ke.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, De ? (this.setPublicKey = Se, this.setPrivateKey = Be) : this._primeCode = 8;
  }
  Object.defineProperty(Pe.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = Ie(this.__prime, this.__gen)), this._primeCode;
    }
  }), Pe.prototype.generateKeys = function() {
    return this._priv || (this._priv = new ae(Ee(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, Pe.prototype.computeSecret = function(ke) {
    ke = new ae(ke), ke = ke.toRed(this._prime);
    var He = ke.redPow(this._priv).fromRed(), De = new Buffer$F(He.toArray()), Ge = this.getPrime();
    if (De.length < Ge.length) {
      var Ye = new Buffer$F(Ge.length - De.length);
      Ye.fill(0), De = Buffer$F.concat([Ye, De]);
    }
    return De;
  }, Pe.prototype.getPublicKey = function(He) {
    return Ne(this._pub, He);
  }, Pe.prototype.getPrivateKey = function(He) {
    return Ne(this._priv, He);
  }, Pe.prototype.getPrime = function(ke) {
    return Ne(this.__prime, ke);
  }, Pe.prototype.getGenerator = function(ke) {
    return Ne(this._gen, ke);
  }, Pe.prototype.setGenerator = function(ke, He) {
    return He = He || "utf8", Buffer$F.isBuffer(ke) || (ke = new Buffer$F(ke, He)), this.__gen = ke, this._gen = new ae(ke), this;
  };
  function Ne(ke, He) {
    var De = new Buffer$F(ke.toArray());
    return He ? De.toString(He) : De;
  }
  return dh;
}
var hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2)
    return browser$6;
  hasRequiredBrowser$2 = 1;
  var ae = requireGeneratePrime(), ie = require$$1$1, se = requireDh();
  function fe(de) {
    var me = new Buffer$F(ie[de].prime, "hex"), we = new Buffer$F(ie[de].gen, "hex");
    return new se(me, we);
  }
  var ue = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function ce(de, me, we, Ee) {
    return Buffer$F.isBuffer(me) || ue[me] === void 0 ? ce(de, "binary", me, we) : (me = me || "binary", Ee = Ee || "binary", we = we || new Buffer$F([2]), Buffer$F.isBuffer(we) || (we = new Buffer$F(we, Ee)), typeof de == "number" ? new se(ae(de, we), we, !0) : (Buffer$F.isBuffer(de) || (de = new Buffer$F(de, me)), new se(de, we, !0)));
  }
  return browser$6.DiffieHellmanGroup = browser$6.createDiffieHellmanGroup = browser$6.getDiffieHellman = fe, browser$6.createDiffieHellman = browser$6.DiffieHellman = ce, browser$6;
}
var sign$4 = { exports: {} }, bn$4 = { exports: {} };
bn$4.exports;
(function(ae) {
  (function(ie, se) {
    function fe(pe, ge) {
      if (!pe)
        throw new Error(ge || "Assertion failed");
    }
    function ue(pe, ge) {
      pe.super_ = ge;
      var ye = function() {
      };
      ye.prototype = ge.prototype, pe.prototype = new ye(), pe.prototype.constructor = pe;
    }
    function ce(pe, ge, ye) {
      if (ce.isBN(pe))
        return pe;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, pe !== null && ((ge === "le" || ge === "be") && (ye = ge, ge = 10), this._init(pe || 0, ge || 10, ye || "be"));
    }
    typeof ie == "object" ? ie.exports = ce : se.BN = ce, ce.BN = ce, ce.wordSize = 26;
    var de;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? de = window.Buffer : de = require$$0$2.Buffer;
    } catch {
    }
    ce.isBN = function(ge) {
      return ge instanceof ce ? !0 : ge !== null && typeof ge == "object" && ge.constructor.wordSize === ce.wordSize && Array.isArray(ge.words);
    }, ce.max = function(ge, ye) {
      return ge.cmp(ye) > 0 ? ge : ye;
    }, ce.min = function(ge, ye) {
      return ge.cmp(ye) < 0 ? ge : ye;
    }, ce.prototype._init = function(ge, ye, xe) {
      if (typeof ge == "number")
        return this._initNumber(ge, ye, xe);
      if (typeof ge == "object")
        return this._initArray(ge, ye, xe);
      ye === "hex" && (ye = 16), fe(ye === (ye | 0) && ye >= 2 && ye <= 36), ge = ge.toString().replace(/\s+/g, "");
      var _e = 0;
      ge[0] === "-" && (_e++, this.negative = 1), _e < ge.length && (ye === 16 ? this._parseHex(ge, _e, xe) : (this._parseBase(ge, ye, _e), xe === "le" && this._initArray(this.toArray(), ye, xe)));
    }, ce.prototype._initNumber = function(ge, ye, xe) {
      ge < 0 && (this.negative = 1, ge = -ge), ge < 67108864 ? (this.words = [ge & 67108863], this.length = 1) : ge < 4503599627370496 ? (this.words = [
        ge & 67108863,
        ge / 67108864 & 67108863
      ], this.length = 2) : (fe(ge < 9007199254740992), this.words = [
        ge & 67108863,
        ge / 67108864 & 67108863,
        1
      ], this.length = 3), xe === "le" && this._initArray(this.toArray(), ye, xe);
    }, ce.prototype._initArray = function(ge, ye, xe) {
      if (fe(typeof ge.length == "number"), ge.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(ge.length / 3), this.words = new Array(this.length);
      for (var _e = 0; _e < this.length; _e++)
        this.words[_e] = 0;
      var Ae, ve, he = 0;
      if (xe === "be")
        for (_e = ge.length - 1, Ae = 0; _e >= 0; _e -= 3)
          ve = ge[_e] | ge[_e - 1] << 8 | ge[_e - 2] << 16, this.words[Ae] |= ve << he & 67108863, this.words[Ae + 1] = ve >>> 26 - he & 67108863, he += 24, he >= 26 && (he -= 26, Ae++);
      else if (xe === "le")
        for (_e = 0, Ae = 0; _e < ge.length; _e += 3)
          ve = ge[_e] | ge[_e + 1] << 8 | ge[_e + 2] << 16, this.words[Ae] |= ve << he & 67108863, this.words[Ae + 1] = ve >>> 26 - he & 67108863, he += 24, he >= 26 && (he -= 26, Ae++);
      return this._strip();
    };
    function me(pe, ge) {
      var ye = pe.charCodeAt(ge);
      if (ye >= 48 && ye <= 57)
        return ye - 48;
      if (ye >= 65 && ye <= 70)
        return ye - 55;
      if (ye >= 97 && ye <= 102)
        return ye - 87;
      fe(!1, "Invalid character in " + pe);
    }
    function we(pe, ge, ye) {
      var xe = me(pe, ye);
      return ye - 1 >= ge && (xe |= me(pe, ye - 1) << 4), xe;
    }
    ce.prototype._parseHex = function(ge, ye, xe) {
      this.length = Math.ceil((ge.length - ye) / 6), this.words = new Array(this.length);
      for (var _e = 0; _e < this.length; _e++)
        this.words[_e] = 0;
      var Ae = 0, ve = 0, he;
      if (xe === "be")
        for (_e = ge.length - 1; _e >= ye; _e -= 2)
          he = we(ge, ye, _e) << Ae, this.words[ve] |= he & 67108863, Ae >= 18 ? (Ae -= 18, ve += 1, this.words[ve] |= he >>> 26) : Ae += 8;
      else {
        var be = ge.length - ye;
        for (_e = be % 2 === 0 ? ye + 1 : ye; _e < ge.length; _e += 2)
          he = we(ge, ye, _e) << Ae, this.words[ve] |= he & 67108863, Ae >= 18 ? (Ae -= 18, ve += 1, this.words[ve] |= he >>> 26) : Ae += 8;
      }
      this._strip();
    };
    function Ee(pe, ge, ye, xe) {
      for (var _e = 0, Ae = 0, ve = Math.min(pe.length, ye), he = ge; he < ve; he++) {
        var be = pe.charCodeAt(he) - 48;
        _e *= xe, be >= 49 ? Ae = be - 49 + 10 : be >= 17 ? Ae = be - 17 + 10 : Ae = be, fe(be >= 0 && Ae < xe, "Invalid character"), _e += Ae;
      }
      return _e;
    }
    ce.prototype._parseBase = function(ge, ye, xe) {
      this.words = [0], this.length = 1;
      for (var _e = 0, Ae = 1; Ae <= 67108863; Ae *= ye)
        _e++;
      _e--, Ae = Ae / ye | 0;
      for (var ve = ge.length - xe, he = ve % _e, be = Math.min(ve, ve - he) + xe, Me = 0, Re = xe; Re < be; Re += _e)
        Me = Ee(ge, Re, Re + _e, ye), this.imuln(Ae), this.words[0] + Me < 67108864 ? this.words[0] += Me : this._iaddn(Me);
      if (he !== 0) {
        var Oe = 1;
        for (Me = Ee(ge, Re, ge.length, ye), Re = 0; Re < he; Re++)
          Oe *= ye;
        this.imuln(Oe), this.words[0] + Me < 67108864 ? this.words[0] += Me : this._iaddn(Me);
      }
      this._strip();
    }, ce.prototype.copy = function(ge) {
      ge.words = new Array(this.length);
      for (var ye = 0; ye < this.length; ye++)
        ge.words[ye] = this.words[ye];
      ge.length = this.length, ge.negative = this.negative, ge.red = this.red;
    };
    function Se(pe, ge) {
      pe.words = ge.words, pe.length = ge.length, pe.negative = ge.negative, pe.red = ge.red;
    }
    if (ce.prototype._move = function(ge) {
      Se(ge, this);
    }, ce.prototype.clone = function() {
      var ge = new ce(null);
      return this.copy(ge), ge;
    }, ce.prototype._expand = function(ge) {
      for (; this.length < ge; )
        this.words[this.length++] = 0;
      return this;
    }, ce.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, ce.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        ce.prototype[Symbol.for("nodejs.util.inspect.custom")] = Be;
      } catch {
        ce.prototype.inspect = Be;
      }
    else
      ce.prototype.inspect = Be;
    function Be() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var Ce = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], Ie = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], Pe = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    ce.prototype.toString = function(ge, ye) {
      ge = ge || 10, ye = ye | 0 || 1;
      var xe;
      if (ge === 16 || ge === "hex") {
        xe = "";
        for (var _e = 0, Ae = 0, ve = 0; ve < this.length; ve++) {
          var he = this.words[ve], be = ((he << _e | Ae) & 16777215).toString(16);
          Ae = he >>> 24 - _e & 16777215, _e += 2, _e >= 26 && (_e -= 26, ve--), Ae !== 0 || ve !== this.length - 1 ? xe = Ce[6 - be.length] + be + xe : xe = be + xe;
        }
        for (Ae !== 0 && (xe = Ae.toString(16) + xe); xe.length % ye !== 0; )
          xe = "0" + xe;
        return this.negative !== 0 && (xe = "-" + xe), xe;
      }
      if (ge === (ge | 0) && ge >= 2 && ge <= 36) {
        var Me = Ie[ge], Re = Pe[ge];
        xe = "";
        var Oe = this.clone();
        for (Oe.negative = 0; !Oe.isZero(); ) {
          var Te = Oe.modrn(Re).toString(ge);
          Oe = Oe.idivn(Re), Oe.isZero() ? xe = Te + xe : xe = Ce[Me - Te.length] + Te + xe;
        }
        for (this.isZero() && (xe = "0" + xe); xe.length % ye !== 0; )
          xe = "0" + xe;
        return this.negative !== 0 && (xe = "-" + xe), xe;
      }
      fe(!1, "Base should be between 2 and 36");
    }, ce.prototype.toNumber = function() {
      var ge = this.words[0];
      return this.length === 2 ? ge += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? ge += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && fe(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -ge : ge;
    }, ce.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, de && (ce.prototype.toBuffer = function(ge, ye) {
      return this.toArrayLike(de, ge, ye);
    }), ce.prototype.toArray = function(ge, ye) {
      return this.toArrayLike(Array, ge, ye);
    };
    var Ne = function(ge, ye) {
      return ge.allocUnsafe ? ge.allocUnsafe(ye) : new ge(ye);
    };
    ce.prototype.toArrayLike = function(ge, ye, xe) {
      this._strip();
      var _e = this.byteLength(), Ae = xe || Math.max(1, _e);
      fe(_e <= Ae, "byte array longer than desired length"), fe(Ae > 0, "Requested array length <= 0");
      var ve = Ne(ge, Ae), he = ye === "le" ? "LE" : "BE";
      return this["_toArrayLike" + he](ve, _e), ve;
    }, ce.prototype._toArrayLikeLE = function(ge, ye) {
      for (var xe = 0, _e = 0, Ae = 0, ve = 0; Ae < this.length; Ae++) {
        var he = this.words[Ae] << ve | _e;
        ge[xe++] = he & 255, xe < ge.length && (ge[xe++] = he >> 8 & 255), xe < ge.length && (ge[xe++] = he >> 16 & 255), ve === 6 ? (xe < ge.length && (ge[xe++] = he >> 24 & 255), _e = 0, ve = 0) : (_e = he >>> 24, ve += 2);
      }
      if (xe < ge.length)
        for (ge[xe++] = _e; xe < ge.length; )
          ge[xe++] = 0;
    }, ce.prototype._toArrayLikeBE = function(ge, ye) {
      for (var xe = ge.length - 1, _e = 0, Ae = 0, ve = 0; Ae < this.length; Ae++) {
        var he = this.words[Ae] << ve | _e;
        ge[xe--] = he & 255, xe >= 0 && (ge[xe--] = he >> 8 & 255), xe >= 0 && (ge[xe--] = he >> 16 & 255), ve === 6 ? (xe >= 0 && (ge[xe--] = he >> 24 & 255), _e = 0, ve = 0) : (_e = he >>> 24, ve += 2);
      }
      if (xe >= 0)
        for (ge[xe--] = _e; xe >= 0; )
          ge[xe--] = 0;
    }, Math.clz32 ? ce.prototype._countBits = function(ge) {
      return 32 - Math.clz32(ge);
    } : ce.prototype._countBits = function(ge) {
      var ye = ge, xe = 0;
      return ye >= 4096 && (xe += 13, ye >>>= 13), ye >= 64 && (xe += 7, ye >>>= 7), ye >= 8 && (xe += 4, ye >>>= 4), ye >= 2 && (xe += 2, ye >>>= 2), xe + ye;
    }, ce.prototype._zeroBits = function(ge) {
      if (ge === 0)
        return 26;
      var ye = ge, xe = 0;
      return ye & 8191 || (xe += 13, ye >>>= 13), ye & 127 || (xe += 7, ye >>>= 7), ye & 15 || (xe += 4, ye >>>= 4), ye & 3 || (xe += 2, ye >>>= 2), ye & 1 || xe++, xe;
    }, ce.prototype.bitLength = function() {
      var ge = this.words[this.length - 1], ye = this._countBits(ge);
      return (this.length - 1) * 26 + ye;
    };
    function ke(pe) {
      for (var ge = new Array(pe.bitLength()), ye = 0; ye < ge.length; ye++) {
        var xe = ye / 26 | 0, _e = ye % 26;
        ge[ye] = pe.words[xe] >>> _e & 1;
      }
      return ge;
    }
    ce.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var ge = 0, ye = 0; ye < this.length; ye++) {
        var xe = this._zeroBits(this.words[ye]);
        if (ge += xe, xe !== 26)
          break;
      }
      return ge;
    }, ce.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, ce.prototype.toTwos = function(ge) {
      return this.negative !== 0 ? this.abs().inotn(ge).iaddn(1) : this.clone();
    }, ce.prototype.fromTwos = function(ge) {
      return this.testn(ge - 1) ? this.notn(ge).iaddn(1).ineg() : this.clone();
    }, ce.prototype.isNeg = function() {
      return this.negative !== 0;
    }, ce.prototype.neg = function() {
      return this.clone().ineg();
    }, ce.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, ce.prototype.iuor = function(ge) {
      for (; this.length < ge.length; )
        this.words[this.length++] = 0;
      for (var ye = 0; ye < ge.length; ye++)
        this.words[ye] = this.words[ye] | ge.words[ye];
      return this._strip();
    }, ce.prototype.ior = function(ge) {
      return fe((this.negative | ge.negative) === 0), this.iuor(ge);
    }, ce.prototype.or = function(ge) {
      return this.length > ge.length ? this.clone().ior(ge) : ge.clone().ior(this);
    }, ce.prototype.uor = function(ge) {
      return this.length > ge.length ? this.clone().iuor(ge) : ge.clone().iuor(this);
    }, ce.prototype.iuand = function(ge) {
      var ye;
      this.length > ge.length ? ye = ge : ye = this;
      for (var xe = 0; xe < ye.length; xe++)
        this.words[xe] = this.words[xe] & ge.words[xe];
      return this.length = ye.length, this._strip();
    }, ce.prototype.iand = function(ge) {
      return fe((this.negative | ge.negative) === 0), this.iuand(ge);
    }, ce.prototype.and = function(ge) {
      return this.length > ge.length ? this.clone().iand(ge) : ge.clone().iand(this);
    }, ce.prototype.uand = function(ge) {
      return this.length > ge.length ? this.clone().iuand(ge) : ge.clone().iuand(this);
    }, ce.prototype.iuxor = function(ge) {
      var ye, xe;
      this.length > ge.length ? (ye = this, xe = ge) : (ye = ge, xe = this);
      for (var _e = 0; _e < xe.length; _e++)
        this.words[_e] = ye.words[_e] ^ xe.words[_e];
      if (this !== ye)
        for (; _e < ye.length; _e++)
          this.words[_e] = ye.words[_e];
      return this.length = ye.length, this._strip();
    }, ce.prototype.ixor = function(ge) {
      return fe((this.negative | ge.negative) === 0), this.iuxor(ge);
    }, ce.prototype.xor = function(ge) {
      return this.length > ge.length ? this.clone().ixor(ge) : ge.clone().ixor(this);
    }, ce.prototype.uxor = function(ge) {
      return this.length > ge.length ? this.clone().iuxor(ge) : ge.clone().iuxor(this);
    }, ce.prototype.inotn = function(ge) {
      fe(typeof ge == "number" && ge >= 0);
      var ye = Math.ceil(ge / 26) | 0, xe = ge % 26;
      this._expand(ye), xe > 0 && ye--;
      for (var _e = 0; _e < ye; _e++)
        this.words[_e] = ~this.words[_e] & 67108863;
      return xe > 0 && (this.words[_e] = ~this.words[_e] & 67108863 >> 26 - xe), this._strip();
    }, ce.prototype.notn = function(ge) {
      return this.clone().inotn(ge);
    }, ce.prototype.setn = function(ge, ye) {
      fe(typeof ge == "number" && ge >= 0);
      var xe = ge / 26 | 0, _e = ge % 26;
      return this._expand(xe + 1), ye ? this.words[xe] = this.words[xe] | 1 << _e : this.words[xe] = this.words[xe] & ~(1 << _e), this._strip();
    }, ce.prototype.iadd = function(ge) {
      var ye;
      if (this.negative !== 0 && ge.negative === 0)
        return this.negative = 0, ye = this.isub(ge), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && ge.negative !== 0)
        return ge.negative = 0, ye = this.isub(ge), ge.negative = 1, ye._normSign();
      var xe, _e;
      this.length > ge.length ? (xe = this, _e = ge) : (xe = ge, _e = this);
      for (var Ae = 0, ve = 0; ve < _e.length; ve++)
        ye = (xe.words[ve] | 0) + (_e.words[ve] | 0) + Ae, this.words[ve] = ye & 67108863, Ae = ye >>> 26;
      for (; Ae !== 0 && ve < xe.length; ve++)
        ye = (xe.words[ve] | 0) + Ae, this.words[ve] = ye & 67108863, Ae = ye >>> 26;
      if (this.length = xe.length, Ae !== 0)
        this.words[this.length] = Ae, this.length++;
      else if (xe !== this)
        for (; ve < xe.length; ve++)
          this.words[ve] = xe.words[ve];
      return this;
    }, ce.prototype.add = function(ge) {
      var ye;
      return ge.negative !== 0 && this.negative === 0 ? (ge.negative = 0, ye = this.sub(ge), ge.negative ^= 1, ye) : ge.negative === 0 && this.negative !== 0 ? (this.negative = 0, ye = ge.sub(this), this.negative = 1, ye) : this.length > ge.length ? this.clone().iadd(ge) : ge.clone().iadd(this);
    }, ce.prototype.isub = function(ge) {
      if (ge.negative !== 0) {
        ge.negative = 0;
        var ye = this.iadd(ge);
        return ge.negative = 1, ye._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(ge), this.negative = 1, this._normSign();
      var xe = this.cmp(ge);
      if (xe === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var _e, Ae;
      xe > 0 ? (_e = this, Ae = ge) : (_e = ge, Ae = this);
      for (var ve = 0, he = 0; he < Ae.length; he++)
        ye = (_e.words[he] | 0) - (Ae.words[he] | 0) + ve, ve = ye >> 26, this.words[he] = ye & 67108863;
      for (; ve !== 0 && he < _e.length; he++)
        ye = (_e.words[he] | 0) + ve, ve = ye >> 26, this.words[he] = ye & 67108863;
      if (ve === 0 && he < _e.length && _e !== this)
        for (; he < _e.length; he++)
          this.words[he] = _e.words[he];
      return this.length = Math.max(this.length, he), _e !== this && (this.negative = 1), this._strip();
    }, ce.prototype.sub = function(ge) {
      return this.clone().isub(ge);
    };
    function He(pe, ge, ye) {
      ye.negative = ge.negative ^ pe.negative;
      var xe = pe.length + ge.length | 0;
      ye.length = xe, xe = xe - 1 | 0;
      var _e = pe.words[0] | 0, Ae = ge.words[0] | 0, ve = _e * Ae, he = ve & 67108863, be = ve / 67108864 | 0;
      ye.words[0] = he;
      for (var Me = 1; Me < xe; Me++) {
        for (var Re = be >>> 26, Oe = be & 67108863, Te = Math.min(Me, ge.length - 1), Fe = Math.max(0, Me - pe.length + 1); Fe <= Te; Fe++) {
          var je = Me - Fe | 0;
          _e = pe.words[je] | 0, Ae = ge.words[Fe] | 0, ve = _e * Ae + Oe, Re += ve / 67108864 | 0, Oe = ve & 67108863;
        }
        ye.words[Me] = Oe | 0, be = Re | 0;
      }
      return be !== 0 ? ye.words[Me] = be | 0 : ye.length--, ye._strip();
    }
    var De = function(ge, ye, xe) {
      var _e = ge.words, Ae = ye.words, ve = xe.words, he = 0, be, Me, Re, Oe = _e[0] | 0, Te = Oe & 8191, Fe = Oe >>> 13, je = _e[1] | 0, ct = je & 8191, nt = je >>> 13, dt = _e[2] | 0, it = dt & 8191, Je = dt >>> 13, gt = _e[3] | 0, Ht = gt & 8191, $t = gt >>> 13, Lt = _e[4] | 0, Tr = Lt & 8191, Zt = Lt >>> 13, wt = _e[5] | 0, Hr = wt & 8191, tr = wt >>> 13, cr = _e[6] | 0, qr = cr & 8191, Wt = cr >>> 13, ar = _e[7] | 0, Dr = ar & 8191, Jt = ar >>> 13, ir = _e[8] | 0, Gr = ir & 8191, We = ir >>> 13, Le = _e[9] | 0, Ke = Le & 8191, rt = Le >>> 13, lt = Ae[0] | 0, It = lt & 8191, yt = lt >>> 13, jt = Ae[1] | 0, Lr = jt & 8191, zt = jt >>> 13, rr = Ae[2] | 0, Cr = rr & 8191, fr = rr >>> 13, pr = Ae[3] | 0, jr = pr & 8191, nr = pr >>> 13, ur = Ae[4] | 0, Wr = ur & 8191, or = ur >>> 13, lr = Ae[5] | 0, Zr = lr & 8191, Xt = lr >>> 13, dr = Ae[6] | 0, Ve = dr & 8191, Ze = dr >>> 13, Xe = Ae[7] | 0, Ue = Xe & 8191, Qe = Xe >>> 13, pt = Ae[8] | 0, Ct = pt & 8191, bt = pt >>> 13, Tt = Ae[9] | 0, br = Tt & 8191, gr = Tt >>> 13;
      xe.negative = ge.negative ^ ye.negative, xe.length = 19, be = Math.imul(Te, It), Me = Math.imul(Te, yt), Me = Me + Math.imul(Fe, It) | 0, Re = Math.imul(Fe, yt);
      var Fr = (he + be | 0) + ((Me & 8191) << 13) | 0;
      he = (Re + (Me >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, be = Math.imul(ct, It), Me = Math.imul(ct, yt), Me = Me + Math.imul(nt, It) | 0, Re = Math.imul(nt, yt), be = be + Math.imul(Te, Lr) | 0, Me = Me + Math.imul(Te, zt) | 0, Me = Me + Math.imul(Fe, Lr) | 0, Re = Re + Math.imul(Fe, zt) | 0;
      var wr = (he + be | 0) + ((Me & 8191) << 13) | 0;
      he = (Re + (Me >>> 13) | 0) + (wr >>> 26) | 0, wr &= 67108863, be = Math.imul(it, It), Me = Math.imul(it, yt), Me = Me + Math.imul(Je, It) | 0, Re = Math.imul(Je, yt), be = be + Math.imul(ct, Lr) | 0, Me = Me + Math.imul(ct, zt) | 0, Me = Me + Math.imul(nt, Lr) | 0, Re = Re + Math.imul(nt, zt) | 0, be = be + Math.imul(Te, Cr) | 0, Me = Me + Math.imul(Te, fr) | 0, Me = Me + Math.imul(Fe, Cr) | 0, Re = Re + Math.imul(Fe, fr) | 0;
      var Rr = (he + be | 0) + ((Me & 8191) << 13) | 0;
      he = (Re + (Me >>> 13) | 0) + (Rr >>> 26) | 0, Rr &= 67108863, be = Math.imul(Ht, It), Me = Math.imul(Ht, yt), Me = Me + Math.imul($t, It) | 0, Re = Math.imul($t, yt), be = be + Math.imul(it, Lr) | 0, Me = Me + Math.imul(it, zt) | 0, Me = Me + Math.imul(Je, Lr) | 0, Re = Re + Math.imul(Je, zt) | 0, be = be + Math.imul(ct, Cr) | 0, Me = Me + Math.imul(ct, fr) | 0, Me = Me + Math.imul(nt, Cr) | 0, Re = Re + Math.imul(nt, fr) | 0, be = be + Math.imul(Te, jr) | 0, Me = Me + Math.imul(Te, nr) | 0, Me = Me + Math.imul(Fe, jr) | 0, Re = Re + Math.imul(Fe, nr) | 0;
      var kr = (he + be | 0) + ((Me & 8191) << 13) | 0;
      he = (Re + (Me >>> 13) | 0) + (kr >>> 26) | 0, kr &= 67108863, be = Math.imul(Tr, It), Me = Math.imul(Tr, yt), Me = Me + Math.imul(Zt, It) | 0, Re = Math.imul(Zt, yt), be = be + Math.imul(Ht, Lr) | 0, Me = Me + Math.imul(Ht, zt) | 0, Me = Me + Math.imul($t, Lr) | 0, Re = Re + Math.imul($t, zt) | 0, be = be + Math.imul(it, Cr) | 0, Me = Me + Math.imul(it, fr) | 0, Me = Me + Math.imul(Je, Cr) | 0, Re = Re + Math.imul(Je, fr) | 0, be = be + Math.imul(ct, jr) | 0, Me = Me + Math.imul(ct, nr) | 0, Me = Me + Math.imul(nt, jr) | 0, Re = Re + Math.imul(nt, nr) | 0, be = be + Math.imul(Te, Wr) | 0, Me = Me + Math.imul(Te, or) | 0, Me = Me + Math.imul(Fe, Wr) | 0, Re = Re + Math.imul(Fe, or) | 0;
      var Pr = (he + be | 0) + ((Me & 8191) << 13) | 0;
      he = (Re + (Me >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, be = Math.imul(Hr, It), Me = Math.imul(Hr, yt), Me = Me + Math.imul(tr, It) | 0, Re = Math.imul(tr, yt), be = be + Math.imul(Tr, Lr) | 0, Me = Me + Math.imul(Tr, zt) | 0, Me = Me + Math.imul(Zt, Lr) | 0, Re = Re + Math.imul(Zt, zt) | 0, be = be + Math.imul(Ht, Cr) | 0, Me = Me + Math.imul(Ht, fr) | 0, Me = Me + Math.imul($t, Cr) | 0, Re = Re + Math.imul($t, fr) | 0, be = be + Math.imul(it, jr) | 0, Me = Me + Math.imul(it, nr) | 0, Me = Me + Math.imul(Je, jr) | 0, Re = Re + Math.imul(Je, nr) | 0, be = be + Math.imul(ct, Wr) | 0, Me = Me + Math.imul(ct, or) | 0, Me = Me + Math.imul(nt, Wr) | 0, Re = Re + Math.imul(nt, or) | 0, be = be + Math.imul(Te, Zr) | 0, Me = Me + Math.imul(Te, Xt) | 0, Me = Me + Math.imul(Fe, Zr) | 0, Re = Re + Math.imul(Fe, Xt) | 0;
      var Ur = (he + be | 0) + ((Me & 8191) << 13) | 0;
      he = (Re + (Me >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, be = Math.imul(qr, It), Me = Math.imul(qr, yt), Me = Me + Math.imul(Wt, It) | 0, Re = Math.imul(Wt, yt), be = be + Math.imul(Hr, Lr) | 0, Me = Me + Math.imul(Hr, zt) | 0, Me = Me + Math.imul(tr, Lr) | 0, Re = Re + Math.imul(tr, zt) | 0, be = be + Math.imul(Tr, Cr) | 0, Me = Me + Math.imul(Tr, fr) | 0, Me = Me + Math.imul(Zt, Cr) | 0, Re = Re + Math.imul(Zt, fr) | 0, be = be + Math.imul(Ht, jr) | 0, Me = Me + Math.imul(Ht, nr) | 0, Me = Me + Math.imul($t, jr) | 0, Re = Re + Math.imul($t, nr) | 0, be = be + Math.imul(it, Wr) | 0, Me = Me + Math.imul(it, or) | 0, Me = Me + Math.imul(Je, Wr) | 0, Re = Re + Math.imul(Je, or) | 0, be = be + Math.imul(ct, Zr) | 0, Me = Me + Math.imul(ct, Xt) | 0, Me = Me + Math.imul(nt, Zr) | 0, Re = Re + Math.imul(nt, Xt) | 0, be = be + Math.imul(Te, Ve) | 0, Me = Me + Math.imul(Te, Ze) | 0, Me = Me + Math.imul(Fe, Ve) | 0, Re = Re + Math.imul(Fe, Ze) | 0;
      var Ir = (he + be | 0) + ((Me & 8191) << 13) | 0;
      he = (Re + (Me >>> 13) | 0) + (Ir >>> 26) | 0, Ir &= 67108863, be = Math.imul(Dr, It), Me = Math.imul(Dr, yt), Me = Me + Math.imul(Jt, It) | 0, Re = Math.imul(Jt, yt), be = be + Math.imul(qr, Lr) | 0, Me = Me + Math.imul(qr, zt) | 0, Me = Me + Math.imul(Wt, Lr) | 0, Re = Re + Math.imul(Wt, zt) | 0, be = be + Math.imul(Hr, Cr) | 0, Me = Me + Math.imul(Hr, fr) | 0, Me = Me + Math.imul(tr, Cr) | 0, Re = Re + Math.imul(tr, fr) | 0, be = be + Math.imul(Tr, jr) | 0, Me = Me + Math.imul(Tr, nr) | 0, Me = Me + Math.imul(Zt, jr) | 0, Re = Re + Math.imul(Zt, nr) | 0, be = be + Math.imul(Ht, Wr) | 0, Me = Me + Math.imul(Ht, or) | 0, Me = Me + Math.imul($t, Wr) | 0, Re = Re + Math.imul($t, or) | 0, be = be + Math.imul(it, Zr) | 0, Me = Me + Math.imul(it, Xt) | 0, Me = Me + Math.imul(Je, Zr) | 0, Re = Re + Math.imul(Je, Xt) | 0, be = be + Math.imul(ct, Ve) | 0, Me = Me + Math.imul(ct, Ze) | 0, Me = Me + Math.imul(nt, Ve) | 0, Re = Re + Math.imul(nt, Ze) | 0, be = be + Math.imul(Te, Ue) | 0, Me = Me + Math.imul(Te, Qe) | 0, Me = Me + Math.imul(Fe, Ue) | 0, Re = Re + Math.imul(Fe, Qe) | 0;
      var Or = (he + be | 0) + ((Me & 8191) << 13) | 0;
      he = (Re + (Me >>> 13) | 0) + (Or >>> 26) | 0, Or &= 67108863, be = Math.imul(Gr, It), Me = Math.imul(Gr, yt), Me = Me + Math.imul(We, It) | 0, Re = Math.imul(We, yt), be = be + Math.imul(Dr, Lr) | 0, Me = Me + Math.imul(Dr, zt) | 0, Me = Me + Math.imul(Jt, Lr) | 0, Re = Re + Math.imul(Jt, zt) | 0, be = be + Math.imul(qr, Cr) | 0, Me = Me + Math.imul(qr, fr) | 0, Me = Me + Math.imul(Wt, Cr) | 0, Re = Re + Math.imul(Wt, fr) | 0, be = be + Math.imul(Hr, jr) | 0, Me = Me + Math.imul(Hr, nr) | 0, Me = Me + Math.imul(tr, jr) | 0, Re = Re + Math.imul(tr, nr) | 0, be = be + Math.imul(Tr, Wr) | 0, Me = Me + Math.imul(Tr, or) | 0, Me = Me + Math.imul(Zt, Wr) | 0, Re = Re + Math.imul(Zt, or) | 0, be = be + Math.imul(Ht, Zr) | 0, Me = Me + Math.imul(Ht, Xt) | 0, Me = Me + Math.imul($t, Zr) | 0, Re = Re + Math.imul($t, Xt) | 0, be = be + Math.imul(it, Ve) | 0, Me = Me + Math.imul(it, Ze) | 0, Me = Me + Math.imul(Je, Ve) | 0, Re = Re + Math.imul(Je, Ze) | 0, be = be + Math.imul(ct, Ue) | 0, Me = Me + Math.imul(ct, Qe) | 0, Me = Me + Math.imul(nt, Ue) | 0, Re = Re + Math.imul(nt, Qe) | 0, be = be + Math.imul(Te, Ct) | 0, Me = Me + Math.imul(Te, bt) | 0, Me = Me + Math.imul(Fe, Ct) | 0, Re = Re + Math.imul(Fe, bt) | 0;
      var Nr = (he + be | 0) + ((Me & 8191) << 13) | 0;
      he = (Re + (Me >>> 13) | 0) + (Nr >>> 26) | 0, Nr &= 67108863, be = Math.imul(Ke, It), Me = Math.imul(Ke, yt), Me = Me + Math.imul(rt, It) | 0, Re = Math.imul(rt, yt), be = be + Math.imul(Gr, Lr) | 0, Me = Me + Math.imul(Gr, zt) | 0, Me = Me + Math.imul(We, Lr) | 0, Re = Re + Math.imul(We, zt) | 0, be = be + Math.imul(Dr, Cr) | 0, Me = Me + Math.imul(Dr, fr) | 0, Me = Me + Math.imul(Jt, Cr) | 0, Re = Re + Math.imul(Jt, fr) | 0, be = be + Math.imul(qr, jr) | 0, Me = Me + Math.imul(qr, nr) | 0, Me = Me + Math.imul(Wt, jr) | 0, Re = Re + Math.imul(Wt, nr) | 0, be = be + Math.imul(Hr, Wr) | 0, Me = Me + Math.imul(Hr, or) | 0, Me = Me + Math.imul(tr, Wr) | 0, Re = Re + Math.imul(tr, or) | 0, be = be + Math.imul(Tr, Zr) | 0, Me = Me + Math.imul(Tr, Xt) | 0, Me = Me + Math.imul(Zt, Zr) | 0, Re = Re + Math.imul(Zt, Xt) | 0, be = be + Math.imul(Ht, Ve) | 0, Me = Me + Math.imul(Ht, Ze) | 0, Me = Me + Math.imul($t, Ve) | 0, Re = Re + Math.imul($t, Ze) | 0, be = be + Math.imul(it, Ue) | 0, Me = Me + Math.imul(it, Qe) | 0, Me = Me + Math.imul(Je, Ue) | 0, Re = Re + Math.imul(Je, Qe) | 0, be = be + Math.imul(ct, Ct) | 0, Me = Me + Math.imul(ct, bt) | 0, Me = Me + Math.imul(nt, Ct) | 0, Re = Re + Math.imul(nt, bt) | 0, be = be + Math.imul(Te, br) | 0, Me = Me + Math.imul(Te, gr) | 0, Me = Me + Math.imul(Fe, br) | 0, Re = Re + Math.imul(Fe, gr) | 0;
      var Er = (he + be | 0) + ((Me & 8191) << 13) | 0;
      he = (Re + (Me >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, be = Math.imul(Ke, Lr), Me = Math.imul(Ke, zt), Me = Me + Math.imul(rt, Lr) | 0, Re = Math.imul(rt, zt), be = be + Math.imul(Gr, Cr) | 0, Me = Me + Math.imul(Gr, fr) | 0, Me = Me + Math.imul(We, Cr) | 0, Re = Re + Math.imul(We, fr) | 0, be = be + Math.imul(Dr, jr) | 0, Me = Me + Math.imul(Dr, nr) | 0, Me = Me + Math.imul(Jt, jr) | 0, Re = Re + Math.imul(Jt, nr) | 0, be = be + Math.imul(qr, Wr) | 0, Me = Me + Math.imul(qr, or) | 0, Me = Me + Math.imul(Wt, Wr) | 0, Re = Re + Math.imul(Wt, or) | 0, be = be + Math.imul(Hr, Zr) | 0, Me = Me + Math.imul(Hr, Xt) | 0, Me = Me + Math.imul(tr, Zr) | 0, Re = Re + Math.imul(tr, Xt) | 0, be = be + Math.imul(Tr, Ve) | 0, Me = Me + Math.imul(Tr, Ze) | 0, Me = Me + Math.imul(Zt, Ve) | 0, Re = Re + Math.imul(Zt, Ze) | 0, be = be + Math.imul(Ht, Ue) | 0, Me = Me + Math.imul(Ht, Qe) | 0, Me = Me + Math.imul($t, Ue) | 0, Re = Re + Math.imul($t, Qe) | 0, be = be + Math.imul(it, Ct) | 0, Me = Me + Math.imul(it, bt) | 0, Me = Me + Math.imul(Je, Ct) | 0, Re = Re + Math.imul(Je, bt) | 0, be = be + Math.imul(ct, br) | 0, Me = Me + Math.imul(ct, gr) | 0, Me = Me + Math.imul(nt, br) | 0, Re = Re + Math.imul(nt, gr) | 0;
      var Br = (he + be | 0) + ((Me & 8191) << 13) | 0;
      he = (Re + (Me >>> 13) | 0) + (Br >>> 26) | 0, Br &= 67108863, be = Math.imul(Ke, Cr), Me = Math.imul(Ke, fr), Me = Me + Math.imul(rt, Cr) | 0, Re = Math.imul(rt, fr), be = be + Math.imul(Gr, jr) | 0, Me = Me + Math.imul(Gr, nr) | 0, Me = Me + Math.imul(We, jr) | 0, Re = Re + Math.imul(We, nr) | 0, be = be + Math.imul(Dr, Wr) | 0, Me = Me + Math.imul(Dr, or) | 0, Me = Me + Math.imul(Jt, Wr) | 0, Re = Re + Math.imul(Jt, or) | 0, be = be + Math.imul(qr, Zr) | 0, Me = Me + Math.imul(qr, Xt) | 0, Me = Me + Math.imul(Wt, Zr) | 0, Re = Re + Math.imul(Wt, Xt) | 0, be = be + Math.imul(Hr, Ve) | 0, Me = Me + Math.imul(Hr, Ze) | 0, Me = Me + Math.imul(tr, Ve) | 0, Re = Re + Math.imul(tr, Ze) | 0, be = be + Math.imul(Tr, Ue) | 0, Me = Me + Math.imul(Tr, Qe) | 0, Me = Me + Math.imul(Zt, Ue) | 0, Re = Re + Math.imul(Zt, Qe) | 0, be = be + Math.imul(Ht, Ct) | 0, Me = Me + Math.imul(Ht, bt) | 0, Me = Me + Math.imul($t, Ct) | 0, Re = Re + Math.imul($t, bt) | 0, be = be + Math.imul(it, br) | 0, Me = Me + Math.imul(it, gr) | 0, Me = Me + Math.imul(Je, br) | 0, Re = Re + Math.imul(Je, gr) | 0;
      var _r = (he + be | 0) + ((Me & 8191) << 13) | 0;
      he = (Re + (Me >>> 13) | 0) + (_r >>> 26) | 0, _r &= 67108863, be = Math.imul(Ke, jr), Me = Math.imul(Ke, nr), Me = Me + Math.imul(rt, jr) | 0, Re = Math.imul(rt, nr), be = be + Math.imul(Gr, Wr) | 0, Me = Me + Math.imul(Gr, or) | 0, Me = Me + Math.imul(We, Wr) | 0, Re = Re + Math.imul(We, or) | 0, be = be + Math.imul(Dr, Zr) | 0, Me = Me + Math.imul(Dr, Xt) | 0, Me = Me + Math.imul(Jt, Zr) | 0, Re = Re + Math.imul(Jt, Xt) | 0, be = be + Math.imul(qr, Ve) | 0, Me = Me + Math.imul(qr, Ze) | 0, Me = Me + Math.imul(Wt, Ve) | 0, Re = Re + Math.imul(Wt, Ze) | 0, be = be + Math.imul(Hr, Ue) | 0, Me = Me + Math.imul(Hr, Qe) | 0, Me = Me + Math.imul(tr, Ue) | 0, Re = Re + Math.imul(tr, Qe) | 0, be = be + Math.imul(Tr, Ct) | 0, Me = Me + Math.imul(Tr, bt) | 0, Me = Me + Math.imul(Zt, Ct) | 0, Re = Re + Math.imul(Zt, bt) | 0, be = be + Math.imul(Ht, br) | 0, Me = Me + Math.imul(Ht, gr) | 0, Me = Me + Math.imul($t, br) | 0, Re = Re + Math.imul($t, gr) | 0;
      var Sr = (he + be | 0) + ((Me & 8191) << 13) | 0;
      he = (Re + (Me >>> 13) | 0) + (Sr >>> 26) | 0, Sr &= 67108863, be = Math.imul(Ke, Wr), Me = Math.imul(Ke, or), Me = Me + Math.imul(rt, Wr) | 0, Re = Math.imul(rt, or), be = be + Math.imul(Gr, Zr) | 0, Me = Me + Math.imul(Gr, Xt) | 0, Me = Me + Math.imul(We, Zr) | 0, Re = Re + Math.imul(We, Xt) | 0, be = be + Math.imul(Dr, Ve) | 0, Me = Me + Math.imul(Dr, Ze) | 0, Me = Me + Math.imul(Jt, Ve) | 0, Re = Re + Math.imul(Jt, Ze) | 0, be = be + Math.imul(qr, Ue) | 0, Me = Me + Math.imul(qr, Qe) | 0, Me = Me + Math.imul(Wt, Ue) | 0, Re = Re + Math.imul(Wt, Qe) | 0, be = be + Math.imul(Hr, Ct) | 0, Me = Me + Math.imul(Hr, bt) | 0, Me = Me + Math.imul(tr, Ct) | 0, Re = Re + Math.imul(tr, bt) | 0, be = be + Math.imul(Tr, br) | 0, Me = Me + Math.imul(Tr, gr) | 0, Me = Me + Math.imul(Zt, br) | 0, Re = Re + Math.imul(Zt, gr) | 0;
      var Mr = (he + be | 0) + ((Me & 8191) << 13) | 0;
      he = (Re + (Me >>> 13) | 0) + (Mr >>> 26) | 0, Mr &= 67108863, be = Math.imul(Ke, Zr), Me = Math.imul(Ke, Xt), Me = Me + Math.imul(rt, Zr) | 0, Re = Math.imul(rt, Xt), be = be + Math.imul(Gr, Ve) | 0, Me = Me + Math.imul(Gr, Ze) | 0, Me = Me + Math.imul(We, Ve) | 0, Re = Re + Math.imul(We, Ze) | 0, be = be + Math.imul(Dr, Ue) | 0, Me = Me + Math.imul(Dr, Qe) | 0, Me = Me + Math.imul(Jt, Ue) | 0, Re = Re + Math.imul(Jt, Qe) | 0, be = be + Math.imul(qr, Ct) | 0, Me = Me + Math.imul(qr, bt) | 0, Me = Me + Math.imul(Wt, Ct) | 0, Re = Re + Math.imul(Wt, bt) | 0, be = be + Math.imul(Hr, br) | 0, Me = Me + Math.imul(Hr, gr) | 0, Me = Me + Math.imul(tr, br) | 0, Re = Re + Math.imul(tr, gr) | 0;
      var $r = (he + be | 0) + ((Me & 8191) << 13) | 0;
      he = (Re + (Me >>> 13) | 0) + ($r >>> 26) | 0, $r &= 67108863, be = Math.imul(Ke, Ve), Me = Math.imul(Ke, Ze), Me = Me + Math.imul(rt, Ve) | 0, Re = Math.imul(rt, Ze), be = be + Math.imul(Gr, Ue) | 0, Me = Me + Math.imul(Gr, Qe) | 0, Me = Me + Math.imul(We, Ue) | 0, Re = Re + Math.imul(We, Qe) | 0, be = be + Math.imul(Dr, Ct) | 0, Me = Me + Math.imul(Dr, bt) | 0, Me = Me + Math.imul(Jt, Ct) | 0, Re = Re + Math.imul(Jt, bt) | 0, be = be + Math.imul(qr, br) | 0, Me = Me + Math.imul(qr, gr) | 0, Me = Me + Math.imul(Wt, br) | 0, Re = Re + Math.imul(Wt, gr) | 0;
      var Yt = (he + be | 0) + ((Me & 8191) << 13) | 0;
      he = (Re + (Me >>> 13) | 0) + (Yt >>> 26) | 0, Yt &= 67108863, be = Math.imul(Ke, Ue), Me = Math.imul(Ke, Qe), Me = Me + Math.imul(rt, Ue) | 0, Re = Math.imul(rt, Qe), be = be + Math.imul(Gr, Ct) | 0, Me = Me + Math.imul(Gr, bt) | 0, Me = Me + Math.imul(We, Ct) | 0, Re = Re + Math.imul(We, bt) | 0, be = be + Math.imul(Dr, br) | 0, Me = Me + Math.imul(Dr, gr) | 0, Me = Me + Math.imul(Jt, br) | 0, Re = Re + Math.imul(Jt, gr) | 0;
      var er = (he + be | 0) + ((Me & 8191) << 13) | 0;
      he = (Re + (Me >>> 13) | 0) + (er >>> 26) | 0, er &= 67108863, be = Math.imul(Ke, Ct), Me = Math.imul(Ke, bt), Me = Me + Math.imul(rt, Ct) | 0, Re = Math.imul(rt, bt), be = be + Math.imul(Gr, br) | 0, Me = Me + Math.imul(Gr, gr) | 0, Me = Me + Math.imul(We, br) | 0, Re = Re + Math.imul(We, gr) | 0;
      var xr = (he + be | 0) + ((Me & 8191) << 13) | 0;
      he = (Re + (Me >>> 13) | 0) + (xr >>> 26) | 0, xr &= 67108863, be = Math.imul(Ke, br), Me = Math.imul(Ke, gr), Me = Me + Math.imul(rt, br) | 0, Re = Math.imul(rt, gr);
      var yr = (he + be | 0) + ((Me & 8191) << 13) | 0;
      return he = (Re + (Me >>> 13) | 0) + (yr >>> 26) | 0, yr &= 67108863, ve[0] = Fr, ve[1] = wr, ve[2] = Rr, ve[3] = kr, ve[4] = Pr, ve[5] = Ur, ve[6] = Ir, ve[7] = Or, ve[8] = Nr, ve[9] = Er, ve[10] = Br, ve[11] = _r, ve[12] = Sr, ve[13] = Mr, ve[14] = $r, ve[15] = Yt, ve[16] = er, ve[17] = xr, ve[18] = yr, he !== 0 && (ve[19] = he, xe.length++), xe;
    };
    Math.imul || (De = He);
    function Ge(pe, ge, ye) {
      ye.negative = ge.negative ^ pe.negative, ye.length = pe.length + ge.length;
      for (var xe = 0, _e = 0, Ae = 0; Ae < ye.length - 1; Ae++) {
        var ve = _e;
        _e = 0;
        for (var he = xe & 67108863, be = Math.min(Ae, ge.length - 1), Me = Math.max(0, Ae - pe.length + 1); Me <= be; Me++) {
          var Re = Ae - Me, Oe = pe.words[Re] | 0, Te = ge.words[Me] | 0, Fe = Oe * Te, je = Fe & 67108863;
          ve = ve + (Fe / 67108864 | 0) | 0, je = je + he | 0, he = je & 67108863, ve = ve + (je >>> 26) | 0, _e += ve >>> 26, ve &= 67108863;
        }
        ye.words[Ae] = he, xe = ve, ve = _e;
      }
      return xe !== 0 ? ye.words[Ae] = xe : ye.length--, ye._strip();
    }
    function Ye(pe, ge, ye) {
      return Ge(pe, ge, ye);
    }
    ce.prototype.mulTo = function(ge, ye) {
      var xe, _e = this.length + ge.length;
      return this.length === 10 && ge.length === 10 ? xe = De(this, ge, ye) : _e < 63 ? xe = He(this, ge, ye) : _e < 1024 ? xe = Ge(this, ge, ye) : xe = Ye(this, ge, ye), xe;
    }, ce.prototype.mul = function(ge) {
      var ye = new ce(null);
      return ye.words = new Array(this.length + ge.length), this.mulTo(ge, ye);
    }, ce.prototype.mulf = function(ge) {
      var ye = new ce(null);
      return ye.words = new Array(this.length + ge.length), Ye(this, ge, ye);
    }, ce.prototype.imul = function(ge) {
      return this.clone().mulTo(ge, this);
    }, ce.prototype.imuln = function(ge) {
      var ye = ge < 0;
      ye && (ge = -ge), fe(typeof ge == "number"), fe(ge < 67108864);
      for (var xe = 0, _e = 0; _e < this.length; _e++) {
        var Ae = (this.words[_e] | 0) * ge, ve = (Ae & 67108863) + (xe & 67108863);
        xe >>= 26, xe += Ae / 67108864 | 0, xe += ve >>> 26, this.words[_e] = ve & 67108863;
      }
      return xe !== 0 && (this.words[_e] = xe, this.length++), ye ? this.ineg() : this;
    }, ce.prototype.muln = function(ge) {
      return this.clone().imuln(ge);
    }, ce.prototype.sqr = function() {
      return this.mul(this);
    }, ce.prototype.isqr = function() {
      return this.imul(this.clone());
    }, ce.prototype.pow = function(ge) {
      var ye = ke(ge);
      if (ye.length === 0)
        return new ce(1);
      for (var xe = this, _e = 0; _e < ye.length && ye[_e] === 0; _e++, xe = xe.sqr())
        ;
      if (++_e < ye.length)
        for (var Ae = xe.sqr(); _e < ye.length; _e++, Ae = Ae.sqr())
          ye[_e] !== 0 && (xe = xe.mul(Ae));
      return xe;
    }, ce.prototype.iushln = function(ge) {
      fe(typeof ge == "number" && ge >= 0);
      var ye = ge % 26, xe = (ge - ye) / 26, _e = 67108863 >>> 26 - ye << 26 - ye, Ae;
      if (ye !== 0) {
        var ve = 0;
        for (Ae = 0; Ae < this.length; Ae++) {
          var he = this.words[Ae] & _e, be = (this.words[Ae] | 0) - he << ye;
          this.words[Ae] = be | ve, ve = he >>> 26 - ye;
        }
        ve && (this.words[Ae] = ve, this.length++);
      }
      if (xe !== 0) {
        for (Ae = this.length - 1; Ae >= 0; Ae--)
          this.words[Ae + xe] = this.words[Ae];
        for (Ae = 0; Ae < xe; Ae++)
          this.words[Ae] = 0;
        this.length += xe;
      }
      return this._strip();
    }, ce.prototype.ishln = function(ge) {
      return fe(this.negative === 0), this.iushln(ge);
    }, ce.prototype.iushrn = function(ge, ye, xe) {
      fe(typeof ge == "number" && ge >= 0);
      var _e;
      ye ? _e = (ye - ye % 26) / 26 : _e = 0;
      var Ae = ge % 26, ve = Math.min((ge - Ae) / 26, this.length), he = 67108863 ^ 67108863 >>> Ae << Ae, be = xe;
      if (_e -= ve, _e = Math.max(0, _e), be) {
        for (var Me = 0; Me < ve; Me++)
          be.words[Me] = this.words[Me];
        be.length = ve;
      }
      if (ve !== 0)
        if (this.length > ve)
          for (this.length -= ve, Me = 0; Me < this.length; Me++)
            this.words[Me] = this.words[Me + ve];
        else
          this.words[0] = 0, this.length = 1;
      var Re = 0;
      for (Me = this.length - 1; Me >= 0 && (Re !== 0 || Me >= _e); Me--) {
        var Oe = this.words[Me] | 0;
        this.words[Me] = Re << 26 - Ae | Oe >>> Ae, Re = Oe & he;
      }
      return be && Re !== 0 && (be.words[be.length++] = Re), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, ce.prototype.ishrn = function(ge, ye, xe) {
      return fe(this.negative === 0), this.iushrn(ge, ye, xe);
    }, ce.prototype.shln = function(ge) {
      return this.clone().ishln(ge);
    }, ce.prototype.ushln = function(ge) {
      return this.clone().iushln(ge);
    }, ce.prototype.shrn = function(ge) {
      return this.clone().ishrn(ge);
    }, ce.prototype.ushrn = function(ge) {
      return this.clone().iushrn(ge);
    }, ce.prototype.testn = function(ge) {
      fe(typeof ge == "number" && ge >= 0);
      var ye = ge % 26, xe = (ge - ye) / 26, _e = 1 << ye;
      if (this.length <= xe)
        return !1;
      var Ae = this.words[xe];
      return !!(Ae & _e);
    }, ce.prototype.imaskn = function(ge) {
      fe(typeof ge == "number" && ge >= 0);
      var ye = ge % 26, xe = (ge - ye) / 26;
      if (fe(this.negative === 0, "imaskn works only with positive numbers"), this.length <= xe)
        return this;
      if (ye !== 0 && xe++, this.length = Math.min(xe, this.length), ye !== 0) {
        var _e = 67108863 ^ 67108863 >>> ye << ye;
        this.words[this.length - 1] &= _e;
      }
      return this._strip();
    }, ce.prototype.maskn = function(ge) {
      return this.clone().imaskn(ge);
    }, ce.prototype.iaddn = function(ge) {
      return fe(typeof ge == "number"), fe(ge < 67108864), ge < 0 ? this.isubn(-ge) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= ge ? (this.words[0] = ge - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(ge), this.negative = 1, this) : this._iaddn(ge);
    }, ce.prototype._iaddn = function(ge) {
      this.words[0] += ge;
      for (var ye = 0; ye < this.length && this.words[ye] >= 67108864; ye++)
        this.words[ye] -= 67108864, ye === this.length - 1 ? this.words[ye + 1] = 1 : this.words[ye + 1]++;
      return this.length = Math.max(this.length, ye + 1), this;
    }, ce.prototype.isubn = function(ge) {
      if (fe(typeof ge == "number"), fe(ge < 67108864), ge < 0)
        return this.iaddn(-ge);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(ge), this.negative = 1, this;
      if (this.words[0] -= ge, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var ye = 0; ye < this.length && this.words[ye] < 0; ye++)
          this.words[ye] += 67108864, this.words[ye + 1] -= 1;
      return this._strip();
    }, ce.prototype.addn = function(ge) {
      return this.clone().iaddn(ge);
    }, ce.prototype.subn = function(ge) {
      return this.clone().isubn(ge);
    }, ce.prototype.iabs = function() {
      return this.negative = 0, this;
    }, ce.prototype.abs = function() {
      return this.clone().iabs();
    }, ce.prototype._ishlnsubmul = function(ge, ye, xe) {
      var _e = ge.length + xe, Ae;
      this._expand(_e);
      var ve, he = 0;
      for (Ae = 0; Ae < ge.length; Ae++) {
        ve = (this.words[Ae + xe] | 0) + he;
        var be = (ge.words[Ae] | 0) * ye;
        ve -= be & 67108863, he = (ve >> 26) - (be / 67108864 | 0), this.words[Ae + xe] = ve & 67108863;
      }
      for (; Ae < this.length - xe; Ae++)
        ve = (this.words[Ae + xe] | 0) + he, he = ve >> 26, this.words[Ae + xe] = ve & 67108863;
      if (he === 0)
        return this._strip();
      for (fe(he === -1), he = 0, Ae = 0; Ae < this.length; Ae++)
        ve = -(this.words[Ae] | 0) + he, he = ve >> 26, this.words[Ae] = ve & 67108863;
      return this.negative = 1, this._strip();
    }, ce.prototype._wordDiv = function(ge, ye) {
      var xe = this.length - ge.length, _e = this.clone(), Ae = ge, ve = Ae.words[Ae.length - 1] | 0, he = this._countBits(ve);
      xe = 26 - he, xe !== 0 && (Ae = Ae.ushln(xe), _e.iushln(xe), ve = Ae.words[Ae.length - 1] | 0);
      var be = _e.length - Ae.length, Me;
      if (ye !== "mod") {
        Me = new ce(null), Me.length = be + 1, Me.words = new Array(Me.length);
        for (var Re = 0; Re < Me.length; Re++)
          Me.words[Re] = 0;
      }
      var Oe = _e.clone()._ishlnsubmul(Ae, 1, be);
      Oe.negative === 0 && (_e = Oe, Me && (Me.words[be] = 1));
      for (var Te = be - 1; Te >= 0; Te--) {
        var Fe = (_e.words[Ae.length + Te] | 0) * 67108864 + (_e.words[Ae.length + Te - 1] | 0);
        for (Fe = Math.min(Fe / ve | 0, 67108863), _e._ishlnsubmul(Ae, Fe, Te); _e.negative !== 0; )
          Fe--, _e.negative = 0, _e._ishlnsubmul(Ae, 1, Te), _e.isZero() || (_e.negative ^= 1);
        Me && (Me.words[Te] = Fe);
      }
      return Me && Me._strip(), _e._strip(), ye !== "div" && xe !== 0 && _e.iushrn(xe), {
        div: Me || null,
        mod: _e
      };
    }, ce.prototype.divmod = function(ge, ye, xe) {
      if (fe(!ge.isZero()), this.isZero())
        return {
          div: new ce(0),
          mod: new ce(0)
        };
      var _e, Ae, ve;
      return this.negative !== 0 && ge.negative === 0 ? (ve = this.neg().divmod(ge, ye), ye !== "mod" && (_e = ve.div.neg()), ye !== "div" && (Ae = ve.mod.neg(), xe && Ae.negative !== 0 && Ae.iadd(ge)), {
        div: _e,
        mod: Ae
      }) : this.negative === 0 && ge.negative !== 0 ? (ve = this.divmod(ge.neg(), ye), ye !== "mod" && (_e = ve.div.neg()), {
        div: _e,
        mod: ve.mod
      }) : this.negative & ge.negative ? (ve = this.neg().divmod(ge.neg(), ye), ye !== "div" && (Ae = ve.mod.neg(), xe && Ae.negative !== 0 && Ae.isub(ge)), {
        div: ve.div,
        mod: Ae
      }) : ge.length > this.length || this.cmp(ge) < 0 ? {
        div: new ce(0),
        mod: this
      } : ge.length === 1 ? ye === "div" ? {
        div: this.divn(ge.words[0]),
        mod: null
      } : ye === "mod" ? {
        div: null,
        mod: new ce(this.modrn(ge.words[0]))
      } : {
        div: this.divn(ge.words[0]),
        mod: new ce(this.modrn(ge.words[0]))
      } : this._wordDiv(ge, ye);
    }, ce.prototype.div = function(ge) {
      return this.divmod(ge, "div", !1).div;
    }, ce.prototype.mod = function(ge) {
      return this.divmod(ge, "mod", !1).mod;
    }, ce.prototype.umod = function(ge) {
      return this.divmod(ge, "mod", !0).mod;
    }, ce.prototype.divRound = function(ge) {
      var ye = this.divmod(ge);
      if (ye.mod.isZero())
        return ye.div;
      var xe = ye.div.negative !== 0 ? ye.mod.isub(ge) : ye.mod, _e = ge.ushrn(1), Ae = ge.andln(1), ve = xe.cmp(_e);
      return ve < 0 || Ae === 1 && ve === 0 ? ye.div : ye.div.negative !== 0 ? ye.div.isubn(1) : ye.div.iaddn(1);
    }, ce.prototype.modrn = function(ge) {
      var ye = ge < 0;
      ye && (ge = -ge), fe(ge <= 67108863);
      for (var xe = (1 << 26) % ge, _e = 0, Ae = this.length - 1; Ae >= 0; Ae--)
        _e = (xe * _e + (this.words[Ae] | 0)) % ge;
      return ye ? -_e : _e;
    }, ce.prototype.modn = function(ge) {
      return this.modrn(ge);
    }, ce.prototype.idivn = function(ge) {
      var ye = ge < 0;
      ye && (ge = -ge), fe(ge <= 67108863);
      for (var xe = 0, _e = this.length - 1; _e >= 0; _e--) {
        var Ae = (this.words[_e] | 0) + xe * 67108864;
        this.words[_e] = Ae / ge | 0, xe = Ae % ge;
      }
      return this._strip(), ye ? this.ineg() : this;
    }, ce.prototype.divn = function(ge) {
      return this.clone().idivn(ge);
    }, ce.prototype.egcd = function(ge) {
      fe(ge.negative === 0), fe(!ge.isZero());
      var ye = this, xe = ge.clone();
      ye.negative !== 0 ? ye = ye.umod(ge) : ye = ye.clone();
      for (var _e = new ce(1), Ae = new ce(0), ve = new ce(0), he = new ce(1), be = 0; ye.isEven() && xe.isEven(); )
        ye.iushrn(1), xe.iushrn(1), ++be;
      for (var Me = xe.clone(), Re = ye.clone(); !ye.isZero(); ) {
        for (var Oe = 0, Te = 1; !(ye.words[0] & Te) && Oe < 26; ++Oe, Te <<= 1)
          ;
        if (Oe > 0)
          for (ye.iushrn(Oe); Oe-- > 0; )
            (_e.isOdd() || Ae.isOdd()) && (_e.iadd(Me), Ae.isub(Re)), _e.iushrn(1), Ae.iushrn(1);
        for (var Fe = 0, je = 1; !(xe.words[0] & je) && Fe < 26; ++Fe, je <<= 1)
          ;
        if (Fe > 0)
          for (xe.iushrn(Fe); Fe-- > 0; )
            (ve.isOdd() || he.isOdd()) && (ve.iadd(Me), he.isub(Re)), ve.iushrn(1), he.iushrn(1);
        ye.cmp(xe) >= 0 ? (ye.isub(xe), _e.isub(ve), Ae.isub(he)) : (xe.isub(ye), ve.isub(_e), he.isub(Ae));
      }
      return {
        a: ve,
        b: he,
        gcd: xe.iushln(be)
      };
    }, ce.prototype._invmp = function(ge) {
      fe(ge.negative === 0), fe(!ge.isZero());
      var ye = this, xe = ge.clone();
      ye.negative !== 0 ? ye = ye.umod(ge) : ye = ye.clone();
      for (var _e = new ce(1), Ae = new ce(0), ve = xe.clone(); ye.cmpn(1) > 0 && xe.cmpn(1) > 0; ) {
        for (var he = 0, be = 1; !(ye.words[0] & be) && he < 26; ++he, be <<= 1)
          ;
        if (he > 0)
          for (ye.iushrn(he); he-- > 0; )
            _e.isOdd() && _e.iadd(ve), _e.iushrn(1);
        for (var Me = 0, Re = 1; !(xe.words[0] & Re) && Me < 26; ++Me, Re <<= 1)
          ;
        if (Me > 0)
          for (xe.iushrn(Me); Me-- > 0; )
            Ae.isOdd() && Ae.iadd(ve), Ae.iushrn(1);
        ye.cmp(xe) >= 0 ? (ye.isub(xe), _e.isub(Ae)) : (xe.isub(ye), Ae.isub(_e));
      }
      var Oe;
      return ye.cmpn(1) === 0 ? Oe = _e : Oe = Ae, Oe.cmpn(0) < 0 && Oe.iadd(ge), Oe;
    }, ce.prototype.gcd = function(ge) {
      if (this.isZero())
        return ge.abs();
      if (ge.isZero())
        return this.abs();
      var ye = this.clone(), xe = ge.clone();
      ye.negative = 0, xe.negative = 0;
      for (var _e = 0; ye.isEven() && xe.isEven(); _e++)
        ye.iushrn(1), xe.iushrn(1);
      do {
        for (; ye.isEven(); )
          ye.iushrn(1);
        for (; xe.isEven(); )
          xe.iushrn(1);
        var Ae = ye.cmp(xe);
        if (Ae < 0) {
          var ve = ye;
          ye = xe, xe = ve;
        } else if (Ae === 0 || xe.cmpn(1) === 0)
          break;
        ye.isub(xe);
      } while (!0);
      return xe.iushln(_e);
    }, ce.prototype.invm = function(ge) {
      return this.egcd(ge).a.umod(ge);
    }, ce.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, ce.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, ce.prototype.andln = function(ge) {
      return this.words[0] & ge;
    }, ce.prototype.bincn = function(ge) {
      fe(typeof ge == "number");
      var ye = ge % 26, xe = (ge - ye) / 26, _e = 1 << ye;
      if (this.length <= xe)
        return this._expand(xe + 1), this.words[xe] |= _e, this;
      for (var Ae = _e, ve = xe; Ae !== 0 && ve < this.length; ve++) {
        var he = this.words[ve] | 0;
        he += Ae, Ae = he >>> 26, he &= 67108863, this.words[ve] = he;
      }
      return Ae !== 0 && (this.words[ve] = Ae, this.length++), this;
    }, ce.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, ce.prototype.cmpn = function(ge) {
      var ye = ge < 0;
      if (this.negative !== 0 && !ye)
        return -1;
      if (this.negative === 0 && ye)
        return 1;
      this._strip();
      var xe;
      if (this.length > 1)
        xe = 1;
      else {
        ye && (ge = -ge), fe(ge <= 67108863, "Number is too big");
        var _e = this.words[0] | 0;
        xe = _e === ge ? 0 : _e < ge ? -1 : 1;
      }
      return this.negative !== 0 ? -xe | 0 : xe;
    }, ce.prototype.cmp = function(ge) {
      if (this.negative !== 0 && ge.negative === 0)
        return -1;
      if (this.negative === 0 && ge.negative !== 0)
        return 1;
      var ye = this.ucmp(ge);
      return this.negative !== 0 ? -ye | 0 : ye;
    }, ce.prototype.ucmp = function(ge) {
      if (this.length > ge.length)
        return 1;
      if (this.length < ge.length)
        return -1;
      for (var ye = 0, xe = this.length - 1; xe >= 0; xe--) {
        var _e = this.words[xe] | 0, Ae = ge.words[xe] | 0;
        if (_e !== Ae) {
          _e < Ae ? ye = -1 : _e > Ae && (ye = 1);
          break;
        }
      }
      return ye;
    }, ce.prototype.gtn = function(ge) {
      return this.cmpn(ge) === 1;
    }, ce.prototype.gt = function(ge) {
      return this.cmp(ge) === 1;
    }, ce.prototype.gten = function(ge) {
      return this.cmpn(ge) >= 0;
    }, ce.prototype.gte = function(ge) {
      return this.cmp(ge) >= 0;
    }, ce.prototype.ltn = function(ge) {
      return this.cmpn(ge) === -1;
    }, ce.prototype.lt = function(ge) {
      return this.cmp(ge) === -1;
    }, ce.prototype.lten = function(ge) {
      return this.cmpn(ge) <= 0;
    }, ce.prototype.lte = function(ge) {
      return this.cmp(ge) <= 0;
    }, ce.prototype.eqn = function(ge) {
      return this.cmpn(ge) === 0;
    }, ce.prototype.eq = function(ge) {
      return this.cmp(ge) === 0;
    }, ce.red = function(ge) {
      return new $e(ge);
    }, ce.prototype.toRed = function(ge) {
      return fe(!this.red, "Already a number in reduction context"), fe(this.negative === 0, "red works only with positives"), ge.convertTo(this)._forceRed(ge);
    }, ce.prototype.fromRed = function() {
      return fe(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, ce.prototype._forceRed = function(ge) {
      return this.red = ge, this;
    }, ce.prototype.forceRed = function(ge) {
      return fe(!this.red, "Already a number in reduction context"), this._forceRed(ge);
    }, ce.prototype.redAdd = function(ge) {
      return fe(this.red, "redAdd works only with red numbers"), this.red.add(this, ge);
    }, ce.prototype.redIAdd = function(ge) {
      return fe(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, ge);
    }, ce.prototype.redSub = function(ge) {
      return fe(this.red, "redSub works only with red numbers"), this.red.sub(this, ge);
    }, ce.prototype.redISub = function(ge) {
      return fe(this.red, "redISub works only with red numbers"), this.red.isub(this, ge);
    }, ce.prototype.redShl = function(ge) {
      return fe(this.red, "redShl works only with red numbers"), this.red.shl(this, ge);
    }, ce.prototype.redMul = function(ge) {
      return fe(this.red, "redMul works only with red numbers"), this.red._verify2(this, ge), this.red.mul(this, ge);
    }, ce.prototype.redIMul = function(ge) {
      return fe(this.red, "redMul works only with red numbers"), this.red._verify2(this, ge), this.red.imul(this, ge);
    }, ce.prototype.redSqr = function() {
      return fe(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, ce.prototype.redISqr = function() {
      return fe(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, ce.prototype.redSqrt = function() {
      return fe(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, ce.prototype.redInvm = function() {
      return fe(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, ce.prototype.redNeg = function() {
      return fe(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, ce.prototype.redPow = function(ge) {
      return fe(this.red && !ge.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, ge);
    };
    var st = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function at(pe, ge) {
      this.name = pe, this.p = new ce(ge, 16), this.n = this.p.bitLength(), this.k = new ce(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    at.prototype._tmp = function() {
      var ge = new ce(null);
      return ge.words = new Array(Math.ceil(this.n / 13)), ge;
    }, at.prototype.ireduce = function(ge) {
      var ye = ge, xe;
      do
        this.split(ye, this.tmp), ye = this.imulK(ye), ye = ye.iadd(this.tmp), xe = ye.bitLength();
      while (xe > this.n);
      var _e = xe < this.n ? -1 : ye.ucmp(this.p);
      return _e === 0 ? (ye.words[0] = 0, ye.length = 1) : _e > 0 ? ye.isub(this.p) : ye.strip !== void 0 ? ye.strip() : ye._strip(), ye;
    }, at.prototype.split = function(ge, ye) {
      ge.iushrn(this.n, 0, ye);
    }, at.prototype.imulK = function(ge) {
      return ge.imul(this.k);
    };
    function mt() {
      at.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    ue(mt, at), mt.prototype.split = function(ge, ye) {
      for (var xe = 4194303, _e = Math.min(ge.length, 9), Ae = 0; Ae < _e; Ae++)
        ye.words[Ae] = ge.words[Ae];
      if (ye.length = _e, ge.length <= 9) {
        ge.words[0] = 0, ge.length = 1;
        return;
      }
      var ve = ge.words[9];
      for (ye.words[ye.length++] = ve & xe, Ae = 10; Ae < ge.length; Ae++) {
        var he = ge.words[Ae] | 0;
        ge.words[Ae - 10] = (he & xe) << 4 | ve >>> 22, ve = he;
      }
      ve >>>= 22, ge.words[Ae - 10] = ve, ve === 0 && ge.length > 10 ? ge.length -= 10 : ge.length -= 9;
    }, mt.prototype.imulK = function(ge) {
      ge.words[ge.length] = 0, ge.words[ge.length + 1] = 0, ge.length += 2;
      for (var ye = 0, xe = 0; xe < ge.length; xe++) {
        var _e = ge.words[xe] | 0;
        ye += _e * 977, ge.words[xe] = ye & 67108863, ye = _e * 64 + (ye / 67108864 | 0);
      }
      return ge.words[ge.length - 1] === 0 && (ge.length--, ge.words[ge.length - 1] === 0 && ge.length--), ge;
    };
    function qe() {
      at.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    ue(qe, at);
    function ze() {
      at.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    ue(ze, at);
    function ot() {
      at.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    ue(ot, at), ot.prototype.imulK = function(ge) {
      for (var ye = 0, xe = 0; xe < ge.length; xe++) {
        var _e = (ge.words[xe] | 0) * 19 + ye, Ae = _e & 67108863;
        _e >>>= 26, ge.words[xe] = Ae, ye = _e;
      }
      return ye !== 0 && (ge.words[ge.length++] = ye), ge;
    }, ce._prime = function(ge) {
      if (st[ge])
        return st[ge];
      var ye;
      if (ge === "k256")
        ye = new mt();
      else if (ge === "p224")
        ye = new qe();
      else if (ge === "p192")
        ye = new ze();
      else if (ge === "p25519")
        ye = new ot();
      else
        throw new Error("Unknown prime " + ge);
      return st[ge] = ye, ye;
    };
    function $e(pe) {
      if (typeof pe == "string") {
        var ge = ce._prime(pe);
        this.m = ge.p, this.prime = ge;
      } else
        fe(pe.gtn(1), "modulus must be greater than 1"), this.m = pe, this.prime = null;
    }
    $e.prototype._verify1 = function(ge) {
      fe(ge.negative === 0, "red works only with positives"), fe(ge.red, "red works only with red numbers");
    }, $e.prototype._verify2 = function(ge, ye) {
      fe((ge.negative | ye.negative) === 0, "red works only with positives"), fe(
        ge.red && ge.red === ye.red,
        "red works only with red numbers"
      );
    }, $e.prototype.imod = function(ge) {
      return this.prime ? this.prime.ireduce(ge)._forceRed(this) : (Se(ge, ge.umod(this.m)._forceRed(this)), ge);
    }, $e.prototype.neg = function(ge) {
      return ge.isZero() ? ge.clone() : this.m.sub(ge)._forceRed(this);
    }, $e.prototype.add = function(ge, ye) {
      this._verify2(ge, ye);
      var xe = ge.add(ye);
      return xe.cmp(this.m) >= 0 && xe.isub(this.m), xe._forceRed(this);
    }, $e.prototype.iadd = function(ge, ye) {
      this._verify2(ge, ye);
      var xe = ge.iadd(ye);
      return xe.cmp(this.m) >= 0 && xe.isub(this.m), xe;
    }, $e.prototype.sub = function(ge, ye) {
      this._verify2(ge, ye);
      var xe = ge.sub(ye);
      return xe.cmpn(0) < 0 && xe.iadd(this.m), xe._forceRed(this);
    }, $e.prototype.isub = function(ge, ye) {
      this._verify2(ge, ye);
      var xe = ge.isub(ye);
      return xe.cmpn(0) < 0 && xe.iadd(this.m), xe;
    }, $e.prototype.shl = function(ge, ye) {
      return this._verify1(ge), this.imod(ge.ushln(ye));
    }, $e.prototype.imul = function(ge, ye) {
      return this._verify2(ge, ye), this.imod(ge.imul(ye));
    }, $e.prototype.mul = function(ge, ye) {
      return this._verify2(ge, ye), this.imod(ge.mul(ye));
    }, $e.prototype.isqr = function(ge) {
      return this.imul(ge, ge.clone());
    }, $e.prototype.sqr = function(ge) {
      return this.mul(ge, ge);
    }, $e.prototype.sqrt = function(ge) {
      if (ge.isZero())
        return ge.clone();
      var ye = this.m.andln(3);
      if (fe(ye % 2 === 1), ye === 3) {
        var xe = this.m.add(new ce(1)).iushrn(2);
        return this.pow(ge, xe);
      }
      for (var _e = this.m.subn(1), Ae = 0; !_e.isZero() && _e.andln(1) === 0; )
        Ae++, _e.iushrn(1);
      fe(!_e.isZero());
      var ve = new ce(1).toRed(this), he = ve.redNeg(), be = this.m.subn(1).iushrn(1), Me = this.m.bitLength();
      for (Me = new ce(2 * Me * Me).toRed(this); this.pow(Me, be).cmp(he) !== 0; )
        Me.redIAdd(he);
      for (var Re = this.pow(Me, _e), Oe = this.pow(ge, _e.addn(1).iushrn(1)), Te = this.pow(ge, _e), Fe = Ae; Te.cmp(ve) !== 0; ) {
        for (var je = Te, ct = 0; je.cmp(ve) !== 0; ct++)
          je = je.redSqr();
        fe(ct < Fe);
        var nt = this.pow(Re, new ce(1).iushln(Fe - ct - 1));
        Oe = Oe.redMul(nt), Re = nt.redSqr(), Te = Te.redMul(Re), Fe = ct;
      }
      return Oe;
    }, $e.prototype.invm = function(ge) {
      var ye = ge._invmp(this.m);
      return ye.negative !== 0 ? (ye.negative = 0, this.imod(ye).redNeg()) : this.imod(ye);
    }, $e.prototype.pow = function(ge, ye) {
      if (ye.isZero())
        return new ce(1).toRed(this);
      if (ye.cmpn(1) === 0)
        return ge.clone();
      var xe = 4, _e = new Array(1 << xe);
      _e[0] = new ce(1).toRed(this), _e[1] = ge;
      for (var Ae = 2; Ae < _e.length; Ae++)
        _e[Ae] = this.mul(_e[Ae - 1], ge);
      var ve = _e[0], he = 0, be = 0, Me = ye.bitLength() % 26;
      for (Me === 0 && (Me = 26), Ae = ye.length - 1; Ae >= 0; Ae--) {
        for (var Re = ye.words[Ae], Oe = Me - 1; Oe >= 0; Oe--) {
          var Te = Re >> Oe & 1;
          if (ve !== _e[0] && (ve = this.sqr(ve)), Te === 0 && he === 0) {
            be = 0;
            continue;
          }
          he <<= 1, he |= Te, be++, !(be !== xe && (Ae !== 0 || Oe !== 0)) && (ve = this.mul(ve, _e[he]), be = 0, he = 0);
        }
        Me = 26;
      }
      return ve;
    }, $e.prototype.convertTo = function(ge) {
      var ye = ge.umod(this.m);
      return ye === ge ? ye.clone() : ye;
    }, $e.prototype.convertFrom = function(ge) {
      var ye = ge.clone();
      return ye.red = null, ye;
    }, ce.mont = function(ge) {
      return new le(ge);
    };
    function le(pe) {
      $e.call(this, pe), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new ce(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    ue(le, $e), le.prototype.convertTo = function(ge) {
      return this.imod(ge.ushln(this.shift));
    }, le.prototype.convertFrom = function(ge) {
      var ye = this.imod(ge.mul(this.rinv));
      return ye.red = null, ye;
    }, le.prototype.imul = function(ge, ye) {
      if (ge.isZero() || ye.isZero())
        return ge.words[0] = 0, ge.length = 1, ge;
      var xe = ge.imul(ye), _e = xe.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Ae = xe.isub(_e).iushrn(this.shift), ve = Ae;
      return Ae.cmp(this.m) >= 0 ? ve = Ae.isub(this.m) : Ae.cmpn(0) < 0 && (ve = Ae.iadd(this.m)), ve._forceRed(this);
    }, le.prototype.mul = function(ge, ye) {
      if (ge.isZero() || ye.isZero())
        return new ce(0)._forceRed(this);
      var xe = ge.mul(ye), _e = xe.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Ae = xe.isub(_e).iushrn(this.shift), ve = Ae;
      return Ae.cmp(this.m) >= 0 ? ve = Ae.isub(this.m) : Ae.cmpn(0) < 0 && (ve = Ae.iadd(this.m)), ve._forceRed(this);
    }, le.prototype.invm = function(ge) {
      var ye = this.imod(ge._invmp(this.m).mul(this.r2));
      return ye._forceRed(this);
    };
  })(ae, commonjsGlobal);
})(bn$4);
var bnExports$4 = bn$4.exports;
const BN$d = /* @__PURE__ */ getDefaultExportFromCjs$2(bnExports$4);
var BN$c = bnExports$4, randomBytes$3 = browserExports;
function blind(ae) {
  var ie = getr(ae), se = ie.toRed(BN$c.mont(ae.modulus)).redPow(new BN$c(ae.publicExponent)).fromRed();
  return { blinder: se, unblinder: ie.invm(ae.modulus) };
}
function getr(ae) {
  var ie = ae.modulus.byteLength(), se;
  do
    se = new BN$c(randomBytes$3(ie));
  while (se.cmp(ae.modulus) >= 0 || !se.umod(ae.prime1) || !se.umod(ae.prime2));
  return se;
}
function crt$2(ae, ie) {
  var se = blind(ie), fe = ie.modulus.byteLength(), ue = new BN$c(ae).mul(se.blinder).umod(ie.modulus), ce = ue.toRed(BN$c.mont(ie.prime1)), de = ue.toRed(BN$c.mont(ie.prime2)), me = ie.coefficient, we = ie.prime1, Ee = ie.prime2, Se = ce.redPow(ie.exponent1).fromRed(), Be = de.redPow(ie.exponent2).fromRed(), Ce = Se.isub(Be).imul(me).umod(we).imul(Ee);
  return Be.iadd(Ce).imul(se.unblinder).umod(ie.modulus).toArrayLike(Buffer$F, "be", fe);
}
crt$2.getr = getr;
var browserifyRsa = crt$2, elliptic$2 = {};
const name = "elliptic", version$l = "6.5.4", description = "EC cryptography", main = "lib/elliptic.js", files = [
  "lib"
], scripts = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, repository = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, keywords = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], author = "Fedor Indutny <fedor@indutny.com>", license = "MIT", bugs = {
  url: "https://github.com/indutny/elliptic/issues"
}, homepage = "https://github.com/indutny/elliptic", devDependencies = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, dependencies = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, require$$0$1 = {
  name,
  version: version$l,
  description,
  main,
  files,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  dependencies
};
var utils$p = {}, bn$3 = { exports: {} };
bn$3.exports;
(function(ae) {
  (function(ie, se) {
    function fe($e, le) {
      if (!$e)
        throw new Error(le || "Assertion failed");
    }
    function ue($e, le) {
      $e.super_ = le;
      var pe = function() {
      };
      pe.prototype = le.prototype, $e.prototype = new pe(), $e.prototype.constructor = $e;
    }
    function ce($e, le, pe) {
      if (ce.isBN($e))
        return $e;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, $e !== null && ((le === "le" || le === "be") && (pe = le, le = 10), this._init($e || 0, le || 10, pe || "be"));
    }
    typeof ie == "object" ? ie.exports = ce : se.BN = ce, ce.BN = ce, ce.wordSize = 26;
    var de;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? de = window.Buffer : de = require$$0$2.Buffer;
    } catch {
    }
    ce.isBN = function(le) {
      return le instanceof ce ? !0 : le !== null && typeof le == "object" && le.constructor.wordSize === ce.wordSize && Array.isArray(le.words);
    }, ce.max = function(le, pe) {
      return le.cmp(pe) > 0 ? le : pe;
    }, ce.min = function(le, pe) {
      return le.cmp(pe) < 0 ? le : pe;
    }, ce.prototype._init = function(le, pe, ge) {
      if (typeof le == "number")
        return this._initNumber(le, pe, ge);
      if (typeof le == "object")
        return this._initArray(le, pe, ge);
      pe === "hex" && (pe = 16), fe(pe === (pe | 0) && pe >= 2 && pe <= 36), le = le.toString().replace(/\s+/g, "");
      var ye = 0;
      le[0] === "-" && (ye++, this.negative = 1), ye < le.length && (pe === 16 ? this._parseHex(le, ye, ge) : (this._parseBase(le, pe, ye), ge === "le" && this._initArray(this.toArray(), pe, ge)));
    }, ce.prototype._initNumber = function(le, pe, ge) {
      le < 0 && (this.negative = 1, le = -le), le < 67108864 ? (this.words = [le & 67108863], this.length = 1) : le < 4503599627370496 ? (this.words = [
        le & 67108863,
        le / 67108864 & 67108863
      ], this.length = 2) : (fe(le < 9007199254740992), this.words = [
        le & 67108863,
        le / 67108864 & 67108863,
        1
      ], this.length = 3), ge === "le" && this._initArray(this.toArray(), pe, ge);
    }, ce.prototype._initArray = function(le, pe, ge) {
      if (fe(typeof le.length == "number"), le.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(le.length / 3), this.words = new Array(this.length);
      for (var ye = 0; ye < this.length; ye++)
        this.words[ye] = 0;
      var xe, _e, Ae = 0;
      if (ge === "be")
        for (ye = le.length - 1, xe = 0; ye >= 0; ye -= 3)
          _e = le[ye] | le[ye - 1] << 8 | le[ye - 2] << 16, this.words[xe] |= _e << Ae & 67108863, this.words[xe + 1] = _e >>> 26 - Ae & 67108863, Ae += 24, Ae >= 26 && (Ae -= 26, xe++);
      else if (ge === "le")
        for (ye = 0, xe = 0; ye < le.length; ye += 3)
          _e = le[ye] | le[ye + 1] << 8 | le[ye + 2] << 16, this.words[xe] |= _e << Ae & 67108863, this.words[xe + 1] = _e >>> 26 - Ae & 67108863, Ae += 24, Ae >= 26 && (Ae -= 26, xe++);
      return this.strip();
    };
    function me($e, le) {
      var pe = $e.charCodeAt(le);
      return pe >= 65 && pe <= 70 ? pe - 55 : pe >= 97 && pe <= 102 ? pe - 87 : pe - 48 & 15;
    }
    function we($e, le, pe) {
      var ge = me($e, pe);
      return pe - 1 >= le && (ge |= me($e, pe - 1) << 4), ge;
    }
    ce.prototype._parseHex = function(le, pe, ge) {
      this.length = Math.ceil((le.length - pe) / 6), this.words = new Array(this.length);
      for (var ye = 0; ye < this.length; ye++)
        this.words[ye] = 0;
      var xe = 0, _e = 0, Ae;
      if (ge === "be")
        for (ye = le.length - 1; ye >= pe; ye -= 2)
          Ae = we(le, pe, ye) << xe, this.words[_e] |= Ae & 67108863, xe >= 18 ? (xe -= 18, _e += 1, this.words[_e] |= Ae >>> 26) : xe += 8;
      else {
        var ve = le.length - pe;
        for (ye = ve % 2 === 0 ? pe + 1 : pe; ye < le.length; ye += 2)
          Ae = we(le, pe, ye) << xe, this.words[_e] |= Ae & 67108863, xe >= 18 ? (xe -= 18, _e += 1, this.words[_e] |= Ae >>> 26) : xe += 8;
      }
      this.strip();
    };
    function Ee($e, le, pe, ge) {
      for (var ye = 0, xe = Math.min($e.length, pe), _e = le; _e < xe; _e++) {
        var Ae = $e.charCodeAt(_e) - 48;
        ye *= ge, Ae >= 49 ? ye += Ae - 49 + 10 : Ae >= 17 ? ye += Ae - 17 + 10 : ye += Ae;
      }
      return ye;
    }
    ce.prototype._parseBase = function(le, pe, ge) {
      this.words = [0], this.length = 1;
      for (var ye = 0, xe = 1; xe <= 67108863; xe *= pe)
        ye++;
      ye--, xe = xe / pe | 0;
      for (var _e = le.length - ge, Ae = _e % ye, ve = Math.min(_e, _e - Ae) + ge, he = 0, be = ge; be < ve; be += ye)
        he = Ee(le, be, be + ye, pe), this.imuln(xe), this.words[0] + he < 67108864 ? this.words[0] += he : this._iaddn(he);
      if (Ae !== 0) {
        var Me = 1;
        for (he = Ee(le, be, le.length, pe), be = 0; be < Ae; be++)
          Me *= pe;
        this.imuln(Me), this.words[0] + he < 67108864 ? this.words[0] += he : this._iaddn(he);
      }
      this.strip();
    }, ce.prototype.copy = function(le) {
      le.words = new Array(this.length);
      for (var pe = 0; pe < this.length; pe++)
        le.words[pe] = this.words[pe];
      le.length = this.length, le.negative = this.negative, le.red = this.red;
    }, ce.prototype.clone = function() {
      var le = new ce(null);
      return this.copy(le), le;
    }, ce.prototype._expand = function(le) {
      for (; this.length < le; )
        this.words[this.length++] = 0;
      return this;
    }, ce.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, ce.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, ce.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var Se = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], Be = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], Ce = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    ce.prototype.toString = function(le, pe) {
      le = le || 10, pe = pe | 0 || 1;
      var ge;
      if (le === 16 || le === "hex") {
        ge = "";
        for (var ye = 0, xe = 0, _e = 0; _e < this.length; _e++) {
          var Ae = this.words[_e], ve = ((Ae << ye | xe) & 16777215).toString(16);
          xe = Ae >>> 24 - ye & 16777215, xe !== 0 || _e !== this.length - 1 ? ge = Se[6 - ve.length] + ve + ge : ge = ve + ge, ye += 2, ye >= 26 && (ye -= 26, _e--);
        }
        for (xe !== 0 && (ge = xe.toString(16) + ge); ge.length % pe !== 0; )
          ge = "0" + ge;
        return this.negative !== 0 && (ge = "-" + ge), ge;
      }
      if (le === (le | 0) && le >= 2 && le <= 36) {
        var he = Be[le], be = Ce[le];
        ge = "";
        var Me = this.clone();
        for (Me.negative = 0; !Me.isZero(); ) {
          var Re = Me.modn(be).toString(le);
          Me = Me.idivn(be), Me.isZero() ? ge = Re + ge : ge = Se[he - Re.length] + Re + ge;
        }
        for (this.isZero() && (ge = "0" + ge); ge.length % pe !== 0; )
          ge = "0" + ge;
        return this.negative !== 0 && (ge = "-" + ge), ge;
      }
      fe(!1, "Base should be between 2 and 36");
    }, ce.prototype.toNumber = function() {
      var le = this.words[0];
      return this.length === 2 ? le += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? le += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && fe(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -le : le;
    }, ce.prototype.toJSON = function() {
      return this.toString(16);
    }, ce.prototype.toBuffer = function(le, pe) {
      return fe(typeof de < "u"), this.toArrayLike(de, le, pe);
    }, ce.prototype.toArray = function(le, pe) {
      return this.toArrayLike(Array, le, pe);
    }, ce.prototype.toArrayLike = function(le, pe, ge) {
      var ye = this.byteLength(), xe = ge || Math.max(1, ye);
      fe(ye <= xe, "byte array longer than desired length"), fe(xe > 0, "Requested array length <= 0"), this.strip();
      var _e = pe === "le", Ae = new le(xe), ve, he, be = this.clone();
      if (_e) {
        for (he = 0; !be.isZero(); he++)
          ve = be.andln(255), be.iushrn(8), Ae[he] = ve;
        for (; he < xe; he++)
          Ae[he] = 0;
      } else {
        for (he = 0; he < xe - ye; he++)
          Ae[he] = 0;
        for (he = 0; !be.isZero(); he++)
          ve = be.andln(255), be.iushrn(8), Ae[xe - he - 1] = ve;
      }
      return Ae;
    }, Math.clz32 ? ce.prototype._countBits = function(le) {
      return 32 - Math.clz32(le);
    } : ce.prototype._countBits = function(le) {
      var pe = le, ge = 0;
      return pe >= 4096 && (ge += 13, pe >>>= 13), pe >= 64 && (ge += 7, pe >>>= 7), pe >= 8 && (ge += 4, pe >>>= 4), pe >= 2 && (ge += 2, pe >>>= 2), ge + pe;
    }, ce.prototype._zeroBits = function(le) {
      if (le === 0)
        return 26;
      var pe = le, ge = 0;
      return pe & 8191 || (ge += 13, pe >>>= 13), pe & 127 || (ge += 7, pe >>>= 7), pe & 15 || (ge += 4, pe >>>= 4), pe & 3 || (ge += 2, pe >>>= 2), pe & 1 || ge++, ge;
    }, ce.prototype.bitLength = function() {
      var le = this.words[this.length - 1], pe = this._countBits(le);
      return (this.length - 1) * 26 + pe;
    };
    function Ie($e) {
      for (var le = new Array($e.bitLength()), pe = 0; pe < le.length; pe++) {
        var ge = pe / 26 | 0, ye = pe % 26;
        le[pe] = ($e.words[ge] & 1 << ye) >>> ye;
      }
      return le;
    }
    ce.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var le = 0, pe = 0; pe < this.length; pe++) {
        var ge = this._zeroBits(this.words[pe]);
        if (le += ge, ge !== 26)
          break;
      }
      return le;
    }, ce.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, ce.prototype.toTwos = function(le) {
      return this.negative !== 0 ? this.abs().inotn(le).iaddn(1) : this.clone();
    }, ce.prototype.fromTwos = function(le) {
      return this.testn(le - 1) ? this.notn(le).iaddn(1).ineg() : this.clone();
    }, ce.prototype.isNeg = function() {
      return this.negative !== 0;
    }, ce.prototype.neg = function() {
      return this.clone().ineg();
    }, ce.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, ce.prototype.iuor = function(le) {
      for (; this.length < le.length; )
        this.words[this.length++] = 0;
      for (var pe = 0; pe < le.length; pe++)
        this.words[pe] = this.words[pe] | le.words[pe];
      return this.strip();
    }, ce.prototype.ior = function(le) {
      return fe((this.negative | le.negative) === 0), this.iuor(le);
    }, ce.prototype.or = function(le) {
      return this.length > le.length ? this.clone().ior(le) : le.clone().ior(this);
    }, ce.prototype.uor = function(le) {
      return this.length > le.length ? this.clone().iuor(le) : le.clone().iuor(this);
    }, ce.prototype.iuand = function(le) {
      var pe;
      this.length > le.length ? pe = le : pe = this;
      for (var ge = 0; ge < pe.length; ge++)
        this.words[ge] = this.words[ge] & le.words[ge];
      return this.length = pe.length, this.strip();
    }, ce.prototype.iand = function(le) {
      return fe((this.negative | le.negative) === 0), this.iuand(le);
    }, ce.prototype.and = function(le) {
      return this.length > le.length ? this.clone().iand(le) : le.clone().iand(this);
    }, ce.prototype.uand = function(le) {
      return this.length > le.length ? this.clone().iuand(le) : le.clone().iuand(this);
    }, ce.prototype.iuxor = function(le) {
      var pe, ge;
      this.length > le.length ? (pe = this, ge = le) : (pe = le, ge = this);
      for (var ye = 0; ye < ge.length; ye++)
        this.words[ye] = pe.words[ye] ^ ge.words[ye];
      if (this !== pe)
        for (; ye < pe.length; ye++)
          this.words[ye] = pe.words[ye];
      return this.length = pe.length, this.strip();
    }, ce.prototype.ixor = function(le) {
      return fe((this.negative | le.negative) === 0), this.iuxor(le);
    }, ce.prototype.xor = function(le) {
      return this.length > le.length ? this.clone().ixor(le) : le.clone().ixor(this);
    }, ce.prototype.uxor = function(le) {
      return this.length > le.length ? this.clone().iuxor(le) : le.clone().iuxor(this);
    }, ce.prototype.inotn = function(le) {
      fe(typeof le == "number" && le >= 0);
      var pe = Math.ceil(le / 26) | 0, ge = le % 26;
      this._expand(pe), ge > 0 && pe--;
      for (var ye = 0; ye < pe; ye++)
        this.words[ye] = ~this.words[ye] & 67108863;
      return ge > 0 && (this.words[ye] = ~this.words[ye] & 67108863 >> 26 - ge), this.strip();
    }, ce.prototype.notn = function(le) {
      return this.clone().inotn(le);
    }, ce.prototype.setn = function(le, pe) {
      fe(typeof le == "number" && le >= 0);
      var ge = le / 26 | 0, ye = le % 26;
      return this._expand(ge + 1), pe ? this.words[ge] = this.words[ge] | 1 << ye : this.words[ge] = this.words[ge] & ~(1 << ye), this.strip();
    }, ce.prototype.iadd = function(le) {
      var pe;
      if (this.negative !== 0 && le.negative === 0)
        return this.negative = 0, pe = this.isub(le), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && le.negative !== 0)
        return le.negative = 0, pe = this.isub(le), le.negative = 1, pe._normSign();
      var ge, ye;
      this.length > le.length ? (ge = this, ye = le) : (ge = le, ye = this);
      for (var xe = 0, _e = 0; _e < ye.length; _e++)
        pe = (ge.words[_e] | 0) + (ye.words[_e] | 0) + xe, this.words[_e] = pe & 67108863, xe = pe >>> 26;
      for (; xe !== 0 && _e < ge.length; _e++)
        pe = (ge.words[_e] | 0) + xe, this.words[_e] = pe & 67108863, xe = pe >>> 26;
      if (this.length = ge.length, xe !== 0)
        this.words[this.length] = xe, this.length++;
      else if (ge !== this)
        for (; _e < ge.length; _e++)
          this.words[_e] = ge.words[_e];
      return this;
    }, ce.prototype.add = function(le) {
      var pe;
      return le.negative !== 0 && this.negative === 0 ? (le.negative = 0, pe = this.sub(le), le.negative ^= 1, pe) : le.negative === 0 && this.negative !== 0 ? (this.negative = 0, pe = le.sub(this), this.negative = 1, pe) : this.length > le.length ? this.clone().iadd(le) : le.clone().iadd(this);
    }, ce.prototype.isub = function(le) {
      if (le.negative !== 0) {
        le.negative = 0;
        var pe = this.iadd(le);
        return le.negative = 1, pe._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(le), this.negative = 1, this._normSign();
      var ge = this.cmp(le);
      if (ge === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var ye, xe;
      ge > 0 ? (ye = this, xe = le) : (ye = le, xe = this);
      for (var _e = 0, Ae = 0; Ae < xe.length; Ae++)
        pe = (ye.words[Ae] | 0) - (xe.words[Ae] | 0) + _e, _e = pe >> 26, this.words[Ae] = pe & 67108863;
      for (; _e !== 0 && Ae < ye.length; Ae++)
        pe = (ye.words[Ae] | 0) + _e, _e = pe >> 26, this.words[Ae] = pe & 67108863;
      if (_e === 0 && Ae < ye.length && ye !== this)
        for (; Ae < ye.length; Ae++)
          this.words[Ae] = ye.words[Ae];
      return this.length = Math.max(this.length, Ae), ye !== this && (this.negative = 1), this.strip();
    }, ce.prototype.sub = function(le) {
      return this.clone().isub(le);
    };
    function Pe($e, le, pe) {
      pe.negative = le.negative ^ $e.negative;
      var ge = $e.length + le.length | 0;
      pe.length = ge, ge = ge - 1 | 0;
      var ye = $e.words[0] | 0, xe = le.words[0] | 0, _e = ye * xe, Ae = _e & 67108863, ve = _e / 67108864 | 0;
      pe.words[0] = Ae;
      for (var he = 1; he < ge; he++) {
        for (var be = ve >>> 26, Me = ve & 67108863, Re = Math.min(he, le.length - 1), Oe = Math.max(0, he - $e.length + 1); Oe <= Re; Oe++) {
          var Te = he - Oe | 0;
          ye = $e.words[Te] | 0, xe = le.words[Oe] | 0, _e = ye * xe + Me, be += _e / 67108864 | 0, Me = _e & 67108863;
        }
        pe.words[he] = Me | 0, ve = be | 0;
      }
      return ve !== 0 ? pe.words[he] = ve | 0 : pe.length--, pe.strip();
    }
    var Ne = function(le, pe, ge) {
      var ye = le.words, xe = pe.words, _e = ge.words, Ae = 0, ve, he, be, Me = ye[0] | 0, Re = Me & 8191, Oe = Me >>> 13, Te = ye[1] | 0, Fe = Te & 8191, je = Te >>> 13, ct = ye[2] | 0, nt = ct & 8191, dt = ct >>> 13, it = ye[3] | 0, Je = it & 8191, gt = it >>> 13, Ht = ye[4] | 0, $t = Ht & 8191, Lt = Ht >>> 13, Tr = ye[5] | 0, Zt = Tr & 8191, wt = Tr >>> 13, Hr = ye[6] | 0, tr = Hr & 8191, cr = Hr >>> 13, qr = ye[7] | 0, Wt = qr & 8191, ar = qr >>> 13, Dr = ye[8] | 0, Jt = Dr & 8191, ir = Dr >>> 13, Gr = ye[9] | 0, We = Gr & 8191, Le = Gr >>> 13, Ke = xe[0] | 0, rt = Ke & 8191, lt = Ke >>> 13, It = xe[1] | 0, yt = It & 8191, jt = It >>> 13, Lr = xe[2] | 0, zt = Lr & 8191, rr = Lr >>> 13, Cr = xe[3] | 0, fr = Cr & 8191, pr = Cr >>> 13, jr = xe[4] | 0, nr = jr & 8191, ur = jr >>> 13, Wr = xe[5] | 0, or = Wr & 8191, lr = Wr >>> 13, Zr = xe[6] | 0, Xt = Zr & 8191, dr = Zr >>> 13, Ve = xe[7] | 0, Ze = Ve & 8191, Xe = Ve >>> 13, Ue = xe[8] | 0, Qe = Ue & 8191, pt = Ue >>> 13, Ct = xe[9] | 0, bt = Ct & 8191, Tt = Ct >>> 13;
      ge.negative = le.negative ^ pe.negative, ge.length = 19, ve = Math.imul(Re, rt), he = Math.imul(Re, lt), he = he + Math.imul(Oe, rt) | 0, be = Math.imul(Oe, lt);
      var br = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (br >>> 26) | 0, br &= 67108863, ve = Math.imul(Fe, rt), he = Math.imul(Fe, lt), he = he + Math.imul(je, rt) | 0, be = Math.imul(je, lt), ve = ve + Math.imul(Re, yt) | 0, he = he + Math.imul(Re, jt) | 0, he = he + Math.imul(Oe, yt) | 0, be = be + Math.imul(Oe, jt) | 0;
      var gr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (gr >>> 26) | 0, gr &= 67108863, ve = Math.imul(nt, rt), he = Math.imul(nt, lt), he = he + Math.imul(dt, rt) | 0, be = Math.imul(dt, lt), ve = ve + Math.imul(Fe, yt) | 0, he = he + Math.imul(Fe, jt) | 0, he = he + Math.imul(je, yt) | 0, be = be + Math.imul(je, jt) | 0, ve = ve + Math.imul(Re, zt) | 0, he = he + Math.imul(Re, rr) | 0, he = he + Math.imul(Oe, zt) | 0, be = be + Math.imul(Oe, rr) | 0;
      var Fr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, ve = Math.imul(Je, rt), he = Math.imul(Je, lt), he = he + Math.imul(gt, rt) | 0, be = Math.imul(gt, lt), ve = ve + Math.imul(nt, yt) | 0, he = he + Math.imul(nt, jt) | 0, he = he + Math.imul(dt, yt) | 0, be = be + Math.imul(dt, jt) | 0, ve = ve + Math.imul(Fe, zt) | 0, he = he + Math.imul(Fe, rr) | 0, he = he + Math.imul(je, zt) | 0, be = be + Math.imul(je, rr) | 0, ve = ve + Math.imul(Re, fr) | 0, he = he + Math.imul(Re, pr) | 0, he = he + Math.imul(Oe, fr) | 0, be = be + Math.imul(Oe, pr) | 0;
      var wr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (wr >>> 26) | 0, wr &= 67108863, ve = Math.imul($t, rt), he = Math.imul($t, lt), he = he + Math.imul(Lt, rt) | 0, be = Math.imul(Lt, lt), ve = ve + Math.imul(Je, yt) | 0, he = he + Math.imul(Je, jt) | 0, he = he + Math.imul(gt, yt) | 0, be = be + Math.imul(gt, jt) | 0, ve = ve + Math.imul(nt, zt) | 0, he = he + Math.imul(nt, rr) | 0, he = he + Math.imul(dt, zt) | 0, be = be + Math.imul(dt, rr) | 0, ve = ve + Math.imul(Fe, fr) | 0, he = he + Math.imul(Fe, pr) | 0, he = he + Math.imul(je, fr) | 0, be = be + Math.imul(je, pr) | 0, ve = ve + Math.imul(Re, nr) | 0, he = he + Math.imul(Re, ur) | 0, he = he + Math.imul(Oe, nr) | 0, be = be + Math.imul(Oe, ur) | 0;
      var Rr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Rr >>> 26) | 0, Rr &= 67108863, ve = Math.imul(Zt, rt), he = Math.imul(Zt, lt), he = he + Math.imul(wt, rt) | 0, be = Math.imul(wt, lt), ve = ve + Math.imul($t, yt) | 0, he = he + Math.imul($t, jt) | 0, he = he + Math.imul(Lt, yt) | 0, be = be + Math.imul(Lt, jt) | 0, ve = ve + Math.imul(Je, zt) | 0, he = he + Math.imul(Je, rr) | 0, he = he + Math.imul(gt, zt) | 0, be = be + Math.imul(gt, rr) | 0, ve = ve + Math.imul(nt, fr) | 0, he = he + Math.imul(nt, pr) | 0, he = he + Math.imul(dt, fr) | 0, be = be + Math.imul(dt, pr) | 0, ve = ve + Math.imul(Fe, nr) | 0, he = he + Math.imul(Fe, ur) | 0, he = he + Math.imul(je, nr) | 0, be = be + Math.imul(je, ur) | 0, ve = ve + Math.imul(Re, or) | 0, he = he + Math.imul(Re, lr) | 0, he = he + Math.imul(Oe, or) | 0, be = be + Math.imul(Oe, lr) | 0;
      var kr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (kr >>> 26) | 0, kr &= 67108863, ve = Math.imul(tr, rt), he = Math.imul(tr, lt), he = he + Math.imul(cr, rt) | 0, be = Math.imul(cr, lt), ve = ve + Math.imul(Zt, yt) | 0, he = he + Math.imul(Zt, jt) | 0, he = he + Math.imul(wt, yt) | 0, be = be + Math.imul(wt, jt) | 0, ve = ve + Math.imul($t, zt) | 0, he = he + Math.imul($t, rr) | 0, he = he + Math.imul(Lt, zt) | 0, be = be + Math.imul(Lt, rr) | 0, ve = ve + Math.imul(Je, fr) | 0, he = he + Math.imul(Je, pr) | 0, he = he + Math.imul(gt, fr) | 0, be = be + Math.imul(gt, pr) | 0, ve = ve + Math.imul(nt, nr) | 0, he = he + Math.imul(nt, ur) | 0, he = he + Math.imul(dt, nr) | 0, be = be + Math.imul(dt, ur) | 0, ve = ve + Math.imul(Fe, or) | 0, he = he + Math.imul(Fe, lr) | 0, he = he + Math.imul(je, or) | 0, be = be + Math.imul(je, lr) | 0, ve = ve + Math.imul(Re, Xt) | 0, he = he + Math.imul(Re, dr) | 0, he = he + Math.imul(Oe, Xt) | 0, be = be + Math.imul(Oe, dr) | 0;
      var Pr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, ve = Math.imul(Wt, rt), he = Math.imul(Wt, lt), he = he + Math.imul(ar, rt) | 0, be = Math.imul(ar, lt), ve = ve + Math.imul(tr, yt) | 0, he = he + Math.imul(tr, jt) | 0, he = he + Math.imul(cr, yt) | 0, be = be + Math.imul(cr, jt) | 0, ve = ve + Math.imul(Zt, zt) | 0, he = he + Math.imul(Zt, rr) | 0, he = he + Math.imul(wt, zt) | 0, be = be + Math.imul(wt, rr) | 0, ve = ve + Math.imul($t, fr) | 0, he = he + Math.imul($t, pr) | 0, he = he + Math.imul(Lt, fr) | 0, be = be + Math.imul(Lt, pr) | 0, ve = ve + Math.imul(Je, nr) | 0, he = he + Math.imul(Je, ur) | 0, he = he + Math.imul(gt, nr) | 0, be = be + Math.imul(gt, ur) | 0, ve = ve + Math.imul(nt, or) | 0, he = he + Math.imul(nt, lr) | 0, he = he + Math.imul(dt, or) | 0, be = be + Math.imul(dt, lr) | 0, ve = ve + Math.imul(Fe, Xt) | 0, he = he + Math.imul(Fe, dr) | 0, he = he + Math.imul(je, Xt) | 0, be = be + Math.imul(je, dr) | 0, ve = ve + Math.imul(Re, Ze) | 0, he = he + Math.imul(Re, Xe) | 0, he = he + Math.imul(Oe, Ze) | 0, be = be + Math.imul(Oe, Xe) | 0;
      var Ur = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, ve = Math.imul(Jt, rt), he = Math.imul(Jt, lt), he = he + Math.imul(ir, rt) | 0, be = Math.imul(ir, lt), ve = ve + Math.imul(Wt, yt) | 0, he = he + Math.imul(Wt, jt) | 0, he = he + Math.imul(ar, yt) | 0, be = be + Math.imul(ar, jt) | 0, ve = ve + Math.imul(tr, zt) | 0, he = he + Math.imul(tr, rr) | 0, he = he + Math.imul(cr, zt) | 0, be = be + Math.imul(cr, rr) | 0, ve = ve + Math.imul(Zt, fr) | 0, he = he + Math.imul(Zt, pr) | 0, he = he + Math.imul(wt, fr) | 0, be = be + Math.imul(wt, pr) | 0, ve = ve + Math.imul($t, nr) | 0, he = he + Math.imul($t, ur) | 0, he = he + Math.imul(Lt, nr) | 0, be = be + Math.imul(Lt, ur) | 0, ve = ve + Math.imul(Je, or) | 0, he = he + Math.imul(Je, lr) | 0, he = he + Math.imul(gt, or) | 0, be = be + Math.imul(gt, lr) | 0, ve = ve + Math.imul(nt, Xt) | 0, he = he + Math.imul(nt, dr) | 0, he = he + Math.imul(dt, Xt) | 0, be = be + Math.imul(dt, dr) | 0, ve = ve + Math.imul(Fe, Ze) | 0, he = he + Math.imul(Fe, Xe) | 0, he = he + Math.imul(je, Ze) | 0, be = be + Math.imul(je, Xe) | 0, ve = ve + Math.imul(Re, Qe) | 0, he = he + Math.imul(Re, pt) | 0, he = he + Math.imul(Oe, Qe) | 0, be = be + Math.imul(Oe, pt) | 0;
      var Ir = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Ir >>> 26) | 0, Ir &= 67108863, ve = Math.imul(We, rt), he = Math.imul(We, lt), he = he + Math.imul(Le, rt) | 0, be = Math.imul(Le, lt), ve = ve + Math.imul(Jt, yt) | 0, he = he + Math.imul(Jt, jt) | 0, he = he + Math.imul(ir, yt) | 0, be = be + Math.imul(ir, jt) | 0, ve = ve + Math.imul(Wt, zt) | 0, he = he + Math.imul(Wt, rr) | 0, he = he + Math.imul(ar, zt) | 0, be = be + Math.imul(ar, rr) | 0, ve = ve + Math.imul(tr, fr) | 0, he = he + Math.imul(tr, pr) | 0, he = he + Math.imul(cr, fr) | 0, be = be + Math.imul(cr, pr) | 0, ve = ve + Math.imul(Zt, nr) | 0, he = he + Math.imul(Zt, ur) | 0, he = he + Math.imul(wt, nr) | 0, be = be + Math.imul(wt, ur) | 0, ve = ve + Math.imul($t, or) | 0, he = he + Math.imul($t, lr) | 0, he = he + Math.imul(Lt, or) | 0, be = be + Math.imul(Lt, lr) | 0, ve = ve + Math.imul(Je, Xt) | 0, he = he + Math.imul(Je, dr) | 0, he = he + Math.imul(gt, Xt) | 0, be = be + Math.imul(gt, dr) | 0, ve = ve + Math.imul(nt, Ze) | 0, he = he + Math.imul(nt, Xe) | 0, he = he + Math.imul(dt, Ze) | 0, be = be + Math.imul(dt, Xe) | 0, ve = ve + Math.imul(Fe, Qe) | 0, he = he + Math.imul(Fe, pt) | 0, he = he + Math.imul(je, Qe) | 0, be = be + Math.imul(je, pt) | 0, ve = ve + Math.imul(Re, bt) | 0, he = he + Math.imul(Re, Tt) | 0, he = he + Math.imul(Oe, bt) | 0, be = be + Math.imul(Oe, Tt) | 0;
      var Or = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Or >>> 26) | 0, Or &= 67108863, ve = Math.imul(We, yt), he = Math.imul(We, jt), he = he + Math.imul(Le, yt) | 0, be = Math.imul(Le, jt), ve = ve + Math.imul(Jt, zt) | 0, he = he + Math.imul(Jt, rr) | 0, he = he + Math.imul(ir, zt) | 0, be = be + Math.imul(ir, rr) | 0, ve = ve + Math.imul(Wt, fr) | 0, he = he + Math.imul(Wt, pr) | 0, he = he + Math.imul(ar, fr) | 0, be = be + Math.imul(ar, pr) | 0, ve = ve + Math.imul(tr, nr) | 0, he = he + Math.imul(tr, ur) | 0, he = he + Math.imul(cr, nr) | 0, be = be + Math.imul(cr, ur) | 0, ve = ve + Math.imul(Zt, or) | 0, he = he + Math.imul(Zt, lr) | 0, he = he + Math.imul(wt, or) | 0, be = be + Math.imul(wt, lr) | 0, ve = ve + Math.imul($t, Xt) | 0, he = he + Math.imul($t, dr) | 0, he = he + Math.imul(Lt, Xt) | 0, be = be + Math.imul(Lt, dr) | 0, ve = ve + Math.imul(Je, Ze) | 0, he = he + Math.imul(Je, Xe) | 0, he = he + Math.imul(gt, Ze) | 0, be = be + Math.imul(gt, Xe) | 0, ve = ve + Math.imul(nt, Qe) | 0, he = he + Math.imul(nt, pt) | 0, he = he + Math.imul(dt, Qe) | 0, be = be + Math.imul(dt, pt) | 0, ve = ve + Math.imul(Fe, bt) | 0, he = he + Math.imul(Fe, Tt) | 0, he = he + Math.imul(je, bt) | 0, be = be + Math.imul(je, Tt) | 0;
      var Nr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Nr >>> 26) | 0, Nr &= 67108863, ve = Math.imul(We, zt), he = Math.imul(We, rr), he = he + Math.imul(Le, zt) | 0, be = Math.imul(Le, rr), ve = ve + Math.imul(Jt, fr) | 0, he = he + Math.imul(Jt, pr) | 0, he = he + Math.imul(ir, fr) | 0, be = be + Math.imul(ir, pr) | 0, ve = ve + Math.imul(Wt, nr) | 0, he = he + Math.imul(Wt, ur) | 0, he = he + Math.imul(ar, nr) | 0, be = be + Math.imul(ar, ur) | 0, ve = ve + Math.imul(tr, or) | 0, he = he + Math.imul(tr, lr) | 0, he = he + Math.imul(cr, or) | 0, be = be + Math.imul(cr, lr) | 0, ve = ve + Math.imul(Zt, Xt) | 0, he = he + Math.imul(Zt, dr) | 0, he = he + Math.imul(wt, Xt) | 0, be = be + Math.imul(wt, dr) | 0, ve = ve + Math.imul($t, Ze) | 0, he = he + Math.imul($t, Xe) | 0, he = he + Math.imul(Lt, Ze) | 0, be = be + Math.imul(Lt, Xe) | 0, ve = ve + Math.imul(Je, Qe) | 0, he = he + Math.imul(Je, pt) | 0, he = he + Math.imul(gt, Qe) | 0, be = be + Math.imul(gt, pt) | 0, ve = ve + Math.imul(nt, bt) | 0, he = he + Math.imul(nt, Tt) | 0, he = he + Math.imul(dt, bt) | 0, be = be + Math.imul(dt, Tt) | 0;
      var Er = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, ve = Math.imul(We, fr), he = Math.imul(We, pr), he = he + Math.imul(Le, fr) | 0, be = Math.imul(Le, pr), ve = ve + Math.imul(Jt, nr) | 0, he = he + Math.imul(Jt, ur) | 0, he = he + Math.imul(ir, nr) | 0, be = be + Math.imul(ir, ur) | 0, ve = ve + Math.imul(Wt, or) | 0, he = he + Math.imul(Wt, lr) | 0, he = he + Math.imul(ar, or) | 0, be = be + Math.imul(ar, lr) | 0, ve = ve + Math.imul(tr, Xt) | 0, he = he + Math.imul(tr, dr) | 0, he = he + Math.imul(cr, Xt) | 0, be = be + Math.imul(cr, dr) | 0, ve = ve + Math.imul(Zt, Ze) | 0, he = he + Math.imul(Zt, Xe) | 0, he = he + Math.imul(wt, Ze) | 0, be = be + Math.imul(wt, Xe) | 0, ve = ve + Math.imul($t, Qe) | 0, he = he + Math.imul($t, pt) | 0, he = he + Math.imul(Lt, Qe) | 0, be = be + Math.imul(Lt, pt) | 0, ve = ve + Math.imul(Je, bt) | 0, he = he + Math.imul(Je, Tt) | 0, he = he + Math.imul(gt, bt) | 0, be = be + Math.imul(gt, Tt) | 0;
      var Br = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Br >>> 26) | 0, Br &= 67108863, ve = Math.imul(We, nr), he = Math.imul(We, ur), he = he + Math.imul(Le, nr) | 0, be = Math.imul(Le, ur), ve = ve + Math.imul(Jt, or) | 0, he = he + Math.imul(Jt, lr) | 0, he = he + Math.imul(ir, or) | 0, be = be + Math.imul(ir, lr) | 0, ve = ve + Math.imul(Wt, Xt) | 0, he = he + Math.imul(Wt, dr) | 0, he = he + Math.imul(ar, Xt) | 0, be = be + Math.imul(ar, dr) | 0, ve = ve + Math.imul(tr, Ze) | 0, he = he + Math.imul(tr, Xe) | 0, he = he + Math.imul(cr, Ze) | 0, be = be + Math.imul(cr, Xe) | 0, ve = ve + Math.imul(Zt, Qe) | 0, he = he + Math.imul(Zt, pt) | 0, he = he + Math.imul(wt, Qe) | 0, be = be + Math.imul(wt, pt) | 0, ve = ve + Math.imul($t, bt) | 0, he = he + Math.imul($t, Tt) | 0, he = he + Math.imul(Lt, bt) | 0, be = be + Math.imul(Lt, Tt) | 0;
      var _r = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (_r >>> 26) | 0, _r &= 67108863, ve = Math.imul(We, or), he = Math.imul(We, lr), he = he + Math.imul(Le, or) | 0, be = Math.imul(Le, lr), ve = ve + Math.imul(Jt, Xt) | 0, he = he + Math.imul(Jt, dr) | 0, he = he + Math.imul(ir, Xt) | 0, be = be + Math.imul(ir, dr) | 0, ve = ve + Math.imul(Wt, Ze) | 0, he = he + Math.imul(Wt, Xe) | 0, he = he + Math.imul(ar, Ze) | 0, be = be + Math.imul(ar, Xe) | 0, ve = ve + Math.imul(tr, Qe) | 0, he = he + Math.imul(tr, pt) | 0, he = he + Math.imul(cr, Qe) | 0, be = be + Math.imul(cr, pt) | 0, ve = ve + Math.imul(Zt, bt) | 0, he = he + Math.imul(Zt, Tt) | 0, he = he + Math.imul(wt, bt) | 0, be = be + Math.imul(wt, Tt) | 0;
      var Sr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Sr >>> 26) | 0, Sr &= 67108863, ve = Math.imul(We, Xt), he = Math.imul(We, dr), he = he + Math.imul(Le, Xt) | 0, be = Math.imul(Le, dr), ve = ve + Math.imul(Jt, Ze) | 0, he = he + Math.imul(Jt, Xe) | 0, he = he + Math.imul(ir, Ze) | 0, be = be + Math.imul(ir, Xe) | 0, ve = ve + Math.imul(Wt, Qe) | 0, he = he + Math.imul(Wt, pt) | 0, he = he + Math.imul(ar, Qe) | 0, be = be + Math.imul(ar, pt) | 0, ve = ve + Math.imul(tr, bt) | 0, he = he + Math.imul(tr, Tt) | 0, he = he + Math.imul(cr, bt) | 0, be = be + Math.imul(cr, Tt) | 0;
      var Mr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Mr >>> 26) | 0, Mr &= 67108863, ve = Math.imul(We, Ze), he = Math.imul(We, Xe), he = he + Math.imul(Le, Ze) | 0, be = Math.imul(Le, Xe), ve = ve + Math.imul(Jt, Qe) | 0, he = he + Math.imul(Jt, pt) | 0, he = he + Math.imul(ir, Qe) | 0, be = be + Math.imul(ir, pt) | 0, ve = ve + Math.imul(Wt, bt) | 0, he = he + Math.imul(Wt, Tt) | 0, he = he + Math.imul(ar, bt) | 0, be = be + Math.imul(ar, Tt) | 0;
      var $r = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + ($r >>> 26) | 0, $r &= 67108863, ve = Math.imul(We, Qe), he = Math.imul(We, pt), he = he + Math.imul(Le, Qe) | 0, be = Math.imul(Le, pt), ve = ve + Math.imul(Jt, bt) | 0, he = he + Math.imul(Jt, Tt) | 0, he = he + Math.imul(ir, bt) | 0, be = be + Math.imul(ir, Tt) | 0;
      var Yt = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Yt >>> 26) | 0, Yt &= 67108863, ve = Math.imul(We, bt), he = Math.imul(We, Tt), he = he + Math.imul(Le, bt) | 0, be = Math.imul(Le, Tt);
      var er = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      return Ae = (be + (he >>> 13) | 0) + (er >>> 26) | 0, er &= 67108863, _e[0] = br, _e[1] = gr, _e[2] = Fr, _e[3] = wr, _e[4] = Rr, _e[5] = kr, _e[6] = Pr, _e[7] = Ur, _e[8] = Ir, _e[9] = Or, _e[10] = Nr, _e[11] = Er, _e[12] = Br, _e[13] = _r, _e[14] = Sr, _e[15] = Mr, _e[16] = $r, _e[17] = Yt, _e[18] = er, Ae !== 0 && (_e[19] = Ae, ge.length++), ge;
    };
    Math.imul || (Ne = Pe);
    function ke($e, le, pe) {
      pe.negative = le.negative ^ $e.negative, pe.length = $e.length + le.length;
      for (var ge = 0, ye = 0, xe = 0; xe < pe.length - 1; xe++) {
        var _e = ye;
        ye = 0;
        for (var Ae = ge & 67108863, ve = Math.min(xe, le.length - 1), he = Math.max(0, xe - $e.length + 1); he <= ve; he++) {
          var be = xe - he, Me = $e.words[be] | 0, Re = le.words[he] | 0, Oe = Me * Re, Te = Oe & 67108863;
          _e = _e + (Oe / 67108864 | 0) | 0, Te = Te + Ae | 0, Ae = Te & 67108863, _e = _e + (Te >>> 26) | 0, ye += _e >>> 26, _e &= 67108863;
        }
        pe.words[xe] = Ae, ge = _e, _e = ye;
      }
      return ge !== 0 ? pe.words[xe] = ge : pe.length--, pe.strip();
    }
    function He($e, le, pe) {
      var ge = new De();
      return ge.mulp($e, le, pe);
    }
    ce.prototype.mulTo = function(le, pe) {
      var ge, ye = this.length + le.length;
      return this.length === 10 && le.length === 10 ? ge = Ne(this, le, pe) : ye < 63 ? ge = Pe(this, le, pe) : ye < 1024 ? ge = ke(this, le, pe) : ge = He(this, le, pe), ge;
    };
    function De($e, le) {
      this.x = $e, this.y = le;
    }
    De.prototype.makeRBT = function(le) {
      for (var pe = new Array(le), ge = ce.prototype._countBits(le) - 1, ye = 0; ye < le; ye++)
        pe[ye] = this.revBin(ye, ge, le);
      return pe;
    }, De.prototype.revBin = function(le, pe, ge) {
      if (le === 0 || le === ge - 1)
        return le;
      for (var ye = 0, xe = 0; xe < pe; xe++)
        ye |= (le & 1) << pe - xe - 1, le >>= 1;
      return ye;
    }, De.prototype.permute = function(le, pe, ge, ye, xe, _e) {
      for (var Ae = 0; Ae < _e; Ae++)
        ye[Ae] = pe[le[Ae]], xe[Ae] = ge[le[Ae]];
    }, De.prototype.transform = function(le, pe, ge, ye, xe, _e) {
      this.permute(_e, le, pe, ge, ye, xe);
      for (var Ae = 1; Ae < xe; Ae <<= 1)
        for (var ve = Ae << 1, he = Math.cos(2 * Math.PI / ve), be = Math.sin(2 * Math.PI / ve), Me = 0; Me < xe; Me += ve)
          for (var Re = he, Oe = be, Te = 0; Te < Ae; Te++) {
            var Fe = ge[Me + Te], je = ye[Me + Te], ct = ge[Me + Te + Ae], nt = ye[Me + Te + Ae], dt = Re * ct - Oe * nt;
            nt = Re * nt + Oe * ct, ct = dt, ge[Me + Te] = Fe + ct, ye[Me + Te] = je + nt, ge[Me + Te + Ae] = Fe - ct, ye[Me + Te + Ae] = je - nt, Te !== ve && (dt = he * Re - be * Oe, Oe = he * Oe + be * Re, Re = dt);
          }
    }, De.prototype.guessLen13b = function(le, pe) {
      var ge = Math.max(pe, le) | 1, ye = ge & 1, xe = 0;
      for (ge = ge / 2 | 0; ge; ge = ge >>> 1)
        xe++;
      return 1 << xe + 1 + ye;
    }, De.prototype.conjugate = function(le, pe, ge) {
      if (!(ge <= 1))
        for (var ye = 0; ye < ge / 2; ye++) {
          var xe = le[ye];
          le[ye] = le[ge - ye - 1], le[ge - ye - 1] = xe, xe = pe[ye], pe[ye] = -pe[ge - ye - 1], pe[ge - ye - 1] = -xe;
        }
    }, De.prototype.normalize13b = function(le, pe) {
      for (var ge = 0, ye = 0; ye < pe / 2; ye++) {
        var xe = Math.round(le[2 * ye + 1] / pe) * 8192 + Math.round(le[2 * ye] / pe) + ge;
        le[ye] = xe & 67108863, xe < 67108864 ? ge = 0 : ge = xe / 67108864 | 0;
      }
      return le;
    }, De.prototype.convert13b = function(le, pe, ge, ye) {
      for (var xe = 0, _e = 0; _e < pe; _e++)
        xe = xe + (le[_e] | 0), ge[2 * _e] = xe & 8191, xe = xe >>> 13, ge[2 * _e + 1] = xe & 8191, xe = xe >>> 13;
      for (_e = 2 * pe; _e < ye; ++_e)
        ge[_e] = 0;
      fe(xe === 0), fe((xe & -8192) === 0);
    }, De.prototype.stub = function(le) {
      for (var pe = new Array(le), ge = 0; ge < le; ge++)
        pe[ge] = 0;
      return pe;
    }, De.prototype.mulp = function(le, pe, ge) {
      var ye = 2 * this.guessLen13b(le.length, pe.length), xe = this.makeRBT(ye), _e = this.stub(ye), Ae = new Array(ye), ve = new Array(ye), he = new Array(ye), be = new Array(ye), Me = new Array(ye), Re = new Array(ye), Oe = ge.words;
      Oe.length = ye, this.convert13b(le.words, le.length, Ae, ye), this.convert13b(pe.words, pe.length, be, ye), this.transform(Ae, _e, ve, he, ye, xe), this.transform(be, _e, Me, Re, ye, xe);
      for (var Te = 0; Te < ye; Te++) {
        var Fe = ve[Te] * Me[Te] - he[Te] * Re[Te];
        he[Te] = ve[Te] * Re[Te] + he[Te] * Me[Te], ve[Te] = Fe;
      }
      return this.conjugate(ve, he, ye), this.transform(ve, he, Oe, _e, ye, xe), this.conjugate(Oe, _e, ye), this.normalize13b(Oe, ye), ge.negative = le.negative ^ pe.negative, ge.length = le.length + pe.length, ge.strip();
    }, ce.prototype.mul = function(le) {
      var pe = new ce(null);
      return pe.words = new Array(this.length + le.length), this.mulTo(le, pe);
    }, ce.prototype.mulf = function(le) {
      var pe = new ce(null);
      return pe.words = new Array(this.length + le.length), He(this, le, pe);
    }, ce.prototype.imul = function(le) {
      return this.clone().mulTo(le, this);
    }, ce.prototype.imuln = function(le) {
      fe(typeof le == "number"), fe(le < 67108864);
      for (var pe = 0, ge = 0; ge < this.length; ge++) {
        var ye = (this.words[ge] | 0) * le, xe = (ye & 67108863) + (pe & 67108863);
        pe >>= 26, pe += ye / 67108864 | 0, pe += xe >>> 26, this.words[ge] = xe & 67108863;
      }
      return pe !== 0 && (this.words[ge] = pe, this.length++), this;
    }, ce.prototype.muln = function(le) {
      return this.clone().imuln(le);
    }, ce.prototype.sqr = function() {
      return this.mul(this);
    }, ce.prototype.isqr = function() {
      return this.imul(this.clone());
    }, ce.prototype.pow = function(le) {
      var pe = Ie(le);
      if (pe.length === 0)
        return new ce(1);
      for (var ge = this, ye = 0; ye < pe.length && pe[ye] === 0; ye++, ge = ge.sqr())
        ;
      if (++ye < pe.length)
        for (var xe = ge.sqr(); ye < pe.length; ye++, xe = xe.sqr())
          pe[ye] !== 0 && (ge = ge.mul(xe));
      return ge;
    }, ce.prototype.iushln = function(le) {
      fe(typeof le == "number" && le >= 0);
      var pe = le % 26, ge = (le - pe) / 26, ye = 67108863 >>> 26 - pe << 26 - pe, xe;
      if (pe !== 0) {
        var _e = 0;
        for (xe = 0; xe < this.length; xe++) {
          var Ae = this.words[xe] & ye, ve = (this.words[xe] | 0) - Ae << pe;
          this.words[xe] = ve | _e, _e = Ae >>> 26 - pe;
        }
        _e && (this.words[xe] = _e, this.length++);
      }
      if (ge !== 0) {
        for (xe = this.length - 1; xe >= 0; xe--)
          this.words[xe + ge] = this.words[xe];
        for (xe = 0; xe < ge; xe++)
          this.words[xe] = 0;
        this.length += ge;
      }
      return this.strip();
    }, ce.prototype.ishln = function(le) {
      return fe(this.negative === 0), this.iushln(le);
    }, ce.prototype.iushrn = function(le, pe, ge) {
      fe(typeof le == "number" && le >= 0);
      var ye;
      pe ? ye = (pe - pe % 26) / 26 : ye = 0;
      var xe = le % 26, _e = Math.min((le - xe) / 26, this.length), Ae = 67108863 ^ 67108863 >>> xe << xe, ve = ge;
      if (ye -= _e, ye = Math.max(0, ye), ve) {
        for (var he = 0; he < _e; he++)
          ve.words[he] = this.words[he];
        ve.length = _e;
      }
      if (_e !== 0)
        if (this.length > _e)
          for (this.length -= _e, he = 0; he < this.length; he++)
            this.words[he] = this.words[he + _e];
        else
          this.words[0] = 0, this.length = 1;
      var be = 0;
      for (he = this.length - 1; he >= 0 && (be !== 0 || he >= ye); he--) {
        var Me = this.words[he] | 0;
        this.words[he] = be << 26 - xe | Me >>> xe, be = Me & Ae;
      }
      return ve && be !== 0 && (ve.words[ve.length++] = be), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, ce.prototype.ishrn = function(le, pe, ge) {
      return fe(this.negative === 0), this.iushrn(le, pe, ge);
    }, ce.prototype.shln = function(le) {
      return this.clone().ishln(le);
    }, ce.prototype.ushln = function(le) {
      return this.clone().iushln(le);
    }, ce.prototype.shrn = function(le) {
      return this.clone().ishrn(le);
    }, ce.prototype.ushrn = function(le) {
      return this.clone().iushrn(le);
    }, ce.prototype.testn = function(le) {
      fe(typeof le == "number" && le >= 0);
      var pe = le % 26, ge = (le - pe) / 26, ye = 1 << pe;
      if (this.length <= ge)
        return !1;
      var xe = this.words[ge];
      return !!(xe & ye);
    }, ce.prototype.imaskn = function(le) {
      fe(typeof le == "number" && le >= 0);
      var pe = le % 26, ge = (le - pe) / 26;
      if (fe(this.negative === 0, "imaskn works only with positive numbers"), this.length <= ge)
        return this;
      if (pe !== 0 && ge++, this.length = Math.min(ge, this.length), pe !== 0) {
        var ye = 67108863 ^ 67108863 >>> pe << pe;
        this.words[this.length - 1] &= ye;
      }
      return this.strip();
    }, ce.prototype.maskn = function(le) {
      return this.clone().imaskn(le);
    }, ce.prototype.iaddn = function(le) {
      return fe(typeof le == "number"), fe(le < 67108864), le < 0 ? this.isubn(-le) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < le ? (this.words[0] = le - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(le), this.negative = 1, this) : this._iaddn(le);
    }, ce.prototype._iaddn = function(le) {
      this.words[0] += le;
      for (var pe = 0; pe < this.length && this.words[pe] >= 67108864; pe++)
        this.words[pe] -= 67108864, pe === this.length - 1 ? this.words[pe + 1] = 1 : this.words[pe + 1]++;
      return this.length = Math.max(this.length, pe + 1), this;
    }, ce.prototype.isubn = function(le) {
      if (fe(typeof le == "number"), fe(le < 67108864), le < 0)
        return this.iaddn(-le);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(le), this.negative = 1, this;
      if (this.words[0] -= le, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var pe = 0; pe < this.length && this.words[pe] < 0; pe++)
          this.words[pe] += 67108864, this.words[pe + 1] -= 1;
      return this.strip();
    }, ce.prototype.addn = function(le) {
      return this.clone().iaddn(le);
    }, ce.prototype.subn = function(le) {
      return this.clone().isubn(le);
    }, ce.prototype.iabs = function() {
      return this.negative = 0, this;
    }, ce.prototype.abs = function() {
      return this.clone().iabs();
    }, ce.prototype._ishlnsubmul = function(le, pe, ge) {
      var ye = le.length + ge, xe;
      this._expand(ye);
      var _e, Ae = 0;
      for (xe = 0; xe < le.length; xe++) {
        _e = (this.words[xe + ge] | 0) + Ae;
        var ve = (le.words[xe] | 0) * pe;
        _e -= ve & 67108863, Ae = (_e >> 26) - (ve / 67108864 | 0), this.words[xe + ge] = _e & 67108863;
      }
      for (; xe < this.length - ge; xe++)
        _e = (this.words[xe + ge] | 0) + Ae, Ae = _e >> 26, this.words[xe + ge] = _e & 67108863;
      if (Ae === 0)
        return this.strip();
      for (fe(Ae === -1), Ae = 0, xe = 0; xe < this.length; xe++)
        _e = -(this.words[xe] | 0) + Ae, Ae = _e >> 26, this.words[xe] = _e & 67108863;
      return this.negative = 1, this.strip();
    }, ce.prototype._wordDiv = function(le, pe) {
      var ge = this.length - le.length, ye = this.clone(), xe = le, _e = xe.words[xe.length - 1] | 0, Ae = this._countBits(_e);
      ge = 26 - Ae, ge !== 0 && (xe = xe.ushln(ge), ye.iushln(ge), _e = xe.words[xe.length - 1] | 0);
      var ve = ye.length - xe.length, he;
      if (pe !== "mod") {
        he = new ce(null), he.length = ve + 1, he.words = new Array(he.length);
        for (var be = 0; be < he.length; be++)
          he.words[be] = 0;
      }
      var Me = ye.clone()._ishlnsubmul(xe, 1, ve);
      Me.negative === 0 && (ye = Me, he && (he.words[ve] = 1));
      for (var Re = ve - 1; Re >= 0; Re--) {
        var Oe = (ye.words[xe.length + Re] | 0) * 67108864 + (ye.words[xe.length + Re - 1] | 0);
        for (Oe = Math.min(Oe / _e | 0, 67108863), ye._ishlnsubmul(xe, Oe, Re); ye.negative !== 0; )
          Oe--, ye.negative = 0, ye._ishlnsubmul(xe, 1, Re), ye.isZero() || (ye.negative ^= 1);
        he && (he.words[Re] = Oe);
      }
      return he && he.strip(), ye.strip(), pe !== "div" && ge !== 0 && ye.iushrn(ge), {
        div: he || null,
        mod: ye
      };
    }, ce.prototype.divmod = function(le, pe, ge) {
      if (fe(!le.isZero()), this.isZero())
        return {
          div: new ce(0),
          mod: new ce(0)
        };
      var ye, xe, _e;
      return this.negative !== 0 && le.negative === 0 ? (_e = this.neg().divmod(le, pe), pe !== "mod" && (ye = _e.div.neg()), pe !== "div" && (xe = _e.mod.neg(), ge && xe.negative !== 0 && xe.iadd(le)), {
        div: ye,
        mod: xe
      }) : this.negative === 0 && le.negative !== 0 ? (_e = this.divmod(le.neg(), pe), pe !== "mod" && (ye = _e.div.neg()), {
        div: ye,
        mod: _e.mod
      }) : this.negative & le.negative ? (_e = this.neg().divmod(le.neg(), pe), pe !== "div" && (xe = _e.mod.neg(), ge && xe.negative !== 0 && xe.isub(le)), {
        div: _e.div,
        mod: xe
      }) : le.length > this.length || this.cmp(le) < 0 ? {
        div: new ce(0),
        mod: this
      } : le.length === 1 ? pe === "div" ? {
        div: this.divn(le.words[0]),
        mod: null
      } : pe === "mod" ? {
        div: null,
        mod: new ce(this.modn(le.words[0]))
      } : {
        div: this.divn(le.words[0]),
        mod: new ce(this.modn(le.words[0]))
      } : this._wordDiv(le, pe);
    }, ce.prototype.div = function(le) {
      return this.divmod(le, "div", !1).div;
    }, ce.prototype.mod = function(le) {
      return this.divmod(le, "mod", !1).mod;
    }, ce.prototype.umod = function(le) {
      return this.divmod(le, "mod", !0).mod;
    }, ce.prototype.divRound = function(le) {
      var pe = this.divmod(le);
      if (pe.mod.isZero())
        return pe.div;
      var ge = pe.div.negative !== 0 ? pe.mod.isub(le) : pe.mod, ye = le.ushrn(1), xe = le.andln(1), _e = ge.cmp(ye);
      return _e < 0 || xe === 1 && _e === 0 ? pe.div : pe.div.negative !== 0 ? pe.div.isubn(1) : pe.div.iaddn(1);
    }, ce.prototype.modn = function(le) {
      fe(le <= 67108863);
      for (var pe = (1 << 26) % le, ge = 0, ye = this.length - 1; ye >= 0; ye--)
        ge = (pe * ge + (this.words[ye] | 0)) % le;
      return ge;
    }, ce.prototype.idivn = function(le) {
      fe(le <= 67108863);
      for (var pe = 0, ge = this.length - 1; ge >= 0; ge--) {
        var ye = (this.words[ge] | 0) + pe * 67108864;
        this.words[ge] = ye / le | 0, pe = ye % le;
      }
      return this.strip();
    }, ce.prototype.divn = function(le) {
      return this.clone().idivn(le);
    }, ce.prototype.egcd = function(le) {
      fe(le.negative === 0), fe(!le.isZero());
      var pe = this, ge = le.clone();
      pe.negative !== 0 ? pe = pe.umod(le) : pe = pe.clone();
      for (var ye = new ce(1), xe = new ce(0), _e = new ce(0), Ae = new ce(1), ve = 0; pe.isEven() && ge.isEven(); )
        pe.iushrn(1), ge.iushrn(1), ++ve;
      for (var he = ge.clone(), be = pe.clone(); !pe.isZero(); ) {
        for (var Me = 0, Re = 1; !(pe.words[0] & Re) && Me < 26; ++Me, Re <<= 1)
          ;
        if (Me > 0)
          for (pe.iushrn(Me); Me-- > 0; )
            (ye.isOdd() || xe.isOdd()) && (ye.iadd(he), xe.isub(be)), ye.iushrn(1), xe.iushrn(1);
        for (var Oe = 0, Te = 1; !(ge.words[0] & Te) && Oe < 26; ++Oe, Te <<= 1)
          ;
        if (Oe > 0)
          for (ge.iushrn(Oe); Oe-- > 0; )
            (_e.isOdd() || Ae.isOdd()) && (_e.iadd(he), Ae.isub(be)), _e.iushrn(1), Ae.iushrn(1);
        pe.cmp(ge) >= 0 ? (pe.isub(ge), ye.isub(_e), xe.isub(Ae)) : (ge.isub(pe), _e.isub(ye), Ae.isub(xe));
      }
      return {
        a: _e,
        b: Ae,
        gcd: ge.iushln(ve)
      };
    }, ce.prototype._invmp = function(le) {
      fe(le.negative === 0), fe(!le.isZero());
      var pe = this, ge = le.clone();
      pe.negative !== 0 ? pe = pe.umod(le) : pe = pe.clone();
      for (var ye = new ce(1), xe = new ce(0), _e = ge.clone(); pe.cmpn(1) > 0 && ge.cmpn(1) > 0; ) {
        for (var Ae = 0, ve = 1; !(pe.words[0] & ve) && Ae < 26; ++Ae, ve <<= 1)
          ;
        if (Ae > 0)
          for (pe.iushrn(Ae); Ae-- > 0; )
            ye.isOdd() && ye.iadd(_e), ye.iushrn(1);
        for (var he = 0, be = 1; !(ge.words[0] & be) && he < 26; ++he, be <<= 1)
          ;
        if (he > 0)
          for (ge.iushrn(he); he-- > 0; )
            xe.isOdd() && xe.iadd(_e), xe.iushrn(1);
        pe.cmp(ge) >= 0 ? (pe.isub(ge), ye.isub(xe)) : (ge.isub(pe), xe.isub(ye));
      }
      var Me;
      return pe.cmpn(1) === 0 ? Me = ye : Me = xe, Me.cmpn(0) < 0 && Me.iadd(le), Me;
    }, ce.prototype.gcd = function(le) {
      if (this.isZero())
        return le.abs();
      if (le.isZero())
        return this.abs();
      var pe = this.clone(), ge = le.clone();
      pe.negative = 0, ge.negative = 0;
      for (var ye = 0; pe.isEven() && ge.isEven(); ye++)
        pe.iushrn(1), ge.iushrn(1);
      do {
        for (; pe.isEven(); )
          pe.iushrn(1);
        for (; ge.isEven(); )
          ge.iushrn(1);
        var xe = pe.cmp(ge);
        if (xe < 0) {
          var _e = pe;
          pe = ge, ge = _e;
        } else if (xe === 0 || ge.cmpn(1) === 0)
          break;
        pe.isub(ge);
      } while (!0);
      return ge.iushln(ye);
    }, ce.prototype.invm = function(le) {
      return this.egcd(le).a.umod(le);
    }, ce.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, ce.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, ce.prototype.andln = function(le) {
      return this.words[0] & le;
    }, ce.prototype.bincn = function(le) {
      fe(typeof le == "number");
      var pe = le % 26, ge = (le - pe) / 26, ye = 1 << pe;
      if (this.length <= ge)
        return this._expand(ge + 1), this.words[ge] |= ye, this;
      for (var xe = ye, _e = ge; xe !== 0 && _e < this.length; _e++) {
        var Ae = this.words[_e] | 0;
        Ae += xe, xe = Ae >>> 26, Ae &= 67108863, this.words[_e] = Ae;
      }
      return xe !== 0 && (this.words[_e] = xe, this.length++), this;
    }, ce.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, ce.prototype.cmpn = function(le) {
      var pe = le < 0;
      if (this.negative !== 0 && !pe)
        return -1;
      if (this.negative === 0 && pe)
        return 1;
      this.strip();
      var ge;
      if (this.length > 1)
        ge = 1;
      else {
        pe && (le = -le), fe(le <= 67108863, "Number is too big");
        var ye = this.words[0] | 0;
        ge = ye === le ? 0 : ye < le ? -1 : 1;
      }
      return this.negative !== 0 ? -ge | 0 : ge;
    }, ce.prototype.cmp = function(le) {
      if (this.negative !== 0 && le.negative === 0)
        return -1;
      if (this.negative === 0 && le.negative !== 0)
        return 1;
      var pe = this.ucmp(le);
      return this.negative !== 0 ? -pe | 0 : pe;
    }, ce.prototype.ucmp = function(le) {
      if (this.length > le.length)
        return 1;
      if (this.length < le.length)
        return -1;
      for (var pe = 0, ge = this.length - 1; ge >= 0; ge--) {
        var ye = this.words[ge] | 0, xe = le.words[ge] | 0;
        if (ye !== xe) {
          ye < xe ? pe = -1 : ye > xe && (pe = 1);
          break;
        }
      }
      return pe;
    }, ce.prototype.gtn = function(le) {
      return this.cmpn(le) === 1;
    }, ce.prototype.gt = function(le) {
      return this.cmp(le) === 1;
    }, ce.prototype.gten = function(le) {
      return this.cmpn(le) >= 0;
    }, ce.prototype.gte = function(le) {
      return this.cmp(le) >= 0;
    }, ce.prototype.ltn = function(le) {
      return this.cmpn(le) === -1;
    }, ce.prototype.lt = function(le) {
      return this.cmp(le) === -1;
    }, ce.prototype.lten = function(le) {
      return this.cmpn(le) <= 0;
    }, ce.prototype.lte = function(le) {
      return this.cmp(le) <= 0;
    }, ce.prototype.eqn = function(le) {
      return this.cmpn(le) === 0;
    }, ce.prototype.eq = function(le) {
      return this.cmp(le) === 0;
    }, ce.red = function(le) {
      return new ze(le);
    }, ce.prototype.toRed = function(le) {
      return fe(!this.red, "Already a number in reduction context"), fe(this.negative === 0, "red works only with positives"), le.convertTo(this)._forceRed(le);
    }, ce.prototype.fromRed = function() {
      return fe(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, ce.prototype._forceRed = function(le) {
      return this.red = le, this;
    }, ce.prototype.forceRed = function(le) {
      return fe(!this.red, "Already a number in reduction context"), this._forceRed(le);
    }, ce.prototype.redAdd = function(le) {
      return fe(this.red, "redAdd works only with red numbers"), this.red.add(this, le);
    }, ce.prototype.redIAdd = function(le) {
      return fe(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, le);
    }, ce.prototype.redSub = function(le) {
      return fe(this.red, "redSub works only with red numbers"), this.red.sub(this, le);
    }, ce.prototype.redISub = function(le) {
      return fe(this.red, "redISub works only with red numbers"), this.red.isub(this, le);
    }, ce.prototype.redShl = function(le) {
      return fe(this.red, "redShl works only with red numbers"), this.red.shl(this, le);
    }, ce.prototype.redMul = function(le) {
      return fe(this.red, "redMul works only with red numbers"), this.red._verify2(this, le), this.red.mul(this, le);
    }, ce.prototype.redIMul = function(le) {
      return fe(this.red, "redMul works only with red numbers"), this.red._verify2(this, le), this.red.imul(this, le);
    }, ce.prototype.redSqr = function() {
      return fe(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, ce.prototype.redISqr = function() {
      return fe(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, ce.prototype.redSqrt = function() {
      return fe(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, ce.prototype.redInvm = function() {
      return fe(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, ce.prototype.redNeg = function() {
      return fe(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, ce.prototype.redPow = function(le) {
      return fe(this.red && !le.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, le);
    };
    var Ge = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Ye($e, le) {
      this.name = $e, this.p = new ce(le, 16), this.n = this.p.bitLength(), this.k = new ce(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Ye.prototype._tmp = function() {
      var le = new ce(null);
      return le.words = new Array(Math.ceil(this.n / 13)), le;
    }, Ye.prototype.ireduce = function(le) {
      var pe = le, ge;
      do
        this.split(pe, this.tmp), pe = this.imulK(pe), pe = pe.iadd(this.tmp), ge = pe.bitLength();
      while (ge > this.n);
      var ye = ge < this.n ? -1 : pe.ucmp(this.p);
      return ye === 0 ? (pe.words[0] = 0, pe.length = 1) : ye > 0 ? pe.isub(this.p) : pe.strip !== void 0 ? pe.strip() : pe._strip(), pe;
    }, Ye.prototype.split = function(le, pe) {
      le.iushrn(this.n, 0, pe);
    }, Ye.prototype.imulK = function(le) {
      return le.imul(this.k);
    };
    function st() {
      Ye.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    ue(st, Ye), st.prototype.split = function(le, pe) {
      for (var ge = 4194303, ye = Math.min(le.length, 9), xe = 0; xe < ye; xe++)
        pe.words[xe] = le.words[xe];
      if (pe.length = ye, le.length <= 9) {
        le.words[0] = 0, le.length = 1;
        return;
      }
      var _e = le.words[9];
      for (pe.words[pe.length++] = _e & ge, xe = 10; xe < le.length; xe++) {
        var Ae = le.words[xe] | 0;
        le.words[xe - 10] = (Ae & ge) << 4 | _e >>> 22, _e = Ae;
      }
      _e >>>= 22, le.words[xe - 10] = _e, _e === 0 && le.length > 10 ? le.length -= 10 : le.length -= 9;
    }, st.prototype.imulK = function(le) {
      le.words[le.length] = 0, le.words[le.length + 1] = 0, le.length += 2;
      for (var pe = 0, ge = 0; ge < le.length; ge++) {
        var ye = le.words[ge] | 0;
        pe += ye * 977, le.words[ge] = pe & 67108863, pe = ye * 64 + (pe / 67108864 | 0);
      }
      return le.words[le.length - 1] === 0 && (le.length--, le.words[le.length - 1] === 0 && le.length--), le;
    };
    function at() {
      Ye.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    ue(at, Ye);
    function mt() {
      Ye.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    ue(mt, Ye);
    function qe() {
      Ye.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    ue(qe, Ye), qe.prototype.imulK = function(le) {
      for (var pe = 0, ge = 0; ge < le.length; ge++) {
        var ye = (le.words[ge] | 0) * 19 + pe, xe = ye & 67108863;
        ye >>>= 26, le.words[ge] = xe, pe = ye;
      }
      return pe !== 0 && (le.words[le.length++] = pe), le;
    }, ce._prime = function(le) {
      if (Ge[le])
        return Ge[le];
      var pe;
      if (le === "k256")
        pe = new st();
      else if (le === "p224")
        pe = new at();
      else if (le === "p192")
        pe = new mt();
      else if (le === "p25519")
        pe = new qe();
      else
        throw new Error("Unknown prime " + le);
      return Ge[le] = pe, pe;
    };
    function ze($e) {
      if (typeof $e == "string") {
        var le = ce._prime($e);
        this.m = le.p, this.prime = le;
      } else
        fe($e.gtn(1), "modulus must be greater than 1"), this.m = $e, this.prime = null;
    }
    ze.prototype._verify1 = function(le) {
      fe(le.negative === 0, "red works only with positives"), fe(le.red, "red works only with red numbers");
    }, ze.prototype._verify2 = function(le, pe) {
      fe((le.negative | pe.negative) === 0, "red works only with positives"), fe(
        le.red && le.red === pe.red,
        "red works only with red numbers"
      );
    }, ze.prototype.imod = function(le) {
      return this.prime ? this.prime.ireduce(le)._forceRed(this) : le.umod(this.m)._forceRed(this);
    }, ze.prototype.neg = function(le) {
      return le.isZero() ? le.clone() : this.m.sub(le)._forceRed(this);
    }, ze.prototype.add = function(le, pe) {
      this._verify2(le, pe);
      var ge = le.add(pe);
      return ge.cmp(this.m) >= 0 && ge.isub(this.m), ge._forceRed(this);
    }, ze.prototype.iadd = function(le, pe) {
      this._verify2(le, pe);
      var ge = le.iadd(pe);
      return ge.cmp(this.m) >= 0 && ge.isub(this.m), ge;
    }, ze.prototype.sub = function(le, pe) {
      this._verify2(le, pe);
      var ge = le.sub(pe);
      return ge.cmpn(0) < 0 && ge.iadd(this.m), ge._forceRed(this);
    }, ze.prototype.isub = function(le, pe) {
      this._verify2(le, pe);
      var ge = le.isub(pe);
      return ge.cmpn(0) < 0 && ge.iadd(this.m), ge;
    }, ze.prototype.shl = function(le, pe) {
      return this._verify1(le), this.imod(le.ushln(pe));
    }, ze.prototype.imul = function(le, pe) {
      return this._verify2(le, pe), this.imod(le.imul(pe));
    }, ze.prototype.mul = function(le, pe) {
      return this._verify2(le, pe), this.imod(le.mul(pe));
    }, ze.prototype.isqr = function(le) {
      return this.imul(le, le.clone());
    }, ze.prototype.sqr = function(le) {
      return this.mul(le, le);
    }, ze.prototype.sqrt = function(le) {
      if (le.isZero())
        return le.clone();
      var pe = this.m.andln(3);
      if (fe(pe % 2 === 1), pe === 3) {
        var ge = this.m.add(new ce(1)).iushrn(2);
        return this.pow(le, ge);
      }
      for (var ye = this.m.subn(1), xe = 0; !ye.isZero() && ye.andln(1) === 0; )
        xe++, ye.iushrn(1);
      fe(!ye.isZero());
      var _e = new ce(1).toRed(this), Ae = _e.redNeg(), ve = this.m.subn(1).iushrn(1), he = this.m.bitLength();
      for (he = new ce(2 * he * he).toRed(this); this.pow(he, ve).cmp(Ae) !== 0; )
        he.redIAdd(Ae);
      for (var be = this.pow(he, ye), Me = this.pow(le, ye.addn(1).iushrn(1)), Re = this.pow(le, ye), Oe = xe; Re.cmp(_e) !== 0; ) {
        for (var Te = Re, Fe = 0; Te.cmp(_e) !== 0; Fe++)
          Te = Te.redSqr();
        fe(Fe < Oe);
        var je = this.pow(be, new ce(1).iushln(Oe - Fe - 1));
        Me = Me.redMul(je), be = je.redSqr(), Re = Re.redMul(be), Oe = Fe;
      }
      return Me;
    }, ze.prototype.invm = function(le) {
      var pe = le._invmp(this.m);
      return pe.negative !== 0 ? (pe.negative = 0, this.imod(pe).redNeg()) : this.imod(pe);
    }, ze.prototype.pow = function(le, pe) {
      if (pe.isZero())
        return new ce(1).toRed(this);
      if (pe.cmpn(1) === 0)
        return le.clone();
      var ge = 4, ye = new Array(1 << ge);
      ye[0] = new ce(1).toRed(this), ye[1] = le;
      for (var xe = 2; xe < ye.length; xe++)
        ye[xe] = this.mul(ye[xe - 1], le);
      var _e = ye[0], Ae = 0, ve = 0, he = pe.bitLength() % 26;
      for (he === 0 && (he = 26), xe = pe.length - 1; xe >= 0; xe--) {
        for (var be = pe.words[xe], Me = he - 1; Me >= 0; Me--) {
          var Re = be >> Me & 1;
          if (_e !== ye[0] && (_e = this.sqr(_e)), Re === 0 && Ae === 0) {
            ve = 0;
            continue;
          }
          Ae <<= 1, Ae |= Re, ve++, !(ve !== ge && (xe !== 0 || Me !== 0)) && (_e = this.mul(_e, ye[Ae]), ve = 0, Ae = 0);
        }
        he = 26;
      }
      return _e;
    }, ze.prototype.convertTo = function(le) {
      var pe = le.umod(this.m);
      return pe === le ? pe.clone() : pe;
    }, ze.prototype.convertFrom = function(le) {
      var pe = le.clone();
      return pe.red = null, pe;
    }, ce.mont = function(le) {
      return new ot(le);
    };
    function ot($e) {
      ze.call(this, $e), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new ce(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    ue(ot, ze), ot.prototype.convertTo = function(le) {
      return this.imod(le.ushln(this.shift));
    }, ot.prototype.convertFrom = function(le) {
      var pe = this.imod(le.mul(this.rinv));
      return pe.red = null, pe;
    }, ot.prototype.imul = function(le, pe) {
      if (le.isZero() || pe.isZero())
        return le.words[0] = 0, le.length = 1, le;
      var ge = le.imul(pe), ye = ge.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), xe = ge.isub(ye).iushrn(this.shift), _e = xe;
      return xe.cmp(this.m) >= 0 ? _e = xe.isub(this.m) : xe.cmpn(0) < 0 && (_e = xe.iadd(this.m)), _e._forceRed(this);
    }, ot.prototype.mul = function(le, pe) {
      if (le.isZero() || pe.isZero())
        return new ce(0)._forceRed(this);
      var ge = le.mul(pe), ye = ge.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), xe = ge.isub(ye).iushrn(this.shift), _e = xe;
      return xe.cmp(this.m) >= 0 ? _e = xe.isub(this.m) : xe.cmpn(0) < 0 && (_e = xe.iadd(this.m)), _e._forceRed(this);
    }, ot.prototype.invm = function(le) {
      var pe = this.imod(le._invmp(this.m).mul(this.r2));
      return pe._forceRed(this);
    };
  })(ae, commonjsGlobal);
})(bn$3);
var bnExports$3 = bn$3.exports, utils$o = {};
(function(ae) {
  var ie = ae;
  function se(ce, de) {
    if (Array.isArray(ce))
      return ce.slice();
    if (!ce)
      return [];
    var me = [];
    if (typeof ce != "string") {
      for (var we = 0; we < ce.length; we++)
        me[we] = ce[we] | 0;
      return me;
    }
    if (de === "hex") {
      ce = ce.replace(/[^a-z0-9]+/ig, ""), ce.length % 2 !== 0 && (ce = "0" + ce);
      for (var we = 0; we < ce.length; we += 2)
        me.push(parseInt(ce[we] + ce[we + 1], 16));
    } else
      for (var we = 0; we < ce.length; we++) {
        var Ee = ce.charCodeAt(we), Se = Ee >> 8, Be = Ee & 255;
        Se ? me.push(Se, Be) : me.push(Be);
      }
    return me;
  }
  ie.toArray = se;
  function fe(ce) {
    return ce.length === 1 ? "0" + ce : ce;
  }
  ie.zero2 = fe;
  function ue(ce) {
    for (var de = "", me = 0; me < ce.length; me++)
      de += fe(ce[me].toString(16));
    return de;
  }
  ie.toHex = ue, ie.encode = function(de, me) {
    return me === "hex" ? ue(de) : de;
  };
})(utils$o);
(function(ae) {
  var ie = ae, se = bnExports$3, fe = minimalisticAssert$1, ue = utils$o;
  ie.assert = fe, ie.toArray = ue.toArray, ie.zero2 = ue.zero2, ie.toHex = ue.toHex, ie.encode = ue.encode;
  function ce(Se, Be, Ce) {
    var Ie = new Array(Math.max(Se.bitLength(), Ce) + 1);
    Ie.fill(0);
    for (var Pe = 1 << Be + 1, Ne = Se.clone(), ke = 0; ke < Ie.length; ke++) {
      var He, De = Ne.andln(Pe - 1);
      Ne.isOdd() ? (De > (Pe >> 1) - 1 ? He = (Pe >> 1) - De : He = De, Ne.isubn(He)) : He = 0, Ie[ke] = He, Ne.iushrn(1);
    }
    return Ie;
  }
  ie.getNAF = ce;
  function de(Se, Be) {
    var Ce = [
      [],
      []
    ];
    Se = Se.clone(), Be = Be.clone();
    for (var Ie = 0, Pe = 0, Ne; Se.cmpn(-Ie) > 0 || Be.cmpn(-Pe) > 0; ) {
      var ke = Se.andln(3) + Ie & 3, He = Be.andln(3) + Pe & 3;
      ke === 3 && (ke = -1), He === 3 && (He = -1);
      var De;
      ke & 1 ? (Ne = Se.andln(7) + Ie & 7, (Ne === 3 || Ne === 5) && He === 2 ? De = -ke : De = ke) : De = 0, Ce[0].push(De);
      var Ge;
      He & 1 ? (Ne = Be.andln(7) + Pe & 7, (Ne === 3 || Ne === 5) && ke === 2 ? Ge = -He : Ge = He) : Ge = 0, Ce[1].push(Ge), 2 * Ie === De + 1 && (Ie = 1 - Ie), 2 * Pe === Ge + 1 && (Pe = 1 - Pe), Se.iushrn(1), Be.iushrn(1);
    }
    return Ce;
  }
  ie.getJSF = de;
  function me(Se, Be, Ce) {
    var Ie = "_" + Be;
    Se.prototype[Be] = function() {
      return this[Ie] !== void 0 ? this[Ie] : this[Ie] = Ce.call(this);
    };
  }
  ie.cachedProperty = me;
  function we(Se) {
    return typeof Se == "string" ? ie.toArray(Se, "hex") : Se;
  }
  ie.parseBytes = we;
  function Ee(Se) {
    return new se(Se, "hex", "le");
  }
  ie.intFromLE = Ee;
})(utils$p);
var curve = {}, BN$b = bnExports$3, utils$n = utils$p, getNAF$1 = utils$n.getNAF, getJSF$1 = utils$n.getJSF, assert$k = utils$n.assert;
function BaseCurve$1(ae, ie) {
  this.type = ae, this.p = new BN$b(ie.p, 16), this.red = ie.prime ? BN$b.red(ie.prime) : BN$b.mont(this.p), this.zero = new BN$b(0).toRed(this.red), this.one = new BN$b(1).toRed(this.red), this.two = new BN$b(2).toRed(this.red), this.n = ie.n && new BN$b(ie.n, 16), this.g = ie.g && this.pointFromJSON(ie.g, ie.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var se = this.n && this.p.div(this.n);
  !se || se.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var base$6 = BaseCurve$1;
BaseCurve$1.prototype.point = function() {
  throw new Error("Not implemented");
};
BaseCurve$1.prototype.validate = function() {
  throw new Error("Not implemented");
};
BaseCurve$1.prototype._fixedNafMul = function(ie, se) {
  assert$k(ie.precomputed);
  var fe = ie._getDoubles(), ue = getNAF$1(se, 1, this._bitLength), ce = (1 << fe.step + 1) - (fe.step % 2 === 0 ? 2 : 1);
  ce /= 3;
  var de = [], me, we;
  for (me = 0; me < ue.length; me += fe.step) {
    we = 0;
    for (var Ee = me + fe.step - 1; Ee >= me; Ee--)
      we = (we << 1) + ue[Ee];
    de.push(we);
  }
  for (var Se = this.jpoint(null, null, null), Be = this.jpoint(null, null, null), Ce = ce; Ce > 0; Ce--) {
    for (me = 0; me < de.length; me++)
      we = de[me], we === Ce ? Be = Be.mixedAdd(fe.points[me]) : we === -Ce && (Be = Be.mixedAdd(fe.points[me].neg()));
    Se = Se.add(Be);
  }
  return Se.toP();
};
BaseCurve$1.prototype._wnafMul = function(ie, se) {
  var fe = 4, ue = ie._getNAFPoints(fe);
  fe = ue.wnd;
  for (var ce = ue.points, de = getNAF$1(se, fe, this._bitLength), me = this.jpoint(null, null, null), we = de.length - 1; we >= 0; we--) {
    for (var Ee = 0; we >= 0 && de[we] === 0; we--)
      Ee++;
    if (we >= 0 && Ee++, me = me.dblp(Ee), we < 0)
      break;
    var Se = de[we];
    assert$k(Se !== 0), ie.type === "affine" ? Se > 0 ? me = me.mixedAdd(ce[Se - 1 >> 1]) : me = me.mixedAdd(ce[-Se - 1 >> 1].neg()) : Se > 0 ? me = me.add(ce[Se - 1 >> 1]) : me = me.add(ce[-Se - 1 >> 1].neg());
  }
  return ie.type === "affine" ? me.toP() : me;
};
BaseCurve$1.prototype._wnafMulAdd = function(ie, se, fe, ue, ce) {
  var de = this._wnafT1, me = this._wnafT2, we = this._wnafT3, Ee = 0, Se, Be, Ce;
  for (Se = 0; Se < ue; Se++) {
    Ce = se[Se];
    var Ie = Ce._getNAFPoints(ie);
    de[Se] = Ie.wnd, me[Se] = Ie.points;
  }
  for (Se = ue - 1; Se >= 1; Se -= 2) {
    var Pe = Se - 1, Ne = Se;
    if (de[Pe] !== 1 || de[Ne] !== 1) {
      we[Pe] = getNAF$1(fe[Pe], de[Pe], this._bitLength), we[Ne] = getNAF$1(fe[Ne], de[Ne], this._bitLength), Ee = Math.max(we[Pe].length, Ee), Ee = Math.max(we[Ne].length, Ee);
      continue;
    }
    var ke = [
      se[Pe],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      se[Ne]
      /* 7 */
    ];
    se[Pe].y.cmp(se[Ne].y) === 0 ? (ke[1] = se[Pe].add(se[Ne]), ke[2] = se[Pe].toJ().mixedAdd(se[Ne].neg())) : se[Pe].y.cmp(se[Ne].y.redNeg()) === 0 ? (ke[1] = se[Pe].toJ().mixedAdd(se[Ne]), ke[2] = se[Pe].add(se[Ne].neg())) : (ke[1] = se[Pe].toJ().mixedAdd(se[Ne]), ke[2] = se[Pe].toJ().mixedAdd(se[Ne].neg()));
    var He = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], De = getJSF$1(fe[Pe], fe[Ne]);
    for (Ee = Math.max(De[0].length, Ee), we[Pe] = new Array(Ee), we[Ne] = new Array(Ee), Be = 0; Be < Ee; Be++) {
      var Ge = De[0][Be] | 0, Ye = De[1][Be] | 0;
      we[Pe][Be] = He[(Ge + 1) * 3 + (Ye + 1)], we[Ne][Be] = 0, me[Pe] = ke;
    }
  }
  var st = this.jpoint(null, null, null), at = this._wnafT4;
  for (Se = Ee; Se >= 0; Se--) {
    for (var mt = 0; Se >= 0; ) {
      var qe = !0;
      for (Be = 0; Be < ue; Be++)
        at[Be] = we[Be][Se] | 0, at[Be] !== 0 && (qe = !1);
      if (!qe)
        break;
      mt++, Se--;
    }
    if (Se >= 0 && mt++, st = st.dblp(mt), Se < 0)
      break;
    for (Be = 0; Be < ue; Be++) {
      var ze = at[Be];
      ze !== 0 && (ze > 0 ? Ce = me[Be][ze - 1 >> 1] : ze < 0 && (Ce = me[Be][-ze - 1 >> 1].neg()), Ce.type === "affine" ? st = st.mixedAdd(Ce) : st = st.add(Ce));
    }
  }
  for (Se = 0; Se < ue; Se++)
    me[Se] = null;
  return ce ? st : st.toP();
};
function BasePoint$1(ae, ie) {
  this.curve = ae, this.type = ie, this.precomputed = null;
}
BaseCurve$1.BasePoint = BasePoint$1;
BasePoint$1.prototype.eq = function() {
  throw new Error("Not implemented");
};
BasePoint$1.prototype.validate = function() {
  return this.curve.validate(this);
};
BaseCurve$1.prototype.decodePoint = function(ie, se) {
  ie = utils$n.toArray(ie, se);
  var fe = this.p.byteLength();
  if ((ie[0] === 4 || ie[0] === 6 || ie[0] === 7) && ie.length - 1 === 2 * fe) {
    ie[0] === 6 ? assert$k(ie[ie.length - 1] % 2 === 0) : ie[0] === 7 && assert$k(ie[ie.length - 1] % 2 === 1);
    var ue = this.point(
      ie.slice(1, 1 + fe),
      ie.slice(1 + fe, 1 + 2 * fe)
    );
    return ue;
  } else if ((ie[0] === 2 || ie[0] === 3) && ie.length - 1 === fe)
    return this.pointFromX(ie.slice(1, 1 + fe), ie[0] === 3);
  throw new Error("Unknown point format");
};
BasePoint$1.prototype.encodeCompressed = function(ie) {
  return this.encode(ie, !0);
};
BasePoint$1.prototype._encode = function(ie) {
  var se = this.curve.p.byteLength(), fe = this.getX().toArray("be", se);
  return ie ? [this.getY().isEven() ? 2 : 3].concat(fe) : [4].concat(fe, this.getY().toArray("be", se));
};
BasePoint$1.prototype.encode = function(ie, se) {
  return utils$n.encode(this._encode(se), ie);
};
BasePoint$1.prototype.precompute = function(ie) {
  if (this.precomputed)
    return this;
  var se = {
    doubles: null,
    naf: null,
    beta: null
  };
  return se.naf = this._getNAFPoints(8), se.doubles = this._getDoubles(4, ie), se.beta = this._getBeta(), this.precomputed = se, this;
};
BasePoint$1.prototype._hasDoubles = function(ie) {
  if (!this.precomputed)
    return !1;
  var se = this.precomputed.doubles;
  return se ? se.points.length >= Math.ceil((ie.bitLength() + 1) / se.step) : !1;
};
BasePoint$1.prototype._getDoubles = function(ie, se) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var fe = [this], ue = this, ce = 0; ce < se; ce += ie) {
    for (var de = 0; de < ie; de++)
      ue = ue.dbl();
    fe.push(ue);
  }
  return {
    step: ie,
    points: fe
  };
};
BasePoint$1.prototype._getNAFPoints = function(ie) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var se = [this], fe = (1 << ie) - 1, ue = fe === 1 ? null : this.dbl(), ce = 1; ce < fe; ce++)
    se[ce] = se[ce - 1].add(ue);
  return {
    wnd: ie,
    points: se
  };
};
BasePoint$1.prototype._getBeta = function() {
  return null;
};
BasePoint$1.prototype.dblp = function(ie) {
  for (var se = this, fe = 0; fe < ie; fe++)
    se = se.dbl();
  return se;
};
var utils$m = utils$p, BN$a = bnExports$3, inherits$b = inherits_browserExports, Base$2 = base$6, assert$j = utils$m.assert;
function ShortCurve$1(ae) {
  Base$2.call(this, "short", ae), this.a = new BN$a(ae.a, 16).toRed(this.red), this.b = new BN$a(ae.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(ae), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
inherits$b(ShortCurve$1, Base$2);
var short = ShortCurve$1;
ShortCurve$1.prototype._getEndomorphism = function(ie) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var se, fe;
    if (ie.beta)
      se = new BN$a(ie.beta, 16).toRed(this.red);
    else {
      var ue = this._getEndoRoots(this.p);
      se = ue[0].cmp(ue[1]) < 0 ? ue[0] : ue[1], se = se.toRed(this.red);
    }
    if (ie.lambda)
      fe = new BN$a(ie.lambda, 16);
    else {
      var ce = this._getEndoRoots(this.n);
      this.g.mul(ce[0]).x.cmp(this.g.x.redMul(se)) === 0 ? fe = ce[0] : (fe = ce[1], assert$j(this.g.mul(fe).x.cmp(this.g.x.redMul(se)) === 0));
    }
    var de;
    return ie.basis ? de = ie.basis.map(function(me) {
      return {
        a: new BN$a(me.a, 16),
        b: new BN$a(me.b, 16)
      };
    }) : de = this._getEndoBasis(fe), {
      beta: se,
      lambda: fe,
      basis: de
    };
  }
};
ShortCurve$1.prototype._getEndoRoots = function(ie) {
  var se = ie === this.p ? this.red : BN$a.mont(ie), fe = new BN$a(2).toRed(se).redInvm(), ue = fe.redNeg(), ce = new BN$a(3).toRed(se).redNeg().redSqrt().redMul(fe), de = ue.redAdd(ce).fromRed(), me = ue.redSub(ce).fromRed();
  return [de, me];
};
ShortCurve$1.prototype._getEndoBasis = function(ie) {
  for (var se = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), fe = ie, ue = this.n.clone(), ce = new BN$a(1), de = new BN$a(0), me = new BN$a(0), we = new BN$a(1), Ee, Se, Be, Ce, Ie, Pe, Ne, ke = 0, He, De; fe.cmpn(0) !== 0; ) {
    var Ge = ue.div(fe);
    He = ue.sub(Ge.mul(fe)), De = me.sub(Ge.mul(ce));
    var Ye = we.sub(Ge.mul(de));
    if (!Be && He.cmp(se) < 0)
      Ee = Ne.neg(), Se = ce, Be = He.neg(), Ce = De;
    else if (Be && ++ke === 2)
      break;
    Ne = He, ue = fe, fe = He, me = ce, ce = De, we = de, de = Ye;
  }
  Ie = He.neg(), Pe = De;
  var st = Be.sqr().add(Ce.sqr()), at = Ie.sqr().add(Pe.sqr());
  return at.cmp(st) >= 0 && (Ie = Ee, Pe = Se), Be.negative && (Be = Be.neg(), Ce = Ce.neg()), Ie.negative && (Ie = Ie.neg(), Pe = Pe.neg()), [
    { a: Be, b: Ce },
    { a: Ie, b: Pe }
  ];
};
ShortCurve$1.prototype._endoSplit = function(ie) {
  var se = this.endo.basis, fe = se[0], ue = se[1], ce = ue.b.mul(ie).divRound(this.n), de = fe.b.neg().mul(ie).divRound(this.n), me = ce.mul(fe.a), we = de.mul(ue.a), Ee = ce.mul(fe.b), Se = de.mul(ue.b), Be = ie.sub(me).sub(we), Ce = Ee.add(Se).neg();
  return { k1: Be, k2: Ce };
};
ShortCurve$1.prototype.pointFromX = function(ie, se) {
  ie = new BN$a(ie, 16), ie.red || (ie = ie.toRed(this.red));
  var fe = ie.redSqr().redMul(ie).redIAdd(ie.redMul(this.a)).redIAdd(this.b), ue = fe.redSqrt();
  if (ue.redSqr().redSub(fe).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var ce = ue.fromRed().isOdd();
  return (se && !ce || !se && ce) && (ue = ue.redNeg()), this.point(ie, ue);
};
ShortCurve$1.prototype.validate = function(ie) {
  if (ie.inf)
    return !0;
  var se = ie.x, fe = ie.y, ue = this.a.redMul(se), ce = se.redSqr().redMul(se).redIAdd(ue).redIAdd(this.b);
  return fe.redSqr().redISub(ce).cmpn(0) === 0;
};
ShortCurve$1.prototype._endoWnafMulAdd = function(ie, se, fe) {
  for (var ue = this._endoWnafT1, ce = this._endoWnafT2, de = 0; de < ie.length; de++) {
    var me = this._endoSplit(se[de]), we = ie[de], Ee = we._getBeta();
    me.k1.negative && (me.k1.ineg(), we = we.neg(!0)), me.k2.negative && (me.k2.ineg(), Ee = Ee.neg(!0)), ue[de * 2] = we, ue[de * 2 + 1] = Ee, ce[de * 2] = me.k1, ce[de * 2 + 1] = me.k2;
  }
  for (var Se = this._wnafMulAdd(1, ue, ce, de * 2, fe), Be = 0; Be < de * 2; Be++)
    ue[Be] = null, ce[Be] = null;
  return Se;
};
function Point$5(ae, ie, se, fe) {
  Base$2.BasePoint.call(this, ae, "affine"), ie === null && se === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN$a(ie, 16), this.y = new BN$a(se, 16), fe && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
inherits$b(Point$5, Base$2.BasePoint);
ShortCurve$1.prototype.point = function(ie, se, fe) {
  return new Point$5(this, ie, se, fe);
};
ShortCurve$1.prototype.pointFromJSON = function(ie, se) {
  return Point$5.fromJSON(this, ie, se);
};
Point$5.prototype._getBeta = function() {
  if (this.curve.endo) {
    var ie = this.precomputed;
    if (ie && ie.beta)
      return ie.beta;
    var se = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (ie) {
      var fe = this.curve, ue = function(ce) {
        return fe.point(ce.x.redMul(fe.endo.beta), ce.y);
      };
      ie.beta = se, se.precomputed = {
        beta: null,
        naf: ie.naf && {
          wnd: ie.naf.wnd,
          points: ie.naf.points.map(ue)
        },
        doubles: ie.doubles && {
          step: ie.doubles.step,
          points: ie.doubles.points.map(ue)
        }
      };
    }
    return se;
  }
};
Point$5.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Point$5.fromJSON = function(ie, se, fe) {
  typeof se == "string" && (se = JSON.parse(se));
  var ue = ie.point(se[0], se[1], fe);
  if (!se[2])
    return ue;
  function ce(me) {
    return ie.point(me[0], me[1], fe);
  }
  var de = se[2];
  return ue.precomputed = {
    beta: null,
    doubles: de.doubles && {
      step: de.doubles.step,
      points: [ue].concat(de.doubles.points.map(ce))
    },
    naf: de.naf && {
      wnd: de.naf.wnd,
      points: [ue].concat(de.naf.points.map(ce))
    }
  }, ue;
};
Point$5.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point$5.prototype.isInfinity = function() {
  return this.inf;
};
Point$5.prototype.add = function(ie) {
  if (this.inf)
    return ie;
  if (ie.inf)
    return this;
  if (this.eq(ie))
    return this.dbl();
  if (this.neg().eq(ie))
    return this.curve.point(null, null);
  if (this.x.cmp(ie.x) === 0)
    return this.curve.point(null, null);
  var se = this.y.redSub(ie.y);
  se.cmpn(0) !== 0 && (se = se.redMul(this.x.redSub(ie.x).redInvm()));
  var fe = se.redSqr().redISub(this.x).redISub(ie.x), ue = se.redMul(this.x.redSub(fe)).redISub(this.y);
  return this.curve.point(fe, ue);
};
Point$5.prototype.dbl = function() {
  if (this.inf)
    return this;
  var ie = this.y.redAdd(this.y);
  if (ie.cmpn(0) === 0)
    return this.curve.point(null, null);
  var se = this.curve.a, fe = this.x.redSqr(), ue = ie.redInvm(), ce = fe.redAdd(fe).redIAdd(fe).redIAdd(se).redMul(ue), de = ce.redSqr().redISub(this.x.redAdd(this.x)), me = ce.redMul(this.x.redSub(de)).redISub(this.y);
  return this.curve.point(de, me);
};
Point$5.prototype.getX = function() {
  return this.x.fromRed();
};
Point$5.prototype.getY = function() {
  return this.y.fromRed();
};
Point$5.prototype.mul = function(ie) {
  return ie = new BN$a(ie, 16), this.isInfinity() ? this : this._hasDoubles(ie) ? this.curve._fixedNafMul(this, ie) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [ie]) : this.curve._wnafMul(this, ie);
};
Point$5.prototype.mulAdd = function(ie, se, fe) {
  var ue = [this, se], ce = [ie, fe];
  return this.curve.endo ? this.curve._endoWnafMulAdd(ue, ce) : this.curve._wnafMulAdd(1, ue, ce, 2);
};
Point$5.prototype.jmulAdd = function(ie, se, fe) {
  var ue = [this, se], ce = [ie, fe];
  return this.curve.endo ? this.curve._endoWnafMulAdd(ue, ce, !0) : this.curve._wnafMulAdd(1, ue, ce, 2, !0);
};
Point$5.prototype.eq = function(ie) {
  return this === ie || this.inf === ie.inf && (this.inf || this.x.cmp(ie.x) === 0 && this.y.cmp(ie.y) === 0);
};
Point$5.prototype.neg = function(ie) {
  if (this.inf)
    return this;
  var se = this.curve.point(this.x, this.y.redNeg());
  if (ie && this.precomputed) {
    var fe = this.precomputed, ue = function(ce) {
      return ce.neg();
    };
    se.precomputed = {
      naf: fe.naf && {
        wnd: fe.naf.wnd,
        points: fe.naf.points.map(ue)
      },
      doubles: fe.doubles && {
        step: fe.doubles.step,
        points: fe.doubles.points.map(ue)
      }
    };
  }
  return se;
};
Point$5.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var ie = this.curve.jpoint(this.x, this.y, this.curve.one);
  return ie;
};
function JPoint$1(ae, ie, se, fe) {
  Base$2.BasePoint.call(this, ae, "jacobian"), ie === null && se === null && fe === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN$a(0)) : (this.x = new BN$a(ie, 16), this.y = new BN$a(se, 16), this.z = new BN$a(fe, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
inherits$b(JPoint$1, Base$2.BasePoint);
ShortCurve$1.prototype.jpoint = function(ie, se, fe) {
  return new JPoint$1(this, ie, se, fe);
};
JPoint$1.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var ie = this.z.redInvm(), se = ie.redSqr(), fe = this.x.redMul(se), ue = this.y.redMul(se).redMul(ie);
  return this.curve.point(fe, ue);
};
JPoint$1.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint$1.prototype.add = function(ie) {
  if (this.isInfinity())
    return ie;
  if (ie.isInfinity())
    return this;
  var se = ie.z.redSqr(), fe = this.z.redSqr(), ue = this.x.redMul(se), ce = ie.x.redMul(fe), de = this.y.redMul(se.redMul(ie.z)), me = ie.y.redMul(fe.redMul(this.z)), we = ue.redSub(ce), Ee = de.redSub(me);
  if (we.cmpn(0) === 0)
    return Ee.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var Se = we.redSqr(), Be = Se.redMul(we), Ce = ue.redMul(Se), Ie = Ee.redSqr().redIAdd(Be).redISub(Ce).redISub(Ce), Pe = Ee.redMul(Ce.redISub(Ie)).redISub(de.redMul(Be)), Ne = this.z.redMul(ie.z).redMul(we);
  return this.curve.jpoint(Ie, Pe, Ne);
};
JPoint$1.prototype.mixedAdd = function(ie) {
  if (this.isInfinity())
    return ie.toJ();
  if (ie.isInfinity())
    return this;
  var se = this.z.redSqr(), fe = this.x, ue = ie.x.redMul(se), ce = this.y, de = ie.y.redMul(se).redMul(this.z), me = fe.redSub(ue), we = ce.redSub(de);
  if (me.cmpn(0) === 0)
    return we.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var Ee = me.redSqr(), Se = Ee.redMul(me), Be = fe.redMul(Ee), Ce = we.redSqr().redIAdd(Se).redISub(Be).redISub(Be), Ie = we.redMul(Be.redISub(Ce)).redISub(ce.redMul(Se)), Pe = this.z.redMul(me);
  return this.curve.jpoint(Ce, Ie, Pe);
};
JPoint$1.prototype.dblp = function(ie) {
  if (ie === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!ie)
    return this.dbl();
  var se;
  if (this.curve.zeroA || this.curve.threeA) {
    var fe = this;
    for (se = 0; se < ie; se++)
      fe = fe.dbl();
    return fe;
  }
  var ue = this.curve.a, ce = this.curve.tinv, de = this.x, me = this.y, we = this.z, Ee = we.redSqr().redSqr(), Se = me.redAdd(me);
  for (se = 0; se < ie; se++) {
    var Be = de.redSqr(), Ce = Se.redSqr(), Ie = Ce.redSqr(), Pe = Be.redAdd(Be).redIAdd(Be).redIAdd(ue.redMul(Ee)), Ne = de.redMul(Ce), ke = Pe.redSqr().redISub(Ne.redAdd(Ne)), He = Ne.redISub(ke), De = Pe.redMul(He);
    De = De.redIAdd(De).redISub(Ie);
    var Ge = Se.redMul(we);
    se + 1 < ie && (Ee = Ee.redMul(Ie)), de = ke, we = Ge, Se = De;
  }
  return this.curve.jpoint(de, Se.redMul(ce), we);
};
JPoint$1.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
JPoint$1.prototype._zeroDbl = function() {
  var ie, se, fe;
  if (this.zOne) {
    var ue = this.x.redSqr(), ce = this.y.redSqr(), de = ce.redSqr(), me = this.x.redAdd(ce).redSqr().redISub(ue).redISub(de);
    me = me.redIAdd(me);
    var we = ue.redAdd(ue).redIAdd(ue), Ee = we.redSqr().redISub(me).redISub(me), Se = de.redIAdd(de);
    Se = Se.redIAdd(Se), Se = Se.redIAdd(Se), ie = Ee, se = we.redMul(me.redISub(Ee)).redISub(Se), fe = this.y.redAdd(this.y);
  } else {
    var Be = this.x.redSqr(), Ce = this.y.redSqr(), Ie = Ce.redSqr(), Pe = this.x.redAdd(Ce).redSqr().redISub(Be).redISub(Ie);
    Pe = Pe.redIAdd(Pe);
    var Ne = Be.redAdd(Be).redIAdd(Be), ke = Ne.redSqr(), He = Ie.redIAdd(Ie);
    He = He.redIAdd(He), He = He.redIAdd(He), ie = ke.redISub(Pe).redISub(Pe), se = Ne.redMul(Pe.redISub(ie)).redISub(He), fe = this.y.redMul(this.z), fe = fe.redIAdd(fe);
  }
  return this.curve.jpoint(ie, se, fe);
};
JPoint$1.prototype._threeDbl = function() {
  var ie, se, fe;
  if (this.zOne) {
    var ue = this.x.redSqr(), ce = this.y.redSqr(), de = ce.redSqr(), me = this.x.redAdd(ce).redSqr().redISub(ue).redISub(de);
    me = me.redIAdd(me);
    var we = ue.redAdd(ue).redIAdd(ue).redIAdd(this.curve.a), Ee = we.redSqr().redISub(me).redISub(me);
    ie = Ee;
    var Se = de.redIAdd(de);
    Se = Se.redIAdd(Se), Se = Se.redIAdd(Se), se = we.redMul(me.redISub(Ee)).redISub(Se), fe = this.y.redAdd(this.y);
  } else {
    var Be = this.z.redSqr(), Ce = this.y.redSqr(), Ie = this.x.redMul(Ce), Pe = this.x.redSub(Be).redMul(this.x.redAdd(Be));
    Pe = Pe.redAdd(Pe).redIAdd(Pe);
    var Ne = Ie.redIAdd(Ie);
    Ne = Ne.redIAdd(Ne);
    var ke = Ne.redAdd(Ne);
    ie = Pe.redSqr().redISub(ke), fe = this.y.redAdd(this.z).redSqr().redISub(Ce).redISub(Be);
    var He = Ce.redSqr();
    He = He.redIAdd(He), He = He.redIAdd(He), He = He.redIAdd(He), se = Pe.redMul(Ne.redISub(ie)).redISub(He);
  }
  return this.curve.jpoint(ie, se, fe);
};
JPoint$1.prototype._dbl = function() {
  var ie = this.curve.a, se = this.x, fe = this.y, ue = this.z, ce = ue.redSqr().redSqr(), de = se.redSqr(), me = fe.redSqr(), we = de.redAdd(de).redIAdd(de).redIAdd(ie.redMul(ce)), Ee = se.redAdd(se);
  Ee = Ee.redIAdd(Ee);
  var Se = Ee.redMul(me), Be = we.redSqr().redISub(Se.redAdd(Se)), Ce = Se.redISub(Be), Ie = me.redSqr();
  Ie = Ie.redIAdd(Ie), Ie = Ie.redIAdd(Ie), Ie = Ie.redIAdd(Ie);
  var Pe = we.redMul(Ce).redISub(Ie), Ne = fe.redAdd(fe).redMul(ue);
  return this.curve.jpoint(Be, Pe, Ne);
};
JPoint$1.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var ie = this.x.redSqr(), se = this.y.redSqr(), fe = this.z.redSqr(), ue = se.redSqr(), ce = ie.redAdd(ie).redIAdd(ie), de = ce.redSqr(), me = this.x.redAdd(se).redSqr().redISub(ie).redISub(ue);
  me = me.redIAdd(me), me = me.redAdd(me).redIAdd(me), me = me.redISub(de);
  var we = me.redSqr(), Ee = ue.redIAdd(ue);
  Ee = Ee.redIAdd(Ee), Ee = Ee.redIAdd(Ee), Ee = Ee.redIAdd(Ee);
  var Se = ce.redIAdd(me).redSqr().redISub(de).redISub(we).redISub(Ee), Be = se.redMul(Se);
  Be = Be.redIAdd(Be), Be = Be.redIAdd(Be);
  var Ce = this.x.redMul(we).redISub(Be);
  Ce = Ce.redIAdd(Ce), Ce = Ce.redIAdd(Ce);
  var Ie = this.y.redMul(Se.redMul(Ee.redISub(Se)).redISub(me.redMul(we)));
  Ie = Ie.redIAdd(Ie), Ie = Ie.redIAdd(Ie), Ie = Ie.redIAdd(Ie);
  var Pe = this.z.redAdd(me).redSqr().redISub(fe).redISub(we);
  return this.curve.jpoint(Ce, Ie, Pe);
};
JPoint$1.prototype.mul = function(ie, se) {
  return ie = new BN$a(ie, se), this.curve._wnafMul(this, ie);
};
JPoint$1.prototype.eq = function(ie) {
  if (ie.type === "affine")
    return this.eq(ie.toJ());
  if (this === ie)
    return !0;
  var se = this.z.redSqr(), fe = ie.z.redSqr();
  if (this.x.redMul(fe).redISub(ie.x.redMul(se)).cmpn(0) !== 0)
    return !1;
  var ue = se.redMul(this.z), ce = fe.redMul(ie.z);
  return this.y.redMul(ce).redISub(ie.y.redMul(ue)).cmpn(0) === 0;
};
JPoint$1.prototype.eqXToP = function(ie) {
  var se = this.z.redSqr(), fe = ie.toRed(this.curve.red).redMul(se);
  if (this.x.cmp(fe) === 0)
    return !0;
  for (var ue = ie.clone(), ce = this.curve.redN.redMul(se); ; ) {
    if (ue.iadd(this.curve.n), ue.cmp(this.curve.p) >= 0)
      return !1;
    if (fe.redIAdd(ce), this.x.cmp(fe) === 0)
      return !0;
  }
};
JPoint$1.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint$1.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var BN$9 = bnExports$3, inherits$a = inherits_browserExports, Base$1 = base$6, utils$l = utils$p;
function MontCurve(ae) {
  Base$1.call(this, "mont", ae), this.a = new BN$9(ae.a, 16).toRed(this.red), this.b = new BN$9(ae.b, 16).toRed(this.red), this.i4 = new BN$9(4).toRed(this.red).redInvm(), this.two = new BN$9(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits$a(MontCurve, Base$1);
var mont = MontCurve;
MontCurve.prototype.validate = function(ie) {
  var se = ie.normalize().x, fe = se.redSqr(), ue = fe.redMul(se).redAdd(fe.redMul(this.a)).redAdd(se), ce = ue.redSqrt();
  return ce.redSqr().cmp(ue) === 0;
};
function Point$4(ae, ie, se) {
  Base$1.BasePoint.call(this, ae, "projective"), ie === null && se === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new BN$9(ie, 16), this.z = new BN$9(se, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
inherits$a(Point$4, Base$1.BasePoint);
MontCurve.prototype.decodePoint = function(ie, se) {
  return this.point(utils$l.toArray(ie, se), 1);
};
MontCurve.prototype.point = function(ie, se) {
  return new Point$4(this, ie, se);
};
MontCurve.prototype.pointFromJSON = function(ie) {
  return Point$4.fromJSON(this, ie);
};
Point$4.prototype.precompute = function() {
};
Point$4.prototype._encode = function() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
Point$4.fromJSON = function(ie, se) {
  return new Point$4(ie, se[0], se[1] || ie.one);
};
Point$4.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point$4.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
Point$4.prototype.dbl = function() {
  var ie = this.x.redAdd(this.z), se = ie.redSqr(), fe = this.x.redSub(this.z), ue = fe.redSqr(), ce = se.redSub(ue), de = se.redMul(ue), me = ce.redMul(ue.redAdd(this.curve.a24.redMul(ce)));
  return this.curve.point(de, me);
};
Point$4.prototype.add = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$4.prototype.diffAdd = function(ie, se) {
  var fe = this.x.redAdd(this.z), ue = this.x.redSub(this.z), ce = ie.x.redAdd(ie.z), de = ie.x.redSub(ie.z), me = de.redMul(fe), we = ce.redMul(ue), Ee = se.z.redMul(me.redAdd(we).redSqr()), Se = se.x.redMul(me.redISub(we).redSqr());
  return this.curve.point(Ee, Se);
};
Point$4.prototype.mul = function(ie) {
  for (var se = ie.clone(), fe = this, ue = this.curve.point(null, null), ce = this, de = []; se.cmpn(0) !== 0; se.iushrn(1))
    de.push(se.andln(1));
  for (var me = de.length - 1; me >= 0; me--)
    de[me] === 0 ? (fe = fe.diffAdd(ue, ce), ue = ue.dbl()) : (ue = fe.diffAdd(ue, ce), fe = fe.dbl());
  return ue;
};
Point$4.prototype.mulAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$4.prototype.jumlAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$4.prototype.eq = function(ie) {
  return this.getX().cmp(ie.getX()) === 0;
};
Point$4.prototype.normalize = function() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
};
Point$4.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
var utils$k = utils$p, BN$8 = bnExports$3, inherits$9 = inherits_browserExports, Base = base$6, assert$i = utils$k.assert;
function EdwardsCurve(ae) {
  this.twisted = (ae.a | 0) !== 1, this.mOneA = this.twisted && (ae.a | 0) === -1, this.extended = this.mOneA, Base.call(this, "edwards", ae), this.a = new BN$8(ae.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new BN$8(ae.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new BN$8(ae.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), assert$i(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (ae.c | 0) === 1;
}
inherits$9(EdwardsCurve, Base);
var edwards = EdwardsCurve;
EdwardsCurve.prototype._mulA = function(ie) {
  return this.mOneA ? ie.redNeg() : this.a.redMul(ie);
};
EdwardsCurve.prototype._mulC = function(ie) {
  return this.oneC ? ie : this.c.redMul(ie);
};
EdwardsCurve.prototype.jpoint = function(ie, se, fe, ue) {
  return this.point(ie, se, fe, ue);
};
EdwardsCurve.prototype.pointFromX = function(ie, se) {
  ie = new BN$8(ie, 16), ie.red || (ie = ie.toRed(this.red));
  var fe = ie.redSqr(), ue = this.c2.redSub(this.a.redMul(fe)), ce = this.one.redSub(this.c2.redMul(this.d).redMul(fe)), de = ue.redMul(ce.redInvm()), me = de.redSqrt();
  if (me.redSqr().redSub(de).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var we = me.fromRed().isOdd();
  return (se && !we || !se && we) && (me = me.redNeg()), this.point(ie, me);
};
EdwardsCurve.prototype.pointFromY = function(ie, se) {
  ie = new BN$8(ie, 16), ie.red || (ie = ie.toRed(this.red));
  var fe = ie.redSqr(), ue = fe.redSub(this.c2), ce = fe.redMul(this.d).redMul(this.c2).redSub(this.a), de = ue.redMul(ce.redInvm());
  if (de.cmp(this.zero) === 0) {
    if (se)
      throw new Error("invalid point");
    return this.point(this.zero, ie);
  }
  var me = de.redSqrt();
  if (me.redSqr().redSub(de).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return me.fromRed().isOdd() !== se && (me = me.redNeg()), this.point(me, ie);
};
EdwardsCurve.prototype.validate = function(ie) {
  if (ie.isInfinity())
    return !0;
  ie.normalize();
  var se = ie.x.redSqr(), fe = ie.y.redSqr(), ue = se.redMul(this.a).redAdd(fe), ce = this.c2.redMul(this.one.redAdd(this.d.redMul(se).redMul(fe)));
  return ue.cmp(ce) === 0;
};
function Point$3(ae, ie, se, fe, ue) {
  Base.BasePoint.call(this, ae, "projective"), ie === null && se === null && fe === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new BN$8(ie, 16), this.y = new BN$8(se, 16), this.z = fe ? new BN$8(fe, 16) : this.curve.one, this.t = ue && new BN$8(ue, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
inherits$9(Point$3, Base.BasePoint);
EdwardsCurve.prototype.pointFromJSON = function(ie) {
  return Point$3.fromJSON(this, ie);
};
EdwardsCurve.prototype.point = function(ie, se, fe, ue) {
  return new Point$3(this, ie, se, fe, ue);
};
Point$3.fromJSON = function(ie, se) {
  return new Point$3(ie, se[0], se[1], se[2]);
};
Point$3.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point$3.prototype.isInfinity = function() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Point$3.prototype._extDbl = function() {
  var ie = this.x.redSqr(), se = this.y.redSqr(), fe = this.z.redSqr();
  fe = fe.redIAdd(fe);
  var ue = this.curve._mulA(ie), ce = this.x.redAdd(this.y).redSqr().redISub(ie).redISub(se), de = ue.redAdd(se), me = de.redSub(fe), we = ue.redSub(se), Ee = ce.redMul(me), Se = de.redMul(we), Be = ce.redMul(we), Ce = me.redMul(de);
  return this.curve.point(Ee, Se, Ce, Be);
};
Point$3.prototype._projDbl = function() {
  var ie = this.x.redAdd(this.y).redSqr(), se = this.x.redSqr(), fe = this.y.redSqr(), ue, ce, de, me, we, Ee;
  if (this.curve.twisted) {
    me = this.curve._mulA(se);
    var Se = me.redAdd(fe);
    this.zOne ? (ue = ie.redSub(se).redSub(fe).redMul(Se.redSub(this.curve.two)), ce = Se.redMul(me.redSub(fe)), de = Se.redSqr().redSub(Se).redSub(Se)) : (we = this.z.redSqr(), Ee = Se.redSub(we).redISub(we), ue = ie.redSub(se).redISub(fe).redMul(Ee), ce = Se.redMul(me.redSub(fe)), de = Se.redMul(Ee));
  } else
    me = se.redAdd(fe), we = this.curve._mulC(this.z).redSqr(), Ee = me.redSub(we).redSub(we), ue = this.curve._mulC(ie.redISub(me)).redMul(Ee), ce = this.curve._mulC(me).redMul(se.redISub(fe)), de = me.redMul(Ee);
  return this.curve.point(ue, ce, de);
};
Point$3.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
};
Point$3.prototype._extAdd = function(ie) {
  var se = this.y.redSub(this.x).redMul(ie.y.redSub(ie.x)), fe = this.y.redAdd(this.x).redMul(ie.y.redAdd(ie.x)), ue = this.t.redMul(this.curve.dd).redMul(ie.t), ce = this.z.redMul(ie.z.redAdd(ie.z)), de = fe.redSub(se), me = ce.redSub(ue), we = ce.redAdd(ue), Ee = fe.redAdd(se), Se = de.redMul(me), Be = we.redMul(Ee), Ce = de.redMul(Ee), Ie = me.redMul(we);
  return this.curve.point(Se, Be, Ie, Ce);
};
Point$3.prototype._projAdd = function(ie) {
  var se = this.z.redMul(ie.z), fe = se.redSqr(), ue = this.x.redMul(ie.x), ce = this.y.redMul(ie.y), de = this.curve.d.redMul(ue).redMul(ce), me = fe.redSub(de), we = fe.redAdd(de), Ee = this.x.redAdd(this.y).redMul(ie.x.redAdd(ie.y)).redISub(ue).redISub(ce), Se = se.redMul(me).redMul(Ee), Be, Ce;
  return this.curve.twisted ? (Be = se.redMul(we).redMul(ce.redSub(this.curve._mulA(ue))), Ce = me.redMul(we)) : (Be = se.redMul(we).redMul(ce.redSub(ue)), Ce = this.curve._mulC(me).redMul(we)), this.curve.point(Se, Be, Ce);
};
Point$3.prototype.add = function(ie) {
  return this.isInfinity() ? ie : ie.isInfinity() ? this : this.curve.extended ? this._extAdd(ie) : this._projAdd(ie);
};
Point$3.prototype.mul = function(ie) {
  return this._hasDoubles(ie) ? this.curve._fixedNafMul(this, ie) : this.curve._wnafMul(this, ie);
};
Point$3.prototype.mulAdd = function(ie, se, fe) {
  return this.curve._wnafMulAdd(1, [this, se], [ie, fe], 2, !1);
};
Point$3.prototype.jmulAdd = function(ie, se, fe) {
  return this.curve._wnafMulAdd(1, [this, se], [ie, fe], 2, !0);
};
Point$3.prototype.normalize = function() {
  if (this.zOne)
    return this;
  var ie = this.z.redInvm();
  return this.x = this.x.redMul(ie), this.y = this.y.redMul(ie), this.t && (this.t = this.t.redMul(ie)), this.z = this.curve.one, this.zOne = !0, this;
};
Point$3.prototype.neg = function() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
Point$3.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
Point$3.prototype.getY = function() {
  return this.normalize(), this.y.fromRed();
};
Point$3.prototype.eq = function(ie) {
  return this === ie || this.getX().cmp(ie.getX()) === 0 && this.getY().cmp(ie.getY()) === 0;
};
Point$3.prototype.eqXToP = function(ie) {
  var se = ie.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(se) === 0)
    return !0;
  for (var fe = ie.clone(), ue = this.curve.redN.redMul(this.z); ; ) {
    if (fe.iadd(this.curve.n), fe.cmp(this.curve.p) >= 0)
      return !1;
    if (se.redIAdd(ue), this.x.cmp(se) === 0)
      return !0;
  }
};
Point$3.prototype.toP = Point$3.prototype.normalize;
Point$3.prototype.mixedAdd = Point$3.prototype.add;
(function(ae) {
  var ie = ae;
  ie.base = base$6, ie.short = short, ie.mont = mont, ie.edwards = edwards;
})(curve);
var curves$1 = {}, hash$4 = {}, utils$j = {}, assert$h = minimalisticAssert$1, inherits$8 = inherits_browserExports;
utils$j.inherits = inherits$8;
function isSurrogatePair(ae, ie) {
  return (ae.charCodeAt(ie) & 64512) !== 55296 || ie < 0 || ie + 1 >= ae.length ? !1 : (ae.charCodeAt(ie + 1) & 64512) === 56320;
}
function toArray$1(ae, ie) {
  if (Array.isArray(ae))
    return ae.slice();
  if (!ae)
    return [];
  var se = [];
  if (typeof ae == "string")
    if (ie) {
      if (ie === "hex")
        for (ae = ae.replace(/[^a-z0-9]+/ig, ""), ae.length % 2 !== 0 && (ae = "0" + ae), ue = 0; ue < ae.length; ue += 2)
          se.push(parseInt(ae[ue] + ae[ue + 1], 16));
    } else
      for (var fe = 0, ue = 0; ue < ae.length; ue++) {
        var ce = ae.charCodeAt(ue);
        ce < 128 ? se[fe++] = ce : ce < 2048 ? (se[fe++] = ce >> 6 | 192, se[fe++] = ce & 63 | 128) : isSurrogatePair(ae, ue) ? (ce = 65536 + ((ce & 1023) << 10) + (ae.charCodeAt(++ue) & 1023), se[fe++] = ce >> 18 | 240, se[fe++] = ce >> 12 & 63 | 128, se[fe++] = ce >> 6 & 63 | 128, se[fe++] = ce & 63 | 128) : (se[fe++] = ce >> 12 | 224, se[fe++] = ce >> 6 & 63 | 128, se[fe++] = ce & 63 | 128);
      }
  else
    for (ue = 0; ue < ae.length; ue++)
      se[ue] = ae[ue] | 0;
  return se;
}
utils$j.toArray = toArray$1;
function toHex$1(ae) {
  for (var ie = "", se = 0; se < ae.length; se++)
    ie += zero2(ae[se].toString(16));
  return ie;
}
utils$j.toHex = toHex$1;
function htonl(ae) {
  var ie = ae >>> 24 | ae >>> 8 & 65280 | ae << 8 & 16711680 | (ae & 255) << 24;
  return ie >>> 0;
}
utils$j.htonl = htonl;
function toHex32(ae, ie) {
  for (var se = "", fe = 0; fe < ae.length; fe++) {
    var ue = ae[fe];
    ie === "little" && (ue = htonl(ue)), se += zero8(ue.toString(16));
  }
  return se;
}
utils$j.toHex32 = toHex32;
function zero2(ae) {
  return ae.length === 1 ? "0" + ae : ae;
}
utils$j.zero2 = zero2;
function zero8(ae) {
  return ae.length === 7 ? "0" + ae : ae.length === 6 ? "00" + ae : ae.length === 5 ? "000" + ae : ae.length === 4 ? "0000" + ae : ae.length === 3 ? "00000" + ae : ae.length === 2 ? "000000" + ae : ae.length === 1 ? "0000000" + ae : ae;
}
utils$j.zero8 = zero8;
function join32(ae, ie, se, fe) {
  var ue = se - ie;
  assert$h(ue % 4 === 0);
  for (var ce = new Array(ue / 4), de = 0, me = ie; de < ce.length; de++, me += 4) {
    var we;
    fe === "big" ? we = ae[me] << 24 | ae[me + 1] << 16 | ae[me + 2] << 8 | ae[me + 3] : we = ae[me + 3] << 24 | ae[me + 2] << 16 | ae[me + 1] << 8 | ae[me], ce[de] = we >>> 0;
  }
  return ce;
}
utils$j.join32 = join32;
function split32(ae, ie) {
  for (var se = new Array(ae.length * 4), fe = 0, ue = 0; fe < ae.length; fe++, ue += 4) {
    var ce = ae[fe];
    ie === "big" ? (se[ue] = ce >>> 24, se[ue + 1] = ce >>> 16 & 255, se[ue + 2] = ce >>> 8 & 255, se[ue + 3] = ce & 255) : (se[ue + 3] = ce >>> 24, se[ue + 2] = ce >>> 16 & 255, se[ue + 1] = ce >>> 8 & 255, se[ue] = ce & 255);
  }
  return se;
}
utils$j.split32 = split32;
function rotr32$1(ae, ie) {
  return ae >>> ie | ae << 32 - ie;
}
utils$j.rotr32 = rotr32$1;
function rotl32$2(ae, ie) {
  return ae << ie | ae >>> 32 - ie;
}
utils$j.rotl32 = rotl32$2;
function sum32$3(ae, ie) {
  return ae + ie >>> 0;
}
utils$j.sum32 = sum32$3;
function sum32_3$1(ae, ie, se) {
  return ae + ie + se >>> 0;
}
utils$j.sum32_3 = sum32_3$1;
function sum32_4$2(ae, ie, se, fe) {
  return ae + ie + se + fe >>> 0;
}
utils$j.sum32_4 = sum32_4$2;
function sum32_5$2(ae, ie, se, fe, ue) {
  return ae + ie + se + fe + ue >>> 0;
}
utils$j.sum32_5 = sum32_5$2;
function sum64$1(ae, ie, se, fe) {
  var ue = ae[ie], ce = ae[ie + 1], de = fe + ce >>> 0, me = (de < fe ? 1 : 0) + se + ue;
  ae[ie] = me >>> 0, ae[ie + 1] = de;
}
utils$j.sum64 = sum64$1;
function sum64_hi$1(ae, ie, se, fe) {
  var ue = ie + fe >>> 0, ce = (ue < ie ? 1 : 0) + ae + se;
  return ce >>> 0;
}
utils$j.sum64_hi = sum64_hi$1;
function sum64_lo$1(ae, ie, se, fe) {
  var ue = ie + fe;
  return ue >>> 0;
}
utils$j.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(ae, ie, se, fe, ue, ce, de, me) {
  var we = 0, Ee = ie;
  Ee = Ee + fe >>> 0, we += Ee < ie ? 1 : 0, Ee = Ee + ce >>> 0, we += Ee < ce ? 1 : 0, Ee = Ee + me >>> 0, we += Ee < me ? 1 : 0;
  var Se = ae + se + ue + de + we;
  return Se >>> 0;
}
utils$j.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(ae, ie, se, fe, ue, ce, de, me) {
  var we = ie + fe + ce + me;
  return we >>> 0;
}
utils$j.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(ae, ie, se, fe, ue, ce, de, me, we, Ee) {
  var Se = 0, Be = ie;
  Be = Be + fe >>> 0, Se += Be < ie ? 1 : 0, Be = Be + ce >>> 0, Se += Be < ce ? 1 : 0, Be = Be + me >>> 0, Se += Be < me ? 1 : 0, Be = Be + Ee >>> 0, Se += Be < Ee ? 1 : 0;
  var Ce = ae + se + ue + de + we + Se;
  return Ce >>> 0;
}
utils$j.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(ae, ie, se, fe, ue, ce, de, me, we, Ee) {
  var Se = ie + fe + ce + me + Ee;
  return Se >>> 0;
}
utils$j.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(ae, ie, se) {
  var fe = ie << 32 - se | ae >>> se;
  return fe >>> 0;
}
utils$j.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(ae, ie, se) {
  var fe = ae << 32 - se | ie >>> se;
  return fe >>> 0;
}
utils$j.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(ae, ie, se) {
  return ae >>> se;
}
utils$j.shr64_hi = shr64_hi$1;
function shr64_lo$1(ae, ie, se) {
  var fe = ae << 32 - se | ie >>> se;
  return fe >>> 0;
}
utils$j.shr64_lo = shr64_lo$1;
var common$5 = {}, utils$i = utils$j, assert$g = minimalisticAssert$1;
function BlockHash$4() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function(ie, se) {
  if (ie = utils$i.toArray(ie, se), this.pending ? this.pending = this.pending.concat(ie) : this.pending = ie, this.pendingTotal += ie.length, this.pending.length >= this._delta8) {
    ie = this.pending;
    var fe = ie.length % this._delta8;
    this.pending = ie.slice(ie.length - fe, ie.length), this.pending.length === 0 && (this.pending = null), ie = utils$i.join32(ie, 0, ie.length - fe, this.endian);
    for (var ue = 0; ue < ie.length; ue += this._delta32)
      this._update(ie, ue, ue + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function(ie) {
  return this.update(this._pad()), assert$g(this.pending === null), this._digest(ie);
};
BlockHash$4.prototype._pad = function() {
  var ie = this.pendingTotal, se = this._delta8, fe = se - (ie + this.padLength) % se, ue = new Array(fe + this.padLength);
  ue[0] = 128;
  for (var ce = 1; ce < fe; ce++)
    ue[ce] = 0;
  if (ie <<= 3, this.endian === "big") {
    for (var de = 8; de < this.padLength; de++)
      ue[ce++] = 0;
    ue[ce++] = 0, ue[ce++] = 0, ue[ce++] = 0, ue[ce++] = 0, ue[ce++] = ie >>> 24 & 255, ue[ce++] = ie >>> 16 & 255, ue[ce++] = ie >>> 8 & 255, ue[ce++] = ie & 255;
  } else
    for (ue[ce++] = ie & 255, ue[ce++] = ie >>> 8 & 255, ue[ce++] = ie >>> 16 & 255, ue[ce++] = ie >>> 24 & 255, ue[ce++] = 0, ue[ce++] = 0, ue[ce++] = 0, ue[ce++] = 0, de = 8; de < this.padLength; de++)
      ue[ce++] = 0;
  return ue;
};
var sha = {}, common$4 = {}, utils$h = utils$j, rotr32 = utils$h.rotr32;
function ft_1$1(ae, ie, se, fe) {
  if (ae === 0)
    return ch32$1(ie, se, fe);
  if (ae === 1 || ae === 3)
    return p32(ie, se, fe);
  if (ae === 2)
    return maj32$1(ie, se, fe);
}
common$4.ft_1 = ft_1$1;
function ch32$1(ae, ie, se) {
  return ae & ie ^ ~ae & se;
}
common$4.ch32 = ch32$1;
function maj32$1(ae, ie, se) {
  return ae & ie ^ ae & se ^ ie & se;
}
common$4.maj32 = maj32$1;
function p32(ae, ie, se) {
  return ae ^ ie ^ se;
}
common$4.p32 = p32;
function s0_256$1(ae) {
  return rotr32(ae, 2) ^ rotr32(ae, 13) ^ rotr32(ae, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(ae) {
  return rotr32(ae, 6) ^ rotr32(ae, 11) ^ rotr32(ae, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(ae) {
  return rotr32(ae, 7) ^ rotr32(ae, 18) ^ ae >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(ae) {
  return rotr32(ae, 17) ^ rotr32(ae, 19) ^ ae >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$g = utils$j, common$3 = common$5, shaCommon$1 = common$4, rotl32$1 = utils$g.rotl32, sum32$2 = utils$g.sum32, sum32_5$1 = utils$g.sum32_5, ft_1 = shaCommon$1.ft_1, BlockHash$3 = common$3.BlockHash, sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
utils$g.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function(ie, se) {
  for (var fe = this.W, ue = 0; ue < 16; ue++)
    fe[ue] = ie[se + ue];
  for (; ue < fe.length; ue++)
    fe[ue] = rotl32$1(fe[ue - 3] ^ fe[ue - 8] ^ fe[ue - 14] ^ fe[ue - 16], 1);
  var ce = this.h[0], de = this.h[1], me = this.h[2], we = this.h[3], Ee = this.h[4];
  for (ue = 0; ue < fe.length; ue++) {
    var Se = ~~(ue / 20), Be = sum32_5$1(rotl32$1(ce, 5), ft_1(Se, de, me, we), Ee, fe[ue], sha1_K[Se]);
    Ee = we, we = me, me = rotl32$1(de, 30), de = ce, ce = Be;
  }
  this.h[0] = sum32$2(this.h[0], ce), this.h[1] = sum32$2(this.h[1], de), this.h[2] = sum32$2(this.h[2], me), this.h[3] = sum32$2(this.h[3], we), this.h[4] = sum32$2(this.h[4], Ee);
};
SHA1.prototype._digest = function(ie) {
  return ie === "hex" ? utils$g.toHex32(this.h, "big") : utils$g.split32(this.h, "big");
};
var utils$f = utils$j, common$2 = common$5, shaCommon = common$4, assert$f = minimalisticAssert$1, sum32$1 = utils$f.sum32, sum32_4$1 = utils$f.sum32_4, sum32_5 = utils$f.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash$2 = common$2.BlockHash, sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$2() {
  if (!(this instanceof SHA256$2))
    return new SHA256$2();
  BlockHash$2.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = sha256_K, this.W = new Array(64);
}
utils$f.inherits(SHA256$2, BlockHash$2);
var _256 = SHA256$2;
SHA256$2.blockSize = 512;
SHA256$2.outSize = 256;
SHA256$2.hmacStrength = 192;
SHA256$2.padLength = 64;
SHA256$2.prototype._update = function(ie, se) {
  for (var fe = this.W, ue = 0; ue < 16; ue++)
    fe[ue] = ie[se + ue];
  for (; ue < fe.length; ue++)
    fe[ue] = sum32_4$1(g1_256(fe[ue - 2]), fe[ue - 7], g0_256(fe[ue - 15]), fe[ue - 16]);
  var ce = this.h[0], de = this.h[1], me = this.h[2], we = this.h[3], Ee = this.h[4], Se = this.h[5], Be = this.h[6], Ce = this.h[7];
  for (assert$f(this.k.length === fe.length), ue = 0; ue < fe.length; ue++) {
    var Ie = sum32_5(Ce, s1_256(Ee), ch32(Ee, Se, Be), this.k[ue], fe[ue]), Pe = sum32$1(s0_256(ce), maj32(ce, de, me));
    Ce = Be, Be = Se, Se = Ee, Ee = sum32$1(we, Ie), we = me, me = de, de = ce, ce = sum32$1(Ie, Pe);
  }
  this.h[0] = sum32$1(this.h[0], ce), this.h[1] = sum32$1(this.h[1], de), this.h[2] = sum32$1(this.h[2], me), this.h[3] = sum32$1(this.h[3], we), this.h[4] = sum32$1(this.h[4], Ee), this.h[5] = sum32$1(this.h[5], Se), this.h[6] = sum32$1(this.h[6], Be), this.h[7] = sum32$1(this.h[7], Ce);
};
SHA256$2.prototype._digest = function(ie) {
  return ie === "hex" ? utils$f.toHex32(this.h, "big") : utils$f.split32(this.h, "big");
};
var utils$e = utils$j, SHA256$1 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256$1.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$e.inherits(SHA224, SHA256$1);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function(ie) {
  return ie === "hex" ? utils$e.toHex32(this.h.slice(0, 7), "big") : utils$e.split32(this.h.slice(0, 7), "big");
};
var utils$d = utils$j, common$1 = common$5, assert$e = minimalisticAssert$1, rotr64_hi = utils$d.rotr64_hi, rotr64_lo = utils$d.rotr64_lo, shr64_hi = utils$d.shr64_hi, shr64_lo = utils$d.shr64_lo, sum64 = utils$d.sum64, sum64_hi = utils$d.sum64_hi, sum64_lo = utils$d.sum64_lo, sum64_4_hi = utils$d.sum64_4_hi, sum64_4_lo = utils$d.sum64_4_lo, sum64_5_hi = utils$d.sum64_5_hi, sum64_5_lo = utils$d.sum64_5_lo, BlockHash$1 = common$1.BlockHash, sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$2() {
  if (!(this instanceof SHA512$2))
    return new SHA512$2();
  BlockHash$1.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = sha512_K, this.W = new Array(160);
}
utils$d.inherits(SHA512$2, BlockHash$1);
var _512 = SHA512$2;
SHA512$2.blockSize = 1024;
SHA512$2.outSize = 512;
SHA512$2.hmacStrength = 192;
SHA512$2.padLength = 128;
SHA512$2.prototype._prepareBlock = function(ie, se) {
  for (var fe = this.W, ue = 0; ue < 32; ue++)
    fe[ue] = ie[se + ue];
  for (; ue < fe.length; ue += 2) {
    var ce = g1_512_hi(fe[ue - 4], fe[ue - 3]), de = g1_512_lo(fe[ue - 4], fe[ue - 3]), me = fe[ue - 14], we = fe[ue - 13], Ee = g0_512_hi(fe[ue - 30], fe[ue - 29]), Se = g0_512_lo(fe[ue - 30], fe[ue - 29]), Be = fe[ue - 32], Ce = fe[ue - 31];
    fe[ue] = sum64_4_hi(
      ce,
      de,
      me,
      we,
      Ee,
      Se,
      Be,
      Ce
    ), fe[ue + 1] = sum64_4_lo(
      ce,
      de,
      me,
      we,
      Ee,
      Se,
      Be,
      Ce
    );
  }
};
SHA512$2.prototype._update = function(ie, se) {
  this._prepareBlock(ie, se);
  var fe = this.W, ue = this.h[0], ce = this.h[1], de = this.h[2], me = this.h[3], we = this.h[4], Ee = this.h[5], Se = this.h[6], Be = this.h[7], Ce = this.h[8], Ie = this.h[9], Pe = this.h[10], Ne = this.h[11], ke = this.h[12], He = this.h[13], De = this.h[14], Ge = this.h[15];
  assert$e(this.k.length === fe.length);
  for (var Ye = 0; Ye < fe.length; Ye += 2) {
    var st = De, at = Ge, mt = s1_512_hi(Ce, Ie), qe = s1_512_lo(Ce, Ie), ze = ch64_hi(Ce, Ie, Pe, Ne, ke), ot = ch64_lo(Ce, Ie, Pe, Ne, ke, He), $e = this.k[Ye], le = this.k[Ye + 1], pe = fe[Ye], ge = fe[Ye + 1], ye = sum64_5_hi(
      st,
      at,
      mt,
      qe,
      ze,
      ot,
      $e,
      le,
      pe,
      ge
    ), xe = sum64_5_lo(
      st,
      at,
      mt,
      qe,
      ze,
      ot,
      $e,
      le,
      pe,
      ge
    );
    st = s0_512_hi(ue, ce), at = s0_512_lo(ue, ce), mt = maj64_hi(ue, ce, de, me, we), qe = maj64_lo(ue, ce, de, me, we, Ee);
    var _e = sum64_hi(st, at, mt, qe), Ae = sum64_lo(st, at, mt, qe);
    De = ke, Ge = He, ke = Pe, He = Ne, Pe = Ce, Ne = Ie, Ce = sum64_hi(Se, Be, ye, xe), Ie = sum64_lo(Be, Be, ye, xe), Se = we, Be = Ee, we = de, Ee = me, de = ue, me = ce, ue = sum64_hi(ye, xe, _e, Ae), ce = sum64_lo(ye, xe, _e, Ae);
  }
  sum64(this.h, 0, ue, ce), sum64(this.h, 2, de, me), sum64(this.h, 4, we, Ee), sum64(this.h, 6, Se, Be), sum64(this.h, 8, Ce, Ie), sum64(this.h, 10, Pe, Ne), sum64(this.h, 12, ke, He), sum64(this.h, 14, De, Ge);
};
SHA512$2.prototype._digest = function(ie) {
  return ie === "hex" ? utils$d.toHex32(this.h, "big") : utils$d.split32(this.h, "big");
};
function ch64_hi(ae, ie, se, fe, ue) {
  var ce = ae & se ^ ~ae & ue;
  return ce < 0 && (ce += 4294967296), ce;
}
function ch64_lo(ae, ie, se, fe, ue, ce) {
  var de = ie & fe ^ ~ie & ce;
  return de < 0 && (de += 4294967296), de;
}
function maj64_hi(ae, ie, se, fe, ue) {
  var ce = ae & se ^ ae & ue ^ se & ue;
  return ce < 0 && (ce += 4294967296), ce;
}
function maj64_lo(ae, ie, se, fe, ue, ce) {
  var de = ie & fe ^ ie & ce ^ fe & ce;
  return de < 0 && (de += 4294967296), de;
}
function s0_512_hi(ae, ie) {
  var se = rotr64_hi(ae, ie, 28), fe = rotr64_hi(ie, ae, 2), ue = rotr64_hi(ie, ae, 7), ce = se ^ fe ^ ue;
  return ce < 0 && (ce += 4294967296), ce;
}
function s0_512_lo(ae, ie) {
  var se = rotr64_lo(ae, ie, 28), fe = rotr64_lo(ie, ae, 2), ue = rotr64_lo(ie, ae, 7), ce = se ^ fe ^ ue;
  return ce < 0 && (ce += 4294967296), ce;
}
function s1_512_hi(ae, ie) {
  var se = rotr64_hi(ae, ie, 14), fe = rotr64_hi(ae, ie, 18), ue = rotr64_hi(ie, ae, 9), ce = se ^ fe ^ ue;
  return ce < 0 && (ce += 4294967296), ce;
}
function s1_512_lo(ae, ie) {
  var se = rotr64_lo(ae, ie, 14), fe = rotr64_lo(ae, ie, 18), ue = rotr64_lo(ie, ae, 9), ce = se ^ fe ^ ue;
  return ce < 0 && (ce += 4294967296), ce;
}
function g0_512_hi(ae, ie) {
  var se = rotr64_hi(ae, ie, 1), fe = rotr64_hi(ae, ie, 8), ue = shr64_hi(ae, ie, 7), ce = se ^ fe ^ ue;
  return ce < 0 && (ce += 4294967296), ce;
}
function g0_512_lo(ae, ie) {
  var se = rotr64_lo(ae, ie, 1), fe = rotr64_lo(ae, ie, 8), ue = shr64_lo(ae, ie, 7), ce = se ^ fe ^ ue;
  return ce < 0 && (ce += 4294967296), ce;
}
function g1_512_hi(ae, ie) {
  var se = rotr64_hi(ae, ie, 19), fe = rotr64_hi(ie, ae, 29), ue = shr64_hi(ae, ie, 6), ce = se ^ fe ^ ue;
  return ce < 0 && (ce += 4294967296), ce;
}
function g1_512_lo(ae, ie) {
  var se = rotr64_lo(ae, ie, 19), fe = rotr64_lo(ie, ae, 29), ue = shr64_lo(ae, ie, 6), ce = se ^ fe ^ ue;
  return ce < 0 && (ce += 4294967296), ce;
}
var utils$c = utils$j, SHA512$1 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512$1.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$c.inherits(SHA384, SHA512$1);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function(ie) {
  return ie === "hex" ? utils$c.toHex32(this.h.slice(0, 12), "big") : utils$c.split32(this.h.slice(0, 12), "big");
};
sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;
var ripemd = {}, utils$b = utils$j, common = common$5, rotl32 = utils$b.rotl32, sum32 = utils$b.sum32, sum32_3 = utils$b.sum32_3, sum32_4 = utils$b.sum32_4, BlockHash = common.BlockHash;
function RIPEMD160$1() {
  if (!(this instanceof RIPEMD160$1))
    return new RIPEMD160$1();
  BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
utils$b.inherits(RIPEMD160$1, BlockHash);
ripemd.ripemd160 = RIPEMD160$1;
RIPEMD160$1.blockSize = 512;
RIPEMD160$1.outSize = 160;
RIPEMD160$1.hmacStrength = 192;
RIPEMD160$1.padLength = 64;
RIPEMD160$1.prototype._update = function(ie, se) {
  for (var fe = this.h[0], ue = this.h[1], ce = this.h[2], de = this.h[3], me = this.h[4], we = fe, Ee = ue, Se = ce, Be = de, Ce = me, Ie = 0; Ie < 80; Ie++) {
    var Pe = sum32(
      rotl32(
        sum32_4(fe, f$d(Ie, ue, ce, de), ie[r$a[Ie] + se], K$3(Ie)),
        s$6[Ie]
      ),
      me
    );
    fe = me, me = de, de = rotl32(ce, 10), ce = ue, ue = Pe, Pe = sum32(
      rotl32(
        sum32_4(we, f$d(79 - Ie, Ee, Se, Be), ie[rh[Ie] + se], Kh(Ie)),
        sh[Ie]
      ),
      Ce
    ), we = Ce, Ce = Be, Be = rotl32(Se, 10), Se = Ee, Ee = Pe;
  }
  Pe = sum32_3(this.h[1], ce, Be), this.h[1] = sum32_3(this.h[2], de, Ce), this.h[2] = sum32_3(this.h[3], me, we), this.h[3] = sum32_3(this.h[4], fe, Ee), this.h[4] = sum32_3(this.h[0], ue, Se), this.h[0] = Pe;
};
RIPEMD160$1.prototype._digest = function(ie) {
  return ie === "hex" ? utils$b.toHex32(this.h, "little") : utils$b.split32(this.h, "little");
};
function f$d(ae, ie, se, fe) {
  return ae <= 15 ? ie ^ se ^ fe : ae <= 31 ? ie & se | ~ie & fe : ae <= 47 ? (ie | ~se) ^ fe : ae <= 63 ? ie & fe | se & ~fe : ie ^ (se | ~fe);
}
function K$3(ae) {
  return ae <= 15 ? 0 : ae <= 31 ? 1518500249 : ae <= 47 ? 1859775393 : ae <= 63 ? 2400959708 : 2840853838;
}
function Kh(ae) {
  return ae <= 15 ? 1352829926 : ae <= 31 ? 1548603684 : ae <= 47 ? 1836072691 : ae <= 63 ? 2053994217 : 0;
}
var r$a = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], s$6 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], utils$a = utils$j, assert$d = minimalisticAssert$1;
function Hmac(ae, ie, se) {
  if (!(this instanceof Hmac))
    return new Hmac(ae, ie, se);
  this.Hash = ae, this.blockSize = ae.blockSize / 8, this.outSize = ae.outSize / 8, this.inner = null, this.outer = null, this._init(utils$a.toArray(ie, se));
}
var hmac$1 = Hmac;
Hmac.prototype._init = function(ie) {
  ie.length > this.blockSize && (ie = new this.Hash().update(ie).digest()), assert$d(ie.length <= this.blockSize);
  for (var se = ie.length; se < this.blockSize; se++)
    ie.push(0);
  for (se = 0; se < ie.length; se++)
    ie[se] ^= 54;
  for (this.inner = new this.Hash().update(ie), se = 0; se < ie.length; se++)
    ie[se] ^= 106;
  this.outer = new this.Hash().update(ie);
};
Hmac.prototype.update = function(ie, se) {
  return this.inner.update(ie, se), this;
};
Hmac.prototype.digest = function(ie) {
  return this.outer.update(this.inner.digest()), this.outer.digest(ie);
};
(function(ae) {
  var ie = ae;
  ie.utils = utils$j, ie.common = common$5, ie.sha = sha, ie.ripemd = ripemd, ie.hmac = hmac$1, ie.sha1 = ie.sha.sha1, ie.sha256 = ie.sha.sha256, ie.sha224 = ie.sha.sha224, ie.sha384 = ie.sha.sha384, ie.sha512 = ie.sha.sha512, ie.ripemd160 = ie.ripemd.ripemd160;
})(hash$4);
const hash$3 = /* @__PURE__ */ getDefaultExportFromCjs$2(hash$4);
var secp256k1$2, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1$2 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1$2;
}
(function(ae) {
  var ie = ae, se = hash$4, fe = curve, ue = utils$p, ce = ue.assert;
  function de(Ee) {
    Ee.type === "short" ? this.curve = new fe.short(Ee) : Ee.type === "edwards" ? this.curve = new fe.edwards(Ee) : this.curve = new fe.mont(Ee), this.g = this.curve.g, this.n = this.curve.n, this.hash = Ee.hash, ce(this.g.validate(), "Invalid curve"), ce(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  ie.PresetCurve = de;
  function me(Ee, Se) {
    Object.defineProperty(ie, Ee, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var Be = new de(Se);
        return Object.defineProperty(ie, Ee, {
          configurable: !0,
          enumerable: !0,
          value: Be
        }), Be;
      }
    });
  }
  me("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: se.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), me("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: se.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), me("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: se.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), me("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: se.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), me("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: se.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), me("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: se.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), me("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: se.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var we;
  try {
    we = requireSecp256k1();
  } catch {
    we = void 0;
  }
  me("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: se.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      we
    ]
  });
})(curves$1);
var hash$2 = hash$4, utils$9 = utils$o, assert$c = minimalisticAssert$1;
function HmacDRBG$1(ae) {
  if (!(this instanceof HmacDRBG$1))
    return new HmacDRBG$1(ae);
  this.hash = ae.hash, this.predResist = !!ae.predResist, this.outLen = this.hash.outSize, this.minEntropy = ae.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var ie = utils$9.toArray(ae.entropy, ae.entropyEnc || "hex"), se = utils$9.toArray(ae.nonce, ae.nonceEnc || "hex"), fe = utils$9.toArray(ae.pers, ae.persEnc || "hex");
  assert$c(
    ie.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(ie, se, fe);
}
var hmacDrbg$1 = HmacDRBG$1;
HmacDRBG$1.prototype._init = function(ie, se, fe) {
  var ue = ie.concat(se).concat(fe);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var ce = 0; ce < this.V.length; ce++)
    this.K[ce] = 0, this.V[ce] = 1;
  this._update(ue), this._reseed = 1, this.reseedInterval = 281474976710656;
};
HmacDRBG$1.prototype._hmac = function() {
  return new hash$2.hmac(this.hash, this.K);
};
HmacDRBG$1.prototype._update = function(ie) {
  var se = this._hmac().update(this.V).update([0]);
  ie && (se = se.update(ie)), this.K = se.digest(), this.V = this._hmac().update(this.V).digest(), ie && (this.K = this._hmac().update(this.V).update([1]).update(ie).digest(), this.V = this._hmac().update(this.V).digest());
};
HmacDRBG$1.prototype.reseed = function(ie, se, fe, ue) {
  typeof se != "string" && (ue = fe, fe = se, se = null), ie = utils$9.toArray(ie, se), fe = utils$9.toArray(fe, ue), assert$c(
    ie.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(ie.concat(fe || [])), this._reseed = 1;
};
HmacDRBG$1.prototype.generate = function(ie, se, fe, ue) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof se != "string" && (ue = fe, fe = se, se = null), fe && (fe = utils$9.toArray(fe, ue || "hex"), this._update(fe));
  for (var ce = []; ce.length < ie; )
    this.V = this._hmac().update(this.V).digest(), ce = ce.concat(this.V);
  var de = ce.slice(0, ie);
  return this._update(fe), this._reseed++, utils$9.encode(de, se);
};
var BN$7 = bnExports$3, utils$8 = utils$p, assert$b = utils$8.assert;
function KeyPair$5(ae, ie) {
  this.ec = ae, this.priv = null, this.pub = null, ie.priv && this._importPrivate(ie.priv, ie.privEnc), ie.pub && this._importPublic(ie.pub, ie.pubEnc);
}
var key$3 = KeyPair$5;
KeyPair$5.fromPublic = function(ie, se, fe) {
  return se instanceof KeyPair$5 ? se : new KeyPair$5(ie, {
    pub: se,
    pubEnc: fe
  });
};
KeyPair$5.fromPrivate = function(ie, se, fe) {
  return se instanceof KeyPair$5 ? se : new KeyPair$5(ie, {
    priv: se,
    privEnc: fe
  });
};
KeyPair$5.prototype.validate = function() {
  var ie = this.getPublic();
  return ie.isInfinity() ? { result: !1, reason: "Invalid public key" } : ie.validate() ? ie.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
KeyPair$5.prototype.getPublic = function(ie, se) {
  return typeof ie == "string" && (se = ie, ie = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), se ? this.pub.encode(se, ie) : this.pub;
};
KeyPair$5.prototype.getPrivate = function(ie) {
  return ie === "hex" ? this.priv.toString(16, 2) : this.priv;
};
KeyPair$5.prototype._importPrivate = function(ie, se) {
  this.priv = new BN$7(ie, se || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair$5.prototype._importPublic = function(ie, se) {
  if (ie.x || ie.y) {
    this.ec.curve.type === "mont" ? assert$b(ie.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && assert$b(ie.x && ie.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(ie.x, ie.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(ie, se);
};
KeyPair$5.prototype.derive = function(ie) {
  return ie.validate() || assert$b(ie.validate(), "public point not validated"), ie.mul(this.priv).getX();
};
KeyPair$5.prototype.sign = function(ie, se, fe) {
  return this.ec.sign(ie, this, se, fe);
};
KeyPair$5.prototype.verify = function(ie, se) {
  return this.ec.verify(ie, se, this);
};
KeyPair$5.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var BN$6 = bnExports$3, utils$7 = utils$p, assert$a = utils$7.assert;
function Signature$5(ae, ie) {
  if (ae instanceof Signature$5)
    return ae;
  this._importDER(ae, ie) || (assert$a(ae.r && ae.s, "Signature without r or s"), this.r = new BN$6(ae.r, 16), this.s = new BN$6(ae.s, 16), ae.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = ae.recoveryParam);
}
var signature$4 = Signature$5;
function Position$1() {
  this.place = 0;
}
function getLength$1(ae, ie) {
  var se = ae[ie.place++];
  if (!(se & 128))
    return se;
  var fe = se & 15;
  if (fe === 0 || fe > 4)
    return !1;
  for (var ue = 0, ce = 0, de = ie.place; ce < fe; ce++, de++)
    ue <<= 8, ue |= ae[de], ue >>>= 0;
  return ue <= 127 ? !1 : (ie.place = de, ue);
}
function rmPadding$1(ae) {
  for (var ie = 0, se = ae.length - 1; !ae[ie] && !(ae[ie + 1] & 128) && ie < se; )
    ie++;
  return ie === 0 ? ae : ae.slice(ie);
}
Signature$5.prototype._importDER = function(ie, se) {
  ie = utils$7.toArray(ie, se);
  var fe = new Position$1();
  if (ie[fe.place++] !== 48)
    return !1;
  var ue = getLength$1(ie, fe);
  if (ue === !1 || ue + fe.place !== ie.length || ie[fe.place++] !== 2)
    return !1;
  var ce = getLength$1(ie, fe);
  if (ce === !1)
    return !1;
  var de = ie.slice(fe.place, ce + fe.place);
  if (fe.place += ce, ie[fe.place++] !== 2)
    return !1;
  var me = getLength$1(ie, fe);
  if (me === !1 || ie.length !== me + fe.place)
    return !1;
  var we = ie.slice(fe.place, me + fe.place);
  if (de[0] === 0)
    if (de[1] & 128)
      de = de.slice(1);
    else
      return !1;
  if (we[0] === 0)
    if (we[1] & 128)
      we = we.slice(1);
    else
      return !1;
  return this.r = new BN$6(de), this.s = new BN$6(we), this.recoveryParam = null, !0;
};
function constructLength$1(ae, ie) {
  if (ie < 128) {
    ae.push(ie);
    return;
  }
  var se = 1 + (Math.log(ie) / Math.LN2 >>> 3);
  for (ae.push(se | 128); --se; )
    ae.push(ie >>> (se << 3) & 255);
  ae.push(ie);
}
Signature$5.prototype.toDER = function(ie) {
  var se = this.r.toArray(), fe = this.s.toArray();
  for (se[0] & 128 && (se = [0].concat(se)), fe[0] & 128 && (fe = [0].concat(fe)), se = rmPadding$1(se), fe = rmPadding$1(fe); !fe[0] && !(fe[1] & 128); )
    fe = fe.slice(1);
  var ue = [2];
  constructLength$1(ue, se.length), ue = ue.concat(se), ue.push(2), constructLength$1(ue, fe.length);
  var ce = ue.concat(fe), de = [48];
  return constructLength$1(de, ce.length), de = de.concat(ce), utils$7.encode(de, ie);
};
var ec$2, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc)
    return ec$2;
  hasRequiredEc = 1;
  var ae = bnExports$3, ie = hmacDrbg$1, se = utils$p, fe = curves$1, ue = requireBrorand(), ce = se.assert, de = key$3, me = signature$4;
  function we(Ee) {
    if (!(this instanceof we))
      return new we(Ee);
    typeof Ee == "string" && (ce(
      Object.prototype.hasOwnProperty.call(fe, Ee),
      "Unknown curve " + Ee
    ), Ee = fe[Ee]), Ee instanceof fe.PresetCurve && (Ee = { curve: Ee }), this.curve = Ee.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = Ee.curve.g, this.g.precompute(Ee.curve.n.bitLength() + 1), this.hash = Ee.hash || Ee.curve.hash;
  }
  return ec$2 = we, we.prototype.keyPair = function(Se) {
    return new de(this, Se);
  }, we.prototype.keyFromPrivate = function(Se, Be) {
    return de.fromPrivate(this, Se, Be);
  }, we.prototype.keyFromPublic = function(Se, Be) {
    return de.fromPublic(this, Se, Be);
  }, we.prototype.genKeyPair = function(Se) {
    Se || (Se = {});
    for (var Be = new ie({
      hash: this.hash,
      pers: Se.pers,
      persEnc: Se.persEnc || "utf8",
      entropy: Se.entropy || ue(this.hash.hmacStrength),
      entropyEnc: Se.entropy && Se.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), Ce = this.n.byteLength(), Ie = this.n.sub(new ae(2)); ; ) {
      var Pe = new ae(Be.generate(Ce));
      if (!(Pe.cmp(Ie) > 0))
        return Pe.iaddn(1), this.keyFromPrivate(Pe);
    }
  }, we.prototype._truncateToN = function(Se, Be) {
    var Ce = Se.byteLength() * 8 - this.n.bitLength();
    return Ce > 0 && (Se = Se.ushrn(Ce)), !Be && Se.cmp(this.n) >= 0 ? Se.sub(this.n) : Se;
  }, we.prototype.sign = function(Se, Be, Ce, Ie) {
    typeof Ce == "object" && (Ie = Ce, Ce = null), Ie || (Ie = {}), Be = this.keyFromPrivate(Be, Ce), Se = this._truncateToN(new ae(Se, 16));
    for (var Pe = this.n.byteLength(), Ne = Be.getPrivate().toArray("be", Pe), ke = Se.toArray("be", Pe), He = new ie({
      hash: this.hash,
      entropy: Ne,
      nonce: ke,
      pers: Ie.pers,
      persEnc: Ie.persEnc || "utf8"
    }), De = this.n.sub(new ae(1)), Ge = 0; ; Ge++) {
      var Ye = Ie.k ? Ie.k(Ge) : new ae(He.generate(this.n.byteLength()));
      if (Ye = this._truncateToN(Ye, !0), !(Ye.cmpn(1) <= 0 || Ye.cmp(De) >= 0)) {
        var st = this.g.mul(Ye);
        if (!st.isInfinity()) {
          var at = st.getX(), mt = at.umod(this.n);
          if (mt.cmpn(0) !== 0) {
            var qe = Ye.invm(this.n).mul(mt.mul(Be.getPrivate()).iadd(Se));
            if (qe = qe.umod(this.n), qe.cmpn(0) !== 0) {
              var ze = (st.getY().isOdd() ? 1 : 0) | (at.cmp(mt) !== 0 ? 2 : 0);
              return Ie.canonical && qe.cmp(this.nh) > 0 && (qe = this.n.sub(qe), ze ^= 1), new me({ r: mt, s: qe, recoveryParam: ze });
            }
          }
        }
      }
    }
  }, we.prototype.verify = function(Se, Be, Ce, Ie) {
    Se = this._truncateToN(new ae(Se, 16)), Ce = this.keyFromPublic(Ce, Ie), Be = new me(Be, "hex");
    var Pe = Be.r, Ne = Be.s;
    if (Pe.cmpn(1) < 0 || Pe.cmp(this.n) >= 0 || Ne.cmpn(1) < 0 || Ne.cmp(this.n) >= 0)
      return !1;
    var ke = Ne.invm(this.n), He = ke.mul(Se).umod(this.n), De = ke.mul(Pe).umod(this.n), Ge;
    return this.curve._maxwellTrick ? (Ge = this.g.jmulAdd(He, Ce.getPublic(), De), Ge.isInfinity() ? !1 : Ge.eqXToP(Pe)) : (Ge = this.g.mulAdd(He, Ce.getPublic(), De), Ge.isInfinity() ? !1 : Ge.getX().umod(this.n).cmp(Pe) === 0);
  }, we.prototype.recoverPubKey = function(Ee, Se, Be, Ce) {
    ce((3 & Be) === Be, "The recovery param is more than two bits"), Se = new me(Se, Ce);
    var Ie = this.n, Pe = new ae(Ee), Ne = Se.r, ke = Se.s, He = Be & 1, De = Be >> 1;
    if (Ne.cmp(this.curve.p.umod(this.curve.n)) >= 0 && De)
      throw new Error("Unable to find sencond key candinate");
    De ? Ne = this.curve.pointFromX(Ne.add(this.curve.n), He) : Ne = this.curve.pointFromX(Ne, He);
    var Ge = Se.r.invm(Ie), Ye = Ie.sub(Pe).mul(Ge).umod(Ie), st = ke.mul(Ge).umod(Ie);
    return this.g.mulAdd(Ye, Ne, st);
  }, we.prototype.getKeyRecoveryParam = function(Ee, Se, Be, Ce) {
    if (Se = new me(Se, Ce), Se.recoveryParam !== null)
      return Se.recoveryParam;
    for (var Ie = 0; Ie < 4; Ie++) {
      var Pe;
      try {
        Pe = this.recoverPubKey(Ee, Se, Ie);
      } catch {
        continue;
      }
      if (Pe.eq(Be))
        return Ie;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec$2;
}
var utils$6 = utils$p, assert$9 = utils$6.assert, parseBytes$2 = utils$6.parseBytes, cachedProperty$1 = utils$6.cachedProperty;
function KeyPair$4(ae, ie) {
  this.eddsa = ae, this._secret = parseBytes$2(ie.secret), ae.isPoint(ie.pub) ? this._pub = ie.pub : this._pubBytes = parseBytes$2(ie.pub);
}
KeyPair$4.fromPublic = function(ie, se) {
  return se instanceof KeyPair$4 ? se : new KeyPair$4(ie, { pub: se });
};
KeyPair$4.fromSecret = function(ie, se) {
  return se instanceof KeyPair$4 ? se : new KeyPair$4(ie, { secret: se });
};
KeyPair$4.prototype.secret = function() {
  return this._secret;
};
cachedProperty$1(KeyPair$4, "pubBytes", function() {
  return this.eddsa.encodePoint(this.pub());
});
cachedProperty$1(KeyPair$4, "pub", function() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
});
cachedProperty$1(KeyPair$4, "privBytes", function() {
  var ie = this.eddsa, se = this.hash(), fe = ie.encodingLength - 1, ue = se.slice(0, ie.encodingLength);
  return ue[0] &= 248, ue[fe] &= 127, ue[fe] |= 64, ue;
});
cachedProperty$1(KeyPair$4, "priv", function() {
  return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty$1(KeyPair$4, "hash", function() {
  return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty$1(KeyPair$4, "messagePrefix", function() {
  return this.hash().slice(this.eddsa.encodingLength);
});
KeyPair$4.prototype.sign = function(ie) {
  return assert$9(this._secret, "KeyPair can only verify"), this.eddsa.sign(ie, this);
};
KeyPair$4.prototype.verify = function(ie, se) {
  return this.eddsa.verify(ie, se, this);
};
KeyPair$4.prototype.getSecret = function(ie) {
  return assert$9(this._secret, "KeyPair is public only"), utils$6.encode(this.secret(), ie);
};
KeyPair$4.prototype.getPublic = function(ie) {
  return utils$6.encode(this.pubBytes(), ie);
};
var key$2 = KeyPair$4, BN$5 = bnExports$3, utils$5 = utils$p, assert$8 = utils$5.assert, cachedProperty = utils$5.cachedProperty, parseBytes$1 = utils$5.parseBytes;
function Signature$4(ae, ie) {
  this.eddsa = ae, typeof ie != "object" && (ie = parseBytes$1(ie)), Array.isArray(ie) && (ie = {
    R: ie.slice(0, ae.encodingLength),
    S: ie.slice(ae.encodingLength)
  }), assert$8(ie.R && ie.S, "Signature without R or S"), ae.isPoint(ie.R) && (this._R = ie.R), ie.S instanceof BN$5 && (this._S = ie.S), this._Rencoded = Array.isArray(ie.R) ? ie.R : ie.Rencoded, this._Sencoded = Array.isArray(ie.S) ? ie.S : ie.Sencoded;
}
cachedProperty(Signature$4, "S", function() {
  return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature$4, "R", function() {
  return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature$4, "Rencoded", function() {
  return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature$4, "Sencoded", function() {
  return this.eddsa.encodeInt(this.S());
});
Signature$4.prototype.toBytes = function() {
  return this.Rencoded().concat(this.Sencoded());
};
Signature$4.prototype.toHex = function() {
  return utils$5.encode(this.toBytes(), "hex").toUpperCase();
};
var signature$3 = Signature$4, hash$1 = hash$4, curves = curves$1, utils$4 = utils$p, assert$7 = utils$4.assert, parseBytes = utils$4.parseBytes, KeyPair$3 = key$2, Signature$3 = signature$3;
function EDDSA(ae) {
  if (assert$7(ae === "ed25519", "only tested with ed25519 so far"), !(this instanceof EDDSA))
    return new EDDSA(ae);
  ae = curves[ae].curve, this.curve = ae, this.g = ae.g, this.g.precompute(ae.n.bitLength() + 1), this.pointClass = ae.point().constructor, this.encodingLength = Math.ceil(ae.n.bitLength() / 8), this.hash = hash$1.sha512;
}
var eddsa = EDDSA;
EDDSA.prototype.sign = function(ie, se) {
  ie = parseBytes(ie);
  var fe = this.keyFromSecret(se), ue = this.hashInt(fe.messagePrefix(), ie), ce = this.g.mul(ue), de = this.encodePoint(ce), me = this.hashInt(de, fe.pubBytes(), ie).mul(fe.priv()), we = ue.add(me).umod(this.curve.n);
  return this.makeSignature({ R: ce, S: we, Rencoded: de });
};
EDDSA.prototype.verify = function(ie, se, fe) {
  ie = parseBytes(ie), se = this.makeSignature(se);
  var ue = this.keyFromPublic(fe), ce = this.hashInt(se.Rencoded(), ue.pubBytes(), ie), de = this.g.mul(se.S()), me = se.R().add(ue.pub().mul(ce));
  return me.eq(de);
};
EDDSA.prototype.hashInt = function() {
  for (var ie = this.hash(), se = 0; se < arguments.length; se++)
    ie.update(arguments[se]);
  return utils$4.intFromLE(ie.digest()).umod(this.curve.n);
};
EDDSA.prototype.keyFromPublic = function(ie) {
  return KeyPair$3.fromPublic(this, ie);
};
EDDSA.prototype.keyFromSecret = function(ie) {
  return KeyPair$3.fromSecret(this, ie);
};
EDDSA.prototype.makeSignature = function(ie) {
  return ie instanceof Signature$3 ? ie : new Signature$3(this, ie);
};
EDDSA.prototype.encodePoint = function(ie) {
  var se = ie.getY().toArray("le", this.encodingLength);
  return se[this.encodingLength - 1] |= ie.getX().isOdd() ? 128 : 0, se;
};
EDDSA.prototype.decodePoint = function(ie) {
  ie = utils$4.parseBytes(ie);
  var se = ie.length - 1, fe = ie.slice(0, se).concat(ie[se] & -129), ue = (ie[se] & 128) !== 0, ce = utils$4.intFromLE(fe);
  return this.curve.pointFromY(ce, ue);
};
EDDSA.prototype.encodeInt = function(ie) {
  return ie.toArray("le", this.encodingLength);
};
EDDSA.prototype.decodeInt = function(ie) {
  return utils$4.intFromLE(ie);
};
EDDSA.prototype.isPoint = function(ie) {
  return ie instanceof this.pointClass;
};
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(ae) {
    var ie = ae;
    ie.version = require$$0$1.version, ie.utils = utils$p, ie.rand = requireBrorand(), ie.curve = curve, ie.curves = curves$1, ie.ec = requireEc(), ie.eddsa = eddsa;
  }(elliptic$2)), elliptic$2;
}
var asn1$3 = {}, asn1$2 = {}, bn$2 = { exports: {} };
bn$2.exports;
(function(ae) {
  (function(ie, se) {
    function fe($e, le) {
      if (!$e)
        throw new Error(le || "Assertion failed");
    }
    function ue($e, le) {
      $e.super_ = le;
      var pe = function() {
      };
      pe.prototype = le.prototype, $e.prototype = new pe(), $e.prototype.constructor = $e;
    }
    function ce($e, le, pe) {
      if (ce.isBN($e))
        return $e;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, $e !== null && ((le === "le" || le === "be") && (pe = le, le = 10), this._init($e || 0, le || 10, pe || "be"));
    }
    typeof ie == "object" ? ie.exports = ce : se.BN = ce, ce.BN = ce, ce.wordSize = 26;
    var de;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? de = window.Buffer : de = require$$0$2.Buffer;
    } catch {
    }
    ce.isBN = function(le) {
      return le instanceof ce ? !0 : le !== null && typeof le == "object" && le.constructor.wordSize === ce.wordSize && Array.isArray(le.words);
    }, ce.max = function(le, pe) {
      return le.cmp(pe) > 0 ? le : pe;
    }, ce.min = function(le, pe) {
      return le.cmp(pe) < 0 ? le : pe;
    }, ce.prototype._init = function(le, pe, ge) {
      if (typeof le == "number")
        return this._initNumber(le, pe, ge);
      if (typeof le == "object")
        return this._initArray(le, pe, ge);
      pe === "hex" && (pe = 16), fe(pe === (pe | 0) && pe >= 2 && pe <= 36), le = le.toString().replace(/\s+/g, "");
      var ye = 0;
      le[0] === "-" && (ye++, this.negative = 1), ye < le.length && (pe === 16 ? this._parseHex(le, ye, ge) : (this._parseBase(le, pe, ye), ge === "le" && this._initArray(this.toArray(), pe, ge)));
    }, ce.prototype._initNumber = function(le, pe, ge) {
      le < 0 && (this.negative = 1, le = -le), le < 67108864 ? (this.words = [le & 67108863], this.length = 1) : le < 4503599627370496 ? (this.words = [
        le & 67108863,
        le / 67108864 & 67108863
      ], this.length = 2) : (fe(le < 9007199254740992), this.words = [
        le & 67108863,
        le / 67108864 & 67108863,
        1
      ], this.length = 3), ge === "le" && this._initArray(this.toArray(), pe, ge);
    }, ce.prototype._initArray = function(le, pe, ge) {
      if (fe(typeof le.length == "number"), le.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(le.length / 3), this.words = new Array(this.length);
      for (var ye = 0; ye < this.length; ye++)
        this.words[ye] = 0;
      var xe, _e, Ae = 0;
      if (ge === "be")
        for (ye = le.length - 1, xe = 0; ye >= 0; ye -= 3)
          _e = le[ye] | le[ye - 1] << 8 | le[ye - 2] << 16, this.words[xe] |= _e << Ae & 67108863, this.words[xe + 1] = _e >>> 26 - Ae & 67108863, Ae += 24, Ae >= 26 && (Ae -= 26, xe++);
      else if (ge === "le")
        for (ye = 0, xe = 0; ye < le.length; ye += 3)
          _e = le[ye] | le[ye + 1] << 8 | le[ye + 2] << 16, this.words[xe] |= _e << Ae & 67108863, this.words[xe + 1] = _e >>> 26 - Ae & 67108863, Ae += 24, Ae >= 26 && (Ae -= 26, xe++);
      return this.strip();
    };
    function me($e, le) {
      var pe = $e.charCodeAt(le);
      return pe >= 65 && pe <= 70 ? pe - 55 : pe >= 97 && pe <= 102 ? pe - 87 : pe - 48 & 15;
    }
    function we($e, le, pe) {
      var ge = me($e, pe);
      return pe - 1 >= le && (ge |= me($e, pe - 1) << 4), ge;
    }
    ce.prototype._parseHex = function(le, pe, ge) {
      this.length = Math.ceil((le.length - pe) / 6), this.words = new Array(this.length);
      for (var ye = 0; ye < this.length; ye++)
        this.words[ye] = 0;
      var xe = 0, _e = 0, Ae;
      if (ge === "be")
        for (ye = le.length - 1; ye >= pe; ye -= 2)
          Ae = we(le, pe, ye) << xe, this.words[_e] |= Ae & 67108863, xe >= 18 ? (xe -= 18, _e += 1, this.words[_e] |= Ae >>> 26) : xe += 8;
      else {
        var ve = le.length - pe;
        for (ye = ve % 2 === 0 ? pe + 1 : pe; ye < le.length; ye += 2)
          Ae = we(le, pe, ye) << xe, this.words[_e] |= Ae & 67108863, xe >= 18 ? (xe -= 18, _e += 1, this.words[_e] |= Ae >>> 26) : xe += 8;
      }
      this.strip();
    };
    function Ee($e, le, pe, ge) {
      for (var ye = 0, xe = Math.min($e.length, pe), _e = le; _e < xe; _e++) {
        var Ae = $e.charCodeAt(_e) - 48;
        ye *= ge, Ae >= 49 ? ye += Ae - 49 + 10 : Ae >= 17 ? ye += Ae - 17 + 10 : ye += Ae;
      }
      return ye;
    }
    ce.prototype._parseBase = function(le, pe, ge) {
      this.words = [0], this.length = 1;
      for (var ye = 0, xe = 1; xe <= 67108863; xe *= pe)
        ye++;
      ye--, xe = xe / pe | 0;
      for (var _e = le.length - ge, Ae = _e % ye, ve = Math.min(_e, _e - Ae) + ge, he = 0, be = ge; be < ve; be += ye)
        he = Ee(le, be, be + ye, pe), this.imuln(xe), this.words[0] + he < 67108864 ? this.words[0] += he : this._iaddn(he);
      if (Ae !== 0) {
        var Me = 1;
        for (he = Ee(le, be, le.length, pe), be = 0; be < Ae; be++)
          Me *= pe;
        this.imuln(Me), this.words[0] + he < 67108864 ? this.words[0] += he : this._iaddn(he);
      }
      this.strip();
    }, ce.prototype.copy = function(le) {
      le.words = new Array(this.length);
      for (var pe = 0; pe < this.length; pe++)
        le.words[pe] = this.words[pe];
      le.length = this.length, le.negative = this.negative, le.red = this.red;
    }, ce.prototype.clone = function() {
      var le = new ce(null);
      return this.copy(le), le;
    }, ce.prototype._expand = function(le) {
      for (; this.length < le; )
        this.words[this.length++] = 0;
      return this;
    }, ce.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, ce.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, ce.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var Se = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], Be = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], Ce = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    ce.prototype.toString = function(le, pe) {
      le = le || 10, pe = pe | 0 || 1;
      var ge;
      if (le === 16 || le === "hex") {
        ge = "";
        for (var ye = 0, xe = 0, _e = 0; _e < this.length; _e++) {
          var Ae = this.words[_e], ve = ((Ae << ye | xe) & 16777215).toString(16);
          xe = Ae >>> 24 - ye & 16777215, xe !== 0 || _e !== this.length - 1 ? ge = Se[6 - ve.length] + ve + ge : ge = ve + ge, ye += 2, ye >= 26 && (ye -= 26, _e--);
        }
        for (xe !== 0 && (ge = xe.toString(16) + ge); ge.length % pe !== 0; )
          ge = "0" + ge;
        return this.negative !== 0 && (ge = "-" + ge), ge;
      }
      if (le === (le | 0) && le >= 2 && le <= 36) {
        var he = Be[le], be = Ce[le];
        ge = "";
        var Me = this.clone();
        for (Me.negative = 0; !Me.isZero(); ) {
          var Re = Me.modn(be).toString(le);
          Me = Me.idivn(be), Me.isZero() ? ge = Re + ge : ge = Se[he - Re.length] + Re + ge;
        }
        for (this.isZero() && (ge = "0" + ge); ge.length % pe !== 0; )
          ge = "0" + ge;
        return this.negative !== 0 && (ge = "-" + ge), ge;
      }
      fe(!1, "Base should be between 2 and 36");
    }, ce.prototype.toNumber = function() {
      var le = this.words[0];
      return this.length === 2 ? le += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? le += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && fe(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -le : le;
    }, ce.prototype.toJSON = function() {
      return this.toString(16);
    }, ce.prototype.toBuffer = function(le, pe) {
      return fe(typeof de < "u"), this.toArrayLike(de, le, pe);
    }, ce.prototype.toArray = function(le, pe) {
      return this.toArrayLike(Array, le, pe);
    }, ce.prototype.toArrayLike = function(le, pe, ge) {
      var ye = this.byteLength(), xe = ge || Math.max(1, ye);
      fe(ye <= xe, "byte array longer than desired length"), fe(xe > 0, "Requested array length <= 0"), this.strip();
      var _e = pe === "le", Ae = new le(xe), ve, he, be = this.clone();
      if (_e) {
        for (he = 0; !be.isZero(); he++)
          ve = be.andln(255), be.iushrn(8), Ae[he] = ve;
        for (; he < xe; he++)
          Ae[he] = 0;
      } else {
        for (he = 0; he < xe - ye; he++)
          Ae[he] = 0;
        for (he = 0; !be.isZero(); he++)
          ve = be.andln(255), be.iushrn(8), Ae[xe - he - 1] = ve;
      }
      return Ae;
    }, Math.clz32 ? ce.prototype._countBits = function(le) {
      return 32 - Math.clz32(le);
    } : ce.prototype._countBits = function(le) {
      var pe = le, ge = 0;
      return pe >= 4096 && (ge += 13, pe >>>= 13), pe >= 64 && (ge += 7, pe >>>= 7), pe >= 8 && (ge += 4, pe >>>= 4), pe >= 2 && (ge += 2, pe >>>= 2), ge + pe;
    }, ce.prototype._zeroBits = function(le) {
      if (le === 0)
        return 26;
      var pe = le, ge = 0;
      return pe & 8191 || (ge += 13, pe >>>= 13), pe & 127 || (ge += 7, pe >>>= 7), pe & 15 || (ge += 4, pe >>>= 4), pe & 3 || (ge += 2, pe >>>= 2), pe & 1 || ge++, ge;
    }, ce.prototype.bitLength = function() {
      var le = this.words[this.length - 1], pe = this._countBits(le);
      return (this.length - 1) * 26 + pe;
    };
    function Ie($e) {
      for (var le = new Array($e.bitLength()), pe = 0; pe < le.length; pe++) {
        var ge = pe / 26 | 0, ye = pe % 26;
        le[pe] = ($e.words[ge] & 1 << ye) >>> ye;
      }
      return le;
    }
    ce.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var le = 0, pe = 0; pe < this.length; pe++) {
        var ge = this._zeroBits(this.words[pe]);
        if (le += ge, ge !== 26)
          break;
      }
      return le;
    }, ce.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, ce.prototype.toTwos = function(le) {
      return this.negative !== 0 ? this.abs().inotn(le).iaddn(1) : this.clone();
    }, ce.prototype.fromTwos = function(le) {
      return this.testn(le - 1) ? this.notn(le).iaddn(1).ineg() : this.clone();
    }, ce.prototype.isNeg = function() {
      return this.negative !== 0;
    }, ce.prototype.neg = function() {
      return this.clone().ineg();
    }, ce.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, ce.prototype.iuor = function(le) {
      for (; this.length < le.length; )
        this.words[this.length++] = 0;
      for (var pe = 0; pe < le.length; pe++)
        this.words[pe] = this.words[pe] | le.words[pe];
      return this.strip();
    }, ce.prototype.ior = function(le) {
      return fe((this.negative | le.negative) === 0), this.iuor(le);
    }, ce.prototype.or = function(le) {
      return this.length > le.length ? this.clone().ior(le) : le.clone().ior(this);
    }, ce.prototype.uor = function(le) {
      return this.length > le.length ? this.clone().iuor(le) : le.clone().iuor(this);
    }, ce.prototype.iuand = function(le) {
      var pe;
      this.length > le.length ? pe = le : pe = this;
      for (var ge = 0; ge < pe.length; ge++)
        this.words[ge] = this.words[ge] & le.words[ge];
      return this.length = pe.length, this.strip();
    }, ce.prototype.iand = function(le) {
      return fe((this.negative | le.negative) === 0), this.iuand(le);
    }, ce.prototype.and = function(le) {
      return this.length > le.length ? this.clone().iand(le) : le.clone().iand(this);
    }, ce.prototype.uand = function(le) {
      return this.length > le.length ? this.clone().iuand(le) : le.clone().iuand(this);
    }, ce.prototype.iuxor = function(le) {
      var pe, ge;
      this.length > le.length ? (pe = this, ge = le) : (pe = le, ge = this);
      for (var ye = 0; ye < ge.length; ye++)
        this.words[ye] = pe.words[ye] ^ ge.words[ye];
      if (this !== pe)
        for (; ye < pe.length; ye++)
          this.words[ye] = pe.words[ye];
      return this.length = pe.length, this.strip();
    }, ce.prototype.ixor = function(le) {
      return fe((this.negative | le.negative) === 0), this.iuxor(le);
    }, ce.prototype.xor = function(le) {
      return this.length > le.length ? this.clone().ixor(le) : le.clone().ixor(this);
    }, ce.prototype.uxor = function(le) {
      return this.length > le.length ? this.clone().iuxor(le) : le.clone().iuxor(this);
    }, ce.prototype.inotn = function(le) {
      fe(typeof le == "number" && le >= 0);
      var pe = Math.ceil(le / 26) | 0, ge = le % 26;
      this._expand(pe), ge > 0 && pe--;
      for (var ye = 0; ye < pe; ye++)
        this.words[ye] = ~this.words[ye] & 67108863;
      return ge > 0 && (this.words[ye] = ~this.words[ye] & 67108863 >> 26 - ge), this.strip();
    }, ce.prototype.notn = function(le) {
      return this.clone().inotn(le);
    }, ce.prototype.setn = function(le, pe) {
      fe(typeof le == "number" && le >= 0);
      var ge = le / 26 | 0, ye = le % 26;
      return this._expand(ge + 1), pe ? this.words[ge] = this.words[ge] | 1 << ye : this.words[ge] = this.words[ge] & ~(1 << ye), this.strip();
    }, ce.prototype.iadd = function(le) {
      var pe;
      if (this.negative !== 0 && le.negative === 0)
        return this.negative = 0, pe = this.isub(le), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && le.negative !== 0)
        return le.negative = 0, pe = this.isub(le), le.negative = 1, pe._normSign();
      var ge, ye;
      this.length > le.length ? (ge = this, ye = le) : (ge = le, ye = this);
      for (var xe = 0, _e = 0; _e < ye.length; _e++)
        pe = (ge.words[_e] | 0) + (ye.words[_e] | 0) + xe, this.words[_e] = pe & 67108863, xe = pe >>> 26;
      for (; xe !== 0 && _e < ge.length; _e++)
        pe = (ge.words[_e] | 0) + xe, this.words[_e] = pe & 67108863, xe = pe >>> 26;
      if (this.length = ge.length, xe !== 0)
        this.words[this.length] = xe, this.length++;
      else if (ge !== this)
        for (; _e < ge.length; _e++)
          this.words[_e] = ge.words[_e];
      return this;
    }, ce.prototype.add = function(le) {
      var pe;
      return le.negative !== 0 && this.negative === 0 ? (le.negative = 0, pe = this.sub(le), le.negative ^= 1, pe) : le.negative === 0 && this.negative !== 0 ? (this.negative = 0, pe = le.sub(this), this.negative = 1, pe) : this.length > le.length ? this.clone().iadd(le) : le.clone().iadd(this);
    }, ce.prototype.isub = function(le) {
      if (le.negative !== 0) {
        le.negative = 0;
        var pe = this.iadd(le);
        return le.negative = 1, pe._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(le), this.negative = 1, this._normSign();
      var ge = this.cmp(le);
      if (ge === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var ye, xe;
      ge > 0 ? (ye = this, xe = le) : (ye = le, xe = this);
      for (var _e = 0, Ae = 0; Ae < xe.length; Ae++)
        pe = (ye.words[Ae] | 0) - (xe.words[Ae] | 0) + _e, _e = pe >> 26, this.words[Ae] = pe & 67108863;
      for (; _e !== 0 && Ae < ye.length; Ae++)
        pe = (ye.words[Ae] | 0) + _e, _e = pe >> 26, this.words[Ae] = pe & 67108863;
      if (_e === 0 && Ae < ye.length && ye !== this)
        for (; Ae < ye.length; Ae++)
          this.words[Ae] = ye.words[Ae];
      return this.length = Math.max(this.length, Ae), ye !== this && (this.negative = 1), this.strip();
    }, ce.prototype.sub = function(le) {
      return this.clone().isub(le);
    };
    function Pe($e, le, pe) {
      pe.negative = le.negative ^ $e.negative;
      var ge = $e.length + le.length | 0;
      pe.length = ge, ge = ge - 1 | 0;
      var ye = $e.words[0] | 0, xe = le.words[0] | 0, _e = ye * xe, Ae = _e & 67108863, ve = _e / 67108864 | 0;
      pe.words[0] = Ae;
      for (var he = 1; he < ge; he++) {
        for (var be = ve >>> 26, Me = ve & 67108863, Re = Math.min(he, le.length - 1), Oe = Math.max(0, he - $e.length + 1); Oe <= Re; Oe++) {
          var Te = he - Oe | 0;
          ye = $e.words[Te] | 0, xe = le.words[Oe] | 0, _e = ye * xe + Me, be += _e / 67108864 | 0, Me = _e & 67108863;
        }
        pe.words[he] = Me | 0, ve = be | 0;
      }
      return ve !== 0 ? pe.words[he] = ve | 0 : pe.length--, pe.strip();
    }
    var Ne = function(le, pe, ge) {
      var ye = le.words, xe = pe.words, _e = ge.words, Ae = 0, ve, he, be, Me = ye[0] | 0, Re = Me & 8191, Oe = Me >>> 13, Te = ye[1] | 0, Fe = Te & 8191, je = Te >>> 13, ct = ye[2] | 0, nt = ct & 8191, dt = ct >>> 13, it = ye[3] | 0, Je = it & 8191, gt = it >>> 13, Ht = ye[4] | 0, $t = Ht & 8191, Lt = Ht >>> 13, Tr = ye[5] | 0, Zt = Tr & 8191, wt = Tr >>> 13, Hr = ye[6] | 0, tr = Hr & 8191, cr = Hr >>> 13, qr = ye[7] | 0, Wt = qr & 8191, ar = qr >>> 13, Dr = ye[8] | 0, Jt = Dr & 8191, ir = Dr >>> 13, Gr = ye[9] | 0, We = Gr & 8191, Le = Gr >>> 13, Ke = xe[0] | 0, rt = Ke & 8191, lt = Ke >>> 13, It = xe[1] | 0, yt = It & 8191, jt = It >>> 13, Lr = xe[2] | 0, zt = Lr & 8191, rr = Lr >>> 13, Cr = xe[3] | 0, fr = Cr & 8191, pr = Cr >>> 13, jr = xe[4] | 0, nr = jr & 8191, ur = jr >>> 13, Wr = xe[5] | 0, or = Wr & 8191, lr = Wr >>> 13, Zr = xe[6] | 0, Xt = Zr & 8191, dr = Zr >>> 13, Ve = xe[7] | 0, Ze = Ve & 8191, Xe = Ve >>> 13, Ue = xe[8] | 0, Qe = Ue & 8191, pt = Ue >>> 13, Ct = xe[9] | 0, bt = Ct & 8191, Tt = Ct >>> 13;
      ge.negative = le.negative ^ pe.negative, ge.length = 19, ve = Math.imul(Re, rt), he = Math.imul(Re, lt), he = he + Math.imul(Oe, rt) | 0, be = Math.imul(Oe, lt);
      var br = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (br >>> 26) | 0, br &= 67108863, ve = Math.imul(Fe, rt), he = Math.imul(Fe, lt), he = he + Math.imul(je, rt) | 0, be = Math.imul(je, lt), ve = ve + Math.imul(Re, yt) | 0, he = he + Math.imul(Re, jt) | 0, he = he + Math.imul(Oe, yt) | 0, be = be + Math.imul(Oe, jt) | 0;
      var gr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (gr >>> 26) | 0, gr &= 67108863, ve = Math.imul(nt, rt), he = Math.imul(nt, lt), he = he + Math.imul(dt, rt) | 0, be = Math.imul(dt, lt), ve = ve + Math.imul(Fe, yt) | 0, he = he + Math.imul(Fe, jt) | 0, he = he + Math.imul(je, yt) | 0, be = be + Math.imul(je, jt) | 0, ve = ve + Math.imul(Re, zt) | 0, he = he + Math.imul(Re, rr) | 0, he = he + Math.imul(Oe, zt) | 0, be = be + Math.imul(Oe, rr) | 0;
      var Fr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, ve = Math.imul(Je, rt), he = Math.imul(Je, lt), he = he + Math.imul(gt, rt) | 0, be = Math.imul(gt, lt), ve = ve + Math.imul(nt, yt) | 0, he = he + Math.imul(nt, jt) | 0, he = he + Math.imul(dt, yt) | 0, be = be + Math.imul(dt, jt) | 0, ve = ve + Math.imul(Fe, zt) | 0, he = he + Math.imul(Fe, rr) | 0, he = he + Math.imul(je, zt) | 0, be = be + Math.imul(je, rr) | 0, ve = ve + Math.imul(Re, fr) | 0, he = he + Math.imul(Re, pr) | 0, he = he + Math.imul(Oe, fr) | 0, be = be + Math.imul(Oe, pr) | 0;
      var wr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (wr >>> 26) | 0, wr &= 67108863, ve = Math.imul($t, rt), he = Math.imul($t, lt), he = he + Math.imul(Lt, rt) | 0, be = Math.imul(Lt, lt), ve = ve + Math.imul(Je, yt) | 0, he = he + Math.imul(Je, jt) | 0, he = he + Math.imul(gt, yt) | 0, be = be + Math.imul(gt, jt) | 0, ve = ve + Math.imul(nt, zt) | 0, he = he + Math.imul(nt, rr) | 0, he = he + Math.imul(dt, zt) | 0, be = be + Math.imul(dt, rr) | 0, ve = ve + Math.imul(Fe, fr) | 0, he = he + Math.imul(Fe, pr) | 0, he = he + Math.imul(je, fr) | 0, be = be + Math.imul(je, pr) | 0, ve = ve + Math.imul(Re, nr) | 0, he = he + Math.imul(Re, ur) | 0, he = he + Math.imul(Oe, nr) | 0, be = be + Math.imul(Oe, ur) | 0;
      var Rr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Rr >>> 26) | 0, Rr &= 67108863, ve = Math.imul(Zt, rt), he = Math.imul(Zt, lt), he = he + Math.imul(wt, rt) | 0, be = Math.imul(wt, lt), ve = ve + Math.imul($t, yt) | 0, he = he + Math.imul($t, jt) | 0, he = he + Math.imul(Lt, yt) | 0, be = be + Math.imul(Lt, jt) | 0, ve = ve + Math.imul(Je, zt) | 0, he = he + Math.imul(Je, rr) | 0, he = he + Math.imul(gt, zt) | 0, be = be + Math.imul(gt, rr) | 0, ve = ve + Math.imul(nt, fr) | 0, he = he + Math.imul(nt, pr) | 0, he = he + Math.imul(dt, fr) | 0, be = be + Math.imul(dt, pr) | 0, ve = ve + Math.imul(Fe, nr) | 0, he = he + Math.imul(Fe, ur) | 0, he = he + Math.imul(je, nr) | 0, be = be + Math.imul(je, ur) | 0, ve = ve + Math.imul(Re, or) | 0, he = he + Math.imul(Re, lr) | 0, he = he + Math.imul(Oe, or) | 0, be = be + Math.imul(Oe, lr) | 0;
      var kr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (kr >>> 26) | 0, kr &= 67108863, ve = Math.imul(tr, rt), he = Math.imul(tr, lt), he = he + Math.imul(cr, rt) | 0, be = Math.imul(cr, lt), ve = ve + Math.imul(Zt, yt) | 0, he = he + Math.imul(Zt, jt) | 0, he = he + Math.imul(wt, yt) | 0, be = be + Math.imul(wt, jt) | 0, ve = ve + Math.imul($t, zt) | 0, he = he + Math.imul($t, rr) | 0, he = he + Math.imul(Lt, zt) | 0, be = be + Math.imul(Lt, rr) | 0, ve = ve + Math.imul(Je, fr) | 0, he = he + Math.imul(Je, pr) | 0, he = he + Math.imul(gt, fr) | 0, be = be + Math.imul(gt, pr) | 0, ve = ve + Math.imul(nt, nr) | 0, he = he + Math.imul(nt, ur) | 0, he = he + Math.imul(dt, nr) | 0, be = be + Math.imul(dt, ur) | 0, ve = ve + Math.imul(Fe, or) | 0, he = he + Math.imul(Fe, lr) | 0, he = he + Math.imul(je, or) | 0, be = be + Math.imul(je, lr) | 0, ve = ve + Math.imul(Re, Xt) | 0, he = he + Math.imul(Re, dr) | 0, he = he + Math.imul(Oe, Xt) | 0, be = be + Math.imul(Oe, dr) | 0;
      var Pr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, ve = Math.imul(Wt, rt), he = Math.imul(Wt, lt), he = he + Math.imul(ar, rt) | 0, be = Math.imul(ar, lt), ve = ve + Math.imul(tr, yt) | 0, he = he + Math.imul(tr, jt) | 0, he = he + Math.imul(cr, yt) | 0, be = be + Math.imul(cr, jt) | 0, ve = ve + Math.imul(Zt, zt) | 0, he = he + Math.imul(Zt, rr) | 0, he = he + Math.imul(wt, zt) | 0, be = be + Math.imul(wt, rr) | 0, ve = ve + Math.imul($t, fr) | 0, he = he + Math.imul($t, pr) | 0, he = he + Math.imul(Lt, fr) | 0, be = be + Math.imul(Lt, pr) | 0, ve = ve + Math.imul(Je, nr) | 0, he = he + Math.imul(Je, ur) | 0, he = he + Math.imul(gt, nr) | 0, be = be + Math.imul(gt, ur) | 0, ve = ve + Math.imul(nt, or) | 0, he = he + Math.imul(nt, lr) | 0, he = he + Math.imul(dt, or) | 0, be = be + Math.imul(dt, lr) | 0, ve = ve + Math.imul(Fe, Xt) | 0, he = he + Math.imul(Fe, dr) | 0, he = he + Math.imul(je, Xt) | 0, be = be + Math.imul(je, dr) | 0, ve = ve + Math.imul(Re, Ze) | 0, he = he + Math.imul(Re, Xe) | 0, he = he + Math.imul(Oe, Ze) | 0, be = be + Math.imul(Oe, Xe) | 0;
      var Ur = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, ve = Math.imul(Jt, rt), he = Math.imul(Jt, lt), he = he + Math.imul(ir, rt) | 0, be = Math.imul(ir, lt), ve = ve + Math.imul(Wt, yt) | 0, he = he + Math.imul(Wt, jt) | 0, he = he + Math.imul(ar, yt) | 0, be = be + Math.imul(ar, jt) | 0, ve = ve + Math.imul(tr, zt) | 0, he = he + Math.imul(tr, rr) | 0, he = he + Math.imul(cr, zt) | 0, be = be + Math.imul(cr, rr) | 0, ve = ve + Math.imul(Zt, fr) | 0, he = he + Math.imul(Zt, pr) | 0, he = he + Math.imul(wt, fr) | 0, be = be + Math.imul(wt, pr) | 0, ve = ve + Math.imul($t, nr) | 0, he = he + Math.imul($t, ur) | 0, he = he + Math.imul(Lt, nr) | 0, be = be + Math.imul(Lt, ur) | 0, ve = ve + Math.imul(Je, or) | 0, he = he + Math.imul(Je, lr) | 0, he = he + Math.imul(gt, or) | 0, be = be + Math.imul(gt, lr) | 0, ve = ve + Math.imul(nt, Xt) | 0, he = he + Math.imul(nt, dr) | 0, he = he + Math.imul(dt, Xt) | 0, be = be + Math.imul(dt, dr) | 0, ve = ve + Math.imul(Fe, Ze) | 0, he = he + Math.imul(Fe, Xe) | 0, he = he + Math.imul(je, Ze) | 0, be = be + Math.imul(je, Xe) | 0, ve = ve + Math.imul(Re, Qe) | 0, he = he + Math.imul(Re, pt) | 0, he = he + Math.imul(Oe, Qe) | 0, be = be + Math.imul(Oe, pt) | 0;
      var Ir = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Ir >>> 26) | 0, Ir &= 67108863, ve = Math.imul(We, rt), he = Math.imul(We, lt), he = he + Math.imul(Le, rt) | 0, be = Math.imul(Le, lt), ve = ve + Math.imul(Jt, yt) | 0, he = he + Math.imul(Jt, jt) | 0, he = he + Math.imul(ir, yt) | 0, be = be + Math.imul(ir, jt) | 0, ve = ve + Math.imul(Wt, zt) | 0, he = he + Math.imul(Wt, rr) | 0, he = he + Math.imul(ar, zt) | 0, be = be + Math.imul(ar, rr) | 0, ve = ve + Math.imul(tr, fr) | 0, he = he + Math.imul(tr, pr) | 0, he = he + Math.imul(cr, fr) | 0, be = be + Math.imul(cr, pr) | 0, ve = ve + Math.imul(Zt, nr) | 0, he = he + Math.imul(Zt, ur) | 0, he = he + Math.imul(wt, nr) | 0, be = be + Math.imul(wt, ur) | 0, ve = ve + Math.imul($t, or) | 0, he = he + Math.imul($t, lr) | 0, he = he + Math.imul(Lt, or) | 0, be = be + Math.imul(Lt, lr) | 0, ve = ve + Math.imul(Je, Xt) | 0, he = he + Math.imul(Je, dr) | 0, he = he + Math.imul(gt, Xt) | 0, be = be + Math.imul(gt, dr) | 0, ve = ve + Math.imul(nt, Ze) | 0, he = he + Math.imul(nt, Xe) | 0, he = he + Math.imul(dt, Ze) | 0, be = be + Math.imul(dt, Xe) | 0, ve = ve + Math.imul(Fe, Qe) | 0, he = he + Math.imul(Fe, pt) | 0, he = he + Math.imul(je, Qe) | 0, be = be + Math.imul(je, pt) | 0, ve = ve + Math.imul(Re, bt) | 0, he = he + Math.imul(Re, Tt) | 0, he = he + Math.imul(Oe, bt) | 0, be = be + Math.imul(Oe, Tt) | 0;
      var Or = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Or >>> 26) | 0, Or &= 67108863, ve = Math.imul(We, yt), he = Math.imul(We, jt), he = he + Math.imul(Le, yt) | 0, be = Math.imul(Le, jt), ve = ve + Math.imul(Jt, zt) | 0, he = he + Math.imul(Jt, rr) | 0, he = he + Math.imul(ir, zt) | 0, be = be + Math.imul(ir, rr) | 0, ve = ve + Math.imul(Wt, fr) | 0, he = he + Math.imul(Wt, pr) | 0, he = he + Math.imul(ar, fr) | 0, be = be + Math.imul(ar, pr) | 0, ve = ve + Math.imul(tr, nr) | 0, he = he + Math.imul(tr, ur) | 0, he = he + Math.imul(cr, nr) | 0, be = be + Math.imul(cr, ur) | 0, ve = ve + Math.imul(Zt, or) | 0, he = he + Math.imul(Zt, lr) | 0, he = he + Math.imul(wt, or) | 0, be = be + Math.imul(wt, lr) | 0, ve = ve + Math.imul($t, Xt) | 0, he = he + Math.imul($t, dr) | 0, he = he + Math.imul(Lt, Xt) | 0, be = be + Math.imul(Lt, dr) | 0, ve = ve + Math.imul(Je, Ze) | 0, he = he + Math.imul(Je, Xe) | 0, he = he + Math.imul(gt, Ze) | 0, be = be + Math.imul(gt, Xe) | 0, ve = ve + Math.imul(nt, Qe) | 0, he = he + Math.imul(nt, pt) | 0, he = he + Math.imul(dt, Qe) | 0, be = be + Math.imul(dt, pt) | 0, ve = ve + Math.imul(Fe, bt) | 0, he = he + Math.imul(Fe, Tt) | 0, he = he + Math.imul(je, bt) | 0, be = be + Math.imul(je, Tt) | 0;
      var Nr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Nr >>> 26) | 0, Nr &= 67108863, ve = Math.imul(We, zt), he = Math.imul(We, rr), he = he + Math.imul(Le, zt) | 0, be = Math.imul(Le, rr), ve = ve + Math.imul(Jt, fr) | 0, he = he + Math.imul(Jt, pr) | 0, he = he + Math.imul(ir, fr) | 0, be = be + Math.imul(ir, pr) | 0, ve = ve + Math.imul(Wt, nr) | 0, he = he + Math.imul(Wt, ur) | 0, he = he + Math.imul(ar, nr) | 0, be = be + Math.imul(ar, ur) | 0, ve = ve + Math.imul(tr, or) | 0, he = he + Math.imul(tr, lr) | 0, he = he + Math.imul(cr, or) | 0, be = be + Math.imul(cr, lr) | 0, ve = ve + Math.imul(Zt, Xt) | 0, he = he + Math.imul(Zt, dr) | 0, he = he + Math.imul(wt, Xt) | 0, be = be + Math.imul(wt, dr) | 0, ve = ve + Math.imul($t, Ze) | 0, he = he + Math.imul($t, Xe) | 0, he = he + Math.imul(Lt, Ze) | 0, be = be + Math.imul(Lt, Xe) | 0, ve = ve + Math.imul(Je, Qe) | 0, he = he + Math.imul(Je, pt) | 0, he = he + Math.imul(gt, Qe) | 0, be = be + Math.imul(gt, pt) | 0, ve = ve + Math.imul(nt, bt) | 0, he = he + Math.imul(nt, Tt) | 0, he = he + Math.imul(dt, bt) | 0, be = be + Math.imul(dt, Tt) | 0;
      var Er = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, ve = Math.imul(We, fr), he = Math.imul(We, pr), he = he + Math.imul(Le, fr) | 0, be = Math.imul(Le, pr), ve = ve + Math.imul(Jt, nr) | 0, he = he + Math.imul(Jt, ur) | 0, he = he + Math.imul(ir, nr) | 0, be = be + Math.imul(ir, ur) | 0, ve = ve + Math.imul(Wt, or) | 0, he = he + Math.imul(Wt, lr) | 0, he = he + Math.imul(ar, or) | 0, be = be + Math.imul(ar, lr) | 0, ve = ve + Math.imul(tr, Xt) | 0, he = he + Math.imul(tr, dr) | 0, he = he + Math.imul(cr, Xt) | 0, be = be + Math.imul(cr, dr) | 0, ve = ve + Math.imul(Zt, Ze) | 0, he = he + Math.imul(Zt, Xe) | 0, he = he + Math.imul(wt, Ze) | 0, be = be + Math.imul(wt, Xe) | 0, ve = ve + Math.imul($t, Qe) | 0, he = he + Math.imul($t, pt) | 0, he = he + Math.imul(Lt, Qe) | 0, be = be + Math.imul(Lt, pt) | 0, ve = ve + Math.imul(Je, bt) | 0, he = he + Math.imul(Je, Tt) | 0, he = he + Math.imul(gt, bt) | 0, be = be + Math.imul(gt, Tt) | 0;
      var Br = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Br >>> 26) | 0, Br &= 67108863, ve = Math.imul(We, nr), he = Math.imul(We, ur), he = he + Math.imul(Le, nr) | 0, be = Math.imul(Le, ur), ve = ve + Math.imul(Jt, or) | 0, he = he + Math.imul(Jt, lr) | 0, he = he + Math.imul(ir, or) | 0, be = be + Math.imul(ir, lr) | 0, ve = ve + Math.imul(Wt, Xt) | 0, he = he + Math.imul(Wt, dr) | 0, he = he + Math.imul(ar, Xt) | 0, be = be + Math.imul(ar, dr) | 0, ve = ve + Math.imul(tr, Ze) | 0, he = he + Math.imul(tr, Xe) | 0, he = he + Math.imul(cr, Ze) | 0, be = be + Math.imul(cr, Xe) | 0, ve = ve + Math.imul(Zt, Qe) | 0, he = he + Math.imul(Zt, pt) | 0, he = he + Math.imul(wt, Qe) | 0, be = be + Math.imul(wt, pt) | 0, ve = ve + Math.imul($t, bt) | 0, he = he + Math.imul($t, Tt) | 0, he = he + Math.imul(Lt, bt) | 0, be = be + Math.imul(Lt, Tt) | 0;
      var _r = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (_r >>> 26) | 0, _r &= 67108863, ve = Math.imul(We, or), he = Math.imul(We, lr), he = he + Math.imul(Le, or) | 0, be = Math.imul(Le, lr), ve = ve + Math.imul(Jt, Xt) | 0, he = he + Math.imul(Jt, dr) | 0, he = he + Math.imul(ir, Xt) | 0, be = be + Math.imul(ir, dr) | 0, ve = ve + Math.imul(Wt, Ze) | 0, he = he + Math.imul(Wt, Xe) | 0, he = he + Math.imul(ar, Ze) | 0, be = be + Math.imul(ar, Xe) | 0, ve = ve + Math.imul(tr, Qe) | 0, he = he + Math.imul(tr, pt) | 0, he = he + Math.imul(cr, Qe) | 0, be = be + Math.imul(cr, pt) | 0, ve = ve + Math.imul(Zt, bt) | 0, he = he + Math.imul(Zt, Tt) | 0, he = he + Math.imul(wt, bt) | 0, be = be + Math.imul(wt, Tt) | 0;
      var Sr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Sr >>> 26) | 0, Sr &= 67108863, ve = Math.imul(We, Xt), he = Math.imul(We, dr), he = he + Math.imul(Le, Xt) | 0, be = Math.imul(Le, dr), ve = ve + Math.imul(Jt, Ze) | 0, he = he + Math.imul(Jt, Xe) | 0, he = he + Math.imul(ir, Ze) | 0, be = be + Math.imul(ir, Xe) | 0, ve = ve + Math.imul(Wt, Qe) | 0, he = he + Math.imul(Wt, pt) | 0, he = he + Math.imul(ar, Qe) | 0, be = be + Math.imul(ar, pt) | 0, ve = ve + Math.imul(tr, bt) | 0, he = he + Math.imul(tr, Tt) | 0, he = he + Math.imul(cr, bt) | 0, be = be + Math.imul(cr, Tt) | 0;
      var Mr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Mr >>> 26) | 0, Mr &= 67108863, ve = Math.imul(We, Ze), he = Math.imul(We, Xe), he = he + Math.imul(Le, Ze) | 0, be = Math.imul(Le, Xe), ve = ve + Math.imul(Jt, Qe) | 0, he = he + Math.imul(Jt, pt) | 0, he = he + Math.imul(ir, Qe) | 0, be = be + Math.imul(ir, pt) | 0, ve = ve + Math.imul(Wt, bt) | 0, he = he + Math.imul(Wt, Tt) | 0, he = he + Math.imul(ar, bt) | 0, be = be + Math.imul(ar, Tt) | 0;
      var $r = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + ($r >>> 26) | 0, $r &= 67108863, ve = Math.imul(We, Qe), he = Math.imul(We, pt), he = he + Math.imul(Le, Qe) | 0, be = Math.imul(Le, pt), ve = ve + Math.imul(Jt, bt) | 0, he = he + Math.imul(Jt, Tt) | 0, he = he + Math.imul(ir, bt) | 0, be = be + Math.imul(ir, Tt) | 0;
      var Yt = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Yt >>> 26) | 0, Yt &= 67108863, ve = Math.imul(We, bt), he = Math.imul(We, Tt), he = he + Math.imul(Le, bt) | 0, be = Math.imul(Le, Tt);
      var er = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      return Ae = (be + (he >>> 13) | 0) + (er >>> 26) | 0, er &= 67108863, _e[0] = br, _e[1] = gr, _e[2] = Fr, _e[3] = wr, _e[4] = Rr, _e[5] = kr, _e[6] = Pr, _e[7] = Ur, _e[8] = Ir, _e[9] = Or, _e[10] = Nr, _e[11] = Er, _e[12] = Br, _e[13] = _r, _e[14] = Sr, _e[15] = Mr, _e[16] = $r, _e[17] = Yt, _e[18] = er, Ae !== 0 && (_e[19] = Ae, ge.length++), ge;
    };
    Math.imul || (Ne = Pe);
    function ke($e, le, pe) {
      pe.negative = le.negative ^ $e.negative, pe.length = $e.length + le.length;
      for (var ge = 0, ye = 0, xe = 0; xe < pe.length - 1; xe++) {
        var _e = ye;
        ye = 0;
        for (var Ae = ge & 67108863, ve = Math.min(xe, le.length - 1), he = Math.max(0, xe - $e.length + 1); he <= ve; he++) {
          var be = xe - he, Me = $e.words[be] | 0, Re = le.words[he] | 0, Oe = Me * Re, Te = Oe & 67108863;
          _e = _e + (Oe / 67108864 | 0) | 0, Te = Te + Ae | 0, Ae = Te & 67108863, _e = _e + (Te >>> 26) | 0, ye += _e >>> 26, _e &= 67108863;
        }
        pe.words[xe] = Ae, ge = _e, _e = ye;
      }
      return ge !== 0 ? pe.words[xe] = ge : pe.length--, pe.strip();
    }
    function He($e, le, pe) {
      var ge = new De();
      return ge.mulp($e, le, pe);
    }
    ce.prototype.mulTo = function(le, pe) {
      var ge, ye = this.length + le.length;
      return this.length === 10 && le.length === 10 ? ge = Ne(this, le, pe) : ye < 63 ? ge = Pe(this, le, pe) : ye < 1024 ? ge = ke(this, le, pe) : ge = He(this, le, pe), ge;
    };
    function De($e, le) {
      this.x = $e, this.y = le;
    }
    De.prototype.makeRBT = function(le) {
      for (var pe = new Array(le), ge = ce.prototype._countBits(le) - 1, ye = 0; ye < le; ye++)
        pe[ye] = this.revBin(ye, ge, le);
      return pe;
    }, De.prototype.revBin = function(le, pe, ge) {
      if (le === 0 || le === ge - 1)
        return le;
      for (var ye = 0, xe = 0; xe < pe; xe++)
        ye |= (le & 1) << pe - xe - 1, le >>= 1;
      return ye;
    }, De.prototype.permute = function(le, pe, ge, ye, xe, _e) {
      for (var Ae = 0; Ae < _e; Ae++)
        ye[Ae] = pe[le[Ae]], xe[Ae] = ge[le[Ae]];
    }, De.prototype.transform = function(le, pe, ge, ye, xe, _e) {
      this.permute(_e, le, pe, ge, ye, xe);
      for (var Ae = 1; Ae < xe; Ae <<= 1)
        for (var ve = Ae << 1, he = Math.cos(2 * Math.PI / ve), be = Math.sin(2 * Math.PI / ve), Me = 0; Me < xe; Me += ve)
          for (var Re = he, Oe = be, Te = 0; Te < Ae; Te++) {
            var Fe = ge[Me + Te], je = ye[Me + Te], ct = ge[Me + Te + Ae], nt = ye[Me + Te + Ae], dt = Re * ct - Oe * nt;
            nt = Re * nt + Oe * ct, ct = dt, ge[Me + Te] = Fe + ct, ye[Me + Te] = je + nt, ge[Me + Te + Ae] = Fe - ct, ye[Me + Te + Ae] = je - nt, Te !== ve && (dt = he * Re - be * Oe, Oe = he * Oe + be * Re, Re = dt);
          }
    }, De.prototype.guessLen13b = function(le, pe) {
      var ge = Math.max(pe, le) | 1, ye = ge & 1, xe = 0;
      for (ge = ge / 2 | 0; ge; ge = ge >>> 1)
        xe++;
      return 1 << xe + 1 + ye;
    }, De.prototype.conjugate = function(le, pe, ge) {
      if (!(ge <= 1))
        for (var ye = 0; ye < ge / 2; ye++) {
          var xe = le[ye];
          le[ye] = le[ge - ye - 1], le[ge - ye - 1] = xe, xe = pe[ye], pe[ye] = -pe[ge - ye - 1], pe[ge - ye - 1] = -xe;
        }
    }, De.prototype.normalize13b = function(le, pe) {
      for (var ge = 0, ye = 0; ye < pe / 2; ye++) {
        var xe = Math.round(le[2 * ye + 1] / pe) * 8192 + Math.round(le[2 * ye] / pe) + ge;
        le[ye] = xe & 67108863, xe < 67108864 ? ge = 0 : ge = xe / 67108864 | 0;
      }
      return le;
    }, De.prototype.convert13b = function(le, pe, ge, ye) {
      for (var xe = 0, _e = 0; _e < pe; _e++)
        xe = xe + (le[_e] | 0), ge[2 * _e] = xe & 8191, xe = xe >>> 13, ge[2 * _e + 1] = xe & 8191, xe = xe >>> 13;
      for (_e = 2 * pe; _e < ye; ++_e)
        ge[_e] = 0;
      fe(xe === 0), fe((xe & -8192) === 0);
    }, De.prototype.stub = function(le) {
      for (var pe = new Array(le), ge = 0; ge < le; ge++)
        pe[ge] = 0;
      return pe;
    }, De.prototype.mulp = function(le, pe, ge) {
      var ye = 2 * this.guessLen13b(le.length, pe.length), xe = this.makeRBT(ye), _e = this.stub(ye), Ae = new Array(ye), ve = new Array(ye), he = new Array(ye), be = new Array(ye), Me = new Array(ye), Re = new Array(ye), Oe = ge.words;
      Oe.length = ye, this.convert13b(le.words, le.length, Ae, ye), this.convert13b(pe.words, pe.length, be, ye), this.transform(Ae, _e, ve, he, ye, xe), this.transform(be, _e, Me, Re, ye, xe);
      for (var Te = 0; Te < ye; Te++) {
        var Fe = ve[Te] * Me[Te] - he[Te] * Re[Te];
        he[Te] = ve[Te] * Re[Te] + he[Te] * Me[Te], ve[Te] = Fe;
      }
      return this.conjugate(ve, he, ye), this.transform(ve, he, Oe, _e, ye, xe), this.conjugate(Oe, _e, ye), this.normalize13b(Oe, ye), ge.negative = le.negative ^ pe.negative, ge.length = le.length + pe.length, ge.strip();
    }, ce.prototype.mul = function(le) {
      var pe = new ce(null);
      return pe.words = new Array(this.length + le.length), this.mulTo(le, pe);
    }, ce.prototype.mulf = function(le) {
      var pe = new ce(null);
      return pe.words = new Array(this.length + le.length), He(this, le, pe);
    }, ce.prototype.imul = function(le) {
      return this.clone().mulTo(le, this);
    }, ce.prototype.imuln = function(le) {
      fe(typeof le == "number"), fe(le < 67108864);
      for (var pe = 0, ge = 0; ge < this.length; ge++) {
        var ye = (this.words[ge] | 0) * le, xe = (ye & 67108863) + (pe & 67108863);
        pe >>= 26, pe += ye / 67108864 | 0, pe += xe >>> 26, this.words[ge] = xe & 67108863;
      }
      return pe !== 0 && (this.words[ge] = pe, this.length++), this;
    }, ce.prototype.muln = function(le) {
      return this.clone().imuln(le);
    }, ce.prototype.sqr = function() {
      return this.mul(this);
    }, ce.prototype.isqr = function() {
      return this.imul(this.clone());
    }, ce.prototype.pow = function(le) {
      var pe = Ie(le);
      if (pe.length === 0)
        return new ce(1);
      for (var ge = this, ye = 0; ye < pe.length && pe[ye] === 0; ye++, ge = ge.sqr())
        ;
      if (++ye < pe.length)
        for (var xe = ge.sqr(); ye < pe.length; ye++, xe = xe.sqr())
          pe[ye] !== 0 && (ge = ge.mul(xe));
      return ge;
    }, ce.prototype.iushln = function(le) {
      fe(typeof le == "number" && le >= 0);
      var pe = le % 26, ge = (le - pe) / 26, ye = 67108863 >>> 26 - pe << 26 - pe, xe;
      if (pe !== 0) {
        var _e = 0;
        for (xe = 0; xe < this.length; xe++) {
          var Ae = this.words[xe] & ye, ve = (this.words[xe] | 0) - Ae << pe;
          this.words[xe] = ve | _e, _e = Ae >>> 26 - pe;
        }
        _e && (this.words[xe] = _e, this.length++);
      }
      if (ge !== 0) {
        for (xe = this.length - 1; xe >= 0; xe--)
          this.words[xe + ge] = this.words[xe];
        for (xe = 0; xe < ge; xe++)
          this.words[xe] = 0;
        this.length += ge;
      }
      return this.strip();
    }, ce.prototype.ishln = function(le) {
      return fe(this.negative === 0), this.iushln(le);
    }, ce.prototype.iushrn = function(le, pe, ge) {
      fe(typeof le == "number" && le >= 0);
      var ye;
      pe ? ye = (pe - pe % 26) / 26 : ye = 0;
      var xe = le % 26, _e = Math.min((le - xe) / 26, this.length), Ae = 67108863 ^ 67108863 >>> xe << xe, ve = ge;
      if (ye -= _e, ye = Math.max(0, ye), ve) {
        for (var he = 0; he < _e; he++)
          ve.words[he] = this.words[he];
        ve.length = _e;
      }
      if (_e !== 0)
        if (this.length > _e)
          for (this.length -= _e, he = 0; he < this.length; he++)
            this.words[he] = this.words[he + _e];
        else
          this.words[0] = 0, this.length = 1;
      var be = 0;
      for (he = this.length - 1; he >= 0 && (be !== 0 || he >= ye); he--) {
        var Me = this.words[he] | 0;
        this.words[he] = be << 26 - xe | Me >>> xe, be = Me & Ae;
      }
      return ve && be !== 0 && (ve.words[ve.length++] = be), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, ce.prototype.ishrn = function(le, pe, ge) {
      return fe(this.negative === 0), this.iushrn(le, pe, ge);
    }, ce.prototype.shln = function(le) {
      return this.clone().ishln(le);
    }, ce.prototype.ushln = function(le) {
      return this.clone().iushln(le);
    }, ce.prototype.shrn = function(le) {
      return this.clone().ishrn(le);
    }, ce.prototype.ushrn = function(le) {
      return this.clone().iushrn(le);
    }, ce.prototype.testn = function(le) {
      fe(typeof le == "number" && le >= 0);
      var pe = le % 26, ge = (le - pe) / 26, ye = 1 << pe;
      if (this.length <= ge)
        return !1;
      var xe = this.words[ge];
      return !!(xe & ye);
    }, ce.prototype.imaskn = function(le) {
      fe(typeof le == "number" && le >= 0);
      var pe = le % 26, ge = (le - pe) / 26;
      if (fe(this.negative === 0, "imaskn works only with positive numbers"), this.length <= ge)
        return this;
      if (pe !== 0 && ge++, this.length = Math.min(ge, this.length), pe !== 0) {
        var ye = 67108863 ^ 67108863 >>> pe << pe;
        this.words[this.length - 1] &= ye;
      }
      return this.strip();
    }, ce.prototype.maskn = function(le) {
      return this.clone().imaskn(le);
    }, ce.prototype.iaddn = function(le) {
      return fe(typeof le == "number"), fe(le < 67108864), le < 0 ? this.isubn(-le) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < le ? (this.words[0] = le - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(le), this.negative = 1, this) : this._iaddn(le);
    }, ce.prototype._iaddn = function(le) {
      this.words[0] += le;
      for (var pe = 0; pe < this.length && this.words[pe] >= 67108864; pe++)
        this.words[pe] -= 67108864, pe === this.length - 1 ? this.words[pe + 1] = 1 : this.words[pe + 1]++;
      return this.length = Math.max(this.length, pe + 1), this;
    }, ce.prototype.isubn = function(le) {
      if (fe(typeof le == "number"), fe(le < 67108864), le < 0)
        return this.iaddn(-le);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(le), this.negative = 1, this;
      if (this.words[0] -= le, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var pe = 0; pe < this.length && this.words[pe] < 0; pe++)
          this.words[pe] += 67108864, this.words[pe + 1] -= 1;
      return this.strip();
    }, ce.prototype.addn = function(le) {
      return this.clone().iaddn(le);
    }, ce.prototype.subn = function(le) {
      return this.clone().isubn(le);
    }, ce.prototype.iabs = function() {
      return this.negative = 0, this;
    }, ce.prototype.abs = function() {
      return this.clone().iabs();
    }, ce.prototype._ishlnsubmul = function(le, pe, ge) {
      var ye = le.length + ge, xe;
      this._expand(ye);
      var _e, Ae = 0;
      for (xe = 0; xe < le.length; xe++) {
        _e = (this.words[xe + ge] | 0) + Ae;
        var ve = (le.words[xe] | 0) * pe;
        _e -= ve & 67108863, Ae = (_e >> 26) - (ve / 67108864 | 0), this.words[xe + ge] = _e & 67108863;
      }
      for (; xe < this.length - ge; xe++)
        _e = (this.words[xe + ge] | 0) + Ae, Ae = _e >> 26, this.words[xe + ge] = _e & 67108863;
      if (Ae === 0)
        return this.strip();
      for (fe(Ae === -1), Ae = 0, xe = 0; xe < this.length; xe++)
        _e = -(this.words[xe] | 0) + Ae, Ae = _e >> 26, this.words[xe] = _e & 67108863;
      return this.negative = 1, this.strip();
    }, ce.prototype._wordDiv = function(le, pe) {
      var ge = this.length - le.length, ye = this.clone(), xe = le, _e = xe.words[xe.length - 1] | 0, Ae = this._countBits(_e);
      ge = 26 - Ae, ge !== 0 && (xe = xe.ushln(ge), ye.iushln(ge), _e = xe.words[xe.length - 1] | 0);
      var ve = ye.length - xe.length, he;
      if (pe !== "mod") {
        he = new ce(null), he.length = ve + 1, he.words = new Array(he.length);
        for (var be = 0; be < he.length; be++)
          he.words[be] = 0;
      }
      var Me = ye.clone()._ishlnsubmul(xe, 1, ve);
      Me.negative === 0 && (ye = Me, he && (he.words[ve] = 1));
      for (var Re = ve - 1; Re >= 0; Re--) {
        var Oe = (ye.words[xe.length + Re] | 0) * 67108864 + (ye.words[xe.length + Re - 1] | 0);
        for (Oe = Math.min(Oe / _e | 0, 67108863), ye._ishlnsubmul(xe, Oe, Re); ye.negative !== 0; )
          Oe--, ye.negative = 0, ye._ishlnsubmul(xe, 1, Re), ye.isZero() || (ye.negative ^= 1);
        he && (he.words[Re] = Oe);
      }
      return he && he.strip(), ye.strip(), pe !== "div" && ge !== 0 && ye.iushrn(ge), {
        div: he || null,
        mod: ye
      };
    }, ce.prototype.divmod = function(le, pe, ge) {
      if (fe(!le.isZero()), this.isZero())
        return {
          div: new ce(0),
          mod: new ce(0)
        };
      var ye, xe, _e;
      return this.negative !== 0 && le.negative === 0 ? (_e = this.neg().divmod(le, pe), pe !== "mod" && (ye = _e.div.neg()), pe !== "div" && (xe = _e.mod.neg(), ge && xe.negative !== 0 && xe.iadd(le)), {
        div: ye,
        mod: xe
      }) : this.negative === 0 && le.negative !== 0 ? (_e = this.divmod(le.neg(), pe), pe !== "mod" && (ye = _e.div.neg()), {
        div: ye,
        mod: _e.mod
      }) : this.negative & le.negative ? (_e = this.neg().divmod(le.neg(), pe), pe !== "div" && (xe = _e.mod.neg(), ge && xe.negative !== 0 && xe.isub(le)), {
        div: _e.div,
        mod: xe
      }) : le.length > this.length || this.cmp(le) < 0 ? {
        div: new ce(0),
        mod: this
      } : le.length === 1 ? pe === "div" ? {
        div: this.divn(le.words[0]),
        mod: null
      } : pe === "mod" ? {
        div: null,
        mod: new ce(this.modn(le.words[0]))
      } : {
        div: this.divn(le.words[0]),
        mod: new ce(this.modn(le.words[0]))
      } : this._wordDiv(le, pe);
    }, ce.prototype.div = function(le) {
      return this.divmod(le, "div", !1).div;
    }, ce.prototype.mod = function(le) {
      return this.divmod(le, "mod", !1).mod;
    }, ce.prototype.umod = function(le) {
      return this.divmod(le, "mod", !0).mod;
    }, ce.prototype.divRound = function(le) {
      var pe = this.divmod(le);
      if (pe.mod.isZero())
        return pe.div;
      var ge = pe.div.negative !== 0 ? pe.mod.isub(le) : pe.mod, ye = le.ushrn(1), xe = le.andln(1), _e = ge.cmp(ye);
      return _e < 0 || xe === 1 && _e === 0 ? pe.div : pe.div.negative !== 0 ? pe.div.isubn(1) : pe.div.iaddn(1);
    }, ce.prototype.modn = function(le) {
      fe(le <= 67108863);
      for (var pe = (1 << 26) % le, ge = 0, ye = this.length - 1; ye >= 0; ye--)
        ge = (pe * ge + (this.words[ye] | 0)) % le;
      return ge;
    }, ce.prototype.idivn = function(le) {
      fe(le <= 67108863);
      for (var pe = 0, ge = this.length - 1; ge >= 0; ge--) {
        var ye = (this.words[ge] | 0) + pe * 67108864;
        this.words[ge] = ye / le | 0, pe = ye % le;
      }
      return this.strip();
    }, ce.prototype.divn = function(le) {
      return this.clone().idivn(le);
    }, ce.prototype.egcd = function(le) {
      fe(le.negative === 0), fe(!le.isZero());
      var pe = this, ge = le.clone();
      pe.negative !== 0 ? pe = pe.umod(le) : pe = pe.clone();
      for (var ye = new ce(1), xe = new ce(0), _e = new ce(0), Ae = new ce(1), ve = 0; pe.isEven() && ge.isEven(); )
        pe.iushrn(1), ge.iushrn(1), ++ve;
      for (var he = ge.clone(), be = pe.clone(); !pe.isZero(); ) {
        for (var Me = 0, Re = 1; !(pe.words[0] & Re) && Me < 26; ++Me, Re <<= 1)
          ;
        if (Me > 0)
          for (pe.iushrn(Me); Me-- > 0; )
            (ye.isOdd() || xe.isOdd()) && (ye.iadd(he), xe.isub(be)), ye.iushrn(1), xe.iushrn(1);
        for (var Oe = 0, Te = 1; !(ge.words[0] & Te) && Oe < 26; ++Oe, Te <<= 1)
          ;
        if (Oe > 0)
          for (ge.iushrn(Oe); Oe-- > 0; )
            (_e.isOdd() || Ae.isOdd()) && (_e.iadd(he), Ae.isub(be)), _e.iushrn(1), Ae.iushrn(1);
        pe.cmp(ge) >= 0 ? (pe.isub(ge), ye.isub(_e), xe.isub(Ae)) : (ge.isub(pe), _e.isub(ye), Ae.isub(xe));
      }
      return {
        a: _e,
        b: Ae,
        gcd: ge.iushln(ve)
      };
    }, ce.prototype._invmp = function(le) {
      fe(le.negative === 0), fe(!le.isZero());
      var pe = this, ge = le.clone();
      pe.negative !== 0 ? pe = pe.umod(le) : pe = pe.clone();
      for (var ye = new ce(1), xe = new ce(0), _e = ge.clone(); pe.cmpn(1) > 0 && ge.cmpn(1) > 0; ) {
        for (var Ae = 0, ve = 1; !(pe.words[0] & ve) && Ae < 26; ++Ae, ve <<= 1)
          ;
        if (Ae > 0)
          for (pe.iushrn(Ae); Ae-- > 0; )
            ye.isOdd() && ye.iadd(_e), ye.iushrn(1);
        for (var he = 0, be = 1; !(ge.words[0] & be) && he < 26; ++he, be <<= 1)
          ;
        if (he > 0)
          for (ge.iushrn(he); he-- > 0; )
            xe.isOdd() && xe.iadd(_e), xe.iushrn(1);
        pe.cmp(ge) >= 0 ? (pe.isub(ge), ye.isub(xe)) : (ge.isub(pe), xe.isub(ye));
      }
      var Me;
      return pe.cmpn(1) === 0 ? Me = ye : Me = xe, Me.cmpn(0) < 0 && Me.iadd(le), Me;
    }, ce.prototype.gcd = function(le) {
      if (this.isZero())
        return le.abs();
      if (le.isZero())
        return this.abs();
      var pe = this.clone(), ge = le.clone();
      pe.negative = 0, ge.negative = 0;
      for (var ye = 0; pe.isEven() && ge.isEven(); ye++)
        pe.iushrn(1), ge.iushrn(1);
      do {
        for (; pe.isEven(); )
          pe.iushrn(1);
        for (; ge.isEven(); )
          ge.iushrn(1);
        var xe = pe.cmp(ge);
        if (xe < 0) {
          var _e = pe;
          pe = ge, ge = _e;
        } else if (xe === 0 || ge.cmpn(1) === 0)
          break;
        pe.isub(ge);
      } while (!0);
      return ge.iushln(ye);
    }, ce.prototype.invm = function(le) {
      return this.egcd(le).a.umod(le);
    }, ce.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, ce.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, ce.prototype.andln = function(le) {
      return this.words[0] & le;
    }, ce.prototype.bincn = function(le) {
      fe(typeof le == "number");
      var pe = le % 26, ge = (le - pe) / 26, ye = 1 << pe;
      if (this.length <= ge)
        return this._expand(ge + 1), this.words[ge] |= ye, this;
      for (var xe = ye, _e = ge; xe !== 0 && _e < this.length; _e++) {
        var Ae = this.words[_e] | 0;
        Ae += xe, xe = Ae >>> 26, Ae &= 67108863, this.words[_e] = Ae;
      }
      return xe !== 0 && (this.words[_e] = xe, this.length++), this;
    }, ce.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, ce.prototype.cmpn = function(le) {
      var pe = le < 0;
      if (this.negative !== 0 && !pe)
        return -1;
      if (this.negative === 0 && pe)
        return 1;
      this.strip();
      var ge;
      if (this.length > 1)
        ge = 1;
      else {
        pe && (le = -le), fe(le <= 67108863, "Number is too big");
        var ye = this.words[0] | 0;
        ge = ye === le ? 0 : ye < le ? -1 : 1;
      }
      return this.negative !== 0 ? -ge | 0 : ge;
    }, ce.prototype.cmp = function(le) {
      if (this.negative !== 0 && le.negative === 0)
        return -1;
      if (this.negative === 0 && le.negative !== 0)
        return 1;
      var pe = this.ucmp(le);
      return this.negative !== 0 ? -pe | 0 : pe;
    }, ce.prototype.ucmp = function(le) {
      if (this.length > le.length)
        return 1;
      if (this.length < le.length)
        return -1;
      for (var pe = 0, ge = this.length - 1; ge >= 0; ge--) {
        var ye = this.words[ge] | 0, xe = le.words[ge] | 0;
        if (ye !== xe) {
          ye < xe ? pe = -1 : ye > xe && (pe = 1);
          break;
        }
      }
      return pe;
    }, ce.prototype.gtn = function(le) {
      return this.cmpn(le) === 1;
    }, ce.prototype.gt = function(le) {
      return this.cmp(le) === 1;
    }, ce.prototype.gten = function(le) {
      return this.cmpn(le) >= 0;
    }, ce.prototype.gte = function(le) {
      return this.cmp(le) >= 0;
    }, ce.prototype.ltn = function(le) {
      return this.cmpn(le) === -1;
    }, ce.prototype.lt = function(le) {
      return this.cmp(le) === -1;
    }, ce.prototype.lten = function(le) {
      return this.cmpn(le) <= 0;
    }, ce.prototype.lte = function(le) {
      return this.cmp(le) <= 0;
    }, ce.prototype.eqn = function(le) {
      return this.cmpn(le) === 0;
    }, ce.prototype.eq = function(le) {
      return this.cmp(le) === 0;
    }, ce.red = function(le) {
      return new ze(le);
    }, ce.prototype.toRed = function(le) {
      return fe(!this.red, "Already a number in reduction context"), fe(this.negative === 0, "red works only with positives"), le.convertTo(this)._forceRed(le);
    }, ce.prototype.fromRed = function() {
      return fe(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, ce.prototype._forceRed = function(le) {
      return this.red = le, this;
    }, ce.prototype.forceRed = function(le) {
      return fe(!this.red, "Already a number in reduction context"), this._forceRed(le);
    }, ce.prototype.redAdd = function(le) {
      return fe(this.red, "redAdd works only with red numbers"), this.red.add(this, le);
    }, ce.prototype.redIAdd = function(le) {
      return fe(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, le);
    }, ce.prototype.redSub = function(le) {
      return fe(this.red, "redSub works only with red numbers"), this.red.sub(this, le);
    }, ce.prototype.redISub = function(le) {
      return fe(this.red, "redISub works only with red numbers"), this.red.isub(this, le);
    }, ce.prototype.redShl = function(le) {
      return fe(this.red, "redShl works only with red numbers"), this.red.shl(this, le);
    }, ce.prototype.redMul = function(le) {
      return fe(this.red, "redMul works only with red numbers"), this.red._verify2(this, le), this.red.mul(this, le);
    }, ce.prototype.redIMul = function(le) {
      return fe(this.red, "redMul works only with red numbers"), this.red._verify2(this, le), this.red.imul(this, le);
    }, ce.prototype.redSqr = function() {
      return fe(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, ce.prototype.redISqr = function() {
      return fe(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, ce.prototype.redSqrt = function() {
      return fe(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, ce.prototype.redInvm = function() {
      return fe(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, ce.prototype.redNeg = function() {
      return fe(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, ce.prototype.redPow = function(le) {
      return fe(this.red && !le.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, le);
    };
    var Ge = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Ye($e, le) {
      this.name = $e, this.p = new ce(le, 16), this.n = this.p.bitLength(), this.k = new ce(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Ye.prototype._tmp = function() {
      var le = new ce(null);
      return le.words = new Array(Math.ceil(this.n / 13)), le;
    }, Ye.prototype.ireduce = function(le) {
      var pe = le, ge;
      do
        this.split(pe, this.tmp), pe = this.imulK(pe), pe = pe.iadd(this.tmp), ge = pe.bitLength();
      while (ge > this.n);
      var ye = ge < this.n ? -1 : pe.ucmp(this.p);
      return ye === 0 ? (pe.words[0] = 0, pe.length = 1) : ye > 0 ? pe.isub(this.p) : pe.strip !== void 0 ? pe.strip() : pe._strip(), pe;
    }, Ye.prototype.split = function(le, pe) {
      le.iushrn(this.n, 0, pe);
    }, Ye.prototype.imulK = function(le) {
      return le.imul(this.k);
    };
    function st() {
      Ye.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    ue(st, Ye), st.prototype.split = function(le, pe) {
      for (var ge = 4194303, ye = Math.min(le.length, 9), xe = 0; xe < ye; xe++)
        pe.words[xe] = le.words[xe];
      if (pe.length = ye, le.length <= 9) {
        le.words[0] = 0, le.length = 1;
        return;
      }
      var _e = le.words[9];
      for (pe.words[pe.length++] = _e & ge, xe = 10; xe < le.length; xe++) {
        var Ae = le.words[xe] | 0;
        le.words[xe - 10] = (Ae & ge) << 4 | _e >>> 22, _e = Ae;
      }
      _e >>>= 22, le.words[xe - 10] = _e, _e === 0 && le.length > 10 ? le.length -= 10 : le.length -= 9;
    }, st.prototype.imulK = function(le) {
      le.words[le.length] = 0, le.words[le.length + 1] = 0, le.length += 2;
      for (var pe = 0, ge = 0; ge < le.length; ge++) {
        var ye = le.words[ge] | 0;
        pe += ye * 977, le.words[ge] = pe & 67108863, pe = ye * 64 + (pe / 67108864 | 0);
      }
      return le.words[le.length - 1] === 0 && (le.length--, le.words[le.length - 1] === 0 && le.length--), le;
    };
    function at() {
      Ye.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    ue(at, Ye);
    function mt() {
      Ye.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    ue(mt, Ye);
    function qe() {
      Ye.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    ue(qe, Ye), qe.prototype.imulK = function(le) {
      for (var pe = 0, ge = 0; ge < le.length; ge++) {
        var ye = (le.words[ge] | 0) * 19 + pe, xe = ye & 67108863;
        ye >>>= 26, le.words[ge] = xe, pe = ye;
      }
      return pe !== 0 && (le.words[le.length++] = pe), le;
    }, ce._prime = function(le) {
      if (Ge[le])
        return Ge[le];
      var pe;
      if (le === "k256")
        pe = new st();
      else if (le === "p224")
        pe = new at();
      else if (le === "p192")
        pe = new mt();
      else if (le === "p25519")
        pe = new qe();
      else
        throw new Error("Unknown prime " + le);
      return Ge[le] = pe, pe;
    };
    function ze($e) {
      if (typeof $e == "string") {
        var le = ce._prime($e);
        this.m = le.p, this.prime = le;
      } else
        fe($e.gtn(1), "modulus must be greater than 1"), this.m = $e, this.prime = null;
    }
    ze.prototype._verify1 = function(le) {
      fe(le.negative === 0, "red works only with positives"), fe(le.red, "red works only with red numbers");
    }, ze.prototype._verify2 = function(le, pe) {
      fe((le.negative | pe.negative) === 0, "red works only with positives"), fe(
        le.red && le.red === pe.red,
        "red works only with red numbers"
      );
    }, ze.prototype.imod = function(le) {
      return this.prime ? this.prime.ireduce(le)._forceRed(this) : le.umod(this.m)._forceRed(this);
    }, ze.prototype.neg = function(le) {
      return le.isZero() ? le.clone() : this.m.sub(le)._forceRed(this);
    }, ze.prototype.add = function(le, pe) {
      this._verify2(le, pe);
      var ge = le.add(pe);
      return ge.cmp(this.m) >= 0 && ge.isub(this.m), ge._forceRed(this);
    }, ze.prototype.iadd = function(le, pe) {
      this._verify2(le, pe);
      var ge = le.iadd(pe);
      return ge.cmp(this.m) >= 0 && ge.isub(this.m), ge;
    }, ze.prototype.sub = function(le, pe) {
      this._verify2(le, pe);
      var ge = le.sub(pe);
      return ge.cmpn(0) < 0 && ge.iadd(this.m), ge._forceRed(this);
    }, ze.prototype.isub = function(le, pe) {
      this._verify2(le, pe);
      var ge = le.isub(pe);
      return ge.cmpn(0) < 0 && ge.iadd(this.m), ge;
    }, ze.prototype.shl = function(le, pe) {
      return this._verify1(le), this.imod(le.ushln(pe));
    }, ze.prototype.imul = function(le, pe) {
      return this._verify2(le, pe), this.imod(le.imul(pe));
    }, ze.prototype.mul = function(le, pe) {
      return this._verify2(le, pe), this.imod(le.mul(pe));
    }, ze.prototype.isqr = function(le) {
      return this.imul(le, le.clone());
    }, ze.prototype.sqr = function(le) {
      return this.mul(le, le);
    }, ze.prototype.sqrt = function(le) {
      if (le.isZero())
        return le.clone();
      var pe = this.m.andln(3);
      if (fe(pe % 2 === 1), pe === 3) {
        var ge = this.m.add(new ce(1)).iushrn(2);
        return this.pow(le, ge);
      }
      for (var ye = this.m.subn(1), xe = 0; !ye.isZero() && ye.andln(1) === 0; )
        xe++, ye.iushrn(1);
      fe(!ye.isZero());
      var _e = new ce(1).toRed(this), Ae = _e.redNeg(), ve = this.m.subn(1).iushrn(1), he = this.m.bitLength();
      for (he = new ce(2 * he * he).toRed(this); this.pow(he, ve).cmp(Ae) !== 0; )
        he.redIAdd(Ae);
      for (var be = this.pow(he, ye), Me = this.pow(le, ye.addn(1).iushrn(1)), Re = this.pow(le, ye), Oe = xe; Re.cmp(_e) !== 0; ) {
        for (var Te = Re, Fe = 0; Te.cmp(_e) !== 0; Fe++)
          Te = Te.redSqr();
        fe(Fe < Oe);
        var je = this.pow(be, new ce(1).iushln(Oe - Fe - 1));
        Me = Me.redMul(je), be = je.redSqr(), Re = Re.redMul(be), Oe = Fe;
      }
      return Me;
    }, ze.prototype.invm = function(le) {
      var pe = le._invmp(this.m);
      return pe.negative !== 0 ? (pe.negative = 0, this.imod(pe).redNeg()) : this.imod(pe);
    }, ze.prototype.pow = function(le, pe) {
      if (pe.isZero())
        return new ce(1).toRed(this);
      if (pe.cmpn(1) === 0)
        return le.clone();
      var ge = 4, ye = new Array(1 << ge);
      ye[0] = new ce(1).toRed(this), ye[1] = le;
      for (var xe = 2; xe < ye.length; xe++)
        ye[xe] = this.mul(ye[xe - 1], le);
      var _e = ye[0], Ae = 0, ve = 0, he = pe.bitLength() % 26;
      for (he === 0 && (he = 26), xe = pe.length - 1; xe >= 0; xe--) {
        for (var be = pe.words[xe], Me = he - 1; Me >= 0; Me--) {
          var Re = be >> Me & 1;
          if (_e !== ye[0] && (_e = this.sqr(_e)), Re === 0 && Ae === 0) {
            ve = 0;
            continue;
          }
          Ae <<= 1, Ae |= Re, ve++, !(ve !== ge && (xe !== 0 || Me !== 0)) && (_e = this.mul(_e, ye[Ae]), ve = 0, Ae = 0);
        }
        he = 26;
      }
      return _e;
    }, ze.prototype.convertTo = function(le) {
      var pe = le.umod(this.m);
      return pe === le ? pe.clone() : pe;
    }, ze.prototype.convertFrom = function(le) {
      var pe = le.clone();
      return pe.red = null, pe;
    }, ce.mont = function(le) {
      return new ot(le);
    };
    function ot($e) {
      ze.call(this, $e), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new ce(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    ue(ot, ze), ot.prototype.convertTo = function(le) {
      return this.imod(le.ushln(this.shift));
    }, ot.prototype.convertFrom = function(le) {
      var pe = this.imod(le.mul(this.rinv));
      return pe.red = null, pe;
    }, ot.prototype.imul = function(le, pe) {
      if (le.isZero() || pe.isZero())
        return le.words[0] = 0, le.length = 1, le;
      var ge = le.imul(pe), ye = ge.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), xe = ge.isub(ye).iushrn(this.shift), _e = xe;
      return xe.cmp(this.m) >= 0 ? _e = xe.isub(this.m) : xe.cmpn(0) < 0 && (_e = xe.iadd(this.m)), _e._forceRed(this);
    }, ot.prototype.mul = function(le, pe) {
      if (le.isZero() || pe.isZero())
        return new ce(0)._forceRed(this);
      var ge = le.mul(pe), ye = ge.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), xe = ge.isub(ye).iushrn(this.shift), _e = xe;
      return xe.cmp(this.m) >= 0 ? _e = xe.isub(this.m) : xe.cmpn(0) < 0 && (_e = xe.iadd(this.m)), _e._forceRed(this);
    }, ot.prototype.invm = function(le) {
      var pe = this.imod(le._invmp(this.m).mul(this.r2));
      return pe._forceRed(this);
    };
  })(ae, commonjsGlobal);
})(bn$2);
var bnExports$2 = bn$2.exports, api$2 = {}, encoders = {}, buffer$1 = require$$0$2, Buffer$a = buffer$1.Buffer, safer = {}, key$1;
for (key$1 in buffer$1)
  buffer$1.hasOwnProperty(key$1) && (key$1 === "SlowBuffer" || key$1 === "Buffer" || (safer[key$1] = buffer$1[key$1]));
var Safer = safer.Buffer = {};
for (key$1 in Buffer$a)
  Buffer$a.hasOwnProperty(key$1) && (key$1 === "allocUnsafe" || key$1 === "allocUnsafeSlow" || (Safer[key$1] = Buffer$a[key$1]));
safer.Buffer.prototype = Buffer$a.prototype;
(!Safer.from || Safer.from === Uint8Array.from) && (Safer.from = function(ae, ie, se) {
  if (typeof ae == "number")
    throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof ae);
  if (ae && typeof ae.length > "u")
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ae);
  return Buffer$a(ae, ie, se);
});
Safer.alloc || (Safer.alloc = function(ae, ie, se) {
  if (typeof ae != "number")
    throw new TypeError('The "size" argument must be of type number. Received type ' + typeof ae);
  if (ae < 0 || ae >= 2 * (1 << 30))
    throw new RangeError('The value "' + ae + '" is invalid for option "size"');
  var fe = Buffer$a(ae);
  return !ie || ie.length === 0 ? fe.fill(0) : typeof se == "string" ? fe.fill(ie, se) : fe.fill(ie), fe;
});
if (!safer.kStringMaxLength)
  try {
    safer.kStringMaxLength = process$1.binding("buffer").kStringMaxLength;
  } catch {
  }
safer.constants || (safer.constants = {
  MAX_LENGTH: safer.kMaxLength
}, safer.kStringMaxLength && (safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength));
var safer_1 = safer, reporter = {};
const inherits$7 = inherits_browserExports;
function Reporter$2(ae) {
  this._reporterState = {
    obj: null,
    path: [],
    options: ae || {},
    errors: []
  };
}
reporter.Reporter = Reporter$2;
Reporter$2.prototype.isError = function(ie) {
  return ie instanceof ReporterError;
};
Reporter$2.prototype.save = function() {
  const ie = this._reporterState;
  return { obj: ie.obj, pathLen: ie.path.length };
};
Reporter$2.prototype.restore = function(ie) {
  const se = this._reporterState;
  se.obj = ie.obj, se.path = se.path.slice(0, ie.pathLen);
};
Reporter$2.prototype.enterKey = function(ie) {
  return this._reporterState.path.push(ie);
};
Reporter$2.prototype.exitKey = function(ie) {
  const se = this._reporterState;
  se.path = se.path.slice(0, ie - 1);
};
Reporter$2.prototype.leaveKey = function(ie, se, fe) {
  const ue = this._reporterState;
  this.exitKey(ie), ue.obj !== null && (ue.obj[se] = fe);
};
Reporter$2.prototype.path = function() {
  return this._reporterState.path.join("/");
};
Reporter$2.prototype.enterObject = function() {
  const ie = this._reporterState, se = ie.obj;
  return ie.obj = {}, se;
};
Reporter$2.prototype.leaveObject = function(ie) {
  const se = this._reporterState, fe = se.obj;
  return se.obj = ie, fe;
};
Reporter$2.prototype.error = function(ie) {
  let se;
  const fe = this._reporterState, ue = ie instanceof ReporterError;
  if (ue ? se = ie : se = new ReporterError(fe.path.map(function(ce) {
    return "[" + JSON.stringify(ce) + "]";
  }).join(""), ie.message || ie, ie.stack), !fe.options.partial)
    throw se;
  return ue || fe.errors.push(se), se;
};
Reporter$2.prototype.wrapResult = function(ie) {
  const se = this._reporterState;
  return se.options.partial ? {
    result: this.isError(ie) ? null : ie,
    errors: se.errors
  } : ie;
};
function ReporterError(ae, ie) {
  this.path = ae, this.rethrow(ie);
}
inherits$7(ReporterError, Error);
ReporterError.prototype.rethrow = function(ie) {
  if (this.message = ie + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, ReporterError), !this.stack)
    try {
      throw new Error(this.message);
    } catch (se) {
      this.stack = se.stack;
    }
  return this;
};
var buffer = {};
const inherits$6 = inherits_browserExports, Reporter$1 = reporter.Reporter, Buffer$9 = safer_1.Buffer;
function DecoderBuffer$2(ae, ie) {
  if (Reporter$1.call(this, ie), !Buffer$9.isBuffer(ae)) {
    this.error("Input not Buffer");
    return;
  }
  this.base = ae, this.offset = 0, this.length = ae.length;
}
inherits$6(DecoderBuffer$2, Reporter$1);
buffer.DecoderBuffer = DecoderBuffer$2;
DecoderBuffer$2.isDecoderBuffer = function(ie) {
  return ie instanceof DecoderBuffer$2 ? !0 : typeof ie == "object" && Buffer$9.isBuffer(ie.base) && ie.constructor.name === "DecoderBuffer" && typeof ie.offset == "number" && typeof ie.length == "number" && typeof ie.save == "function" && typeof ie.restore == "function" && typeof ie.isEmpty == "function" && typeof ie.readUInt8 == "function" && typeof ie.skip == "function" && typeof ie.raw == "function";
};
DecoderBuffer$2.prototype.save = function() {
  return { offset: this.offset, reporter: Reporter$1.prototype.save.call(this) };
};
DecoderBuffer$2.prototype.restore = function(ie) {
  const se = new DecoderBuffer$2(this.base);
  return se.offset = ie.offset, se.length = this.offset, this.offset = ie.offset, Reporter$1.prototype.restore.call(this, ie.reporter), se;
};
DecoderBuffer$2.prototype.isEmpty = function() {
  return this.offset === this.length;
};
DecoderBuffer$2.prototype.readUInt8 = function(ie) {
  return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(ie || "DecoderBuffer overrun");
};
DecoderBuffer$2.prototype.skip = function(ie, se) {
  if (!(this.offset + ie <= this.length))
    return this.error(se || "DecoderBuffer overrun");
  const fe = new DecoderBuffer$2(this.base);
  return fe._reporterState = this._reporterState, fe.offset = this.offset, fe.length = this.offset + ie, this.offset += ie, fe;
};
DecoderBuffer$2.prototype.raw = function(ie) {
  return this.base.slice(ie ? ie.offset : this.offset, this.length);
};
function EncoderBuffer$1(ae, ie) {
  if (Array.isArray(ae))
    this.length = 0, this.value = ae.map(function(se) {
      return EncoderBuffer$1.isEncoderBuffer(se) || (se = new EncoderBuffer$1(se, ie)), this.length += se.length, se;
    }, this);
  else if (typeof ae == "number") {
    if (!(0 <= ae && ae <= 255))
      return ie.error("non-byte EncoderBuffer value");
    this.value = ae, this.length = 1;
  } else if (typeof ae == "string")
    this.value = ae, this.length = Buffer$9.byteLength(ae);
  else if (Buffer$9.isBuffer(ae))
    this.value = ae, this.length = ae.length;
  else
    return ie.error("Unsupported type: " + typeof ae);
}
buffer.EncoderBuffer = EncoderBuffer$1;
EncoderBuffer$1.isEncoderBuffer = function(ie) {
  return ie instanceof EncoderBuffer$1 ? !0 : typeof ie == "object" && ie.constructor.name === "EncoderBuffer" && typeof ie.length == "number" && typeof ie.join == "function";
};
EncoderBuffer$1.prototype.join = function(ie, se) {
  return ie || (ie = Buffer$9.alloc(this.length)), se || (se = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(fe) {
    fe.join(ie, se), se += fe.length;
  }) : (typeof this.value == "number" ? ie[se] = this.value : typeof this.value == "string" ? ie.write(this.value, se) : Buffer$9.isBuffer(this.value) && this.value.copy(ie, se), se += this.length)), ie;
};
const Reporter = reporter.Reporter, EncoderBuffer = buffer.EncoderBuffer, DecoderBuffer$1 = buffer.DecoderBuffer, assert$6 = minimalisticAssert$1, tags = [
  "seq",
  "seqof",
  "set",
  "setof",
  "objid",
  "bool",
  "gentime",
  "utctime",
  "null_",
  "enum",
  "int",
  "objDesc",
  "bitstr",
  "bmpstr",
  "charstr",
  "genstr",
  "graphstr",
  "ia5str",
  "iso646str",
  "numstr",
  "octstr",
  "printstr",
  "t61str",
  "unistr",
  "utf8str",
  "videostr"
], methods = [
  "key",
  "obj",
  "use",
  "optional",
  "explicit",
  "implicit",
  "def",
  "choice",
  "any",
  "contains"
].concat(tags), overrided = [
  "_peekTag",
  "_decodeTag",
  "_use",
  "_decodeStr",
  "_decodeObjid",
  "_decodeTime",
  "_decodeNull",
  "_decodeInt",
  "_decodeBool",
  "_decodeList",
  "_encodeComposite",
  "_encodeStr",
  "_encodeObjid",
  "_encodeTime",
  "_encodeNull",
  "_encodeInt",
  "_encodeBool"
];
function Node$2(ae, ie, se) {
  const fe = {};
  this._baseState = fe, fe.name = se, fe.enc = ae, fe.parent = ie || null, fe.children = null, fe.tag = null, fe.args = null, fe.reverseArgs = null, fe.choice = null, fe.optional = !1, fe.any = !1, fe.obj = !1, fe.use = null, fe.useDecoder = null, fe.key = null, fe.default = null, fe.explicit = null, fe.implicit = null, fe.contains = null, fe.parent || (fe.children = [], this._wrap());
}
var node = Node$2;
const stateProps = [
  "enc",
  "parent",
  "children",
  "tag",
  "args",
  "reverseArgs",
  "choice",
  "optional",
  "any",
  "obj",
  "use",
  "alteredUse",
  "key",
  "default",
  "explicit",
  "implicit",
  "contains"
];
Node$2.prototype.clone = function() {
  const ie = this._baseState, se = {};
  stateProps.forEach(function(ue) {
    se[ue] = ie[ue];
  });
  const fe = new this.constructor(se.parent);
  return fe._baseState = se, fe;
};
Node$2.prototype._wrap = function() {
  const ie = this._baseState;
  methods.forEach(function(se) {
    this[se] = function() {
      const ue = new this.constructor(this);
      return ie.children.push(ue), ue[se].apply(ue, arguments);
    };
  }, this);
};
Node$2.prototype._init = function(ie) {
  const se = this._baseState;
  assert$6(se.parent === null), ie.call(this), se.children = se.children.filter(function(fe) {
    return fe._baseState.parent === this;
  }, this), assert$6.equal(se.children.length, 1, "Root node can have only one child");
};
Node$2.prototype._useArgs = function(ie) {
  const se = this._baseState, fe = ie.filter(function(ue) {
    return ue instanceof this.constructor;
  }, this);
  ie = ie.filter(function(ue) {
    return !(ue instanceof this.constructor);
  }, this), fe.length !== 0 && (assert$6(se.children === null), se.children = fe, fe.forEach(function(ue) {
    ue._baseState.parent = this;
  }, this)), ie.length !== 0 && (assert$6(se.args === null), se.args = ie, se.reverseArgs = ie.map(function(ue) {
    if (typeof ue != "object" || ue.constructor !== Object)
      return ue;
    const ce = {};
    return Object.keys(ue).forEach(function(de) {
      de == (de | 0) && (de |= 0);
      const me = ue[de];
      ce[me] = de;
    }), ce;
  }));
};
overrided.forEach(function(ae) {
  Node$2.prototype[ae] = function() {
    const se = this._baseState;
    throw new Error(ae + " not implemented for encoding: " + se.enc);
  };
});
tags.forEach(function(ae) {
  Node$2.prototype[ae] = function() {
    const se = this._baseState, fe = Array.prototype.slice.call(arguments);
    return assert$6(se.tag === null), se.tag = ae, this._useArgs(fe), this;
  };
});
Node$2.prototype.use = function(ie) {
  assert$6(ie);
  const se = this._baseState;
  return assert$6(se.use === null), se.use = ie, this;
};
Node$2.prototype.optional = function() {
  const ie = this._baseState;
  return ie.optional = !0, this;
};
Node$2.prototype.def = function(ie) {
  const se = this._baseState;
  return assert$6(se.default === null), se.default = ie, se.optional = !0, this;
};
Node$2.prototype.explicit = function(ie) {
  const se = this._baseState;
  return assert$6(se.explicit === null && se.implicit === null), se.explicit = ie, this;
};
Node$2.prototype.implicit = function(ie) {
  const se = this._baseState;
  return assert$6(se.explicit === null && se.implicit === null), se.implicit = ie, this;
};
Node$2.prototype.obj = function() {
  const ie = this._baseState, se = Array.prototype.slice.call(arguments);
  return ie.obj = !0, se.length !== 0 && this._useArgs(se), this;
};
Node$2.prototype.key = function(ie) {
  const se = this._baseState;
  return assert$6(se.key === null), se.key = ie, this;
};
Node$2.prototype.any = function() {
  const ie = this._baseState;
  return ie.any = !0, this;
};
Node$2.prototype.choice = function(ie) {
  const se = this._baseState;
  return assert$6(se.choice === null), se.choice = ie, this._useArgs(Object.keys(ie).map(function(fe) {
    return ie[fe];
  })), this;
};
Node$2.prototype.contains = function(ie) {
  const se = this._baseState;
  return assert$6(se.use === null), se.contains = ie, this;
};
Node$2.prototype._decode = function(ie, se) {
  const fe = this._baseState;
  if (fe.parent === null)
    return ie.wrapResult(fe.children[0]._decode(ie, se));
  let ue = fe.default, ce = !0, de = null;
  if (fe.key !== null && (de = ie.enterKey(fe.key)), fe.optional) {
    let we = null;
    if (fe.explicit !== null ? we = fe.explicit : fe.implicit !== null ? we = fe.implicit : fe.tag !== null && (we = fe.tag), we === null && !fe.any) {
      const Ee = ie.save();
      try {
        fe.choice === null ? this._decodeGeneric(fe.tag, ie, se) : this._decodeChoice(ie, se), ce = !0;
      } catch {
        ce = !1;
      }
      ie.restore(Ee);
    } else if (ce = this._peekTag(ie, we, fe.any), ie.isError(ce))
      return ce;
  }
  let me;
  if (fe.obj && ce && (me = ie.enterObject()), ce) {
    if (fe.explicit !== null) {
      const Ee = this._decodeTag(ie, fe.explicit);
      if (ie.isError(Ee))
        return Ee;
      ie = Ee;
    }
    const we = ie.offset;
    if (fe.use === null && fe.choice === null) {
      let Ee;
      fe.any && (Ee = ie.save());
      const Se = this._decodeTag(
        ie,
        fe.implicit !== null ? fe.implicit : fe.tag,
        fe.any
      );
      if (ie.isError(Se))
        return Se;
      fe.any ? ue = ie.raw(Ee) : ie = Se;
    }
    if (se && se.track && fe.tag !== null && se.track(ie.path(), we, ie.length, "tagged"), se && se.track && fe.tag !== null && se.track(ie.path(), ie.offset, ie.length, "content"), fe.any || (fe.choice === null ? ue = this._decodeGeneric(fe.tag, ie, se) : ue = this._decodeChoice(ie, se)), ie.isError(ue))
      return ue;
    if (!fe.any && fe.choice === null && fe.children !== null && fe.children.forEach(function(Se) {
      Se._decode(ie, se);
    }), fe.contains && (fe.tag === "octstr" || fe.tag === "bitstr")) {
      const Ee = new DecoderBuffer$1(ue);
      ue = this._getUse(fe.contains, ie._reporterState.obj)._decode(Ee, se);
    }
  }
  return fe.obj && ce && (ue = ie.leaveObject(me)), fe.key !== null && (ue !== null || ce === !0) ? ie.leaveKey(de, fe.key, ue) : de !== null && ie.exitKey(de), ue;
};
Node$2.prototype._decodeGeneric = function(ie, se, fe) {
  const ue = this._baseState;
  return ie === "seq" || ie === "set" ? null : ie === "seqof" || ie === "setof" ? this._decodeList(se, ie, ue.args[0], fe) : /str$/.test(ie) ? this._decodeStr(se, ie, fe) : ie === "objid" && ue.args ? this._decodeObjid(se, ue.args[0], ue.args[1], fe) : ie === "objid" ? this._decodeObjid(se, null, null, fe) : ie === "gentime" || ie === "utctime" ? this._decodeTime(se, ie, fe) : ie === "null_" ? this._decodeNull(se, fe) : ie === "bool" ? this._decodeBool(se, fe) : ie === "objDesc" ? this._decodeStr(se, ie, fe) : ie === "int" || ie === "enum" ? this._decodeInt(se, ue.args && ue.args[0], fe) : ue.use !== null ? this._getUse(ue.use, se._reporterState.obj)._decode(se, fe) : se.error("unknown tag: " + ie);
};
Node$2.prototype._getUse = function(ie, se) {
  const fe = this._baseState;
  return fe.useDecoder = this._use(ie, se), assert$6(fe.useDecoder._baseState.parent === null), fe.useDecoder = fe.useDecoder._baseState.children[0], fe.implicit !== fe.useDecoder._baseState.implicit && (fe.useDecoder = fe.useDecoder.clone(), fe.useDecoder._baseState.implicit = fe.implicit), fe.useDecoder;
};
Node$2.prototype._decodeChoice = function(ie, se) {
  const fe = this._baseState;
  let ue = null, ce = !1;
  return Object.keys(fe.choice).some(function(de) {
    const me = ie.save(), we = fe.choice[de];
    try {
      const Ee = we._decode(ie, se);
      if (ie.isError(Ee))
        return !1;
      ue = { type: de, value: Ee }, ce = !0;
    } catch {
      return ie.restore(me), !1;
    }
    return !0;
  }, this), ce ? ue : ie.error("Choice not matched");
};
Node$2.prototype._createEncoderBuffer = function(ie) {
  return new EncoderBuffer(ie, this.reporter);
};
Node$2.prototype._encode = function(ie, se, fe) {
  const ue = this._baseState;
  if (ue.default !== null && ue.default === ie)
    return;
  const ce = this._encodeValue(ie, se, fe);
  if (ce !== void 0 && !this._skipDefault(ce, se, fe))
    return ce;
};
Node$2.prototype._encodeValue = function(ie, se, fe) {
  const ue = this._baseState;
  if (ue.parent === null)
    return ue.children[0]._encode(ie, se || new Reporter());
  let ce = null;
  if (this.reporter = se, ue.optional && ie === void 0)
    if (ue.default !== null)
      ie = ue.default;
    else
      return;
  let de = null, me = !1;
  if (ue.any)
    ce = this._createEncoderBuffer(ie);
  else if (ue.choice)
    ce = this._encodeChoice(ie, se);
  else if (ue.contains)
    de = this._getUse(ue.contains, fe)._encode(ie, se), me = !0;
  else if (ue.children)
    de = ue.children.map(function(we) {
      if (we._baseState.tag === "null_")
        return we._encode(null, se, ie);
      if (we._baseState.key === null)
        return se.error("Child should have a key");
      const Ee = se.enterKey(we._baseState.key);
      if (typeof ie != "object")
        return se.error("Child expected, but input is not object");
      const Se = we._encode(ie[we._baseState.key], se, ie);
      return se.leaveKey(Ee), Se;
    }, this).filter(function(we) {
      return we;
    }), de = this._createEncoderBuffer(de);
  else if (ue.tag === "seqof" || ue.tag === "setof") {
    if (!(ue.args && ue.args.length === 1))
      return se.error("Too many args for : " + ue.tag);
    if (!Array.isArray(ie))
      return se.error("seqof/setof, but data is not Array");
    const we = this.clone();
    we._baseState.implicit = null, de = this._createEncoderBuffer(ie.map(function(Ee) {
      const Se = this._baseState;
      return this._getUse(Se.args[0], ie)._encode(Ee, se);
    }, we));
  } else
    ue.use !== null ? ce = this._getUse(ue.use, fe)._encode(ie, se) : (de = this._encodePrimitive(ue.tag, ie), me = !0);
  if (!ue.any && ue.choice === null) {
    const we = ue.implicit !== null ? ue.implicit : ue.tag, Ee = ue.implicit === null ? "universal" : "context";
    we === null ? ue.use === null && se.error("Tag could be omitted only for .use()") : ue.use === null && (ce = this._encodeComposite(we, me, Ee, de));
  }
  return ue.explicit !== null && (ce = this._encodeComposite(ue.explicit, !1, "context", ce)), ce;
};
Node$2.prototype._encodeChoice = function(ie, se) {
  const fe = this._baseState, ue = fe.choice[ie.type];
  return ue || assert$6(
    !1,
    ie.type + " not found in " + JSON.stringify(Object.keys(fe.choice))
  ), ue._encode(ie.value, se);
};
Node$2.prototype._encodePrimitive = function(ie, se) {
  const fe = this._baseState;
  if (/str$/.test(ie))
    return this._encodeStr(se, ie);
  if (ie === "objid" && fe.args)
    return this._encodeObjid(se, fe.reverseArgs[0], fe.args[1]);
  if (ie === "objid")
    return this._encodeObjid(se, null, null);
  if (ie === "gentime" || ie === "utctime")
    return this._encodeTime(se, ie);
  if (ie === "null_")
    return this._encodeNull();
  if (ie === "int" || ie === "enum")
    return this._encodeInt(se, fe.args && fe.reverseArgs[0]);
  if (ie === "bool")
    return this._encodeBool(se);
  if (ie === "objDesc")
    return this._encodeStr(se, ie);
  throw new Error("Unsupported tag: " + ie);
};
Node$2.prototype._isNumstr = function(ie) {
  return /^[0-9 ]*$/.test(ie);
};
Node$2.prototype._isPrintstr = function(ie) {
  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(ie);
};
var der$2 = {};
(function(ae) {
  function ie(se) {
    const fe = {};
    return Object.keys(se).forEach(function(ue) {
      (ue | 0) == ue && (ue = ue | 0);
      const ce = se[ue];
      fe[ce] = ue;
    }), fe;
  }
  ae.tagClass = {
    0: "universal",
    1: "application",
    2: "context",
    3: "private"
  }, ae.tagClassByName = ie(ae.tagClass), ae.tag = {
    0: "end",
    1: "bool",
    2: "int",
    3: "bitstr",
    4: "octstr",
    5: "null_",
    6: "objid",
    7: "objDesc",
    8: "external",
    9: "real",
    10: "enum",
    11: "embed",
    12: "utf8str",
    13: "relativeOid",
    16: "seq",
    17: "set",
    18: "numstr",
    19: "printstr",
    20: "t61str",
    21: "videostr",
    22: "ia5str",
    23: "utctime",
    24: "gentime",
    25: "graphstr",
    26: "iso646str",
    27: "genstr",
    28: "unistr",
    29: "charstr",
    30: "bmpstr"
  }, ae.tagByName = ie(ae.tag);
})(der$2);
const inherits$5 = inherits_browserExports, Buffer$8 = safer_1.Buffer, Node$1 = node, der$1 = der$2;
function DEREncoder$1(ae) {
  this.enc = "der", this.name = ae.name, this.entity = ae, this.tree = new DERNode$1(), this.tree._init(ae.body);
}
var der_1$1 = DEREncoder$1;
DEREncoder$1.prototype.encode = function(ie, se) {
  return this.tree._encode(ie, se).join();
};
function DERNode$1(ae) {
  Node$1.call(this, "der", ae);
}
inherits$5(DERNode$1, Node$1);
DERNode$1.prototype._encodeComposite = function(ie, se, fe, ue) {
  const ce = encodeTag(ie, se, fe, this.reporter);
  if (ue.length < 128) {
    const we = Buffer$8.alloc(2);
    return we[0] = ce, we[1] = ue.length, this._createEncoderBuffer([we, ue]);
  }
  let de = 1;
  for (let we = ue.length; we >= 256; we >>= 8)
    de++;
  const me = Buffer$8.alloc(2 + de);
  me[0] = ce, me[1] = 128 | de;
  for (let we = 1 + de, Ee = ue.length; Ee > 0; we--, Ee >>= 8)
    me[we] = Ee & 255;
  return this._createEncoderBuffer([me, ue]);
};
DERNode$1.prototype._encodeStr = function(ie, se) {
  if (se === "bitstr")
    return this._createEncoderBuffer([ie.unused | 0, ie.data]);
  if (se === "bmpstr") {
    const fe = Buffer$8.alloc(ie.length * 2);
    for (let ue = 0; ue < ie.length; ue++)
      fe.writeUInt16BE(ie.charCodeAt(ue), ue * 2);
    return this._createEncoderBuffer(fe);
  } else
    return se === "numstr" ? this._isNumstr(ie) ? this._createEncoderBuffer(ie) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : se === "printstr" ? this._isPrintstr(ie) ? this._createEncoderBuffer(ie) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(se) ? this._createEncoderBuffer(ie) : se === "objDesc" ? this._createEncoderBuffer(ie) : this.reporter.error("Encoding of string type: " + se + " unsupported");
};
DERNode$1.prototype._encodeObjid = function(ie, se, fe) {
  if (typeof ie == "string") {
    if (!se)
      return this.reporter.error("string objid given, but no values map found");
    if (!se.hasOwnProperty(ie))
      return this.reporter.error("objid not found in values map");
    ie = se[ie].split(/[\s.]+/g);
    for (let me = 0; me < ie.length; me++)
      ie[me] |= 0;
  } else if (Array.isArray(ie)) {
    ie = ie.slice();
    for (let me = 0; me < ie.length; me++)
      ie[me] |= 0;
  }
  if (!Array.isArray(ie))
    return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(ie));
  if (!fe) {
    if (ie[1] >= 40)
      return this.reporter.error("Second objid identifier OOB");
    ie.splice(0, 2, ie[0] * 40 + ie[1]);
  }
  let ue = 0;
  for (let me = 0; me < ie.length; me++) {
    let we = ie[me];
    for (ue++; we >= 128; we >>= 7)
      ue++;
  }
  const ce = Buffer$8.alloc(ue);
  let de = ce.length - 1;
  for (let me = ie.length - 1; me >= 0; me--) {
    let we = ie[me];
    for (ce[de--] = we & 127; (we >>= 7) > 0; )
      ce[de--] = 128 | we & 127;
  }
  return this._createEncoderBuffer(ce);
};
function two(ae) {
  return ae < 10 ? "0" + ae : ae;
}
DERNode$1.prototype._encodeTime = function(ie, se) {
  let fe;
  const ue = new Date(ie);
  return se === "gentime" ? fe = [
    two(ue.getUTCFullYear()),
    two(ue.getUTCMonth() + 1),
    two(ue.getUTCDate()),
    two(ue.getUTCHours()),
    two(ue.getUTCMinutes()),
    two(ue.getUTCSeconds()),
    "Z"
  ].join("") : se === "utctime" ? fe = [
    two(ue.getUTCFullYear() % 100),
    two(ue.getUTCMonth() + 1),
    two(ue.getUTCDate()),
    two(ue.getUTCHours()),
    two(ue.getUTCMinutes()),
    two(ue.getUTCSeconds()),
    "Z"
  ].join("") : this.reporter.error("Encoding " + se + " time is not supported yet"), this._encodeStr(fe, "octstr");
};
DERNode$1.prototype._encodeNull = function() {
  return this._createEncoderBuffer("");
};
DERNode$1.prototype._encodeInt = function(ie, se) {
  if (typeof ie == "string") {
    if (!se)
      return this.reporter.error("String int or enum given, but no values map");
    if (!se.hasOwnProperty(ie))
      return this.reporter.error("Values map doesn't contain: " + JSON.stringify(ie));
    ie = se[ie];
  }
  if (typeof ie != "number" && !Buffer$8.isBuffer(ie)) {
    const ce = ie.toArray();
    !ie.sign && ce[0] & 128 && ce.unshift(0), ie = Buffer$8.from(ce);
  }
  if (Buffer$8.isBuffer(ie)) {
    let ce = ie.length;
    ie.length === 0 && ce++;
    const de = Buffer$8.alloc(ce);
    return ie.copy(de), ie.length === 0 && (de[0] = 0), this._createEncoderBuffer(de);
  }
  if (ie < 128)
    return this._createEncoderBuffer(ie);
  if (ie < 256)
    return this._createEncoderBuffer([0, ie]);
  let fe = 1;
  for (let ce = ie; ce >= 256; ce >>= 8)
    fe++;
  const ue = new Array(fe);
  for (let ce = ue.length - 1; ce >= 0; ce--)
    ue[ce] = ie & 255, ie >>= 8;
  return ue[0] & 128 && ue.unshift(0), this._createEncoderBuffer(Buffer$8.from(ue));
};
DERNode$1.prototype._encodeBool = function(ie) {
  return this._createEncoderBuffer(ie ? 255 : 0);
};
DERNode$1.prototype._use = function(ie, se) {
  return typeof ie == "function" && (ie = ie(se)), ie._getEncoder("der").tree;
};
DERNode$1.prototype._skipDefault = function(ie, se, fe) {
  const ue = this._baseState;
  let ce;
  if (ue.default === null)
    return !1;
  const de = ie.join();
  if (ue.defaultBuffer === void 0 && (ue.defaultBuffer = this._encodeValue(ue.default, se, fe).join()), de.length !== ue.defaultBuffer.length)
    return !1;
  for (ce = 0; ce < de.length; ce++)
    if (de[ce] !== ue.defaultBuffer[ce])
      return !1;
  return !0;
};
function encodeTag(ae, ie, se, fe) {
  let ue;
  if (ae === "seqof" ? ae = "seq" : ae === "setof" && (ae = "set"), der$1.tagByName.hasOwnProperty(ae))
    ue = der$1.tagByName[ae];
  else if (typeof ae == "number" && (ae | 0) === ae)
    ue = ae;
  else
    return fe.error("Unknown tag: " + ae);
  return ue >= 31 ? fe.error("Multi-octet tag encoding unsupported") : (ie || (ue |= 32), ue |= der$1.tagClassByName[se || "universal"] << 6, ue);
}
const inherits$4 = inherits_browserExports, DEREncoder = der_1$1;
function PEMEncoder(ae) {
  DEREncoder.call(this, ae), this.enc = "pem";
}
inherits$4(PEMEncoder, DEREncoder);
var pem$1 = PEMEncoder;
PEMEncoder.prototype.encode = function(ie, se) {
  const ue = DEREncoder.prototype.encode.call(this, ie).toString("base64"), ce = ["-----BEGIN " + se.label + "-----"];
  for (let de = 0; de < ue.length; de += 64)
    ce.push(ue.slice(de, de + 64));
  return ce.push("-----END " + se.label + "-----"), ce.join(`
`);
};
(function(ae) {
  const ie = ae;
  ie.der = der_1$1, ie.pem = pem$1;
})(encoders);
var decoders = {};
const inherits$3 = inherits_browserExports, bignum = bnExports$2, DecoderBuffer = buffer.DecoderBuffer, Node = node, der = der$2;
function DERDecoder$1(ae) {
  this.enc = "der", this.name = ae.name, this.entity = ae, this.tree = new DERNode(), this.tree._init(ae.body);
}
var der_1 = DERDecoder$1;
DERDecoder$1.prototype.decode = function(ie, se) {
  return DecoderBuffer.isDecoderBuffer(ie) || (ie = new DecoderBuffer(ie, se)), this.tree._decode(ie, se);
};
function DERNode(ae) {
  Node.call(this, "der", ae);
}
inherits$3(DERNode, Node);
DERNode.prototype._peekTag = function(ie, se, fe) {
  if (ie.isEmpty())
    return !1;
  const ue = ie.save(), ce = derDecodeTag(ie, 'Failed to peek tag: "' + se + '"');
  return ie.isError(ce) ? ce : (ie.restore(ue), ce.tag === se || ce.tagStr === se || ce.tagStr + "of" === se || fe);
};
DERNode.prototype._decodeTag = function(ie, se, fe) {
  const ue = derDecodeTag(
    ie,
    'Failed to decode tag of "' + se + '"'
  );
  if (ie.isError(ue))
    return ue;
  let ce = derDecodeLen(
    ie,
    ue.primitive,
    'Failed to get length of "' + se + '"'
  );
  if (ie.isError(ce))
    return ce;
  if (!fe && ue.tag !== se && ue.tagStr !== se && ue.tagStr + "of" !== se)
    return ie.error('Failed to match tag: "' + se + '"');
  if (ue.primitive || ce !== null)
    return ie.skip(ce, 'Failed to match body of: "' + se + '"');
  const de = ie.save(), me = this._skipUntilEnd(
    ie,
    'Failed to skip indefinite length body: "' + this.tag + '"'
  );
  return ie.isError(me) ? me : (ce = ie.offset - de.offset, ie.restore(de), ie.skip(ce, 'Failed to match body of: "' + se + '"'));
};
DERNode.prototype._skipUntilEnd = function(ie, se) {
  for (; ; ) {
    const fe = derDecodeTag(ie, se);
    if (ie.isError(fe))
      return fe;
    const ue = derDecodeLen(ie, fe.primitive, se);
    if (ie.isError(ue))
      return ue;
    let ce;
    if (fe.primitive || ue !== null ? ce = ie.skip(ue) : ce = this._skipUntilEnd(ie, se), ie.isError(ce))
      return ce;
    if (fe.tagStr === "end")
      break;
  }
};
DERNode.prototype._decodeList = function(ie, se, fe, ue) {
  const ce = [];
  for (; !ie.isEmpty(); ) {
    const de = this._peekTag(ie, "end");
    if (ie.isError(de))
      return de;
    const me = fe.decode(ie, "der", ue);
    if (ie.isError(me) && de)
      break;
    ce.push(me);
  }
  return ce;
};
DERNode.prototype._decodeStr = function(ie, se) {
  if (se === "bitstr") {
    const fe = ie.readUInt8();
    return ie.isError(fe) ? fe : { unused: fe, data: ie.raw() };
  } else if (se === "bmpstr") {
    const fe = ie.raw();
    if (fe.length % 2 === 1)
      return ie.error("Decoding of string type: bmpstr length mismatch");
    let ue = "";
    for (let ce = 0; ce < fe.length / 2; ce++)
      ue += String.fromCharCode(fe.readUInt16BE(ce * 2));
    return ue;
  } else if (se === "numstr") {
    const fe = ie.raw().toString("ascii");
    return this._isNumstr(fe) ? fe : ie.error("Decoding of string type: numstr unsupported characters");
  } else {
    if (se === "octstr")
      return ie.raw();
    if (se === "objDesc")
      return ie.raw();
    if (se === "printstr") {
      const fe = ie.raw().toString("ascii");
      return this._isPrintstr(fe) ? fe : ie.error("Decoding of string type: printstr unsupported characters");
    } else
      return /str$/.test(se) ? ie.raw().toString() : ie.error("Decoding of string type: " + se + " unsupported");
  }
};
DERNode.prototype._decodeObjid = function(ie, se, fe) {
  let ue;
  const ce = [];
  let de = 0, me = 0;
  for (; !ie.isEmpty(); )
    me = ie.readUInt8(), de <<= 7, de |= me & 127, me & 128 || (ce.push(de), de = 0);
  me & 128 && ce.push(de);
  const we = ce[0] / 40 | 0, Ee = ce[0] % 40;
  if (fe ? ue = ce : ue = [we, Ee].concat(ce.slice(1)), se) {
    let Se = se[ue.join(" ")];
    Se === void 0 && (Se = se[ue.join(".")]), Se !== void 0 && (ue = Se);
  }
  return ue;
};
DERNode.prototype._decodeTime = function(ie, se) {
  const fe = ie.raw().toString();
  let ue, ce, de, me, we, Ee;
  if (se === "gentime")
    ue = fe.slice(0, 4) | 0, ce = fe.slice(4, 6) | 0, de = fe.slice(6, 8) | 0, me = fe.slice(8, 10) | 0, we = fe.slice(10, 12) | 0, Ee = fe.slice(12, 14) | 0;
  else if (se === "utctime")
    ue = fe.slice(0, 2) | 0, ce = fe.slice(2, 4) | 0, de = fe.slice(4, 6) | 0, me = fe.slice(6, 8) | 0, we = fe.slice(8, 10) | 0, Ee = fe.slice(10, 12) | 0, ue < 70 ? ue = 2e3 + ue : ue = 1900 + ue;
  else
    return ie.error("Decoding " + se + " time is not supported yet");
  return Date.UTC(ue, ce - 1, de, me, we, Ee, 0);
};
DERNode.prototype._decodeNull = function() {
  return null;
};
DERNode.prototype._decodeBool = function(ie) {
  const se = ie.readUInt8();
  return ie.isError(se) ? se : se !== 0;
};
DERNode.prototype._decodeInt = function(ie, se) {
  const fe = ie.raw();
  let ue = new bignum(fe);
  return se && (ue = se[ue.toString(10)] || ue), ue;
};
DERNode.prototype._use = function(ie, se) {
  return typeof ie == "function" && (ie = ie(se)), ie._getDecoder("der").tree;
};
function derDecodeTag(ae, ie) {
  let se = ae.readUInt8(ie);
  if (ae.isError(se))
    return se;
  const fe = der.tagClass[se >> 6], ue = (se & 32) === 0;
  if ((se & 31) === 31) {
    let de = se;
    for (se = 0; (de & 128) === 128; ) {
      if (de = ae.readUInt8(ie), ae.isError(de))
        return de;
      se <<= 7, se |= de & 127;
    }
  } else
    se &= 31;
  const ce = der.tag[se];
  return {
    cls: fe,
    primitive: ue,
    tag: se,
    tagStr: ce
  };
}
function derDecodeLen(ae, ie, se) {
  let fe = ae.readUInt8(se);
  if (ae.isError(fe))
    return fe;
  if (!ie && fe === 128)
    return null;
  if (!(fe & 128))
    return fe;
  const ue = fe & 127;
  if (ue > 4)
    return ae.error("length octect is too long");
  fe = 0;
  for (let ce = 0; ce < ue; ce++) {
    fe <<= 8;
    const de = ae.readUInt8(se);
    if (ae.isError(de))
      return de;
    fe |= de;
  }
  return fe;
}
const inherits$2 = inherits_browserExports, Buffer$7 = safer_1.Buffer, DERDecoder = der_1;
function PEMDecoder(ae) {
  DERDecoder.call(this, ae), this.enc = "pem";
}
inherits$2(PEMDecoder, DERDecoder);
var pem = PEMDecoder;
PEMDecoder.prototype.decode = function(ie, se) {
  const fe = ie.toString().split(/[\r\n]+/g), ue = se.label.toUpperCase(), ce = /^-----(BEGIN|END) ([^-]+)-----$/;
  let de = -1, me = -1;
  for (let Se = 0; Se < fe.length; Se++) {
    const Be = fe[Se].match(ce);
    if (Be !== null && Be[2] === ue)
      if (de === -1) {
        if (Be[1] !== "BEGIN")
          break;
        de = Se;
      } else {
        if (Be[1] !== "END")
          break;
        me = Se;
        break;
      }
  }
  if (de === -1 || me === -1)
    throw new Error("PEM section not found for: " + ue);
  const we = fe.slice(de + 1, me).join("");
  we.replace(/[^a-z0-9+/=]+/gi, "");
  const Ee = Buffer$7.from(we, "base64");
  return DERDecoder.prototype.decode.call(this, Ee, se);
};
(function(ae) {
  const ie = ae;
  ie.der = der_1, ie.pem = pem;
})(decoders);
(function(ae) {
  const ie = encoders, se = decoders, fe = inherits_browserExports, ue = ae;
  ue.define = function(me, we) {
    return new ce(me, we);
  };
  function ce(de, me) {
    this.name = de, this.body = me, this.decoders = {}, this.encoders = {};
  }
  ce.prototype._createNamed = function(me) {
    const we = this.name;
    function Ee(Se) {
      this._initNamed(Se, we);
    }
    return fe(Ee, me), Ee.prototype._initNamed = function(Be, Ce) {
      me.call(this, Be, Ce);
    }, new Ee(this);
  }, ce.prototype._getDecoder = function(me) {
    return me = me || "der", this.decoders.hasOwnProperty(me) || (this.decoders[me] = this._createNamed(se[me])), this.decoders[me];
  }, ce.prototype.decode = function(me, we, Ee) {
    return this._getDecoder(we).decode(me, Ee);
  }, ce.prototype._getEncoder = function(me) {
    return me = me || "der", this.encoders.hasOwnProperty(me) || (this.encoders[me] = this._createNamed(ie[me])), this.encoders[me];
  }, ce.prototype.encode = function(me, we, Ee) {
    return this._getEncoder(we).encode(me, Ee);
  };
})(api$2);
const api$1 = /* @__PURE__ */ getDefaultExportFromCjs$2(api$2);
var base$5 = {};
(function(ae) {
  const ie = ae;
  ie.Reporter = reporter.Reporter, ie.DecoderBuffer = buffer.DecoderBuffer, ie.EncoderBuffer = buffer.EncoderBuffer, ie.Node = node;
})(base$5);
var constants$2 = {};
(function(ae) {
  const ie = ae;
  ie._reverse = function(fe) {
    const ue = {};
    return Object.keys(fe).forEach(function(ce) {
      (ce | 0) == ce && (ce = ce | 0);
      const de = fe[ce];
      ue[de] = ce;
    }), ue;
  }, ie.der = der$2;
})(constants$2);
(function(ae) {
  const ie = ae;
  ie.bignum = bnExports$2, ie.define = api$2.define, ie.base = base$5, ie.constants = constants$2, ie.decoders = decoders, ie.encoders = encoders;
})(asn1$2);
var asn = asn1$2, Time = asn.define("Time", function() {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  });
}), AttributeTypeValue = asn.define("AttributeTypeValue", function() {
  this.seq().obj(
    this.key("type").objid(),
    this.key("value").any()
  );
}), AlgorithmIdentifier$2 = asn.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("parameters").optional(),
    this.key("curve").objid().optional()
  );
}), SubjectPublicKeyInfo = asn.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(AlgorithmIdentifier$2),
    this.key("subjectPublicKey").bitstr()
  );
}), RelativeDistinguishedName = asn.define("RelativeDistinguishedName", function() {
  this.setof(AttributeTypeValue);
}), RDNSequence = asn.define("RDNSequence", function() {
  this.seqof(RelativeDistinguishedName);
}), Name = asn.define("Name", function() {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  });
}), Validity = asn.define("Validity", function() {
  this.seq().obj(
    this.key("notBefore").use(Time),
    this.key("notAfter").use(Time)
  );
}), Extension = asn.define("Extension", function() {
  this.seq().obj(
    this.key("extnID").objid(),
    this.key("critical").bool().def(!1),
    this.key("extnValue").octstr()
  );
}), TBSCertificate = asn.define("TBSCertificate", function() {
  this.seq().obj(
    this.key("version").explicit(0).int().optional(),
    this.key("serialNumber").int(),
    this.key("signature").use(AlgorithmIdentifier$2),
    this.key("issuer").use(Name),
    this.key("validity").use(Validity),
    this.key("subject").use(Name),
    this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo),
    this.key("issuerUniqueID").implicit(1).bitstr().optional(),
    this.key("subjectUniqueID").implicit(2).bitstr().optional(),
    this.key("extensions").explicit(3).seqof(Extension).optional()
  );
}), X509Certificate = asn.define("X509Certificate", function() {
  this.seq().obj(
    this.key("tbsCertificate").use(TBSCertificate),
    this.key("signatureAlgorithm").use(AlgorithmIdentifier$2),
    this.key("signatureValue").bitstr()
  );
}), certificate = X509Certificate, asn1$1 = asn1$2;
asn1$3.certificate = certificate;
var RSAPrivateKey$1 = asn1$1.define("RSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("modulus").int(),
    this.key("publicExponent").int(),
    this.key("privateExponent").int(),
    this.key("prime1").int(),
    this.key("prime2").int(),
    this.key("exponent1").int(),
    this.key("exponent2").int(),
    this.key("coefficient").int()
  );
});
asn1$3.RSAPrivateKey = RSAPrivateKey$1;
var RSAPublicKey$1 = asn1$1.define("RSAPublicKey", function() {
  this.seq().obj(
    this.key("modulus").int(),
    this.key("publicExponent").int()
  );
});
asn1$3.RSAPublicKey = RSAPublicKey$1;
var PublicKey$3 = asn1$1.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(AlgorithmIdentifier$1),
    this.key("subjectPublicKey").bitstr()
  );
});
asn1$3.PublicKey = PublicKey$3;
var AlgorithmIdentifier$1 = asn1$1.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("none").null_().optional(),
    this.key("curve").objid().optional(),
    this.key("params").seq().obj(
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int()
    ).optional()
  );
}), PrivateKeyInfo = asn1$1.define("PrivateKeyInfo", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("algorithm").use(AlgorithmIdentifier$1),
    this.key("subjectPrivateKey").octstr()
  );
});
asn1$3.PrivateKey = PrivateKeyInfo;
var EncryptedPrivateKeyInfo = asn1$1.define("EncryptedPrivateKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").seq().obj(
      this.key("id").objid(),
      this.key("decrypt").seq().obj(
        this.key("kde").seq().obj(
          this.key("id").objid(),
          this.key("kdeparams").seq().obj(
            this.key("salt").octstr(),
            this.key("iters").int()
          )
        ),
        this.key("cipher").seq().obj(
          this.key("algo").objid(),
          this.key("iv").octstr()
        )
      )
    ),
    this.key("subjectPrivateKey").octstr()
  );
});
asn1$3.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
var DSAPrivateKey = asn1$1.define("DSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("p").int(),
    this.key("q").int(),
    this.key("g").int(),
    this.key("pub_key").int(),
    this.key("priv_key").int()
  );
});
asn1$3.DSAPrivateKey = DSAPrivateKey;
asn1$3.DSAparam = asn1$1.define("DSAparam", function() {
  this.int();
});
var ECPrivateKey = asn1$1.define("ECPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("privateKey").octstr(),
    this.key("parameters").optional().explicit(0).use(ECParameters),
    this.key("publicKey").optional().explicit(1).bitstr()
  );
});
asn1$3.ECPrivateKey = ECPrivateKey;
var ECParameters = asn1$1.define("ECParameters", function() {
  this.choice({
    namedCurve: this.objid()
  });
});
asn1$3.signature = asn1$1.define("signature", function() {
  this.seq().obj(
    this.key("r").int(),
    this.key("s").int()
  );
});
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, evp = evp_bytestokey, ciphers$1 = browser$7, Buffer$6 = safeBufferExports.Buffer, fixProc$1 = function(ae, ie) {
  var se = ae.toString(), fe = se.match(findProc), ue;
  if (fe) {
    var de = "aes" + fe[1], me = Buffer$6.from(fe[2], "hex"), we = Buffer$6.from(fe[3].replace(/[\r\n]/g, ""), "base64"), Ee = evp(ie, me.slice(0, 8), parseInt(fe[1], 10)).key, Se = [], Be = ciphers$1.createDecipheriv(de, Ee, me);
    Se.push(Be.update(we)), Se.push(Be.final()), ue = Buffer$6.concat(Se);
  } else {
    var ce = se.match(fullRegex);
    ue = Buffer$6.from(ce[2].replace(/[\r\n]/g, ""), "base64");
  }
  var Ce = se.match(startRegex)[1];
  return {
    tag: Ce,
    data: ue
  };
}, asn1 = asn1$3, aesid = require$$1, fixProc = fixProc$1, ciphers = browser$7, compat = browser$9, Buffer$5 = safeBufferExports.Buffer, parseAsn1 = parseKeys$2;
function parseKeys$2(ae) {
  var ie;
  typeof ae == "object" && !Buffer$5.isBuffer(ae) && (ie = ae.passphrase, ae = ae.key), typeof ae == "string" && (ae = Buffer$5.from(ae));
  var se = fixProc(ae, ie), fe = se.tag, ue = se.data, ce, de;
  switch (fe) {
    case "CERTIFICATE":
      de = asn1.certificate.decode(ue, "der").tbsCertificate.subjectPublicKeyInfo;
    case "PUBLIC KEY":
      switch (de || (de = asn1.PublicKey.decode(ue, "der")), ce = de.algorithm.algorithm.join("."), ce) {
        case "1.2.840.113549.1.1.1":
          return asn1.RSAPublicKey.decode(de.subjectPublicKey.data, "der");
        case "1.2.840.10045.2.1":
          return de.subjectPrivateKey = de.subjectPublicKey, {
            type: "ec",
            data: de
          };
        case "1.2.840.10040.4.1":
          return de.algorithm.params.pub_key = asn1.DSAparam.decode(de.subjectPublicKey.data, "der"), {
            type: "dsa",
            data: de.algorithm.params
          };
        default:
          throw new Error("unknown key id " + ce);
      }
    case "ENCRYPTED PRIVATE KEY":
      ue = asn1.EncryptedPrivateKey.decode(ue, "der"), ue = decrypt$2(ue, ie);
    case "PRIVATE KEY":
      switch (de = asn1.PrivateKey.decode(ue, "der"), ce = de.algorithm.algorithm.join("."), ce) {
        case "1.2.840.113549.1.1.1":
          return asn1.RSAPrivateKey.decode(de.subjectPrivateKey, "der");
        case "1.2.840.10045.2.1":
          return {
            curve: de.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(de.subjectPrivateKey, "der").privateKey
          };
        case "1.2.840.10040.4.1":
          return de.algorithm.params.priv_key = asn1.DSAparam.decode(de.subjectPrivateKey, "der"), {
            type: "dsa",
            params: de.algorithm.params
          };
        default:
          throw new Error("unknown key id " + ce);
      }
    case "RSA PUBLIC KEY":
      return asn1.RSAPublicKey.decode(ue, "der");
    case "RSA PRIVATE KEY":
      return asn1.RSAPrivateKey.decode(ue, "der");
    case "DSA PRIVATE KEY":
      return {
        type: "dsa",
        params: asn1.DSAPrivateKey.decode(ue, "der")
      };
    case "EC PRIVATE KEY":
      return ue = asn1.ECPrivateKey.decode(ue, "der"), {
        curve: ue.parameters.value,
        privateKey: ue.privateKey
      };
    default:
      throw new Error("unknown key type " + fe);
  }
}
parseKeys$2.signature = asn1.signature;
function decrypt$2(ae, ie) {
  var se = ae.algorithm.decrypt.kde.kdeparams.salt, fe = parseInt(ae.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), ue = aesid[ae.algorithm.decrypt.cipher.algo.join(".")], ce = ae.algorithm.decrypt.cipher.iv, de = ae.subjectPrivateKey, me = parseInt(ue.split("-")[1], 10) / 8, we = compat.pbkdf2Sync(ie, se, fe, me, "sha1"), Ee = ciphers.createDecipheriv(ue, we, ce), Se = [];
  return Se.push(Ee.update(de)), Se.push(Ee.final()), Buffer$5.concat(Se);
}
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign)
    return sign$4.exports;
  hasRequiredSign = 1;
  var ae = safeBufferExports.Buffer, ie = browser$a, se = browserifyRsa, fe = requireElliptic().ec, ue = bnExports$4, ce = parseAsn1, de = require$$4, me = 1;
  function we(He, De, Ge, Ye, st) {
    var at = ce(De);
    if (at.curve) {
      if (Ye !== "ecdsa" && Ye !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return Ee(He, at);
    } else if (at.type === "dsa") {
      if (Ye !== "dsa")
        throw new Error("wrong private key type");
      return Se(He, at, Ge);
    }
    if (Ye !== "rsa" && Ye !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (De.padding !== void 0 && De.padding !== me)
      throw new Error("illegal or unsupported padding mode");
    He = ae.concat([st, He]);
    for (var mt = at.modulus.byteLength(), qe = [0, 1]; He.length + qe.length + 1 < mt; )
      qe.push(255);
    qe.push(0);
    for (var ze = -1; ++ze < He.length; )
      qe.push(He[ze]);
    var ot = se(qe, at);
    return ot;
  }
  function Ee(He, De) {
    var Ge = de[De.curve.join(".")];
    if (!Ge)
      throw new Error("unknown curve " + De.curve.join("."));
    var Ye = new fe(Ge), st = Ye.keyFromPrivate(De.privateKey), at = st.sign(He);
    return ae.from(at.toDER());
  }
  function Se(He, De, Ge) {
    for (var Ye = De.params.priv_key, st = De.params.p, at = De.params.q, mt = De.params.g, qe = new ue(0), ze, ot = Ie(He, at).mod(at), $e = !1, le = Ce(Ye, at, He, Ge); $e === !1; )
      ze = Ne(at, le, Ge), qe = ke(mt, ze, st, at), $e = ze.invm(at).imul(ot.add(Ye.mul(qe))).mod(at), $e.cmpn(0) === 0 && ($e = !1, qe = new ue(0));
    return Be(qe, $e);
  }
  function Be(He, De) {
    He = He.toArray(), De = De.toArray(), He[0] & 128 && (He = [0].concat(He)), De[0] & 128 && (De = [0].concat(De));
    var Ge = He.length + De.length + 4, Ye = [
      48,
      Ge,
      2,
      He.length
    ];
    return Ye = Ye.concat(He, [2, De.length], De), ae.from(Ye);
  }
  function Ce(He, De, Ge, Ye) {
    if (He = ae.from(He.toArray()), He.length < De.byteLength()) {
      var st = ae.alloc(De.byteLength() - He.length);
      He = ae.concat([st, He]);
    }
    var at = Ge.length, mt = Pe(Ge, De), qe = ae.alloc(at);
    qe.fill(1);
    var ze = ae.alloc(at);
    return ze = ie(Ye, ze).update(qe).update(ae.from([0])).update(He).update(mt).digest(), qe = ie(Ye, ze).update(qe).digest(), ze = ie(Ye, ze).update(qe).update(ae.from([1])).update(He).update(mt).digest(), qe = ie(Ye, ze).update(qe).digest(), { k: ze, v: qe };
  }
  function Ie(He, De) {
    var Ge = new ue(He), Ye = (He.length << 3) - De.bitLength();
    return Ye > 0 && Ge.ishrn(Ye), Ge;
  }
  function Pe(He, De) {
    He = Ie(He, De), He = He.mod(De);
    var Ge = ae.from(He.toArray());
    if (Ge.length < De.byteLength()) {
      var Ye = ae.alloc(De.byteLength() - Ge.length);
      Ge = ae.concat([Ye, Ge]);
    }
    return Ge;
  }
  function Ne(He, De, Ge) {
    var Ye, st;
    do {
      for (Ye = ae.alloc(0); Ye.length * 8 < He.bitLength(); )
        De.v = ie(Ge, De.k).update(De.v).digest(), Ye = ae.concat([Ye, De.v]);
      st = Ie(Ye, He), De.k = ie(Ge, De.k).update(De.v).update(ae.from([0])).digest(), De.v = ie(Ge, De.k).update(De.v).digest();
    } while (st.cmp(He) !== -1);
    return st;
  }
  function ke(He, De, Ge, Ye) {
    return He.toRed(ue.mont(Ge)).redPow(De).fromRed().mod(Ye);
  }
  return sign$4.exports = we, sign$4.exports.getKey = Ce, sign$4.exports.makeKey = Ne, sign$4.exports;
}
var verify_1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify)
    return verify_1;
  hasRequiredVerify = 1;
  var ae = safeBufferExports.Buffer, ie = bnExports$4, se = requireElliptic().ec, fe = parseAsn1, ue = require$$4;
  function ce(Ee, Se, Be, Ce, Ie) {
    var Pe = fe(Be);
    if (Pe.type === "ec") {
      if (Ce !== "ecdsa" && Ce !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return de(Ee, Se, Pe);
    } else if (Pe.type === "dsa") {
      if (Ce !== "dsa")
        throw new Error("wrong public key type");
      return me(Ee, Se, Pe);
    }
    if (Ce !== "rsa" && Ce !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    Se = ae.concat([Ie, Se]);
    for (var Ne = Pe.modulus.byteLength(), ke = [1], He = 0; Se.length + ke.length + 2 < Ne; )
      ke.push(255), He += 1;
    ke.push(0);
    for (var De = -1; ++De < Se.length; )
      ke.push(Se[De]);
    ke = ae.from(ke);
    var Ge = ie.mont(Pe.modulus);
    Ee = new ie(Ee).toRed(Ge), Ee = Ee.redPow(new ie(Pe.publicExponent)), Ee = ae.from(Ee.fromRed().toArray());
    var Ye = He < 8 ? 1 : 0;
    for (Ne = Math.min(Ee.length, ke.length), Ee.length !== ke.length && (Ye = 1), De = -1; ++De < Ne; )
      Ye |= Ee[De] ^ ke[De];
    return Ye === 0;
  }
  function de(Ee, Se, Be) {
    var Ce = ue[Be.data.algorithm.curve.join(".")];
    if (!Ce)
      throw new Error("unknown curve " + Be.data.algorithm.curve.join("."));
    var Ie = new se(Ce), Pe = Be.data.subjectPrivateKey.data;
    return Ie.verify(Se, Ee, Pe);
  }
  function me(Ee, Se, Be) {
    var Ce = Be.data.p, Ie = Be.data.q, Pe = Be.data.g, Ne = Be.data.pub_key, ke = fe.signature.decode(Ee, "der"), He = ke.s, De = ke.r;
    we(He, Ie), we(De, Ie);
    var Ge = ie.mont(Ce), Ye = He.invm(Ie), st = Pe.toRed(Ge).redPow(new ie(Se).mul(Ye).mod(Ie)).fromRed().mul(Ne.toRed(Ge).redPow(De.mul(Ye).mod(Ie)).fromRed()).mod(Ce).mod(Ie);
    return st.cmp(De) === 0;
  }
  function we(Ee, Se) {
    if (Ee.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (Ee.cmp(Se) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1 = ce, verify_1;
}
var browser$5, hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1)
    return browser$5;
  hasRequiredBrowser$1 = 1;
  var ae = safeBufferExports.Buffer, ie = browser$b, se = readableBrowserExports, fe = inherits_browserExports, ue = requireSign(), ce = requireVerify(), de = require$$6;
  Object.keys(de).forEach(function(Be) {
    de[Be].id = ae.from(de[Be].id, "hex"), de[Be.toLowerCase()] = de[Be];
  });
  function me(Be) {
    se.Writable.call(this);
    var Ce = de[Be];
    if (!Ce)
      throw new Error("Unknown message digest");
    this._hashType = Ce.hash, this._hash = ie(Ce.hash), this._tag = Ce.id, this._signType = Ce.sign;
  }
  fe(me, se.Writable), me.prototype._write = function(Ce, Ie, Pe) {
    this._hash.update(Ce), Pe();
  }, me.prototype.update = function(Ce, Ie) {
    return this._hash.update(typeof Ce == "string" ? ae.from(Ce, Ie) : Ce), this;
  }, me.prototype.sign = function(Ce, Ie) {
    this.end();
    var Pe = this._hash.digest(), Ne = ue(Pe, Ce, this._hashType, this._signType, this._tag);
    return Ie ? Ne.toString(Ie) : Ne;
  };
  function we(Be) {
    se.Writable.call(this);
    var Ce = de[Be];
    if (!Ce)
      throw new Error("Unknown message digest");
    this._hash = ie(Ce.hash), this._tag = Ce.id, this._signType = Ce.sign;
  }
  fe(we, se.Writable), we.prototype._write = function(Ce, Ie, Pe) {
    this._hash.update(Ce), Pe();
  }, we.prototype.update = function(Ce, Ie) {
    return this._hash.update(typeof Ce == "string" ? ae.from(Ce, Ie) : Ce), this;
  }, we.prototype.verify = function(Ce, Ie, Pe) {
    var Ne = typeof Ie == "string" ? ae.from(Ie, Pe) : Ie;
    this.end();
    var ke = this._hash.digest();
    return ce(Ne, ke, Ce, this._signType, this._tag);
  };
  function Ee(Be) {
    return new me(Be);
  }
  function Se(Be) {
    return new we(Be);
  }
  return browser$5 = {
    Sign: Ee,
    Verify: Se,
    createSign: Ee,
    createVerify: Se
  }, browser$5;
}
var bn$1 = { exports: {} };
bn$1.exports;
(function(ae) {
  (function(ie, se) {
    function fe($e, le) {
      if (!$e)
        throw new Error(le || "Assertion failed");
    }
    function ue($e, le) {
      $e.super_ = le;
      var pe = function() {
      };
      pe.prototype = le.prototype, $e.prototype = new pe(), $e.prototype.constructor = $e;
    }
    function ce($e, le, pe) {
      if (ce.isBN($e))
        return $e;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, $e !== null && ((le === "le" || le === "be") && (pe = le, le = 10), this._init($e || 0, le || 10, pe || "be"));
    }
    typeof ie == "object" ? ie.exports = ce : se.BN = ce, ce.BN = ce, ce.wordSize = 26;
    var de;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? de = window.Buffer : de = require$$0$2.Buffer;
    } catch {
    }
    ce.isBN = function(le) {
      return le instanceof ce ? !0 : le !== null && typeof le == "object" && le.constructor.wordSize === ce.wordSize && Array.isArray(le.words);
    }, ce.max = function(le, pe) {
      return le.cmp(pe) > 0 ? le : pe;
    }, ce.min = function(le, pe) {
      return le.cmp(pe) < 0 ? le : pe;
    }, ce.prototype._init = function(le, pe, ge) {
      if (typeof le == "number")
        return this._initNumber(le, pe, ge);
      if (typeof le == "object")
        return this._initArray(le, pe, ge);
      pe === "hex" && (pe = 16), fe(pe === (pe | 0) && pe >= 2 && pe <= 36), le = le.toString().replace(/\s+/g, "");
      var ye = 0;
      le[0] === "-" && (ye++, this.negative = 1), ye < le.length && (pe === 16 ? this._parseHex(le, ye, ge) : (this._parseBase(le, pe, ye), ge === "le" && this._initArray(this.toArray(), pe, ge)));
    }, ce.prototype._initNumber = function(le, pe, ge) {
      le < 0 && (this.negative = 1, le = -le), le < 67108864 ? (this.words = [le & 67108863], this.length = 1) : le < 4503599627370496 ? (this.words = [
        le & 67108863,
        le / 67108864 & 67108863
      ], this.length = 2) : (fe(le < 9007199254740992), this.words = [
        le & 67108863,
        le / 67108864 & 67108863,
        1
      ], this.length = 3), ge === "le" && this._initArray(this.toArray(), pe, ge);
    }, ce.prototype._initArray = function(le, pe, ge) {
      if (fe(typeof le.length == "number"), le.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(le.length / 3), this.words = new Array(this.length);
      for (var ye = 0; ye < this.length; ye++)
        this.words[ye] = 0;
      var xe, _e, Ae = 0;
      if (ge === "be")
        for (ye = le.length - 1, xe = 0; ye >= 0; ye -= 3)
          _e = le[ye] | le[ye - 1] << 8 | le[ye - 2] << 16, this.words[xe] |= _e << Ae & 67108863, this.words[xe + 1] = _e >>> 26 - Ae & 67108863, Ae += 24, Ae >= 26 && (Ae -= 26, xe++);
      else if (ge === "le")
        for (ye = 0, xe = 0; ye < le.length; ye += 3)
          _e = le[ye] | le[ye + 1] << 8 | le[ye + 2] << 16, this.words[xe] |= _e << Ae & 67108863, this.words[xe + 1] = _e >>> 26 - Ae & 67108863, Ae += 24, Ae >= 26 && (Ae -= 26, xe++);
      return this.strip();
    };
    function me($e, le) {
      var pe = $e.charCodeAt(le);
      return pe >= 65 && pe <= 70 ? pe - 55 : pe >= 97 && pe <= 102 ? pe - 87 : pe - 48 & 15;
    }
    function we($e, le, pe) {
      var ge = me($e, pe);
      return pe - 1 >= le && (ge |= me($e, pe - 1) << 4), ge;
    }
    ce.prototype._parseHex = function(le, pe, ge) {
      this.length = Math.ceil((le.length - pe) / 6), this.words = new Array(this.length);
      for (var ye = 0; ye < this.length; ye++)
        this.words[ye] = 0;
      var xe = 0, _e = 0, Ae;
      if (ge === "be")
        for (ye = le.length - 1; ye >= pe; ye -= 2)
          Ae = we(le, pe, ye) << xe, this.words[_e] |= Ae & 67108863, xe >= 18 ? (xe -= 18, _e += 1, this.words[_e] |= Ae >>> 26) : xe += 8;
      else {
        var ve = le.length - pe;
        for (ye = ve % 2 === 0 ? pe + 1 : pe; ye < le.length; ye += 2)
          Ae = we(le, pe, ye) << xe, this.words[_e] |= Ae & 67108863, xe >= 18 ? (xe -= 18, _e += 1, this.words[_e] |= Ae >>> 26) : xe += 8;
      }
      this.strip();
    };
    function Ee($e, le, pe, ge) {
      for (var ye = 0, xe = Math.min($e.length, pe), _e = le; _e < xe; _e++) {
        var Ae = $e.charCodeAt(_e) - 48;
        ye *= ge, Ae >= 49 ? ye += Ae - 49 + 10 : Ae >= 17 ? ye += Ae - 17 + 10 : ye += Ae;
      }
      return ye;
    }
    ce.prototype._parseBase = function(le, pe, ge) {
      this.words = [0], this.length = 1;
      for (var ye = 0, xe = 1; xe <= 67108863; xe *= pe)
        ye++;
      ye--, xe = xe / pe | 0;
      for (var _e = le.length - ge, Ae = _e % ye, ve = Math.min(_e, _e - Ae) + ge, he = 0, be = ge; be < ve; be += ye)
        he = Ee(le, be, be + ye, pe), this.imuln(xe), this.words[0] + he < 67108864 ? this.words[0] += he : this._iaddn(he);
      if (Ae !== 0) {
        var Me = 1;
        for (he = Ee(le, be, le.length, pe), be = 0; be < Ae; be++)
          Me *= pe;
        this.imuln(Me), this.words[0] + he < 67108864 ? this.words[0] += he : this._iaddn(he);
      }
      this.strip();
    }, ce.prototype.copy = function(le) {
      le.words = new Array(this.length);
      for (var pe = 0; pe < this.length; pe++)
        le.words[pe] = this.words[pe];
      le.length = this.length, le.negative = this.negative, le.red = this.red;
    }, ce.prototype.clone = function() {
      var le = new ce(null);
      return this.copy(le), le;
    }, ce.prototype._expand = function(le) {
      for (; this.length < le; )
        this.words[this.length++] = 0;
      return this;
    }, ce.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, ce.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, ce.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var Se = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], Be = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], Ce = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    ce.prototype.toString = function(le, pe) {
      le = le || 10, pe = pe | 0 || 1;
      var ge;
      if (le === 16 || le === "hex") {
        ge = "";
        for (var ye = 0, xe = 0, _e = 0; _e < this.length; _e++) {
          var Ae = this.words[_e], ve = ((Ae << ye | xe) & 16777215).toString(16);
          xe = Ae >>> 24 - ye & 16777215, xe !== 0 || _e !== this.length - 1 ? ge = Se[6 - ve.length] + ve + ge : ge = ve + ge, ye += 2, ye >= 26 && (ye -= 26, _e--);
        }
        for (xe !== 0 && (ge = xe.toString(16) + ge); ge.length % pe !== 0; )
          ge = "0" + ge;
        return this.negative !== 0 && (ge = "-" + ge), ge;
      }
      if (le === (le | 0) && le >= 2 && le <= 36) {
        var he = Be[le], be = Ce[le];
        ge = "";
        var Me = this.clone();
        for (Me.negative = 0; !Me.isZero(); ) {
          var Re = Me.modn(be).toString(le);
          Me = Me.idivn(be), Me.isZero() ? ge = Re + ge : ge = Se[he - Re.length] + Re + ge;
        }
        for (this.isZero() && (ge = "0" + ge); ge.length % pe !== 0; )
          ge = "0" + ge;
        return this.negative !== 0 && (ge = "-" + ge), ge;
      }
      fe(!1, "Base should be between 2 and 36");
    }, ce.prototype.toNumber = function() {
      var le = this.words[0];
      return this.length === 2 ? le += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? le += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && fe(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -le : le;
    }, ce.prototype.toJSON = function() {
      return this.toString(16);
    }, ce.prototype.toBuffer = function(le, pe) {
      return fe(typeof de < "u"), this.toArrayLike(de, le, pe);
    }, ce.prototype.toArray = function(le, pe) {
      return this.toArrayLike(Array, le, pe);
    }, ce.prototype.toArrayLike = function(le, pe, ge) {
      var ye = this.byteLength(), xe = ge || Math.max(1, ye);
      fe(ye <= xe, "byte array longer than desired length"), fe(xe > 0, "Requested array length <= 0"), this.strip();
      var _e = pe === "le", Ae = new le(xe), ve, he, be = this.clone();
      if (_e) {
        for (he = 0; !be.isZero(); he++)
          ve = be.andln(255), be.iushrn(8), Ae[he] = ve;
        for (; he < xe; he++)
          Ae[he] = 0;
      } else {
        for (he = 0; he < xe - ye; he++)
          Ae[he] = 0;
        for (he = 0; !be.isZero(); he++)
          ve = be.andln(255), be.iushrn(8), Ae[xe - he - 1] = ve;
      }
      return Ae;
    }, Math.clz32 ? ce.prototype._countBits = function(le) {
      return 32 - Math.clz32(le);
    } : ce.prototype._countBits = function(le) {
      var pe = le, ge = 0;
      return pe >= 4096 && (ge += 13, pe >>>= 13), pe >= 64 && (ge += 7, pe >>>= 7), pe >= 8 && (ge += 4, pe >>>= 4), pe >= 2 && (ge += 2, pe >>>= 2), ge + pe;
    }, ce.prototype._zeroBits = function(le) {
      if (le === 0)
        return 26;
      var pe = le, ge = 0;
      return pe & 8191 || (ge += 13, pe >>>= 13), pe & 127 || (ge += 7, pe >>>= 7), pe & 15 || (ge += 4, pe >>>= 4), pe & 3 || (ge += 2, pe >>>= 2), pe & 1 || ge++, ge;
    }, ce.prototype.bitLength = function() {
      var le = this.words[this.length - 1], pe = this._countBits(le);
      return (this.length - 1) * 26 + pe;
    };
    function Ie($e) {
      for (var le = new Array($e.bitLength()), pe = 0; pe < le.length; pe++) {
        var ge = pe / 26 | 0, ye = pe % 26;
        le[pe] = ($e.words[ge] & 1 << ye) >>> ye;
      }
      return le;
    }
    ce.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var le = 0, pe = 0; pe < this.length; pe++) {
        var ge = this._zeroBits(this.words[pe]);
        if (le += ge, ge !== 26)
          break;
      }
      return le;
    }, ce.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, ce.prototype.toTwos = function(le) {
      return this.negative !== 0 ? this.abs().inotn(le).iaddn(1) : this.clone();
    }, ce.prototype.fromTwos = function(le) {
      return this.testn(le - 1) ? this.notn(le).iaddn(1).ineg() : this.clone();
    }, ce.prototype.isNeg = function() {
      return this.negative !== 0;
    }, ce.prototype.neg = function() {
      return this.clone().ineg();
    }, ce.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, ce.prototype.iuor = function(le) {
      for (; this.length < le.length; )
        this.words[this.length++] = 0;
      for (var pe = 0; pe < le.length; pe++)
        this.words[pe] = this.words[pe] | le.words[pe];
      return this.strip();
    }, ce.prototype.ior = function(le) {
      return fe((this.negative | le.negative) === 0), this.iuor(le);
    }, ce.prototype.or = function(le) {
      return this.length > le.length ? this.clone().ior(le) : le.clone().ior(this);
    }, ce.prototype.uor = function(le) {
      return this.length > le.length ? this.clone().iuor(le) : le.clone().iuor(this);
    }, ce.prototype.iuand = function(le) {
      var pe;
      this.length > le.length ? pe = le : pe = this;
      for (var ge = 0; ge < pe.length; ge++)
        this.words[ge] = this.words[ge] & le.words[ge];
      return this.length = pe.length, this.strip();
    }, ce.prototype.iand = function(le) {
      return fe((this.negative | le.negative) === 0), this.iuand(le);
    }, ce.prototype.and = function(le) {
      return this.length > le.length ? this.clone().iand(le) : le.clone().iand(this);
    }, ce.prototype.uand = function(le) {
      return this.length > le.length ? this.clone().iuand(le) : le.clone().iuand(this);
    }, ce.prototype.iuxor = function(le) {
      var pe, ge;
      this.length > le.length ? (pe = this, ge = le) : (pe = le, ge = this);
      for (var ye = 0; ye < ge.length; ye++)
        this.words[ye] = pe.words[ye] ^ ge.words[ye];
      if (this !== pe)
        for (; ye < pe.length; ye++)
          this.words[ye] = pe.words[ye];
      return this.length = pe.length, this.strip();
    }, ce.prototype.ixor = function(le) {
      return fe((this.negative | le.negative) === 0), this.iuxor(le);
    }, ce.prototype.xor = function(le) {
      return this.length > le.length ? this.clone().ixor(le) : le.clone().ixor(this);
    }, ce.prototype.uxor = function(le) {
      return this.length > le.length ? this.clone().iuxor(le) : le.clone().iuxor(this);
    }, ce.prototype.inotn = function(le) {
      fe(typeof le == "number" && le >= 0);
      var pe = Math.ceil(le / 26) | 0, ge = le % 26;
      this._expand(pe), ge > 0 && pe--;
      for (var ye = 0; ye < pe; ye++)
        this.words[ye] = ~this.words[ye] & 67108863;
      return ge > 0 && (this.words[ye] = ~this.words[ye] & 67108863 >> 26 - ge), this.strip();
    }, ce.prototype.notn = function(le) {
      return this.clone().inotn(le);
    }, ce.prototype.setn = function(le, pe) {
      fe(typeof le == "number" && le >= 0);
      var ge = le / 26 | 0, ye = le % 26;
      return this._expand(ge + 1), pe ? this.words[ge] = this.words[ge] | 1 << ye : this.words[ge] = this.words[ge] & ~(1 << ye), this.strip();
    }, ce.prototype.iadd = function(le) {
      var pe;
      if (this.negative !== 0 && le.negative === 0)
        return this.negative = 0, pe = this.isub(le), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && le.negative !== 0)
        return le.negative = 0, pe = this.isub(le), le.negative = 1, pe._normSign();
      var ge, ye;
      this.length > le.length ? (ge = this, ye = le) : (ge = le, ye = this);
      for (var xe = 0, _e = 0; _e < ye.length; _e++)
        pe = (ge.words[_e] | 0) + (ye.words[_e] | 0) + xe, this.words[_e] = pe & 67108863, xe = pe >>> 26;
      for (; xe !== 0 && _e < ge.length; _e++)
        pe = (ge.words[_e] | 0) + xe, this.words[_e] = pe & 67108863, xe = pe >>> 26;
      if (this.length = ge.length, xe !== 0)
        this.words[this.length] = xe, this.length++;
      else if (ge !== this)
        for (; _e < ge.length; _e++)
          this.words[_e] = ge.words[_e];
      return this;
    }, ce.prototype.add = function(le) {
      var pe;
      return le.negative !== 0 && this.negative === 0 ? (le.negative = 0, pe = this.sub(le), le.negative ^= 1, pe) : le.negative === 0 && this.negative !== 0 ? (this.negative = 0, pe = le.sub(this), this.negative = 1, pe) : this.length > le.length ? this.clone().iadd(le) : le.clone().iadd(this);
    }, ce.prototype.isub = function(le) {
      if (le.negative !== 0) {
        le.negative = 0;
        var pe = this.iadd(le);
        return le.negative = 1, pe._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(le), this.negative = 1, this._normSign();
      var ge = this.cmp(le);
      if (ge === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var ye, xe;
      ge > 0 ? (ye = this, xe = le) : (ye = le, xe = this);
      for (var _e = 0, Ae = 0; Ae < xe.length; Ae++)
        pe = (ye.words[Ae] | 0) - (xe.words[Ae] | 0) + _e, _e = pe >> 26, this.words[Ae] = pe & 67108863;
      for (; _e !== 0 && Ae < ye.length; Ae++)
        pe = (ye.words[Ae] | 0) + _e, _e = pe >> 26, this.words[Ae] = pe & 67108863;
      if (_e === 0 && Ae < ye.length && ye !== this)
        for (; Ae < ye.length; Ae++)
          this.words[Ae] = ye.words[Ae];
      return this.length = Math.max(this.length, Ae), ye !== this && (this.negative = 1), this.strip();
    }, ce.prototype.sub = function(le) {
      return this.clone().isub(le);
    };
    function Pe($e, le, pe) {
      pe.negative = le.negative ^ $e.negative;
      var ge = $e.length + le.length | 0;
      pe.length = ge, ge = ge - 1 | 0;
      var ye = $e.words[0] | 0, xe = le.words[0] | 0, _e = ye * xe, Ae = _e & 67108863, ve = _e / 67108864 | 0;
      pe.words[0] = Ae;
      for (var he = 1; he < ge; he++) {
        for (var be = ve >>> 26, Me = ve & 67108863, Re = Math.min(he, le.length - 1), Oe = Math.max(0, he - $e.length + 1); Oe <= Re; Oe++) {
          var Te = he - Oe | 0;
          ye = $e.words[Te] | 0, xe = le.words[Oe] | 0, _e = ye * xe + Me, be += _e / 67108864 | 0, Me = _e & 67108863;
        }
        pe.words[he] = Me | 0, ve = be | 0;
      }
      return ve !== 0 ? pe.words[he] = ve | 0 : pe.length--, pe.strip();
    }
    var Ne = function(le, pe, ge) {
      var ye = le.words, xe = pe.words, _e = ge.words, Ae = 0, ve, he, be, Me = ye[0] | 0, Re = Me & 8191, Oe = Me >>> 13, Te = ye[1] | 0, Fe = Te & 8191, je = Te >>> 13, ct = ye[2] | 0, nt = ct & 8191, dt = ct >>> 13, it = ye[3] | 0, Je = it & 8191, gt = it >>> 13, Ht = ye[4] | 0, $t = Ht & 8191, Lt = Ht >>> 13, Tr = ye[5] | 0, Zt = Tr & 8191, wt = Tr >>> 13, Hr = ye[6] | 0, tr = Hr & 8191, cr = Hr >>> 13, qr = ye[7] | 0, Wt = qr & 8191, ar = qr >>> 13, Dr = ye[8] | 0, Jt = Dr & 8191, ir = Dr >>> 13, Gr = ye[9] | 0, We = Gr & 8191, Le = Gr >>> 13, Ke = xe[0] | 0, rt = Ke & 8191, lt = Ke >>> 13, It = xe[1] | 0, yt = It & 8191, jt = It >>> 13, Lr = xe[2] | 0, zt = Lr & 8191, rr = Lr >>> 13, Cr = xe[3] | 0, fr = Cr & 8191, pr = Cr >>> 13, jr = xe[4] | 0, nr = jr & 8191, ur = jr >>> 13, Wr = xe[5] | 0, or = Wr & 8191, lr = Wr >>> 13, Zr = xe[6] | 0, Xt = Zr & 8191, dr = Zr >>> 13, Ve = xe[7] | 0, Ze = Ve & 8191, Xe = Ve >>> 13, Ue = xe[8] | 0, Qe = Ue & 8191, pt = Ue >>> 13, Ct = xe[9] | 0, bt = Ct & 8191, Tt = Ct >>> 13;
      ge.negative = le.negative ^ pe.negative, ge.length = 19, ve = Math.imul(Re, rt), he = Math.imul(Re, lt), he = he + Math.imul(Oe, rt) | 0, be = Math.imul(Oe, lt);
      var br = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (br >>> 26) | 0, br &= 67108863, ve = Math.imul(Fe, rt), he = Math.imul(Fe, lt), he = he + Math.imul(je, rt) | 0, be = Math.imul(je, lt), ve = ve + Math.imul(Re, yt) | 0, he = he + Math.imul(Re, jt) | 0, he = he + Math.imul(Oe, yt) | 0, be = be + Math.imul(Oe, jt) | 0;
      var gr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (gr >>> 26) | 0, gr &= 67108863, ve = Math.imul(nt, rt), he = Math.imul(nt, lt), he = he + Math.imul(dt, rt) | 0, be = Math.imul(dt, lt), ve = ve + Math.imul(Fe, yt) | 0, he = he + Math.imul(Fe, jt) | 0, he = he + Math.imul(je, yt) | 0, be = be + Math.imul(je, jt) | 0, ve = ve + Math.imul(Re, zt) | 0, he = he + Math.imul(Re, rr) | 0, he = he + Math.imul(Oe, zt) | 0, be = be + Math.imul(Oe, rr) | 0;
      var Fr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, ve = Math.imul(Je, rt), he = Math.imul(Je, lt), he = he + Math.imul(gt, rt) | 0, be = Math.imul(gt, lt), ve = ve + Math.imul(nt, yt) | 0, he = he + Math.imul(nt, jt) | 0, he = he + Math.imul(dt, yt) | 0, be = be + Math.imul(dt, jt) | 0, ve = ve + Math.imul(Fe, zt) | 0, he = he + Math.imul(Fe, rr) | 0, he = he + Math.imul(je, zt) | 0, be = be + Math.imul(je, rr) | 0, ve = ve + Math.imul(Re, fr) | 0, he = he + Math.imul(Re, pr) | 0, he = he + Math.imul(Oe, fr) | 0, be = be + Math.imul(Oe, pr) | 0;
      var wr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (wr >>> 26) | 0, wr &= 67108863, ve = Math.imul($t, rt), he = Math.imul($t, lt), he = he + Math.imul(Lt, rt) | 0, be = Math.imul(Lt, lt), ve = ve + Math.imul(Je, yt) | 0, he = he + Math.imul(Je, jt) | 0, he = he + Math.imul(gt, yt) | 0, be = be + Math.imul(gt, jt) | 0, ve = ve + Math.imul(nt, zt) | 0, he = he + Math.imul(nt, rr) | 0, he = he + Math.imul(dt, zt) | 0, be = be + Math.imul(dt, rr) | 0, ve = ve + Math.imul(Fe, fr) | 0, he = he + Math.imul(Fe, pr) | 0, he = he + Math.imul(je, fr) | 0, be = be + Math.imul(je, pr) | 0, ve = ve + Math.imul(Re, nr) | 0, he = he + Math.imul(Re, ur) | 0, he = he + Math.imul(Oe, nr) | 0, be = be + Math.imul(Oe, ur) | 0;
      var Rr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Rr >>> 26) | 0, Rr &= 67108863, ve = Math.imul(Zt, rt), he = Math.imul(Zt, lt), he = he + Math.imul(wt, rt) | 0, be = Math.imul(wt, lt), ve = ve + Math.imul($t, yt) | 0, he = he + Math.imul($t, jt) | 0, he = he + Math.imul(Lt, yt) | 0, be = be + Math.imul(Lt, jt) | 0, ve = ve + Math.imul(Je, zt) | 0, he = he + Math.imul(Je, rr) | 0, he = he + Math.imul(gt, zt) | 0, be = be + Math.imul(gt, rr) | 0, ve = ve + Math.imul(nt, fr) | 0, he = he + Math.imul(nt, pr) | 0, he = he + Math.imul(dt, fr) | 0, be = be + Math.imul(dt, pr) | 0, ve = ve + Math.imul(Fe, nr) | 0, he = he + Math.imul(Fe, ur) | 0, he = he + Math.imul(je, nr) | 0, be = be + Math.imul(je, ur) | 0, ve = ve + Math.imul(Re, or) | 0, he = he + Math.imul(Re, lr) | 0, he = he + Math.imul(Oe, or) | 0, be = be + Math.imul(Oe, lr) | 0;
      var kr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (kr >>> 26) | 0, kr &= 67108863, ve = Math.imul(tr, rt), he = Math.imul(tr, lt), he = he + Math.imul(cr, rt) | 0, be = Math.imul(cr, lt), ve = ve + Math.imul(Zt, yt) | 0, he = he + Math.imul(Zt, jt) | 0, he = he + Math.imul(wt, yt) | 0, be = be + Math.imul(wt, jt) | 0, ve = ve + Math.imul($t, zt) | 0, he = he + Math.imul($t, rr) | 0, he = he + Math.imul(Lt, zt) | 0, be = be + Math.imul(Lt, rr) | 0, ve = ve + Math.imul(Je, fr) | 0, he = he + Math.imul(Je, pr) | 0, he = he + Math.imul(gt, fr) | 0, be = be + Math.imul(gt, pr) | 0, ve = ve + Math.imul(nt, nr) | 0, he = he + Math.imul(nt, ur) | 0, he = he + Math.imul(dt, nr) | 0, be = be + Math.imul(dt, ur) | 0, ve = ve + Math.imul(Fe, or) | 0, he = he + Math.imul(Fe, lr) | 0, he = he + Math.imul(je, or) | 0, be = be + Math.imul(je, lr) | 0, ve = ve + Math.imul(Re, Xt) | 0, he = he + Math.imul(Re, dr) | 0, he = he + Math.imul(Oe, Xt) | 0, be = be + Math.imul(Oe, dr) | 0;
      var Pr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, ve = Math.imul(Wt, rt), he = Math.imul(Wt, lt), he = he + Math.imul(ar, rt) | 0, be = Math.imul(ar, lt), ve = ve + Math.imul(tr, yt) | 0, he = he + Math.imul(tr, jt) | 0, he = he + Math.imul(cr, yt) | 0, be = be + Math.imul(cr, jt) | 0, ve = ve + Math.imul(Zt, zt) | 0, he = he + Math.imul(Zt, rr) | 0, he = he + Math.imul(wt, zt) | 0, be = be + Math.imul(wt, rr) | 0, ve = ve + Math.imul($t, fr) | 0, he = he + Math.imul($t, pr) | 0, he = he + Math.imul(Lt, fr) | 0, be = be + Math.imul(Lt, pr) | 0, ve = ve + Math.imul(Je, nr) | 0, he = he + Math.imul(Je, ur) | 0, he = he + Math.imul(gt, nr) | 0, be = be + Math.imul(gt, ur) | 0, ve = ve + Math.imul(nt, or) | 0, he = he + Math.imul(nt, lr) | 0, he = he + Math.imul(dt, or) | 0, be = be + Math.imul(dt, lr) | 0, ve = ve + Math.imul(Fe, Xt) | 0, he = he + Math.imul(Fe, dr) | 0, he = he + Math.imul(je, Xt) | 0, be = be + Math.imul(je, dr) | 0, ve = ve + Math.imul(Re, Ze) | 0, he = he + Math.imul(Re, Xe) | 0, he = he + Math.imul(Oe, Ze) | 0, be = be + Math.imul(Oe, Xe) | 0;
      var Ur = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, ve = Math.imul(Jt, rt), he = Math.imul(Jt, lt), he = he + Math.imul(ir, rt) | 0, be = Math.imul(ir, lt), ve = ve + Math.imul(Wt, yt) | 0, he = he + Math.imul(Wt, jt) | 0, he = he + Math.imul(ar, yt) | 0, be = be + Math.imul(ar, jt) | 0, ve = ve + Math.imul(tr, zt) | 0, he = he + Math.imul(tr, rr) | 0, he = he + Math.imul(cr, zt) | 0, be = be + Math.imul(cr, rr) | 0, ve = ve + Math.imul(Zt, fr) | 0, he = he + Math.imul(Zt, pr) | 0, he = he + Math.imul(wt, fr) | 0, be = be + Math.imul(wt, pr) | 0, ve = ve + Math.imul($t, nr) | 0, he = he + Math.imul($t, ur) | 0, he = he + Math.imul(Lt, nr) | 0, be = be + Math.imul(Lt, ur) | 0, ve = ve + Math.imul(Je, or) | 0, he = he + Math.imul(Je, lr) | 0, he = he + Math.imul(gt, or) | 0, be = be + Math.imul(gt, lr) | 0, ve = ve + Math.imul(nt, Xt) | 0, he = he + Math.imul(nt, dr) | 0, he = he + Math.imul(dt, Xt) | 0, be = be + Math.imul(dt, dr) | 0, ve = ve + Math.imul(Fe, Ze) | 0, he = he + Math.imul(Fe, Xe) | 0, he = he + Math.imul(je, Ze) | 0, be = be + Math.imul(je, Xe) | 0, ve = ve + Math.imul(Re, Qe) | 0, he = he + Math.imul(Re, pt) | 0, he = he + Math.imul(Oe, Qe) | 0, be = be + Math.imul(Oe, pt) | 0;
      var Ir = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Ir >>> 26) | 0, Ir &= 67108863, ve = Math.imul(We, rt), he = Math.imul(We, lt), he = he + Math.imul(Le, rt) | 0, be = Math.imul(Le, lt), ve = ve + Math.imul(Jt, yt) | 0, he = he + Math.imul(Jt, jt) | 0, he = he + Math.imul(ir, yt) | 0, be = be + Math.imul(ir, jt) | 0, ve = ve + Math.imul(Wt, zt) | 0, he = he + Math.imul(Wt, rr) | 0, he = he + Math.imul(ar, zt) | 0, be = be + Math.imul(ar, rr) | 0, ve = ve + Math.imul(tr, fr) | 0, he = he + Math.imul(tr, pr) | 0, he = he + Math.imul(cr, fr) | 0, be = be + Math.imul(cr, pr) | 0, ve = ve + Math.imul(Zt, nr) | 0, he = he + Math.imul(Zt, ur) | 0, he = he + Math.imul(wt, nr) | 0, be = be + Math.imul(wt, ur) | 0, ve = ve + Math.imul($t, or) | 0, he = he + Math.imul($t, lr) | 0, he = he + Math.imul(Lt, or) | 0, be = be + Math.imul(Lt, lr) | 0, ve = ve + Math.imul(Je, Xt) | 0, he = he + Math.imul(Je, dr) | 0, he = he + Math.imul(gt, Xt) | 0, be = be + Math.imul(gt, dr) | 0, ve = ve + Math.imul(nt, Ze) | 0, he = he + Math.imul(nt, Xe) | 0, he = he + Math.imul(dt, Ze) | 0, be = be + Math.imul(dt, Xe) | 0, ve = ve + Math.imul(Fe, Qe) | 0, he = he + Math.imul(Fe, pt) | 0, he = he + Math.imul(je, Qe) | 0, be = be + Math.imul(je, pt) | 0, ve = ve + Math.imul(Re, bt) | 0, he = he + Math.imul(Re, Tt) | 0, he = he + Math.imul(Oe, bt) | 0, be = be + Math.imul(Oe, Tt) | 0;
      var Or = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Or >>> 26) | 0, Or &= 67108863, ve = Math.imul(We, yt), he = Math.imul(We, jt), he = he + Math.imul(Le, yt) | 0, be = Math.imul(Le, jt), ve = ve + Math.imul(Jt, zt) | 0, he = he + Math.imul(Jt, rr) | 0, he = he + Math.imul(ir, zt) | 0, be = be + Math.imul(ir, rr) | 0, ve = ve + Math.imul(Wt, fr) | 0, he = he + Math.imul(Wt, pr) | 0, he = he + Math.imul(ar, fr) | 0, be = be + Math.imul(ar, pr) | 0, ve = ve + Math.imul(tr, nr) | 0, he = he + Math.imul(tr, ur) | 0, he = he + Math.imul(cr, nr) | 0, be = be + Math.imul(cr, ur) | 0, ve = ve + Math.imul(Zt, or) | 0, he = he + Math.imul(Zt, lr) | 0, he = he + Math.imul(wt, or) | 0, be = be + Math.imul(wt, lr) | 0, ve = ve + Math.imul($t, Xt) | 0, he = he + Math.imul($t, dr) | 0, he = he + Math.imul(Lt, Xt) | 0, be = be + Math.imul(Lt, dr) | 0, ve = ve + Math.imul(Je, Ze) | 0, he = he + Math.imul(Je, Xe) | 0, he = he + Math.imul(gt, Ze) | 0, be = be + Math.imul(gt, Xe) | 0, ve = ve + Math.imul(nt, Qe) | 0, he = he + Math.imul(nt, pt) | 0, he = he + Math.imul(dt, Qe) | 0, be = be + Math.imul(dt, pt) | 0, ve = ve + Math.imul(Fe, bt) | 0, he = he + Math.imul(Fe, Tt) | 0, he = he + Math.imul(je, bt) | 0, be = be + Math.imul(je, Tt) | 0;
      var Nr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Nr >>> 26) | 0, Nr &= 67108863, ve = Math.imul(We, zt), he = Math.imul(We, rr), he = he + Math.imul(Le, zt) | 0, be = Math.imul(Le, rr), ve = ve + Math.imul(Jt, fr) | 0, he = he + Math.imul(Jt, pr) | 0, he = he + Math.imul(ir, fr) | 0, be = be + Math.imul(ir, pr) | 0, ve = ve + Math.imul(Wt, nr) | 0, he = he + Math.imul(Wt, ur) | 0, he = he + Math.imul(ar, nr) | 0, be = be + Math.imul(ar, ur) | 0, ve = ve + Math.imul(tr, or) | 0, he = he + Math.imul(tr, lr) | 0, he = he + Math.imul(cr, or) | 0, be = be + Math.imul(cr, lr) | 0, ve = ve + Math.imul(Zt, Xt) | 0, he = he + Math.imul(Zt, dr) | 0, he = he + Math.imul(wt, Xt) | 0, be = be + Math.imul(wt, dr) | 0, ve = ve + Math.imul($t, Ze) | 0, he = he + Math.imul($t, Xe) | 0, he = he + Math.imul(Lt, Ze) | 0, be = be + Math.imul(Lt, Xe) | 0, ve = ve + Math.imul(Je, Qe) | 0, he = he + Math.imul(Je, pt) | 0, he = he + Math.imul(gt, Qe) | 0, be = be + Math.imul(gt, pt) | 0, ve = ve + Math.imul(nt, bt) | 0, he = he + Math.imul(nt, Tt) | 0, he = he + Math.imul(dt, bt) | 0, be = be + Math.imul(dt, Tt) | 0;
      var Er = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, ve = Math.imul(We, fr), he = Math.imul(We, pr), he = he + Math.imul(Le, fr) | 0, be = Math.imul(Le, pr), ve = ve + Math.imul(Jt, nr) | 0, he = he + Math.imul(Jt, ur) | 0, he = he + Math.imul(ir, nr) | 0, be = be + Math.imul(ir, ur) | 0, ve = ve + Math.imul(Wt, or) | 0, he = he + Math.imul(Wt, lr) | 0, he = he + Math.imul(ar, or) | 0, be = be + Math.imul(ar, lr) | 0, ve = ve + Math.imul(tr, Xt) | 0, he = he + Math.imul(tr, dr) | 0, he = he + Math.imul(cr, Xt) | 0, be = be + Math.imul(cr, dr) | 0, ve = ve + Math.imul(Zt, Ze) | 0, he = he + Math.imul(Zt, Xe) | 0, he = he + Math.imul(wt, Ze) | 0, be = be + Math.imul(wt, Xe) | 0, ve = ve + Math.imul($t, Qe) | 0, he = he + Math.imul($t, pt) | 0, he = he + Math.imul(Lt, Qe) | 0, be = be + Math.imul(Lt, pt) | 0, ve = ve + Math.imul(Je, bt) | 0, he = he + Math.imul(Je, Tt) | 0, he = he + Math.imul(gt, bt) | 0, be = be + Math.imul(gt, Tt) | 0;
      var Br = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Br >>> 26) | 0, Br &= 67108863, ve = Math.imul(We, nr), he = Math.imul(We, ur), he = he + Math.imul(Le, nr) | 0, be = Math.imul(Le, ur), ve = ve + Math.imul(Jt, or) | 0, he = he + Math.imul(Jt, lr) | 0, he = he + Math.imul(ir, or) | 0, be = be + Math.imul(ir, lr) | 0, ve = ve + Math.imul(Wt, Xt) | 0, he = he + Math.imul(Wt, dr) | 0, he = he + Math.imul(ar, Xt) | 0, be = be + Math.imul(ar, dr) | 0, ve = ve + Math.imul(tr, Ze) | 0, he = he + Math.imul(tr, Xe) | 0, he = he + Math.imul(cr, Ze) | 0, be = be + Math.imul(cr, Xe) | 0, ve = ve + Math.imul(Zt, Qe) | 0, he = he + Math.imul(Zt, pt) | 0, he = he + Math.imul(wt, Qe) | 0, be = be + Math.imul(wt, pt) | 0, ve = ve + Math.imul($t, bt) | 0, he = he + Math.imul($t, Tt) | 0, he = he + Math.imul(Lt, bt) | 0, be = be + Math.imul(Lt, Tt) | 0;
      var _r = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (_r >>> 26) | 0, _r &= 67108863, ve = Math.imul(We, or), he = Math.imul(We, lr), he = he + Math.imul(Le, or) | 0, be = Math.imul(Le, lr), ve = ve + Math.imul(Jt, Xt) | 0, he = he + Math.imul(Jt, dr) | 0, he = he + Math.imul(ir, Xt) | 0, be = be + Math.imul(ir, dr) | 0, ve = ve + Math.imul(Wt, Ze) | 0, he = he + Math.imul(Wt, Xe) | 0, he = he + Math.imul(ar, Ze) | 0, be = be + Math.imul(ar, Xe) | 0, ve = ve + Math.imul(tr, Qe) | 0, he = he + Math.imul(tr, pt) | 0, he = he + Math.imul(cr, Qe) | 0, be = be + Math.imul(cr, pt) | 0, ve = ve + Math.imul(Zt, bt) | 0, he = he + Math.imul(Zt, Tt) | 0, he = he + Math.imul(wt, bt) | 0, be = be + Math.imul(wt, Tt) | 0;
      var Sr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Sr >>> 26) | 0, Sr &= 67108863, ve = Math.imul(We, Xt), he = Math.imul(We, dr), he = he + Math.imul(Le, Xt) | 0, be = Math.imul(Le, dr), ve = ve + Math.imul(Jt, Ze) | 0, he = he + Math.imul(Jt, Xe) | 0, he = he + Math.imul(ir, Ze) | 0, be = be + Math.imul(ir, Xe) | 0, ve = ve + Math.imul(Wt, Qe) | 0, he = he + Math.imul(Wt, pt) | 0, he = he + Math.imul(ar, Qe) | 0, be = be + Math.imul(ar, pt) | 0, ve = ve + Math.imul(tr, bt) | 0, he = he + Math.imul(tr, Tt) | 0, he = he + Math.imul(cr, bt) | 0, be = be + Math.imul(cr, Tt) | 0;
      var Mr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Mr >>> 26) | 0, Mr &= 67108863, ve = Math.imul(We, Ze), he = Math.imul(We, Xe), he = he + Math.imul(Le, Ze) | 0, be = Math.imul(Le, Xe), ve = ve + Math.imul(Jt, Qe) | 0, he = he + Math.imul(Jt, pt) | 0, he = he + Math.imul(ir, Qe) | 0, be = be + Math.imul(ir, pt) | 0, ve = ve + Math.imul(Wt, bt) | 0, he = he + Math.imul(Wt, Tt) | 0, he = he + Math.imul(ar, bt) | 0, be = be + Math.imul(ar, Tt) | 0;
      var $r = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + ($r >>> 26) | 0, $r &= 67108863, ve = Math.imul(We, Qe), he = Math.imul(We, pt), he = he + Math.imul(Le, Qe) | 0, be = Math.imul(Le, pt), ve = ve + Math.imul(Jt, bt) | 0, he = he + Math.imul(Jt, Tt) | 0, he = he + Math.imul(ir, bt) | 0, be = be + Math.imul(ir, Tt) | 0;
      var Yt = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Yt >>> 26) | 0, Yt &= 67108863, ve = Math.imul(We, bt), he = Math.imul(We, Tt), he = he + Math.imul(Le, bt) | 0, be = Math.imul(Le, Tt);
      var er = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      return Ae = (be + (he >>> 13) | 0) + (er >>> 26) | 0, er &= 67108863, _e[0] = br, _e[1] = gr, _e[2] = Fr, _e[3] = wr, _e[4] = Rr, _e[5] = kr, _e[6] = Pr, _e[7] = Ur, _e[8] = Ir, _e[9] = Or, _e[10] = Nr, _e[11] = Er, _e[12] = Br, _e[13] = _r, _e[14] = Sr, _e[15] = Mr, _e[16] = $r, _e[17] = Yt, _e[18] = er, Ae !== 0 && (_e[19] = Ae, ge.length++), ge;
    };
    Math.imul || (Ne = Pe);
    function ke($e, le, pe) {
      pe.negative = le.negative ^ $e.negative, pe.length = $e.length + le.length;
      for (var ge = 0, ye = 0, xe = 0; xe < pe.length - 1; xe++) {
        var _e = ye;
        ye = 0;
        for (var Ae = ge & 67108863, ve = Math.min(xe, le.length - 1), he = Math.max(0, xe - $e.length + 1); he <= ve; he++) {
          var be = xe - he, Me = $e.words[be] | 0, Re = le.words[he] | 0, Oe = Me * Re, Te = Oe & 67108863;
          _e = _e + (Oe / 67108864 | 0) | 0, Te = Te + Ae | 0, Ae = Te & 67108863, _e = _e + (Te >>> 26) | 0, ye += _e >>> 26, _e &= 67108863;
        }
        pe.words[xe] = Ae, ge = _e, _e = ye;
      }
      return ge !== 0 ? pe.words[xe] = ge : pe.length--, pe.strip();
    }
    function He($e, le, pe) {
      var ge = new De();
      return ge.mulp($e, le, pe);
    }
    ce.prototype.mulTo = function(le, pe) {
      var ge, ye = this.length + le.length;
      return this.length === 10 && le.length === 10 ? ge = Ne(this, le, pe) : ye < 63 ? ge = Pe(this, le, pe) : ye < 1024 ? ge = ke(this, le, pe) : ge = He(this, le, pe), ge;
    };
    function De($e, le) {
      this.x = $e, this.y = le;
    }
    De.prototype.makeRBT = function(le) {
      for (var pe = new Array(le), ge = ce.prototype._countBits(le) - 1, ye = 0; ye < le; ye++)
        pe[ye] = this.revBin(ye, ge, le);
      return pe;
    }, De.prototype.revBin = function(le, pe, ge) {
      if (le === 0 || le === ge - 1)
        return le;
      for (var ye = 0, xe = 0; xe < pe; xe++)
        ye |= (le & 1) << pe - xe - 1, le >>= 1;
      return ye;
    }, De.prototype.permute = function(le, pe, ge, ye, xe, _e) {
      for (var Ae = 0; Ae < _e; Ae++)
        ye[Ae] = pe[le[Ae]], xe[Ae] = ge[le[Ae]];
    }, De.prototype.transform = function(le, pe, ge, ye, xe, _e) {
      this.permute(_e, le, pe, ge, ye, xe);
      for (var Ae = 1; Ae < xe; Ae <<= 1)
        for (var ve = Ae << 1, he = Math.cos(2 * Math.PI / ve), be = Math.sin(2 * Math.PI / ve), Me = 0; Me < xe; Me += ve)
          for (var Re = he, Oe = be, Te = 0; Te < Ae; Te++) {
            var Fe = ge[Me + Te], je = ye[Me + Te], ct = ge[Me + Te + Ae], nt = ye[Me + Te + Ae], dt = Re * ct - Oe * nt;
            nt = Re * nt + Oe * ct, ct = dt, ge[Me + Te] = Fe + ct, ye[Me + Te] = je + nt, ge[Me + Te + Ae] = Fe - ct, ye[Me + Te + Ae] = je - nt, Te !== ve && (dt = he * Re - be * Oe, Oe = he * Oe + be * Re, Re = dt);
          }
    }, De.prototype.guessLen13b = function(le, pe) {
      var ge = Math.max(pe, le) | 1, ye = ge & 1, xe = 0;
      for (ge = ge / 2 | 0; ge; ge = ge >>> 1)
        xe++;
      return 1 << xe + 1 + ye;
    }, De.prototype.conjugate = function(le, pe, ge) {
      if (!(ge <= 1))
        for (var ye = 0; ye < ge / 2; ye++) {
          var xe = le[ye];
          le[ye] = le[ge - ye - 1], le[ge - ye - 1] = xe, xe = pe[ye], pe[ye] = -pe[ge - ye - 1], pe[ge - ye - 1] = -xe;
        }
    }, De.prototype.normalize13b = function(le, pe) {
      for (var ge = 0, ye = 0; ye < pe / 2; ye++) {
        var xe = Math.round(le[2 * ye + 1] / pe) * 8192 + Math.round(le[2 * ye] / pe) + ge;
        le[ye] = xe & 67108863, xe < 67108864 ? ge = 0 : ge = xe / 67108864 | 0;
      }
      return le;
    }, De.prototype.convert13b = function(le, pe, ge, ye) {
      for (var xe = 0, _e = 0; _e < pe; _e++)
        xe = xe + (le[_e] | 0), ge[2 * _e] = xe & 8191, xe = xe >>> 13, ge[2 * _e + 1] = xe & 8191, xe = xe >>> 13;
      for (_e = 2 * pe; _e < ye; ++_e)
        ge[_e] = 0;
      fe(xe === 0), fe((xe & -8192) === 0);
    }, De.prototype.stub = function(le) {
      for (var pe = new Array(le), ge = 0; ge < le; ge++)
        pe[ge] = 0;
      return pe;
    }, De.prototype.mulp = function(le, pe, ge) {
      var ye = 2 * this.guessLen13b(le.length, pe.length), xe = this.makeRBT(ye), _e = this.stub(ye), Ae = new Array(ye), ve = new Array(ye), he = new Array(ye), be = new Array(ye), Me = new Array(ye), Re = new Array(ye), Oe = ge.words;
      Oe.length = ye, this.convert13b(le.words, le.length, Ae, ye), this.convert13b(pe.words, pe.length, be, ye), this.transform(Ae, _e, ve, he, ye, xe), this.transform(be, _e, Me, Re, ye, xe);
      for (var Te = 0; Te < ye; Te++) {
        var Fe = ve[Te] * Me[Te] - he[Te] * Re[Te];
        he[Te] = ve[Te] * Re[Te] + he[Te] * Me[Te], ve[Te] = Fe;
      }
      return this.conjugate(ve, he, ye), this.transform(ve, he, Oe, _e, ye, xe), this.conjugate(Oe, _e, ye), this.normalize13b(Oe, ye), ge.negative = le.negative ^ pe.negative, ge.length = le.length + pe.length, ge.strip();
    }, ce.prototype.mul = function(le) {
      var pe = new ce(null);
      return pe.words = new Array(this.length + le.length), this.mulTo(le, pe);
    }, ce.prototype.mulf = function(le) {
      var pe = new ce(null);
      return pe.words = new Array(this.length + le.length), He(this, le, pe);
    }, ce.prototype.imul = function(le) {
      return this.clone().mulTo(le, this);
    }, ce.prototype.imuln = function(le) {
      fe(typeof le == "number"), fe(le < 67108864);
      for (var pe = 0, ge = 0; ge < this.length; ge++) {
        var ye = (this.words[ge] | 0) * le, xe = (ye & 67108863) + (pe & 67108863);
        pe >>= 26, pe += ye / 67108864 | 0, pe += xe >>> 26, this.words[ge] = xe & 67108863;
      }
      return pe !== 0 && (this.words[ge] = pe, this.length++), this;
    }, ce.prototype.muln = function(le) {
      return this.clone().imuln(le);
    }, ce.prototype.sqr = function() {
      return this.mul(this);
    }, ce.prototype.isqr = function() {
      return this.imul(this.clone());
    }, ce.prototype.pow = function(le) {
      var pe = Ie(le);
      if (pe.length === 0)
        return new ce(1);
      for (var ge = this, ye = 0; ye < pe.length && pe[ye] === 0; ye++, ge = ge.sqr())
        ;
      if (++ye < pe.length)
        for (var xe = ge.sqr(); ye < pe.length; ye++, xe = xe.sqr())
          pe[ye] !== 0 && (ge = ge.mul(xe));
      return ge;
    }, ce.prototype.iushln = function(le) {
      fe(typeof le == "number" && le >= 0);
      var pe = le % 26, ge = (le - pe) / 26, ye = 67108863 >>> 26 - pe << 26 - pe, xe;
      if (pe !== 0) {
        var _e = 0;
        for (xe = 0; xe < this.length; xe++) {
          var Ae = this.words[xe] & ye, ve = (this.words[xe] | 0) - Ae << pe;
          this.words[xe] = ve | _e, _e = Ae >>> 26 - pe;
        }
        _e && (this.words[xe] = _e, this.length++);
      }
      if (ge !== 0) {
        for (xe = this.length - 1; xe >= 0; xe--)
          this.words[xe + ge] = this.words[xe];
        for (xe = 0; xe < ge; xe++)
          this.words[xe] = 0;
        this.length += ge;
      }
      return this.strip();
    }, ce.prototype.ishln = function(le) {
      return fe(this.negative === 0), this.iushln(le);
    }, ce.prototype.iushrn = function(le, pe, ge) {
      fe(typeof le == "number" && le >= 0);
      var ye;
      pe ? ye = (pe - pe % 26) / 26 : ye = 0;
      var xe = le % 26, _e = Math.min((le - xe) / 26, this.length), Ae = 67108863 ^ 67108863 >>> xe << xe, ve = ge;
      if (ye -= _e, ye = Math.max(0, ye), ve) {
        for (var he = 0; he < _e; he++)
          ve.words[he] = this.words[he];
        ve.length = _e;
      }
      if (_e !== 0)
        if (this.length > _e)
          for (this.length -= _e, he = 0; he < this.length; he++)
            this.words[he] = this.words[he + _e];
        else
          this.words[0] = 0, this.length = 1;
      var be = 0;
      for (he = this.length - 1; he >= 0 && (be !== 0 || he >= ye); he--) {
        var Me = this.words[he] | 0;
        this.words[he] = be << 26 - xe | Me >>> xe, be = Me & Ae;
      }
      return ve && be !== 0 && (ve.words[ve.length++] = be), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, ce.prototype.ishrn = function(le, pe, ge) {
      return fe(this.negative === 0), this.iushrn(le, pe, ge);
    }, ce.prototype.shln = function(le) {
      return this.clone().ishln(le);
    }, ce.prototype.ushln = function(le) {
      return this.clone().iushln(le);
    }, ce.prototype.shrn = function(le) {
      return this.clone().ishrn(le);
    }, ce.prototype.ushrn = function(le) {
      return this.clone().iushrn(le);
    }, ce.prototype.testn = function(le) {
      fe(typeof le == "number" && le >= 0);
      var pe = le % 26, ge = (le - pe) / 26, ye = 1 << pe;
      if (this.length <= ge)
        return !1;
      var xe = this.words[ge];
      return !!(xe & ye);
    }, ce.prototype.imaskn = function(le) {
      fe(typeof le == "number" && le >= 0);
      var pe = le % 26, ge = (le - pe) / 26;
      if (fe(this.negative === 0, "imaskn works only with positive numbers"), this.length <= ge)
        return this;
      if (pe !== 0 && ge++, this.length = Math.min(ge, this.length), pe !== 0) {
        var ye = 67108863 ^ 67108863 >>> pe << pe;
        this.words[this.length - 1] &= ye;
      }
      return this.strip();
    }, ce.prototype.maskn = function(le) {
      return this.clone().imaskn(le);
    }, ce.prototype.iaddn = function(le) {
      return fe(typeof le == "number"), fe(le < 67108864), le < 0 ? this.isubn(-le) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < le ? (this.words[0] = le - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(le), this.negative = 1, this) : this._iaddn(le);
    }, ce.prototype._iaddn = function(le) {
      this.words[0] += le;
      for (var pe = 0; pe < this.length && this.words[pe] >= 67108864; pe++)
        this.words[pe] -= 67108864, pe === this.length - 1 ? this.words[pe + 1] = 1 : this.words[pe + 1]++;
      return this.length = Math.max(this.length, pe + 1), this;
    }, ce.prototype.isubn = function(le) {
      if (fe(typeof le == "number"), fe(le < 67108864), le < 0)
        return this.iaddn(-le);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(le), this.negative = 1, this;
      if (this.words[0] -= le, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var pe = 0; pe < this.length && this.words[pe] < 0; pe++)
          this.words[pe] += 67108864, this.words[pe + 1] -= 1;
      return this.strip();
    }, ce.prototype.addn = function(le) {
      return this.clone().iaddn(le);
    }, ce.prototype.subn = function(le) {
      return this.clone().isubn(le);
    }, ce.prototype.iabs = function() {
      return this.negative = 0, this;
    }, ce.prototype.abs = function() {
      return this.clone().iabs();
    }, ce.prototype._ishlnsubmul = function(le, pe, ge) {
      var ye = le.length + ge, xe;
      this._expand(ye);
      var _e, Ae = 0;
      for (xe = 0; xe < le.length; xe++) {
        _e = (this.words[xe + ge] | 0) + Ae;
        var ve = (le.words[xe] | 0) * pe;
        _e -= ve & 67108863, Ae = (_e >> 26) - (ve / 67108864 | 0), this.words[xe + ge] = _e & 67108863;
      }
      for (; xe < this.length - ge; xe++)
        _e = (this.words[xe + ge] | 0) + Ae, Ae = _e >> 26, this.words[xe + ge] = _e & 67108863;
      if (Ae === 0)
        return this.strip();
      for (fe(Ae === -1), Ae = 0, xe = 0; xe < this.length; xe++)
        _e = -(this.words[xe] | 0) + Ae, Ae = _e >> 26, this.words[xe] = _e & 67108863;
      return this.negative = 1, this.strip();
    }, ce.prototype._wordDiv = function(le, pe) {
      var ge = this.length - le.length, ye = this.clone(), xe = le, _e = xe.words[xe.length - 1] | 0, Ae = this._countBits(_e);
      ge = 26 - Ae, ge !== 0 && (xe = xe.ushln(ge), ye.iushln(ge), _e = xe.words[xe.length - 1] | 0);
      var ve = ye.length - xe.length, he;
      if (pe !== "mod") {
        he = new ce(null), he.length = ve + 1, he.words = new Array(he.length);
        for (var be = 0; be < he.length; be++)
          he.words[be] = 0;
      }
      var Me = ye.clone()._ishlnsubmul(xe, 1, ve);
      Me.negative === 0 && (ye = Me, he && (he.words[ve] = 1));
      for (var Re = ve - 1; Re >= 0; Re--) {
        var Oe = (ye.words[xe.length + Re] | 0) * 67108864 + (ye.words[xe.length + Re - 1] | 0);
        for (Oe = Math.min(Oe / _e | 0, 67108863), ye._ishlnsubmul(xe, Oe, Re); ye.negative !== 0; )
          Oe--, ye.negative = 0, ye._ishlnsubmul(xe, 1, Re), ye.isZero() || (ye.negative ^= 1);
        he && (he.words[Re] = Oe);
      }
      return he && he.strip(), ye.strip(), pe !== "div" && ge !== 0 && ye.iushrn(ge), {
        div: he || null,
        mod: ye
      };
    }, ce.prototype.divmod = function(le, pe, ge) {
      if (fe(!le.isZero()), this.isZero())
        return {
          div: new ce(0),
          mod: new ce(0)
        };
      var ye, xe, _e;
      return this.negative !== 0 && le.negative === 0 ? (_e = this.neg().divmod(le, pe), pe !== "mod" && (ye = _e.div.neg()), pe !== "div" && (xe = _e.mod.neg(), ge && xe.negative !== 0 && xe.iadd(le)), {
        div: ye,
        mod: xe
      }) : this.negative === 0 && le.negative !== 0 ? (_e = this.divmod(le.neg(), pe), pe !== "mod" && (ye = _e.div.neg()), {
        div: ye,
        mod: _e.mod
      }) : this.negative & le.negative ? (_e = this.neg().divmod(le.neg(), pe), pe !== "div" && (xe = _e.mod.neg(), ge && xe.negative !== 0 && xe.isub(le)), {
        div: _e.div,
        mod: xe
      }) : le.length > this.length || this.cmp(le) < 0 ? {
        div: new ce(0),
        mod: this
      } : le.length === 1 ? pe === "div" ? {
        div: this.divn(le.words[0]),
        mod: null
      } : pe === "mod" ? {
        div: null,
        mod: new ce(this.modn(le.words[0]))
      } : {
        div: this.divn(le.words[0]),
        mod: new ce(this.modn(le.words[0]))
      } : this._wordDiv(le, pe);
    }, ce.prototype.div = function(le) {
      return this.divmod(le, "div", !1).div;
    }, ce.prototype.mod = function(le) {
      return this.divmod(le, "mod", !1).mod;
    }, ce.prototype.umod = function(le) {
      return this.divmod(le, "mod", !0).mod;
    }, ce.prototype.divRound = function(le) {
      var pe = this.divmod(le);
      if (pe.mod.isZero())
        return pe.div;
      var ge = pe.div.negative !== 0 ? pe.mod.isub(le) : pe.mod, ye = le.ushrn(1), xe = le.andln(1), _e = ge.cmp(ye);
      return _e < 0 || xe === 1 && _e === 0 ? pe.div : pe.div.negative !== 0 ? pe.div.isubn(1) : pe.div.iaddn(1);
    }, ce.prototype.modn = function(le) {
      fe(le <= 67108863);
      for (var pe = (1 << 26) % le, ge = 0, ye = this.length - 1; ye >= 0; ye--)
        ge = (pe * ge + (this.words[ye] | 0)) % le;
      return ge;
    }, ce.prototype.idivn = function(le) {
      fe(le <= 67108863);
      for (var pe = 0, ge = this.length - 1; ge >= 0; ge--) {
        var ye = (this.words[ge] | 0) + pe * 67108864;
        this.words[ge] = ye / le | 0, pe = ye % le;
      }
      return this.strip();
    }, ce.prototype.divn = function(le) {
      return this.clone().idivn(le);
    }, ce.prototype.egcd = function(le) {
      fe(le.negative === 0), fe(!le.isZero());
      var pe = this, ge = le.clone();
      pe.negative !== 0 ? pe = pe.umod(le) : pe = pe.clone();
      for (var ye = new ce(1), xe = new ce(0), _e = new ce(0), Ae = new ce(1), ve = 0; pe.isEven() && ge.isEven(); )
        pe.iushrn(1), ge.iushrn(1), ++ve;
      for (var he = ge.clone(), be = pe.clone(); !pe.isZero(); ) {
        for (var Me = 0, Re = 1; !(pe.words[0] & Re) && Me < 26; ++Me, Re <<= 1)
          ;
        if (Me > 0)
          for (pe.iushrn(Me); Me-- > 0; )
            (ye.isOdd() || xe.isOdd()) && (ye.iadd(he), xe.isub(be)), ye.iushrn(1), xe.iushrn(1);
        for (var Oe = 0, Te = 1; !(ge.words[0] & Te) && Oe < 26; ++Oe, Te <<= 1)
          ;
        if (Oe > 0)
          for (ge.iushrn(Oe); Oe-- > 0; )
            (_e.isOdd() || Ae.isOdd()) && (_e.iadd(he), Ae.isub(be)), _e.iushrn(1), Ae.iushrn(1);
        pe.cmp(ge) >= 0 ? (pe.isub(ge), ye.isub(_e), xe.isub(Ae)) : (ge.isub(pe), _e.isub(ye), Ae.isub(xe));
      }
      return {
        a: _e,
        b: Ae,
        gcd: ge.iushln(ve)
      };
    }, ce.prototype._invmp = function(le) {
      fe(le.negative === 0), fe(!le.isZero());
      var pe = this, ge = le.clone();
      pe.negative !== 0 ? pe = pe.umod(le) : pe = pe.clone();
      for (var ye = new ce(1), xe = new ce(0), _e = ge.clone(); pe.cmpn(1) > 0 && ge.cmpn(1) > 0; ) {
        for (var Ae = 0, ve = 1; !(pe.words[0] & ve) && Ae < 26; ++Ae, ve <<= 1)
          ;
        if (Ae > 0)
          for (pe.iushrn(Ae); Ae-- > 0; )
            ye.isOdd() && ye.iadd(_e), ye.iushrn(1);
        for (var he = 0, be = 1; !(ge.words[0] & be) && he < 26; ++he, be <<= 1)
          ;
        if (he > 0)
          for (ge.iushrn(he); he-- > 0; )
            xe.isOdd() && xe.iadd(_e), xe.iushrn(1);
        pe.cmp(ge) >= 0 ? (pe.isub(ge), ye.isub(xe)) : (ge.isub(pe), xe.isub(ye));
      }
      var Me;
      return pe.cmpn(1) === 0 ? Me = ye : Me = xe, Me.cmpn(0) < 0 && Me.iadd(le), Me;
    }, ce.prototype.gcd = function(le) {
      if (this.isZero())
        return le.abs();
      if (le.isZero())
        return this.abs();
      var pe = this.clone(), ge = le.clone();
      pe.negative = 0, ge.negative = 0;
      for (var ye = 0; pe.isEven() && ge.isEven(); ye++)
        pe.iushrn(1), ge.iushrn(1);
      do {
        for (; pe.isEven(); )
          pe.iushrn(1);
        for (; ge.isEven(); )
          ge.iushrn(1);
        var xe = pe.cmp(ge);
        if (xe < 0) {
          var _e = pe;
          pe = ge, ge = _e;
        } else if (xe === 0 || ge.cmpn(1) === 0)
          break;
        pe.isub(ge);
      } while (!0);
      return ge.iushln(ye);
    }, ce.prototype.invm = function(le) {
      return this.egcd(le).a.umod(le);
    }, ce.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, ce.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, ce.prototype.andln = function(le) {
      return this.words[0] & le;
    }, ce.prototype.bincn = function(le) {
      fe(typeof le == "number");
      var pe = le % 26, ge = (le - pe) / 26, ye = 1 << pe;
      if (this.length <= ge)
        return this._expand(ge + 1), this.words[ge] |= ye, this;
      for (var xe = ye, _e = ge; xe !== 0 && _e < this.length; _e++) {
        var Ae = this.words[_e] | 0;
        Ae += xe, xe = Ae >>> 26, Ae &= 67108863, this.words[_e] = Ae;
      }
      return xe !== 0 && (this.words[_e] = xe, this.length++), this;
    }, ce.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, ce.prototype.cmpn = function(le) {
      var pe = le < 0;
      if (this.negative !== 0 && !pe)
        return -1;
      if (this.negative === 0 && pe)
        return 1;
      this.strip();
      var ge;
      if (this.length > 1)
        ge = 1;
      else {
        pe && (le = -le), fe(le <= 67108863, "Number is too big");
        var ye = this.words[0] | 0;
        ge = ye === le ? 0 : ye < le ? -1 : 1;
      }
      return this.negative !== 0 ? -ge | 0 : ge;
    }, ce.prototype.cmp = function(le) {
      if (this.negative !== 0 && le.negative === 0)
        return -1;
      if (this.negative === 0 && le.negative !== 0)
        return 1;
      var pe = this.ucmp(le);
      return this.negative !== 0 ? -pe | 0 : pe;
    }, ce.prototype.ucmp = function(le) {
      if (this.length > le.length)
        return 1;
      if (this.length < le.length)
        return -1;
      for (var pe = 0, ge = this.length - 1; ge >= 0; ge--) {
        var ye = this.words[ge] | 0, xe = le.words[ge] | 0;
        if (ye !== xe) {
          ye < xe ? pe = -1 : ye > xe && (pe = 1);
          break;
        }
      }
      return pe;
    }, ce.prototype.gtn = function(le) {
      return this.cmpn(le) === 1;
    }, ce.prototype.gt = function(le) {
      return this.cmp(le) === 1;
    }, ce.prototype.gten = function(le) {
      return this.cmpn(le) >= 0;
    }, ce.prototype.gte = function(le) {
      return this.cmp(le) >= 0;
    }, ce.prototype.ltn = function(le) {
      return this.cmpn(le) === -1;
    }, ce.prototype.lt = function(le) {
      return this.cmp(le) === -1;
    }, ce.prototype.lten = function(le) {
      return this.cmpn(le) <= 0;
    }, ce.prototype.lte = function(le) {
      return this.cmp(le) <= 0;
    }, ce.prototype.eqn = function(le) {
      return this.cmpn(le) === 0;
    }, ce.prototype.eq = function(le) {
      return this.cmp(le) === 0;
    }, ce.red = function(le) {
      return new ze(le);
    }, ce.prototype.toRed = function(le) {
      return fe(!this.red, "Already a number in reduction context"), fe(this.negative === 0, "red works only with positives"), le.convertTo(this)._forceRed(le);
    }, ce.prototype.fromRed = function() {
      return fe(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, ce.prototype._forceRed = function(le) {
      return this.red = le, this;
    }, ce.prototype.forceRed = function(le) {
      return fe(!this.red, "Already a number in reduction context"), this._forceRed(le);
    }, ce.prototype.redAdd = function(le) {
      return fe(this.red, "redAdd works only with red numbers"), this.red.add(this, le);
    }, ce.prototype.redIAdd = function(le) {
      return fe(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, le);
    }, ce.prototype.redSub = function(le) {
      return fe(this.red, "redSub works only with red numbers"), this.red.sub(this, le);
    }, ce.prototype.redISub = function(le) {
      return fe(this.red, "redISub works only with red numbers"), this.red.isub(this, le);
    }, ce.prototype.redShl = function(le) {
      return fe(this.red, "redShl works only with red numbers"), this.red.shl(this, le);
    }, ce.prototype.redMul = function(le) {
      return fe(this.red, "redMul works only with red numbers"), this.red._verify2(this, le), this.red.mul(this, le);
    }, ce.prototype.redIMul = function(le) {
      return fe(this.red, "redMul works only with red numbers"), this.red._verify2(this, le), this.red.imul(this, le);
    }, ce.prototype.redSqr = function() {
      return fe(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, ce.prototype.redISqr = function() {
      return fe(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, ce.prototype.redSqrt = function() {
      return fe(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, ce.prototype.redInvm = function() {
      return fe(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, ce.prototype.redNeg = function() {
      return fe(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, ce.prototype.redPow = function(le) {
      return fe(this.red && !le.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, le);
    };
    var Ge = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Ye($e, le) {
      this.name = $e, this.p = new ce(le, 16), this.n = this.p.bitLength(), this.k = new ce(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Ye.prototype._tmp = function() {
      var le = new ce(null);
      return le.words = new Array(Math.ceil(this.n / 13)), le;
    }, Ye.prototype.ireduce = function(le) {
      var pe = le, ge;
      do
        this.split(pe, this.tmp), pe = this.imulK(pe), pe = pe.iadd(this.tmp), ge = pe.bitLength();
      while (ge > this.n);
      var ye = ge < this.n ? -1 : pe.ucmp(this.p);
      return ye === 0 ? (pe.words[0] = 0, pe.length = 1) : ye > 0 ? pe.isub(this.p) : pe.strip !== void 0 ? pe.strip() : pe._strip(), pe;
    }, Ye.prototype.split = function(le, pe) {
      le.iushrn(this.n, 0, pe);
    }, Ye.prototype.imulK = function(le) {
      return le.imul(this.k);
    };
    function st() {
      Ye.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    ue(st, Ye), st.prototype.split = function(le, pe) {
      for (var ge = 4194303, ye = Math.min(le.length, 9), xe = 0; xe < ye; xe++)
        pe.words[xe] = le.words[xe];
      if (pe.length = ye, le.length <= 9) {
        le.words[0] = 0, le.length = 1;
        return;
      }
      var _e = le.words[9];
      for (pe.words[pe.length++] = _e & ge, xe = 10; xe < le.length; xe++) {
        var Ae = le.words[xe] | 0;
        le.words[xe - 10] = (Ae & ge) << 4 | _e >>> 22, _e = Ae;
      }
      _e >>>= 22, le.words[xe - 10] = _e, _e === 0 && le.length > 10 ? le.length -= 10 : le.length -= 9;
    }, st.prototype.imulK = function(le) {
      le.words[le.length] = 0, le.words[le.length + 1] = 0, le.length += 2;
      for (var pe = 0, ge = 0; ge < le.length; ge++) {
        var ye = le.words[ge] | 0;
        pe += ye * 977, le.words[ge] = pe & 67108863, pe = ye * 64 + (pe / 67108864 | 0);
      }
      return le.words[le.length - 1] === 0 && (le.length--, le.words[le.length - 1] === 0 && le.length--), le;
    };
    function at() {
      Ye.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    ue(at, Ye);
    function mt() {
      Ye.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    ue(mt, Ye);
    function qe() {
      Ye.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    ue(qe, Ye), qe.prototype.imulK = function(le) {
      for (var pe = 0, ge = 0; ge < le.length; ge++) {
        var ye = (le.words[ge] | 0) * 19 + pe, xe = ye & 67108863;
        ye >>>= 26, le.words[ge] = xe, pe = ye;
      }
      return pe !== 0 && (le.words[le.length++] = pe), le;
    }, ce._prime = function(le) {
      if (Ge[le])
        return Ge[le];
      var pe;
      if (le === "k256")
        pe = new st();
      else if (le === "p224")
        pe = new at();
      else if (le === "p192")
        pe = new mt();
      else if (le === "p25519")
        pe = new qe();
      else
        throw new Error("Unknown prime " + le);
      return Ge[le] = pe, pe;
    };
    function ze($e) {
      if (typeof $e == "string") {
        var le = ce._prime($e);
        this.m = le.p, this.prime = le;
      } else
        fe($e.gtn(1), "modulus must be greater than 1"), this.m = $e, this.prime = null;
    }
    ze.prototype._verify1 = function(le) {
      fe(le.negative === 0, "red works only with positives"), fe(le.red, "red works only with red numbers");
    }, ze.prototype._verify2 = function(le, pe) {
      fe((le.negative | pe.negative) === 0, "red works only with positives"), fe(
        le.red && le.red === pe.red,
        "red works only with red numbers"
      );
    }, ze.prototype.imod = function(le) {
      return this.prime ? this.prime.ireduce(le)._forceRed(this) : le.umod(this.m)._forceRed(this);
    }, ze.prototype.neg = function(le) {
      return le.isZero() ? le.clone() : this.m.sub(le)._forceRed(this);
    }, ze.prototype.add = function(le, pe) {
      this._verify2(le, pe);
      var ge = le.add(pe);
      return ge.cmp(this.m) >= 0 && ge.isub(this.m), ge._forceRed(this);
    }, ze.prototype.iadd = function(le, pe) {
      this._verify2(le, pe);
      var ge = le.iadd(pe);
      return ge.cmp(this.m) >= 0 && ge.isub(this.m), ge;
    }, ze.prototype.sub = function(le, pe) {
      this._verify2(le, pe);
      var ge = le.sub(pe);
      return ge.cmpn(0) < 0 && ge.iadd(this.m), ge._forceRed(this);
    }, ze.prototype.isub = function(le, pe) {
      this._verify2(le, pe);
      var ge = le.isub(pe);
      return ge.cmpn(0) < 0 && ge.iadd(this.m), ge;
    }, ze.prototype.shl = function(le, pe) {
      return this._verify1(le), this.imod(le.ushln(pe));
    }, ze.prototype.imul = function(le, pe) {
      return this._verify2(le, pe), this.imod(le.imul(pe));
    }, ze.prototype.mul = function(le, pe) {
      return this._verify2(le, pe), this.imod(le.mul(pe));
    }, ze.prototype.isqr = function(le) {
      return this.imul(le, le.clone());
    }, ze.prototype.sqr = function(le) {
      return this.mul(le, le);
    }, ze.prototype.sqrt = function(le) {
      if (le.isZero())
        return le.clone();
      var pe = this.m.andln(3);
      if (fe(pe % 2 === 1), pe === 3) {
        var ge = this.m.add(new ce(1)).iushrn(2);
        return this.pow(le, ge);
      }
      for (var ye = this.m.subn(1), xe = 0; !ye.isZero() && ye.andln(1) === 0; )
        xe++, ye.iushrn(1);
      fe(!ye.isZero());
      var _e = new ce(1).toRed(this), Ae = _e.redNeg(), ve = this.m.subn(1).iushrn(1), he = this.m.bitLength();
      for (he = new ce(2 * he * he).toRed(this); this.pow(he, ve).cmp(Ae) !== 0; )
        he.redIAdd(Ae);
      for (var be = this.pow(he, ye), Me = this.pow(le, ye.addn(1).iushrn(1)), Re = this.pow(le, ye), Oe = xe; Re.cmp(_e) !== 0; ) {
        for (var Te = Re, Fe = 0; Te.cmp(_e) !== 0; Fe++)
          Te = Te.redSqr();
        fe(Fe < Oe);
        var je = this.pow(be, new ce(1).iushln(Oe - Fe - 1));
        Me = Me.redMul(je), be = je.redSqr(), Re = Re.redMul(be), Oe = Fe;
      }
      return Me;
    }, ze.prototype.invm = function(le) {
      var pe = le._invmp(this.m);
      return pe.negative !== 0 ? (pe.negative = 0, this.imod(pe).redNeg()) : this.imod(pe);
    }, ze.prototype.pow = function(le, pe) {
      if (pe.isZero())
        return new ce(1).toRed(this);
      if (pe.cmpn(1) === 0)
        return le.clone();
      var ge = 4, ye = new Array(1 << ge);
      ye[0] = new ce(1).toRed(this), ye[1] = le;
      for (var xe = 2; xe < ye.length; xe++)
        ye[xe] = this.mul(ye[xe - 1], le);
      var _e = ye[0], Ae = 0, ve = 0, he = pe.bitLength() % 26;
      for (he === 0 && (he = 26), xe = pe.length - 1; xe >= 0; xe--) {
        for (var be = pe.words[xe], Me = he - 1; Me >= 0; Me--) {
          var Re = be >> Me & 1;
          if (_e !== ye[0] && (_e = this.sqr(_e)), Re === 0 && Ae === 0) {
            ve = 0;
            continue;
          }
          Ae <<= 1, Ae |= Re, ve++, !(ve !== ge && (xe !== 0 || Me !== 0)) && (_e = this.mul(_e, ye[Ae]), ve = 0, Ae = 0);
        }
        he = 26;
      }
      return _e;
    }, ze.prototype.convertTo = function(le) {
      var pe = le.umod(this.m);
      return pe === le ? pe.clone() : pe;
    }, ze.prototype.convertFrom = function(le) {
      var pe = le.clone();
      return pe.red = null, pe;
    }, ce.mont = function(le) {
      return new ot(le);
    };
    function ot($e) {
      ze.call(this, $e), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new ce(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    ue(ot, ze), ot.prototype.convertTo = function(le) {
      return this.imod(le.ushln(this.shift));
    }, ot.prototype.convertFrom = function(le) {
      var pe = this.imod(le.mul(this.rinv));
      return pe.red = null, pe;
    }, ot.prototype.imul = function(le, pe) {
      if (le.isZero() || pe.isZero())
        return le.words[0] = 0, le.length = 1, le;
      var ge = le.imul(pe), ye = ge.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), xe = ge.isub(ye).iushrn(this.shift), _e = xe;
      return xe.cmp(this.m) >= 0 ? _e = xe.isub(this.m) : xe.cmpn(0) < 0 && (_e = xe.iadd(this.m)), _e._forceRed(this);
    }, ot.prototype.mul = function(le, pe) {
      if (le.isZero() || pe.isZero())
        return new ce(0)._forceRed(this);
      var ge = le.mul(pe), ye = ge.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), xe = ge.isub(ye).iushrn(this.shift), _e = xe;
      return xe.cmp(this.m) >= 0 ? _e = xe.isub(this.m) : xe.cmpn(0) < 0 && (_e = xe.iadd(this.m)), _e._forceRed(this);
    }, ot.prototype.invm = function(le) {
      var pe = this.imod(le._invmp(this.m).mul(this.r2));
      return pe._forceRed(this);
    };
  })(ae, commonjsGlobal);
})(bn$1);
var bnExports$1 = bn$1.exports, browser$4, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser$4;
  hasRequiredBrowser = 1;
  var ae = requireElliptic(), ie = bnExports$1;
  browser$4 = function(de) {
    return new fe(de);
  };
  var se = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  se.p224 = se.secp224r1, se.p256 = se.secp256r1 = se.prime256v1, se.p192 = se.secp192r1 = se.prime192v1, se.p384 = se.secp384r1, se.p521 = se.secp521r1;
  function fe(ce) {
    this.curveType = se[ce], this.curveType || (this.curveType = {
      name: ce
    }), this.curve = new ae.ec(this.curveType.name), this.keys = void 0;
  }
  fe.prototype.generateKeys = function(ce, de) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(ce, de);
  }, fe.prototype.computeSecret = function(ce, de, me) {
    de = de || "utf8", Buffer$F.isBuffer(ce) || (ce = new Buffer$F(ce, de));
    var we = this.curve.keyFromPublic(ce).getPublic(), Ee = we.mul(this.keys.getPrivate()).getX();
    return ue(Ee, me, this.curveType.byteLength);
  }, fe.prototype.getPublicKey = function(ce, de) {
    var me = this.keys.getPublic(de === "compressed", !0);
    return de === "hybrid" && (me[me.length - 1] % 2 ? me[0] = 7 : me[0] = 6), ue(me, ce);
  }, fe.prototype.getPrivateKey = function(ce) {
    return ue(this.keys.getPrivate(), ce);
  }, fe.prototype.setPublicKey = function(ce, de) {
    return de = de || "utf8", Buffer$F.isBuffer(ce) || (ce = new Buffer$F(ce, de)), this.keys._importPublic(ce), this;
  }, fe.prototype.setPrivateKey = function(ce, de) {
    de = de || "utf8", Buffer$F.isBuffer(ce) || (ce = new Buffer$F(ce, de));
    var me = new ie(ce);
    return me = me.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(me), this;
  };
  function ue(ce, de, me) {
    Array.isArray(ce) || (ce = ce.toArray());
    var we = new Buffer$F(ce);
    if (me && we.length < me) {
      var Ee = new Buffer$F(me - we.length);
      Ee.fill(0), we = Buffer$F.concat([Ee, we]);
    }
    return de ? we.toString(de) : we;
  }
  return browser$4;
}
var browser$3 = {}, createHash$2 = browser$b, Buffer$4 = safeBufferExports.Buffer, mgf$2 = function(ae, ie) {
  for (var se = Buffer$4.alloc(0), fe = 0, ue; se.length < ie; )
    ue = i2ops(fe++), se = Buffer$4.concat([se, createHash$2("sha1").update(ae).update(ue).digest()]);
  return se.slice(0, ie);
};
function i2ops(ae) {
  var ie = Buffer$4.allocUnsafe(4);
  return ie.writeUInt32BE(ae, 0), ie;
}
var xor$2 = function(ie, se) {
  for (var fe = ie.length, ue = -1; ++ue < fe; )
    ie[ue] ^= se[ue];
  return ie;
}, bn = { exports: {} };
bn.exports;
(function(ae) {
  (function(ie, se) {
    function fe($e, le) {
      if (!$e)
        throw new Error(le || "Assertion failed");
    }
    function ue($e, le) {
      $e.super_ = le;
      var pe = function() {
      };
      pe.prototype = le.prototype, $e.prototype = new pe(), $e.prototype.constructor = $e;
    }
    function ce($e, le, pe) {
      if (ce.isBN($e))
        return $e;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, $e !== null && ((le === "le" || le === "be") && (pe = le, le = 10), this._init($e || 0, le || 10, pe || "be"));
    }
    typeof ie == "object" ? ie.exports = ce : se.BN = ce, ce.BN = ce, ce.wordSize = 26;
    var de;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? de = window.Buffer : de = require$$0$2.Buffer;
    } catch {
    }
    ce.isBN = function(le) {
      return le instanceof ce ? !0 : le !== null && typeof le == "object" && le.constructor.wordSize === ce.wordSize && Array.isArray(le.words);
    }, ce.max = function(le, pe) {
      return le.cmp(pe) > 0 ? le : pe;
    }, ce.min = function(le, pe) {
      return le.cmp(pe) < 0 ? le : pe;
    }, ce.prototype._init = function(le, pe, ge) {
      if (typeof le == "number")
        return this._initNumber(le, pe, ge);
      if (typeof le == "object")
        return this._initArray(le, pe, ge);
      pe === "hex" && (pe = 16), fe(pe === (pe | 0) && pe >= 2 && pe <= 36), le = le.toString().replace(/\s+/g, "");
      var ye = 0;
      le[0] === "-" && (ye++, this.negative = 1), ye < le.length && (pe === 16 ? this._parseHex(le, ye, ge) : (this._parseBase(le, pe, ye), ge === "le" && this._initArray(this.toArray(), pe, ge)));
    }, ce.prototype._initNumber = function(le, pe, ge) {
      le < 0 && (this.negative = 1, le = -le), le < 67108864 ? (this.words = [le & 67108863], this.length = 1) : le < 4503599627370496 ? (this.words = [
        le & 67108863,
        le / 67108864 & 67108863
      ], this.length = 2) : (fe(le < 9007199254740992), this.words = [
        le & 67108863,
        le / 67108864 & 67108863,
        1
      ], this.length = 3), ge === "le" && this._initArray(this.toArray(), pe, ge);
    }, ce.prototype._initArray = function(le, pe, ge) {
      if (fe(typeof le.length == "number"), le.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(le.length / 3), this.words = new Array(this.length);
      for (var ye = 0; ye < this.length; ye++)
        this.words[ye] = 0;
      var xe, _e, Ae = 0;
      if (ge === "be")
        for (ye = le.length - 1, xe = 0; ye >= 0; ye -= 3)
          _e = le[ye] | le[ye - 1] << 8 | le[ye - 2] << 16, this.words[xe] |= _e << Ae & 67108863, this.words[xe + 1] = _e >>> 26 - Ae & 67108863, Ae += 24, Ae >= 26 && (Ae -= 26, xe++);
      else if (ge === "le")
        for (ye = 0, xe = 0; ye < le.length; ye += 3)
          _e = le[ye] | le[ye + 1] << 8 | le[ye + 2] << 16, this.words[xe] |= _e << Ae & 67108863, this.words[xe + 1] = _e >>> 26 - Ae & 67108863, Ae += 24, Ae >= 26 && (Ae -= 26, xe++);
      return this.strip();
    };
    function me($e, le) {
      var pe = $e.charCodeAt(le);
      return pe >= 65 && pe <= 70 ? pe - 55 : pe >= 97 && pe <= 102 ? pe - 87 : pe - 48 & 15;
    }
    function we($e, le, pe) {
      var ge = me($e, pe);
      return pe - 1 >= le && (ge |= me($e, pe - 1) << 4), ge;
    }
    ce.prototype._parseHex = function(le, pe, ge) {
      this.length = Math.ceil((le.length - pe) / 6), this.words = new Array(this.length);
      for (var ye = 0; ye < this.length; ye++)
        this.words[ye] = 0;
      var xe = 0, _e = 0, Ae;
      if (ge === "be")
        for (ye = le.length - 1; ye >= pe; ye -= 2)
          Ae = we(le, pe, ye) << xe, this.words[_e] |= Ae & 67108863, xe >= 18 ? (xe -= 18, _e += 1, this.words[_e] |= Ae >>> 26) : xe += 8;
      else {
        var ve = le.length - pe;
        for (ye = ve % 2 === 0 ? pe + 1 : pe; ye < le.length; ye += 2)
          Ae = we(le, pe, ye) << xe, this.words[_e] |= Ae & 67108863, xe >= 18 ? (xe -= 18, _e += 1, this.words[_e] |= Ae >>> 26) : xe += 8;
      }
      this.strip();
    };
    function Ee($e, le, pe, ge) {
      for (var ye = 0, xe = Math.min($e.length, pe), _e = le; _e < xe; _e++) {
        var Ae = $e.charCodeAt(_e) - 48;
        ye *= ge, Ae >= 49 ? ye += Ae - 49 + 10 : Ae >= 17 ? ye += Ae - 17 + 10 : ye += Ae;
      }
      return ye;
    }
    ce.prototype._parseBase = function(le, pe, ge) {
      this.words = [0], this.length = 1;
      for (var ye = 0, xe = 1; xe <= 67108863; xe *= pe)
        ye++;
      ye--, xe = xe / pe | 0;
      for (var _e = le.length - ge, Ae = _e % ye, ve = Math.min(_e, _e - Ae) + ge, he = 0, be = ge; be < ve; be += ye)
        he = Ee(le, be, be + ye, pe), this.imuln(xe), this.words[0] + he < 67108864 ? this.words[0] += he : this._iaddn(he);
      if (Ae !== 0) {
        var Me = 1;
        for (he = Ee(le, be, le.length, pe), be = 0; be < Ae; be++)
          Me *= pe;
        this.imuln(Me), this.words[0] + he < 67108864 ? this.words[0] += he : this._iaddn(he);
      }
      this.strip();
    }, ce.prototype.copy = function(le) {
      le.words = new Array(this.length);
      for (var pe = 0; pe < this.length; pe++)
        le.words[pe] = this.words[pe];
      le.length = this.length, le.negative = this.negative, le.red = this.red;
    }, ce.prototype.clone = function() {
      var le = new ce(null);
      return this.copy(le), le;
    }, ce.prototype._expand = function(le) {
      for (; this.length < le; )
        this.words[this.length++] = 0;
      return this;
    }, ce.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, ce.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, ce.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var Se = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], Be = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], Ce = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    ce.prototype.toString = function(le, pe) {
      le = le || 10, pe = pe | 0 || 1;
      var ge;
      if (le === 16 || le === "hex") {
        ge = "";
        for (var ye = 0, xe = 0, _e = 0; _e < this.length; _e++) {
          var Ae = this.words[_e], ve = ((Ae << ye | xe) & 16777215).toString(16);
          xe = Ae >>> 24 - ye & 16777215, xe !== 0 || _e !== this.length - 1 ? ge = Se[6 - ve.length] + ve + ge : ge = ve + ge, ye += 2, ye >= 26 && (ye -= 26, _e--);
        }
        for (xe !== 0 && (ge = xe.toString(16) + ge); ge.length % pe !== 0; )
          ge = "0" + ge;
        return this.negative !== 0 && (ge = "-" + ge), ge;
      }
      if (le === (le | 0) && le >= 2 && le <= 36) {
        var he = Be[le], be = Ce[le];
        ge = "";
        var Me = this.clone();
        for (Me.negative = 0; !Me.isZero(); ) {
          var Re = Me.modn(be).toString(le);
          Me = Me.idivn(be), Me.isZero() ? ge = Re + ge : ge = Se[he - Re.length] + Re + ge;
        }
        for (this.isZero() && (ge = "0" + ge); ge.length % pe !== 0; )
          ge = "0" + ge;
        return this.negative !== 0 && (ge = "-" + ge), ge;
      }
      fe(!1, "Base should be between 2 and 36");
    }, ce.prototype.toNumber = function() {
      var le = this.words[0];
      return this.length === 2 ? le += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? le += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && fe(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -le : le;
    }, ce.prototype.toJSON = function() {
      return this.toString(16);
    }, ce.prototype.toBuffer = function(le, pe) {
      return fe(typeof de < "u"), this.toArrayLike(de, le, pe);
    }, ce.prototype.toArray = function(le, pe) {
      return this.toArrayLike(Array, le, pe);
    }, ce.prototype.toArrayLike = function(le, pe, ge) {
      var ye = this.byteLength(), xe = ge || Math.max(1, ye);
      fe(ye <= xe, "byte array longer than desired length"), fe(xe > 0, "Requested array length <= 0"), this.strip();
      var _e = pe === "le", Ae = new le(xe), ve, he, be = this.clone();
      if (_e) {
        for (he = 0; !be.isZero(); he++)
          ve = be.andln(255), be.iushrn(8), Ae[he] = ve;
        for (; he < xe; he++)
          Ae[he] = 0;
      } else {
        for (he = 0; he < xe - ye; he++)
          Ae[he] = 0;
        for (he = 0; !be.isZero(); he++)
          ve = be.andln(255), be.iushrn(8), Ae[xe - he - 1] = ve;
      }
      return Ae;
    }, Math.clz32 ? ce.prototype._countBits = function(le) {
      return 32 - Math.clz32(le);
    } : ce.prototype._countBits = function(le) {
      var pe = le, ge = 0;
      return pe >= 4096 && (ge += 13, pe >>>= 13), pe >= 64 && (ge += 7, pe >>>= 7), pe >= 8 && (ge += 4, pe >>>= 4), pe >= 2 && (ge += 2, pe >>>= 2), ge + pe;
    }, ce.prototype._zeroBits = function(le) {
      if (le === 0)
        return 26;
      var pe = le, ge = 0;
      return pe & 8191 || (ge += 13, pe >>>= 13), pe & 127 || (ge += 7, pe >>>= 7), pe & 15 || (ge += 4, pe >>>= 4), pe & 3 || (ge += 2, pe >>>= 2), pe & 1 || ge++, ge;
    }, ce.prototype.bitLength = function() {
      var le = this.words[this.length - 1], pe = this._countBits(le);
      return (this.length - 1) * 26 + pe;
    };
    function Ie($e) {
      for (var le = new Array($e.bitLength()), pe = 0; pe < le.length; pe++) {
        var ge = pe / 26 | 0, ye = pe % 26;
        le[pe] = ($e.words[ge] & 1 << ye) >>> ye;
      }
      return le;
    }
    ce.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var le = 0, pe = 0; pe < this.length; pe++) {
        var ge = this._zeroBits(this.words[pe]);
        if (le += ge, ge !== 26)
          break;
      }
      return le;
    }, ce.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, ce.prototype.toTwos = function(le) {
      return this.negative !== 0 ? this.abs().inotn(le).iaddn(1) : this.clone();
    }, ce.prototype.fromTwos = function(le) {
      return this.testn(le - 1) ? this.notn(le).iaddn(1).ineg() : this.clone();
    }, ce.prototype.isNeg = function() {
      return this.negative !== 0;
    }, ce.prototype.neg = function() {
      return this.clone().ineg();
    }, ce.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, ce.prototype.iuor = function(le) {
      for (; this.length < le.length; )
        this.words[this.length++] = 0;
      for (var pe = 0; pe < le.length; pe++)
        this.words[pe] = this.words[pe] | le.words[pe];
      return this.strip();
    }, ce.prototype.ior = function(le) {
      return fe((this.negative | le.negative) === 0), this.iuor(le);
    }, ce.prototype.or = function(le) {
      return this.length > le.length ? this.clone().ior(le) : le.clone().ior(this);
    }, ce.prototype.uor = function(le) {
      return this.length > le.length ? this.clone().iuor(le) : le.clone().iuor(this);
    }, ce.prototype.iuand = function(le) {
      var pe;
      this.length > le.length ? pe = le : pe = this;
      for (var ge = 0; ge < pe.length; ge++)
        this.words[ge] = this.words[ge] & le.words[ge];
      return this.length = pe.length, this.strip();
    }, ce.prototype.iand = function(le) {
      return fe((this.negative | le.negative) === 0), this.iuand(le);
    }, ce.prototype.and = function(le) {
      return this.length > le.length ? this.clone().iand(le) : le.clone().iand(this);
    }, ce.prototype.uand = function(le) {
      return this.length > le.length ? this.clone().iuand(le) : le.clone().iuand(this);
    }, ce.prototype.iuxor = function(le) {
      var pe, ge;
      this.length > le.length ? (pe = this, ge = le) : (pe = le, ge = this);
      for (var ye = 0; ye < ge.length; ye++)
        this.words[ye] = pe.words[ye] ^ ge.words[ye];
      if (this !== pe)
        for (; ye < pe.length; ye++)
          this.words[ye] = pe.words[ye];
      return this.length = pe.length, this.strip();
    }, ce.prototype.ixor = function(le) {
      return fe((this.negative | le.negative) === 0), this.iuxor(le);
    }, ce.prototype.xor = function(le) {
      return this.length > le.length ? this.clone().ixor(le) : le.clone().ixor(this);
    }, ce.prototype.uxor = function(le) {
      return this.length > le.length ? this.clone().iuxor(le) : le.clone().iuxor(this);
    }, ce.prototype.inotn = function(le) {
      fe(typeof le == "number" && le >= 0);
      var pe = Math.ceil(le / 26) | 0, ge = le % 26;
      this._expand(pe), ge > 0 && pe--;
      for (var ye = 0; ye < pe; ye++)
        this.words[ye] = ~this.words[ye] & 67108863;
      return ge > 0 && (this.words[ye] = ~this.words[ye] & 67108863 >> 26 - ge), this.strip();
    }, ce.prototype.notn = function(le) {
      return this.clone().inotn(le);
    }, ce.prototype.setn = function(le, pe) {
      fe(typeof le == "number" && le >= 0);
      var ge = le / 26 | 0, ye = le % 26;
      return this._expand(ge + 1), pe ? this.words[ge] = this.words[ge] | 1 << ye : this.words[ge] = this.words[ge] & ~(1 << ye), this.strip();
    }, ce.prototype.iadd = function(le) {
      var pe;
      if (this.negative !== 0 && le.negative === 0)
        return this.negative = 0, pe = this.isub(le), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && le.negative !== 0)
        return le.negative = 0, pe = this.isub(le), le.negative = 1, pe._normSign();
      var ge, ye;
      this.length > le.length ? (ge = this, ye = le) : (ge = le, ye = this);
      for (var xe = 0, _e = 0; _e < ye.length; _e++)
        pe = (ge.words[_e] | 0) + (ye.words[_e] | 0) + xe, this.words[_e] = pe & 67108863, xe = pe >>> 26;
      for (; xe !== 0 && _e < ge.length; _e++)
        pe = (ge.words[_e] | 0) + xe, this.words[_e] = pe & 67108863, xe = pe >>> 26;
      if (this.length = ge.length, xe !== 0)
        this.words[this.length] = xe, this.length++;
      else if (ge !== this)
        for (; _e < ge.length; _e++)
          this.words[_e] = ge.words[_e];
      return this;
    }, ce.prototype.add = function(le) {
      var pe;
      return le.negative !== 0 && this.negative === 0 ? (le.negative = 0, pe = this.sub(le), le.negative ^= 1, pe) : le.negative === 0 && this.negative !== 0 ? (this.negative = 0, pe = le.sub(this), this.negative = 1, pe) : this.length > le.length ? this.clone().iadd(le) : le.clone().iadd(this);
    }, ce.prototype.isub = function(le) {
      if (le.negative !== 0) {
        le.negative = 0;
        var pe = this.iadd(le);
        return le.negative = 1, pe._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(le), this.negative = 1, this._normSign();
      var ge = this.cmp(le);
      if (ge === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var ye, xe;
      ge > 0 ? (ye = this, xe = le) : (ye = le, xe = this);
      for (var _e = 0, Ae = 0; Ae < xe.length; Ae++)
        pe = (ye.words[Ae] | 0) - (xe.words[Ae] | 0) + _e, _e = pe >> 26, this.words[Ae] = pe & 67108863;
      for (; _e !== 0 && Ae < ye.length; Ae++)
        pe = (ye.words[Ae] | 0) + _e, _e = pe >> 26, this.words[Ae] = pe & 67108863;
      if (_e === 0 && Ae < ye.length && ye !== this)
        for (; Ae < ye.length; Ae++)
          this.words[Ae] = ye.words[Ae];
      return this.length = Math.max(this.length, Ae), ye !== this && (this.negative = 1), this.strip();
    }, ce.prototype.sub = function(le) {
      return this.clone().isub(le);
    };
    function Pe($e, le, pe) {
      pe.negative = le.negative ^ $e.negative;
      var ge = $e.length + le.length | 0;
      pe.length = ge, ge = ge - 1 | 0;
      var ye = $e.words[0] | 0, xe = le.words[0] | 0, _e = ye * xe, Ae = _e & 67108863, ve = _e / 67108864 | 0;
      pe.words[0] = Ae;
      for (var he = 1; he < ge; he++) {
        for (var be = ve >>> 26, Me = ve & 67108863, Re = Math.min(he, le.length - 1), Oe = Math.max(0, he - $e.length + 1); Oe <= Re; Oe++) {
          var Te = he - Oe | 0;
          ye = $e.words[Te] | 0, xe = le.words[Oe] | 0, _e = ye * xe + Me, be += _e / 67108864 | 0, Me = _e & 67108863;
        }
        pe.words[he] = Me | 0, ve = be | 0;
      }
      return ve !== 0 ? pe.words[he] = ve | 0 : pe.length--, pe.strip();
    }
    var Ne = function(le, pe, ge) {
      var ye = le.words, xe = pe.words, _e = ge.words, Ae = 0, ve, he, be, Me = ye[0] | 0, Re = Me & 8191, Oe = Me >>> 13, Te = ye[1] | 0, Fe = Te & 8191, je = Te >>> 13, ct = ye[2] | 0, nt = ct & 8191, dt = ct >>> 13, it = ye[3] | 0, Je = it & 8191, gt = it >>> 13, Ht = ye[4] | 0, $t = Ht & 8191, Lt = Ht >>> 13, Tr = ye[5] | 0, Zt = Tr & 8191, wt = Tr >>> 13, Hr = ye[6] | 0, tr = Hr & 8191, cr = Hr >>> 13, qr = ye[7] | 0, Wt = qr & 8191, ar = qr >>> 13, Dr = ye[8] | 0, Jt = Dr & 8191, ir = Dr >>> 13, Gr = ye[9] | 0, We = Gr & 8191, Le = Gr >>> 13, Ke = xe[0] | 0, rt = Ke & 8191, lt = Ke >>> 13, It = xe[1] | 0, yt = It & 8191, jt = It >>> 13, Lr = xe[2] | 0, zt = Lr & 8191, rr = Lr >>> 13, Cr = xe[3] | 0, fr = Cr & 8191, pr = Cr >>> 13, jr = xe[4] | 0, nr = jr & 8191, ur = jr >>> 13, Wr = xe[5] | 0, or = Wr & 8191, lr = Wr >>> 13, Zr = xe[6] | 0, Xt = Zr & 8191, dr = Zr >>> 13, Ve = xe[7] | 0, Ze = Ve & 8191, Xe = Ve >>> 13, Ue = xe[8] | 0, Qe = Ue & 8191, pt = Ue >>> 13, Ct = xe[9] | 0, bt = Ct & 8191, Tt = Ct >>> 13;
      ge.negative = le.negative ^ pe.negative, ge.length = 19, ve = Math.imul(Re, rt), he = Math.imul(Re, lt), he = he + Math.imul(Oe, rt) | 0, be = Math.imul(Oe, lt);
      var br = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (br >>> 26) | 0, br &= 67108863, ve = Math.imul(Fe, rt), he = Math.imul(Fe, lt), he = he + Math.imul(je, rt) | 0, be = Math.imul(je, lt), ve = ve + Math.imul(Re, yt) | 0, he = he + Math.imul(Re, jt) | 0, he = he + Math.imul(Oe, yt) | 0, be = be + Math.imul(Oe, jt) | 0;
      var gr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (gr >>> 26) | 0, gr &= 67108863, ve = Math.imul(nt, rt), he = Math.imul(nt, lt), he = he + Math.imul(dt, rt) | 0, be = Math.imul(dt, lt), ve = ve + Math.imul(Fe, yt) | 0, he = he + Math.imul(Fe, jt) | 0, he = he + Math.imul(je, yt) | 0, be = be + Math.imul(je, jt) | 0, ve = ve + Math.imul(Re, zt) | 0, he = he + Math.imul(Re, rr) | 0, he = he + Math.imul(Oe, zt) | 0, be = be + Math.imul(Oe, rr) | 0;
      var Fr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, ve = Math.imul(Je, rt), he = Math.imul(Je, lt), he = he + Math.imul(gt, rt) | 0, be = Math.imul(gt, lt), ve = ve + Math.imul(nt, yt) | 0, he = he + Math.imul(nt, jt) | 0, he = he + Math.imul(dt, yt) | 0, be = be + Math.imul(dt, jt) | 0, ve = ve + Math.imul(Fe, zt) | 0, he = he + Math.imul(Fe, rr) | 0, he = he + Math.imul(je, zt) | 0, be = be + Math.imul(je, rr) | 0, ve = ve + Math.imul(Re, fr) | 0, he = he + Math.imul(Re, pr) | 0, he = he + Math.imul(Oe, fr) | 0, be = be + Math.imul(Oe, pr) | 0;
      var wr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (wr >>> 26) | 0, wr &= 67108863, ve = Math.imul($t, rt), he = Math.imul($t, lt), he = he + Math.imul(Lt, rt) | 0, be = Math.imul(Lt, lt), ve = ve + Math.imul(Je, yt) | 0, he = he + Math.imul(Je, jt) | 0, he = he + Math.imul(gt, yt) | 0, be = be + Math.imul(gt, jt) | 0, ve = ve + Math.imul(nt, zt) | 0, he = he + Math.imul(nt, rr) | 0, he = he + Math.imul(dt, zt) | 0, be = be + Math.imul(dt, rr) | 0, ve = ve + Math.imul(Fe, fr) | 0, he = he + Math.imul(Fe, pr) | 0, he = he + Math.imul(je, fr) | 0, be = be + Math.imul(je, pr) | 0, ve = ve + Math.imul(Re, nr) | 0, he = he + Math.imul(Re, ur) | 0, he = he + Math.imul(Oe, nr) | 0, be = be + Math.imul(Oe, ur) | 0;
      var Rr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Rr >>> 26) | 0, Rr &= 67108863, ve = Math.imul(Zt, rt), he = Math.imul(Zt, lt), he = he + Math.imul(wt, rt) | 0, be = Math.imul(wt, lt), ve = ve + Math.imul($t, yt) | 0, he = he + Math.imul($t, jt) | 0, he = he + Math.imul(Lt, yt) | 0, be = be + Math.imul(Lt, jt) | 0, ve = ve + Math.imul(Je, zt) | 0, he = he + Math.imul(Je, rr) | 0, he = he + Math.imul(gt, zt) | 0, be = be + Math.imul(gt, rr) | 0, ve = ve + Math.imul(nt, fr) | 0, he = he + Math.imul(nt, pr) | 0, he = he + Math.imul(dt, fr) | 0, be = be + Math.imul(dt, pr) | 0, ve = ve + Math.imul(Fe, nr) | 0, he = he + Math.imul(Fe, ur) | 0, he = he + Math.imul(je, nr) | 0, be = be + Math.imul(je, ur) | 0, ve = ve + Math.imul(Re, or) | 0, he = he + Math.imul(Re, lr) | 0, he = he + Math.imul(Oe, or) | 0, be = be + Math.imul(Oe, lr) | 0;
      var kr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (kr >>> 26) | 0, kr &= 67108863, ve = Math.imul(tr, rt), he = Math.imul(tr, lt), he = he + Math.imul(cr, rt) | 0, be = Math.imul(cr, lt), ve = ve + Math.imul(Zt, yt) | 0, he = he + Math.imul(Zt, jt) | 0, he = he + Math.imul(wt, yt) | 0, be = be + Math.imul(wt, jt) | 0, ve = ve + Math.imul($t, zt) | 0, he = he + Math.imul($t, rr) | 0, he = he + Math.imul(Lt, zt) | 0, be = be + Math.imul(Lt, rr) | 0, ve = ve + Math.imul(Je, fr) | 0, he = he + Math.imul(Je, pr) | 0, he = he + Math.imul(gt, fr) | 0, be = be + Math.imul(gt, pr) | 0, ve = ve + Math.imul(nt, nr) | 0, he = he + Math.imul(nt, ur) | 0, he = he + Math.imul(dt, nr) | 0, be = be + Math.imul(dt, ur) | 0, ve = ve + Math.imul(Fe, or) | 0, he = he + Math.imul(Fe, lr) | 0, he = he + Math.imul(je, or) | 0, be = be + Math.imul(je, lr) | 0, ve = ve + Math.imul(Re, Xt) | 0, he = he + Math.imul(Re, dr) | 0, he = he + Math.imul(Oe, Xt) | 0, be = be + Math.imul(Oe, dr) | 0;
      var Pr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, ve = Math.imul(Wt, rt), he = Math.imul(Wt, lt), he = he + Math.imul(ar, rt) | 0, be = Math.imul(ar, lt), ve = ve + Math.imul(tr, yt) | 0, he = he + Math.imul(tr, jt) | 0, he = he + Math.imul(cr, yt) | 0, be = be + Math.imul(cr, jt) | 0, ve = ve + Math.imul(Zt, zt) | 0, he = he + Math.imul(Zt, rr) | 0, he = he + Math.imul(wt, zt) | 0, be = be + Math.imul(wt, rr) | 0, ve = ve + Math.imul($t, fr) | 0, he = he + Math.imul($t, pr) | 0, he = he + Math.imul(Lt, fr) | 0, be = be + Math.imul(Lt, pr) | 0, ve = ve + Math.imul(Je, nr) | 0, he = he + Math.imul(Je, ur) | 0, he = he + Math.imul(gt, nr) | 0, be = be + Math.imul(gt, ur) | 0, ve = ve + Math.imul(nt, or) | 0, he = he + Math.imul(nt, lr) | 0, he = he + Math.imul(dt, or) | 0, be = be + Math.imul(dt, lr) | 0, ve = ve + Math.imul(Fe, Xt) | 0, he = he + Math.imul(Fe, dr) | 0, he = he + Math.imul(je, Xt) | 0, be = be + Math.imul(je, dr) | 0, ve = ve + Math.imul(Re, Ze) | 0, he = he + Math.imul(Re, Xe) | 0, he = he + Math.imul(Oe, Ze) | 0, be = be + Math.imul(Oe, Xe) | 0;
      var Ur = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, ve = Math.imul(Jt, rt), he = Math.imul(Jt, lt), he = he + Math.imul(ir, rt) | 0, be = Math.imul(ir, lt), ve = ve + Math.imul(Wt, yt) | 0, he = he + Math.imul(Wt, jt) | 0, he = he + Math.imul(ar, yt) | 0, be = be + Math.imul(ar, jt) | 0, ve = ve + Math.imul(tr, zt) | 0, he = he + Math.imul(tr, rr) | 0, he = he + Math.imul(cr, zt) | 0, be = be + Math.imul(cr, rr) | 0, ve = ve + Math.imul(Zt, fr) | 0, he = he + Math.imul(Zt, pr) | 0, he = he + Math.imul(wt, fr) | 0, be = be + Math.imul(wt, pr) | 0, ve = ve + Math.imul($t, nr) | 0, he = he + Math.imul($t, ur) | 0, he = he + Math.imul(Lt, nr) | 0, be = be + Math.imul(Lt, ur) | 0, ve = ve + Math.imul(Je, or) | 0, he = he + Math.imul(Je, lr) | 0, he = he + Math.imul(gt, or) | 0, be = be + Math.imul(gt, lr) | 0, ve = ve + Math.imul(nt, Xt) | 0, he = he + Math.imul(nt, dr) | 0, he = he + Math.imul(dt, Xt) | 0, be = be + Math.imul(dt, dr) | 0, ve = ve + Math.imul(Fe, Ze) | 0, he = he + Math.imul(Fe, Xe) | 0, he = he + Math.imul(je, Ze) | 0, be = be + Math.imul(je, Xe) | 0, ve = ve + Math.imul(Re, Qe) | 0, he = he + Math.imul(Re, pt) | 0, he = he + Math.imul(Oe, Qe) | 0, be = be + Math.imul(Oe, pt) | 0;
      var Ir = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Ir >>> 26) | 0, Ir &= 67108863, ve = Math.imul(We, rt), he = Math.imul(We, lt), he = he + Math.imul(Le, rt) | 0, be = Math.imul(Le, lt), ve = ve + Math.imul(Jt, yt) | 0, he = he + Math.imul(Jt, jt) | 0, he = he + Math.imul(ir, yt) | 0, be = be + Math.imul(ir, jt) | 0, ve = ve + Math.imul(Wt, zt) | 0, he = he + Math.imul(Wt, rr) | 0, he = he + Math.imul(ar, zt) | 0, be = be + Math.imul(ar, rr) | 0, ve = ve + Math.imul(tr, fr) | 0, he = he + Math.imul(tr, pr) | 0, he = he + Math.imul(cr, fr) | 0, be = be + Math.imul(cr, pr) | 0, ve = ve + Math.imul(Zt, nr) | 0, he = he + Math.imul(Zt, ur) | 0, he = he + Math.imul(wt, nr) | 0, be = be + Math.imul(wt, ur) | 0, ve = ve + Math.imul($t, or) | 0, he = he + Math.imul($t, lr) | 0, he = he + Math.imul(Lt, or) | 0, be = be + Math.imul(Lt, lr) | 0, ve = ve + Math.imul(Je, Xt) | 0, he = he + Math.imul(Je, dr) | 0, he = he + Math.imul(gt, Xt) | 0, be = be + Math.imul(gt, dr) | 0, ve = ve + Math.imul(nt, Ze) | 0, he = he + Math.imul(nt, Xe) | 0, he = he + Math.imul(dt, Ze) | 0, be = be + Math.imul(dt, Xe) | 0, ve = ve + Math.imul(Fe, Qe) | 0, he = he + Math.imul(Fe, pt) | 0, he = he + Math.imul(je, Qe) | 0, be = be + Math.imul(je, pt) | 0, ve = ve + Math.imul(Re, bt) | 0, he = he + Math.imul(Re, Tt) | 0, he = he + Math.imul(Oe, bt) | 0, be = be + Math.imul(Oe, Tt) | 0;
      var Or = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Or >>> 26) | 0, Or &= 67108863, ve = Math.imul(We, yt), he = Math.imul(We, jt), he = he + Math.imul(Le, yt) | 0, be = Math.imul(Le, jt), ve = ve + Math.imul(Jt, zt) | 0, he = he + Math.imul(Jt, rr) | 0, he = he + Math.imul(ir, zt) | 0, be = be + Math.imul(ir, rr) | 0, ve = ve + Math.imul(Wt, fr) | 0, he = he + Math.imul(Wt, pr) | 0, he = he + Math.imul(ar, fr) | 0, be = be + Math.imul(ar, pr) | 0, ve = ve + Math.imul(tr, nr) | 0, he = he + Math.imul(tr, ur) | 0, he = he + Math.imul(cr, nr) | 0, be = be + Math.imul(cr, ur) | 0, ve = ve + Math.imul(Zt, or) | 0, he = he + Math.imul(Zt, lr) | 0, he = he + Math.imul(wt, or) | 0, be = be + Math.imul(wt, lr) | 0, ve = ve + Math.imul($t, Xt) | 0, he = he + Math.imul($t, dr) | 0, he = he + Math.imul(Lt, Xt) | 0, be = be + Math.imul(Lt, dr) | 0, ve = ve + Math.imul(Je, Ze) | 0, he = he + Math.imul(Je, Xe) | 0, he = he + Math.imul(gt, Ze) | 0, be = be + Math.imul(gt, Xe) | 0, ve = ve + Math.imul(nt, Qe) | 0, he = he + Math.imul(nt, pt) | 0, he = he + Math.imul(dt, Qe) | 0, be = be + Math.imul(dt, pt) | 0, ve = ve + Math.imul(Fe, bt) | 0, he = he + Math.imul(Fe, Tt) | 0, he = he + Math.imul(je, bt) | 0, be = be + Math.imul(je, Tt) | 0;
      var Nr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Nr >>> 26) | 0, Nr &= 67108863, ve = Math.imul(We, zt), he = Math.imul(We, rr), he = he + Math.imul(Le, zt) | 0, be = Math.imul(Le, rr), ve = ve + Math.imul(Jt, fr) | 0, he = he + Math.imul(Jt, pr) | 0, he = he + Math.imul(ir, fr) | 0, be = be + Math.imul(ir, pr) | 0, ve = ve + Math.imul(Wt, nr) | 0, he = he + Math.imul(Wt, ur) | 0, he = he + Math.imul(ar, nr) | 0, be = be + Math.imul(ar, ur) | 0, ve = ve + Math.imul(tr, or) | 0, he = he + Math.imul(tr, lr) | 0, he = he + Math.imul(cr, or) | 0, be = be + Math.imul(cr, lr) | 0, ve = ve + Math.imul(Zt, Xt) | 0, he = he + Math.imul(Zt, dr) | 0, he = he + Math.imul(wt, Xt) | 0, be = be + Math.imul(wt, dr) | 0, ve = ve + Math.imul($t, Ze) | 0, he = he + Math.imul($t, Xe) | 0, he = he + Math.imul(Lt, Ze) | 0, be = be + Math.imul(Lt, Xe) | 0, ve = ve + Math.imul(Je, Qe) | 0, he = he + Math.imul(Je, pt) | 0, he = he + Math.imul(gt, Qe) | 0, be = be + Math.imul(gt, pt) | 0, ve = ve + Math.imul(nt, bt) | 0, he = he + Math.imul(nt, Tt) | 0, he = he + Math.imul(dt, bt) | 0, be = be + Math.imul(dt, Tt) | 0;
      var Er = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, ve = Math.imul(We, fr), he = Math.imul(We, pr), he = he + Math.imul(Le, fr) | 0, be = Math.imul(Le, pr), ve = ve + Math.imul(Jt, nr) | 0, he = he + Math.imul(Jt, ur) | 0, he = he + Math.imul(ir, nr) | 0, be = be + Math.imul(ir, ur) | 0, ve = ve + Math.imul(Wt, or) | 0, he = he + Math.imul(Wt, lr) | 0, he = he + Math.imul(ar, or) | 0, be = be + Math.imul(ar, lr) | 0, ve = ve + Math.imul(tr, Xt) | 0, he = he + Math.imul(tr, dr) | 0, he = he + Math.imul(cr, Xt) | 0, be = be + Math.imul(cr, dr) | 0, ve = ve + Math.imul(Zt, Ze) | 0, he = he + Math.imul(Zt, Xe) | 0, he = he + Math.imul(wt, Ze) | 0, be = be + Math.imul(wt, Xe) | 0, ve = ve + Math.imul($t, Qe) | 0, he = he + Math.imul($t, pt) | 0, he = he + Math.imul(Lt, Qe) | 0, be = be + Math.imul(Lt, pt) | 0, ve = ve + Math.imul(Je, bt) | 0, he = he + Math.imul(Je, Tt) | 0, he = he + Math.imul(gt, bt) | 0, be = be + Math.imul(gt, Tt) | 0;
      var Br = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Br >>> 26) | 0, Br &= 67108863, ve = Math.imul(We, nr), he = Math.imul(We, ur), he = he + Math.imul(Le, nr) | 0, be = Math.imul(Le, ur), ve = ve + Math.imul(Jt, or) | 0, he = he + Math.imul(Jt, lr) | 0, he = he + Math.imul(ir, or) | 0, be = be + Math.imul(ir, lr) | 0, ve = ve + Math.imul(Wt, Xt) | 0, he = he + Math.imul(Wt, dr) | 0, he = he + Math.imul(ar, Xt) | 0, be = be + Math.imul(ar, dr) | 0, ve = ve + Math.imul(tr, Ze) | 0, he = he + Math.imul(tr, Xe) | 0, he = he + Math.imul(cr, Ze) | 0, be = be + Math.imul(cr, Xe) | 0, ve = ve + Math.imul(Zt, Qe) | 0, he = he + Math.imul(Zt, pt) | 0, he = he + Math.imul(wt, Qe) | 0, be = be + Math.imul(wt, pt) | 0, ve = ve + Math.imul($t, bt) | 0, he = he + Math.imul($t, Tt) | 0, he = he + Math.imul(Lt, bt) | 0, be = be + Math.imul(Lt, Tt) | 0;
      var _r = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (_r >>> 26) | 0, _r &= 67108863, ve = Math.imul(We, or), he = Math.imul(We, lr), he = he + Math.imul(Le, or) | 0, be = Math.imul(Le, lr), ve = ve + Math.imul(Jt, Xt) | 0, he = he + Math.imul(Jt, dr) | 0, he = he + Math.imul(ir, Xt) | 0, be = be + Math.imul(ir, dr) | 0, ve = ve + Math.imul(Wt, Ze) | 0, he = he + Math.imul(Wt, Xe) | 0, he = he + Math.imul(ar, Ze) | 0, be = be + Math.imul(ar, Xe) | 0, ve = ve + Math.imul(tr, Qe) | 0, he = he + Math.imul(tr, pt) | 0, he = he + Math.imul(cr, Qe) | 0, be = be + Math.imul(cr, pt) | 0, ve = ve + Math.imul(Zt, bt) | 0, he = he + Math.imul(Zt, Tt) | 0, he = he + Math.imul(wt, bt) | 0, be = be + Math.imul(wt, Tt) | 0;
      var Sr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Sr >>> 26) | 0, Sr &= 67108863, ve = Math.imul(We, Xt), he = Math.imul(We, dr), he = he + Math.imul(Le, Xt) | 0, be = Math.imul(Le, dr), ve = ve + Math.imul(Jt, Ze) | 0, he = he + Math.imul(Jt, Xe) | 0, he = he + Math.imul(ir, Ze) | 0, be = be + Math.imul(ir, Xe) | 0, ve = ve + Math.imul(Wt, Qe) | 0, he = he + Math.imul(Wt, pt) | 0, he = he + Math.imul(ar, Qe) | 0, be = be + Math.imul(ar, pt) | 0, ve = ve + Math.imul(tr, bt) | 0, he = he + Math.imul(tr, Tt) | 0, he = he + Math.imul(cr, bt) | 0, be = be + Math.imul(cr, Tt) | 0;
      var Mr = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Mr >>> 26) | 0, Mr &= 67108863, ve = Math.imul(We, Ze), he = Math.imul(We, Xe), he = he + Math.imul(Le, Ze) | 0, be = Math.imul(Le, Xe), ve = ve + Math.imul(Jt, Qe) | 0, he = he + Math.imul(Jt, pt) | 0, he = he + Math.imul(ir, Qe) | 0, be = be + Math.imul(ir, pt) | 0, ve = ve + Math.imul(Wt, bt) | 0, he = he + Math.imul(Wt, Tt) | 0, he = he + Math.imul(ar, bt) | 0, be = be + Math.imul(ar, Tt) | 0;
      var $r = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + ($r >>> 26) | 0, $r &= 67108863, ve = Math.imul(We, Qe), he = Math.imul(We, pt), he = he + Math.imul(Le, Qe) | 0, be = Math.imul(Le, pt), ve = ve + Math.imul(Jt, bt) | 0, he = he + Math.imul(Jt, Tt) | 0, he = he + Math.imul(ir, bt) | 0, be = be + Math.imul(ir, Tt) | 0;
      var Yt = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      Ae = (be + (he >>> 13) | 0) + (Yt >>> 26) | 0, Yt &= 67108863, ve = Math.imul(We, bt), he = Math.imul(We, Tt), he = he + Math.imul(Le, bt) | 0, be = Math.imul(Le, Tt);
      var er = (Ae + ve | 0) + ((he & 8191) << 13) | 0;
      return Ae = (be + (he >>> 13) | 0) + (er >>> 26) | 0, er &= 67108863, _e[0] = br, _e[1] = gr, _e[2] = Fr, _e[3] = wr, _e[4] = Rr, _e[5] = kr, _e[6] = Pr, _e[7] = Ur, _e[8] = Ir, _e[9] = Or, _e[10] = Nr, _e[11] = Er, _e[12] = Br, _e[13] = _r, _e[14] = Sr, _e[15] = Mr, _e[16] = $r, _e[17] = Yt, _e[18] = er, Ae !== 0 && (_e[19] = Ae, ge.length++), ge;
    };
    Math.imul || (Ne = Pe);
    function ke($e, le, pe) {
      pe.negative = le.negative ^ $e.negative, pe.length = $e.length + le.length;
      for (var ge = 0, ye = 0, xe = 0; xe < pe.length - 1; xe++) {
        var _e = ye;
        ye = 0;
        for (var Ae = ge & 67108863, ve = Math.min(xe, le.length - 1), he = Math.max(0, xe - $e.length + 1); he <= ve; he++) {
          var be = xe - he, Me = $e.words[be] | 0, Re = le.words[he] | 0, Oe = Me * Re, Te = Oe & 67108863;
          _e = _e + (Oe / 67108864 | 0) | 0, Te = Te + Ae | 0, Ae = Te & 67108863, _e = _e + (Te >>> 26) | 0, ye += _e >>> 26, _e &= 67108863;
        }
        pe.words[xe] = Ae, ge = _e, _e = ye;
      }
      return ge !== 0 ? pe.words[xe] = ge : pe.length--, pe.strip();
    }
    function He($e, le, pe) {
      var ge = new De();
      return ge.mulp($e, le, pe);
    }
    ce.prototype.mulTo = function(le, pe) {
      var ge, ye = this.length + le.length;
      return this.length === 10 && le.length === 10 ? ge = Ne(this, le, pe) : ye < 63 ? ge = Pe(this, le, pe) : ye < 1024 ? ge = ke(this, le, pe) : ge = He(this, le, pe), ge;
    };
    function De($e, le) {
      this.x = $e, this.y = le;
    }
    De.prototype.makeRBT = function(le) {
      for (var pe = new Array(le), ge = ce.prototype._countBits(le) - 1, ye = 0; ye < le; ye++)
        pe[ye] = this.revBin(ye, ge, le);
      return pe;
    }, De.prototype.revBin = function(le, pe, ge) {
      if (le === 0 || le === ge - 1)
        return le;
      for (var ye = 0, xe = 0; xe < pe; xe++)
        ye |= (le & 1) << pe - xe - 1, le >>= 1;
      return ye;
    }, De.prototype.permute = function(le, pe, ge, ye, xe, _e) {
      for (var Ae = 0; Ae < _e; Ae++)
        ye[Ae] = pe[le[Ae]], xe[Ae] = ge[le[Ae]];
    }, De.prototype.transform = function(le, pe, ge, ye, xe, _e) {
      this.permute(_e, le, pe, ge, ye, xe);
      for (var Ae = 1; Ae < xe; Ae <<= 1)
        for (var ve = Ae << 1, he = Math.cos(2 * Math.PI / ve), be = Math.sin(2 * Math.PI / ve), Me = 0; Me < xe; Me += ve)
          for (var Re = he, Oe = be, Te = 0; Te < Ae; Te++) {
            var Fe = ge[Me + Te], je = ye[Me + Te], ct = ge[Me + Te + Ae], nt = ye[Me + Te + Ae], dt = Re * ct - Oe * nt;
            nt = Re * nt + Oe * ct, ct = dt, ge[Me + Te] = Fe + ct, ye[Me + Te] = je + nt, ge[Me + Te + Ae] = Fe - ct, ye[Me + Te + Ae] = je - nt, Te !== ve && (dt = he * Re - be * Oe, Oe = he * Oe + be * Re, Re = dt);
          }
    }, De.prototype.guessLen13b = function(le, pe) {
      var ge = Math.max(pe, le) | 1, ye = ge & 1, xe = 0;
      for (ge = ge / 2 | 0; ge; ge = ge >>> 1)
        xe++;
      return 1 << xe + 1 + ye;
    }, De.prototype.conjugate = function(le, pe, ge) {
      if (!(ge <= 1))
        for (var ye = 0; ye < ge / 2; ye++) {
          var xe = le[ye];
          le[ye] = le[ge - ye - 1], le[ge - ye - 1] = xe, xe = pe[ye], pe[ye] = -pe[ge - ye - 1], pe[ge - ye - 1] = -xe;
        }
    }, De.prototype.normalize13b = function(le, pe) {
      for (var ge = 0, ye = 0; ye < pe / 2; ye++) {
        var xe = Math.round(le[2 * ye + 1] / pe) * 8192 + Math.round(le[2 * ye] / pe) + ge;
        le[ye] = xe & 67108863, xe < 67108864 ? ge = 0 : ge = xe / 67108864 | 0;
      }
      return le;
    }, De.prototype.convert13b = function(le, pe, ge, ye) {
      for (var xe = 0, _e = 0; _e < pe; _e++)
        xe = xe + (le[_e] | 0), ge[2 * _e] = xe & 8191, xe = xe >>> 13, ge[2 * _e + 1] = xe & 8191, xe = xe >>> 13;
      for (_e = 2 * pe; _e < ye; ++_e)
        ge[_e] = 0;
      fe(xe === 0), fe((xe & -8192) === 0);
    }, De.prototype.stub = function(le) {
      for (var pe = new Array(le), ge = 0; ge < le; ge++)
        pe[ge] = 0;
      return pe;
    }, De.prototype.mulp = function(le, pe, ge) {
      var ye = 2 * this.guessLen13b(le.length, pe.length), xe = this.makeRBT(ye), _e = this.stub(ye), Ae = new Array(ye), ve = new Array(ye), he = new Array(ye), be = new Array(ye), Me = new Array(ye), Re = new Array(ye), Oe = ge.words;
      Oe.length = ye, this.convert13b(le.words, le.length, Ae, ye), this.convert13b(pe.words, pe.length, be, ye), this.transform(Ae, _e, ve, he, ye, xe), this.transform(be, _e, Me, Re, ye, xe);
      for (var Te = 0; Te < ye; Te++) {
        var Fe = ve[Te] * Me[Te] - he[Te] * Re[Te];
        he[Te] = ve[Te] * Re[Te] + he[Te] * Me[Te], ve[Te] = Fe;
      }
      return this.conjugate(ve, he, ye), this.transform(ve, he, Oe, _e, ye, xe), this.conjugate(Oe, _e, ye), this.normalize13b(Oe, ye), ge.negative = le.negative ^ pe.negative, ge.length = le.length + pe.length, ge.strip();
    }, ce.prototype.mul = function(le) {
      var pe = new ce(null);
      return pe.words = new Array(this.length + le.length), this.mulTo(le, pe);
    }, ce.prototype.mulf = function(le) {
      var pe = new ce(null);
      return pe.words = new Array(this.length + le.length), He(this, le, pe);
    }, ce.prototype.imul = function(le) {
      return this.clone().mulTo(le, this);
    }, ce.prototype.imuln = function(le) {
      fe(typeof le == "number"), fe(le < 67108864);
      for (var pe = 0, ge = 0; ge < this.length; ge++) {
        var ye = (this.words[ge] | 0) * le, xe = (ye & 67108863) + (pe & 67108863);
        pe >>= 26, pe += ye / 67108864 | 0, pe += xe >>> 26, this.words[ge] = xe & 67108863;
      }
      return pe !== 0 && (this.words[ge] = pe, this.length++), this;
    }, ce.prototype.muln = function(le) {
      return this.clone().imuln(le);
    }, ce.prototype.sqr = function() {
      return this.mul(this);
    }, ce.prototype.isqr = function() {
      return this.imul(this.clone());
    }, ce.prototype.pow = function(le) {
      var pe = Ie(le);
      if (pe.length === 0)
        return new ce(1);
      for (var ge = this, ye = 0; ye < pe.length && pe[ye] === 0; ye++, ge = ge.sqr())
        ;
      if (++ye < pe.length)
        for (var xe = ge.sqr(); ye < pe.length; ye++, xe = xe.sqr())
          pe[ye] !== 0 && (ge = ge.mul(xe));
      return ge;
    }, ce.prototype.iushln = function(le) {
      fe(typeof le == "number" && le >= 0);
      var pe = le % 26, ge = (le - pe) / 26, ye = 67108863 >>> 26 - pe << 26 - pe, xe;
      if (pe !== 0) {
        var _e = 0;
        for (xe = 0; xe < this.length; xe++) {
          var Ae = this.words[xe] & ye, ve = (this.words[xe] | 0) - Ae << pe;
          this.words[xe] = ve | _e, _e = Ae >>> 26 - pe;
        }
        _e && (this.words[xe] = _e, this.length++);
      }
      if (ge !== 0) {
        for (xe = this.length - 1; xe >= 0; xe--)
          this.words[xe + ge] = this.words[xe];
        for (xe = 0; xe < ge; xe++)
          this.words[xe] = 0;
        this.length += ge;
      }
      return this.strip();
    }, ce.prototype.ishln = function(le) {
      return fe(this.negative === 0), this.iushln(le);
    }, ce.prototype.iushrn = function(le, pe, ge) {
      fe(typeof le == "number" && le >= 0);
      var ye;
      pe ? ye = (pe - pe % 26) / 26 : ye = 0;
      var xe = le % 26, _e = Math.min((le - xe) / 26, this.length), Ae = 67108863 ^ 67108863 >>> xe << xe, ve = ge;
      if (ye -= _e, ye = Math.max(0, ye), ve) {
        for (var he = 0; he < _e; he++)
          ve.words[he] = this.words[he];
        ve.length = _e;
      }
      if (_e !== 0)
        if (this.length > _e)
          for (this.length -= _e, he = 0; he < this.length; he++)
            this.words[he] = this.words[he + _e];
        else
          this.words[0] = 0, this.length = 1;
      var be = 0;
      for (he = this.length - 1; he >= 0 && (be !== 0 || he >= ye); he--) {
        var Me = this.words[he] | 0;
        this.words[he] = be << 26 - xe | Me >>> xe, be = Me & Ae;
      }
      return ve && be !== 0 && (ve.words[ve.length++] = be), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, ce.prototype.ishrn = function(le, pe, ge) {
      return fe(this.negative === 0), this.iushrn(le, pe, ge);
    }, ce.prototype.shln = function(le) {
      return this.clone().ishln(le);
    }, ce.prototype.ushln = function(le) {
      return this.clone().iushln(le);
    }, ce.prototype.shrn = function(le) {
      return this.clone().ishrn(le);
    }, ce.prototype.ushrn = function(le) {
      return this.clone().iushrn(le);
    }, ce.prototype.testn = function(le) {
      fe(typeof le == "number" && le >= 0);
      var pe = le % 26, ge = (le - pe) / 26, ye = 1 << pe;
      if (this.length <= ge)
        return !1;
      var xe = this.words[ge];
      return !!(xe & ye);
    }, ce.prototype.imaskn = function(le) {
      fe(typeof le == "number" && le >= 0);
      var pe = le % 26, ge = (le - pe) / 26;
      if (fe(this.negative === 0, "imaskn works only with positive numbers"), this.length <= ge)
        return this;
      if (pe !== 0 && ge++, this.length = Math.min(ge, this.length), pe !== 0) {
        var ye = 67108863 ^ 67108863 >>> pe << pe;
        this.words[this.length - 1] &= ye;
      }
      return this.strip();
    }, ce.prototype.maskn = function(le) {
      return this.clone().imaskn(le);
    }, ce.prototype.iaddn = function(le) {
      return fe(typeof le == "number"), fe(le < 67108864), le < 0 ? this.isubn(-le) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < le ? (this.words[0] = le - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(le), this.negative = 1, this) : this._iaddn(le);
    }, ce.prototype._iaddn = function(le) {
      this.words[0] += le;
      for (var pe = 0; pe < this.length && this.words[pe] >= 67108864; pe++)
        this.words[pe] -= 67108864, pe === this.length - 1 ? this.words[pe + 1] = 1 : this.words[pe + 1]++;
      return this.length = Math.max(this.length, pe + 1), this;
    }, ce.prototype.isubn = function(le) {
      if (fe(typeof le == "number"), fe(le < 67108864), le < 0)
        return this.iaddn(-le);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(le), this.negative = 1, this;
      if (this.words[0] -= le, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var pe = 0; pe < this.length && this.words[pe] < 0; pe++)
          this.words[pe] += 67108864, this.words[pe + 1] -= 1;
      return this.strip();
    }, ce.prototype.addn = function(le) {
      return this.clone().iaddn(le);
    }, ce.prototype.subn = function(le) {
      return this.clone().isubn(le);
    }, ce.prototype.iabs = function() {
      return this.negative = 0, this;
    }, ce.prototype.abs = function() {
      return this.clone().iabs();
    }, ce.prototype._ishlnsubmul = function(le, pe, ge) {
      var ye = le.length + ge, xe;
      this._expand(ye);
      var _e, Ae = 0;
      for (xe = 0; xe < le.length; xe++) {
        _e = (this.words[xe + ge] | 0) + Ae;
        var ve = (le.words[xe] | 0) * pe;
        _e -= ve & 67108863, Ae = (_e >> 26) - (ve / 67108864 | 0), this.words[xe + ge] = _e & 67108863;
      }
      for (; xe < this.length - ge; xe++)
        _e = (this.words[xe + ge] | 0) + Ae, Ae = _e >> 26, this.words[xe + ge] = _e & 67108863;
      if (Ae === 0)
        return this.strip();
      for (fe(Ae === -1), Ae = 0, xe = 0; xe < this.length; xe++)
        _e = -(this.words[xe] | 0) + Ae, Ae = _e >> 26, this.words[xe] = _e & 67108863;
      return this.negative = 1, this.strip();
    }, ce.prototype._wordDiv = function(le, pe) {
      var ge = this.length - le.length, ye = this.clone(), xe = le, _e = xe.words[xe.length - 1] | 0, Ae = this._countBits(_e);
      ge = 26 - Ae, ge !== 0 && (xe = xe.ushln(ge), ye.iushln(ge), _e = xe.words[xe.length - 1] | 0);
      var ve = ye.length - xe.length, he;
      if (pe !== "mod") {
        he = new ce(null), he.length = ve + 1, he.words = new Array(he.length);
        for (var be = 0; be < he.length; be++)
          he.words[be] = 0;
      }
      var Me = ye.clone()._ishlnsubmul(xe, 1, ve);
      Me.negative === 0 && (ye = Me, he && (he.words[ve] = 1));
      for (var Re = ve - 1; Re >= 0; Re--) {
        var Oe = (ye.words[xe.length + Re] | 0) * 67108864 + (ye.words[xe.length + Re - 1] | 0);
        for (Oe = Math.min(Oe / _e | 0, 67108863), ye._ishlnsubmul(xe, Oe, Re); ye.negative !== 0; )
          Oe--, ye.negative = 0, ye._ishlnsubmul(xe, 1, Re), ye.isZero() || (ye.negative ^= 1);
        he && (he.words[Re] = Oe);
      }
      return he && he.strip(), ye.strip(), pe !== "div" && ge !== 0 && ye.iushrn(ge), {
        div: he || null,
        mod: ye
      };
    }, ce.prototype.divmod = function(le, pe, ge) {
      if (fe(!le.isZero()), this.isZero())
        return {
          div: new ce(0),
          mod: new ce(0)
        };
      var ye, xe, _e;
      return this.negative !== 0 && le.negative === 0 ? (_e = this.neg().divmod(le, pe), pe !== "mod" && (ye = _e.div.neg()), pe !== "div" && (xe = _e.mod.neg(), ge && xe.negative !== 0 && xe.iadd(le)), {
        div: ye,
        mod: xe
      }) : this.negative === 0 && le.negative !== 0 ? (_e = this.divmod(le.neg(), pe), pe !== "mod" && (ye = _e.div.neg()), {
        div: ye,
        mod: _e.mod
      }) : this.negative & le.negative ? (_e = this.neg().divmod(le.neg(), pe), pe !== "div" && (xe = _e.mod.neg(), ge && xe.negative !== 0 && xe.isub(le)), {
        div: _e.div,
        mod: xe
      }) : le.length > this.length || this.cmp(le) < 0 ? {
        div: new ce(0),
        mod: this
      } : le.length === 1 ? pe === "div" ? {
        div: this.divn(le.words[0]),
        mod: null
      } : pe === "mod" ? {
        div: null,
        mod: new ce(this.modn(le.words[0]))
      } : {
        div: this.divn(le.words[0]),
        mod: new ce(this.modn(le.words[0]))
      } : this._wordDiv(le, pe);
    }, ce.prototype.div = function(le) {
      return this.divmod(le, "div", !1).div;
    }, ce.prototype.mod = function(le) {
      return this.divmod(le, "mod", !1).mod;
    }, ce.prototype.umod = function(le) {
      return this.divmod(le, "mod", !0).mod;
    }, ce.prototype.divRound = function(le) {
      var pe = this.divmod(le);
      if (pe.mod.isZero())
        return pe.div;
      var ge = pe.div.negative !== 0 ? pe.mod.isub(le) : pe.mod, ye = le.ushrn(1), xe = le.andln(1), _e = ge.cmp(ye);
      return _e < 0 || xe === 1 && _e === 0 ? pe.div : pe.div.negative !== 0 ? pe.div.isubn(1) : pe.div.iaddn(1);
    }, ce.prototype.modn = function(le) {
      fe(le <= 67108863);
      for (var pe = (1 << 26) % le, ge = 0, ye = this.length - 1; ye >= 0; ye--)
        ge = (pe * ge + (this.words[ye] | 0)) % le;
      return ge;
    }, ce.prototype.idivn = function(le) {
      fe(le <= 67108863);
      for (var pe = 0, ge = this.length - 1; ge >= 0; ge--) {
        var ye = (this.words[ge] | 0) + pe * 67108864;
        this.words[ge] = ye / le | 0, pe = ye % le;
      }
      return this.strip();
    }, ce.prototype.divn = function(le) {
      return this.clone().idivn(le);
    }, ce.prototype.egcd = function(le) {
      fe(le.negative === 0), fe(!le.isZero());
      var pe = this, ge = le.clone();
      pe.negative !== 0 ? pe = pe.umod(le) : pe = pe.clone();
      for (var ye = new ce(1), xe = new ce(0), _e = new ce(0), Ae = new ce(1), ve = 0; pe.isEven() && ge.isEven(); )
        pe.iushrn(1), ge.iushrn(1), ++ve;
      for (var he = ge.clone(), be = pe.clone(); !pe.isZero(); ) {
        for (var Me = 0, Re = 1; !(pe.words[0] & Re) && Me < 26; ++Me, Re <<= 1)
          ;
        if (Me > 0)
          for (pe.iushrn(Me); Me-- > 0; )
            (ye.isOdd() || xe.isOdd()) && (ye.iadd(he), xe.isub(be)), ye.iushrn(1), xe.iushrn(1);
        for (var Oe = 0, Te = 1; !(ge.words[0] & Te) && Oe < 26; ++Oe, Te <<= 1)
          ;
        if (Oe > 0)
          for (ge.iushrn(Oe); Oe-- > 0; )
            (_e.isOdd() || Ae.isOdd()) && (_e.iadd(he), Ae.isub(be)), _e.iushrn(1), Ae.iushrn(1);
        pe.cmp(ge) >= 0 ? (pe.isub(ge), ye.isub(_e), xe.isub(Ae)) : (ge.isub(pe), _e.isub(ye), Ae.isub(xe));
      }
      return {
        a: _e,
        b: Ae,
        gcd: ge.iushln(ve)
      };
    }, ce.prototype._invmp = function(le) {
      fe(le.negative === 0), fe(!le.isZero());
      var pe = this, ge = le.clone();
      pe.negative !== 0 ? pe = pe.umod(le) : pe = pe.clone();
      for (var ye = new ce(1), xe = new ce(0), _e = ge.clone(); pe.cmpn(1) > 0 && ge.cmpn(1) > 0; ) {
        for (var Ae = 0, ve = 1; !(pe.words[0] & ve) && Ae < 26; ++Ae, ve <<= 1)
          ;
        if (Ae > 0)
          for (pe.iushrn(Ae); Ae-- > 0; )
            ye.isOdd() && ye.iadd(_e), ye.iushrn(1);
        for (var he = 0, be = 1; !(ge.words[0] & be) && he < 26; ++he, be <<= 1)
          ;
        if (he > 0)
          for (ge.iushrn(he); he-- > 0; )
            xe.isOdd() && xe.iadd(_e), xe.iushrn(1);
        pe.cmp(ge) >= 0 ? (pe.isub(ge), ye.isub(xe)) : (ge.isub(pe), xe.isub(ye));
      }
      var Me;
      return pe.cmpn(1) === 0 ? Me = ye : Me = xe, Me.cmpn(0) < 0 && Me.iadd(le), Me;
    }, ce.prototype.gcd = function(le) {
      if (this.isZero())
        return le.abs();
      if (le.isZero())
        return this.abs();
      var pe = this.clone(), ge = le.clone();
      pe.negative = 0, ge.negative = 0;
      for (var ye = 0; pe.isEven() && ge.isEven(); ye++)
        pe.iushrn(1), ge.iushrn(1);
      do {
        for (; pe.isEven(); )
          pe.iushrn(1);
        for (; ge.isEven(); )
          ge.iushrn(1);
        var xe = pe.cmp(ge);
        if (xe < 0) {
          var _e = pe;
          pe = ge, ge = _e;
        } else if (xe === 0 || ge.cmpn(1) === 0)
          break;
        pe.isub(ge);
      } while (!0);
      return ge.iushln(ye);
    }, ce.prototype.invm = function(le) {
      return this.egcd(le).a.umod(le);
    }, ce.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, ce.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, ce.prototype.andln = function(le) {
      return this.words[0] & le;
    }, ce.prototype.bincn = function(le) {
      fe(typeof le == "number");
      var pe = le % 26, ge = (le - pe) / 26, ye = 1 << pe;
      if (this.length <= ge)
        return this._expand(ge + 1), this.words[ge] |= ye, this;
      for (var xe = ye, _e = ge; xe !== 0 && _e < this.length; _e++) {
        var Ae = this.words[_e] | 0;
        Ae += xe, xe = Ae >>> 26, Ae &= 67108863, this.words[_e] = Ae;
      }
      return xe !== 0 && (this.words[_e] = xe, this.length++), this;
    }, ce.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, ce.prototype.cmpn = function(le) {
      var pe = le < 0;
      if (this.negative !== 0 && !pe)
        return -1;
      if (this.negative === 0 && pe)
        return 1;
      this.strip();
      var ge;
      if (this.length > 1)
        ge = 1;
      else {
        pe && (le = -le), fe(le <= 67108863, "Number is too big");
        var ye = this.words[0] | 0;
        ge = ye === le ? 0 : ye < le ? -1 : 1;
      }
      return this.negative !== 0 ? -ge | 0 : ge;
    }, ce.prototype.cmp = function(le) {
      if (this.negative !== 0 && le.negative === 0)
        return -1;
      if (this.negative === 0 && le.negative !== 0)
        return 1;
      var pe = this.ucmp(le);
      return this.negative !== 0 ? -pe | 0 : pe;
    }, ce.prototype.ucmp = function(le) {
      if (this.length > le.length)
        return 1;
      if (this.length < le.length)
        return -1;
      for (var pe = 0, ge = this.length - 1; ge >= 0; ge--) {
        var ye = this.words[ge] | 0, xe = le.words[ge] | 0;
        if (ye !== xe) {
          ye < xe ? pe = -1 : ye > xe && (pe = 1);
          break;
        }
      }
      return pe;
    }, ce.prototype.gtn = function(le) {
      return this.cmpn(le) === 1;
    }, ce.prototype.gt = function(le) {
      return this.cmp(le) === 1;
    }, ce.prototype.gten = function(le) {
      return this.cmpn(le) >= 0;
    }, ce.prototype.gte = function(le) {
      return this.cmp(le) >= 0;
    }, ce.prototype.ltn = function(le) {
      return this.cmpn(le) === -1;
    }, ce.prototype.lt = function(le) {
      return this.cmp(le) === -1;
    }, ce.prototype.lten = function(le) {
      return this.cmpn(le) <= 0;
    }, ce.prototype.lte = function(le) {
      return this.cmp(le) <= 0;
    }, ce.prototype.eqn = function(le) {
      return this.cmpn(le) === 0;
    }, ce.prototype.eq = function(le) {
      return this.cmp(le) === 0;
    }, ce.red = function(le) {
      return new ze(le);
    }, ce.prototype.toRed = function(le) {
      return fe(!this.red, "Already a number in reduction context"), fe(this.negative === 0, "red works only with positives"), le.convertTo(this)._forceRed(le);
    }, ce.prototype.fromRed = function() {
      return fe(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, ce.prototype._forceRed = function(le) {
      return this.red = le, this;
    }, ce.prototype.forceRed = function(le) {
      return fe(!this.red, "Already a number in reduction context"), this._forceRed(le);
    }, ce.prototype.redAdd = function(le) {
      return fe(this.red, "redAdd works only with red numbers"), this.red.add(this, le);
    }, ce.prototype.redIAdd = function(le) {
      return fe(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, le);
    }, ce.prototype.redSub = function(le) {
      return fe(this.red, "redSub works only with red numbers"), this.red.sub(this, le);
    }, ce.prototype.redISub = function(le) {
      return fe(this.red, "redISub works only with red numbers"), this.red.isub(this, le);
    }, ce.prototype.redShl = function(le) {
      return fe(this.red, "redShl works only with red numbers"), this.red.shl(this, le);
    }, ce.prototype.redMul = function(le) {
      return fe(this.red, "redMul works only with red numbers"), this.red._verify2(this, le), this.red.mul(this, le);
    }, ce.prototype.redIMul = function(le) {
      return fe(this.red, "redMul works only with red numbers"), this.red._verify2(this, le), this.red.imul(this, le);
    }, ce.prototype.redSqr = function() {
      return fe(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, ce.prototype.redISqr = function() {
      return fe(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, ce.prototype.redSqrt = function() {
      return fe(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, ce.prototype.redInvm = function() {
      return fe(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, ce.prototype.redNeg = function() {
      return fe(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, ce.prototype.redPow = function(le) {
      return fe(this.red && !le.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, le);
    };
    var Ge = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Ye($e, le) {
      this.name = $e, this.p = new ce(le, 16), this.n = this.p.bitLength(), this.k = new ce(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Ye.prototype._tmp = function() {
      var le = new ce(null);
      return le.words = new Array(Math.ceil(this.n / 13)), le;
    }, Ye.prototype.ireduce = function(le) {
      var pe = le, ge;
      do
        this.split(pe, this.tmp), pe = this.imulK(pe), pe = pe.iadd(this.tmp), ge = pe.bitLength();
      while (ge > this.n);
      var ye = ge < this.n ? -1 : pe.ucmp(this.p);
      return ye === 0 ? (pe.words[0] = 0, pe.length = 1) : ye > 0 ? pe.isub(this.p) : pe.strip !== void 0 ? pe.strip() : pe._strip(), pe;
    }, Ye.prototype.split = function(le, pe) {
      le.iushrn(this.n, 0, pe);
    }, Ye.prototype.imulK = function(le) {
      return le.imul(this.k);
    };
    function st() {
      Ye.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    ue(st, Ye), st.prototype.split = function(le, pe) {
      for (var ge = 4194303, ye = Math.min(le.length, 9), xe = 0; xe < ye; xe++)
        pe.words[xe] = le.words[xe];
      if (pe.length = ye, le.length <= 9) {
        le.words[0] = 0, le.length = 1;
        return;
      }
      var _e = le.words[9];
      for (pe.words[pe.length++] = _e & ge, xe = 10; xe < le.length; xe++) {
        var Ae = le.words[xe] | 0;
        le.words[xe - 10] = (Ae & ge) << 4 | _e >>> 22, _e = Ae;
      }
      _e >>>= 22, le.words[xe - 10] = _e, _e === 0 && le.length > 10 ? le.length -= 10 : le.length -= 9;
    }, st.prototype.imulK = function(le) {
      le.words[le.length] = 0, le.words[le.length + 1] = 0, le.length += 2;
      for (var pe = 0, ge = 0; ge < le.length; ge++) {
        var ye = le.words[ge] | 0;
        pe += ye * 977, le.words[ge] = pe & 67108863, pe = ye * 64 + (pe / 67108864 | 0);
      }
      return le.words[le.length - 1] === 0 && (le.length--, le.words[le.length - 1] === 0 && le.length--), le;
    };
    function at() {
      Ye.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    ue(at, Ye);
    function mt() {
      Ye.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    ue(mt, Ye);
    function qe() {
      Ye.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    ue(qe, Ye), qe.prototype.imulK = function(le) {
      for (var pe = 0, ge = 0; ge < le.length; ge++) {
        var ye = (le.words[ge] | 0) * 19 + pe, xe = ye & 67108863;
        ye >>>= 26, le.words[ge] = xe, pe = ye;
      }
      return pe !== 0 && (le.words[le.length++] = pe), le;
    }, ce._prime = function(le) {
      if (Ge[le])
        return Ge[le];
      var pe;
      if (le === "k256")
        pe = new st();
      else if (le === "p224")
        pe = new at();
      else if (le === "p192")
        pe = new mt();
      else if (le === "p25519")
        pe = new qe();
      else
        throw new Error("Unknown prime " + le);
      return Ge[le] = pe, pe;
    };
    function ze($e) {
      if (typeof $e == "string") {
        var le = ce._prime($e);
        this.m = le.p, this.prime = le;
      } else
        fe($e.gtn(1), "modulus must be greater than 1"), this.m = $e, this.prime = null;
    }
    ze.prototype._verify1 = function(le) {
      fe(le.negative === 0, "red works only with positives"), fe(le.red, "red works only with red numbers");
    }, ze.prototype._verify2 = function(le, pe) {
      fe((le.negative | pe.negative) === 0, "red works only with positives"), fe(
        le.red && le.red === pe.red,
        "red works only with red numbers"
      );
    }, ze.prototype.imod = function(le) {
      return this.prime ? this.prime.ireduce(le)._forceRed(this) : le.umod(this.m)._forceRed(this);
    }, ze.prototype.neg = function(le) {
      return le.isZero() ? le.clone() : this.m.sub(le)._forceRed(this);
    }, ze.prototype.add = function(le, pe) {
      this._verify2(le, pe);
      var ge = le.add(pe);
      return ge.cmp(this.m) >= 0 && ge.isub(this.m), ge._forceRed(this);
    }, ze.prototype.iadd = function(le, pe) {
      this._verify2(le, pe);
      var ge = le.iadd(pe);
      return ge.cmp(this.m) >= 0 && ge.isub(this.m), ge;
    }, ze.prototype.sub = function(le, pe) {
      this._verify2(le, pe);
      var ge = le.sub(pe);
      return ge.cmpn(0) < 0 && ge.iadd(this.m), ge._forceRed(this);
    }, ze.prototype.isub = function(le, pe) {
      this._verify2(le, pe);
      var ge = le.isub(pe);
      return ge.cmpn(0) < 0 && ge.iadd(this.m), ge;
    }, ze.prototype.shl = function(le, pe) {
      return this._verify1(le), this.imod(le.ushln(pe));
    }, ze.prototype.imul = function(le, pe) {
      return this._verify2(le, pe), this.imod(le.imul(pe));
    }, ze.prototype.mul = function(le, pe) {
      return this._verify2(le, pe), this.imod(le.mul(pe));
    }, ze.prototype.isqr = function(le) {
      return this.imul(le, le.clone());
    }, ze.prototype.sqr = function(le) {
      return this.mul(le, le);
    }, ze.prototype.sqrt = function(le) {
      if (le.isZero())
        return le.clone();
      var pe = this.m.andln(3);
      if (fe(pe % 2 === 1), pe === 3) {
        var ge = this.m.add(new ce(1)).iushrn(2);
        return this.pow(le, ge);
      }
      for (var ye = this.m.subn(1), xe = 0; !ye.isZero() && ye.andln(1) === 0; )
        xe++, ye.iushrn(1);
      fe(!ye.isZero());
      var _e = new ce(1).toRed(this), Ae = _e.redNeg(), ve = this.m.subn(1).iushrn(1), he = this.m.bitLength();
      for (he = new ce(2 * he * he).toRed(this); this.pow(he, ve).cmp(Ae) !== 0; )
        he.redIAdd(Ae);
      for (var be = this.pow(he, ye), Me = this.pow(le, ye.addn(1).iushrn(1)), Re = this.pow(le, ye), Oe = xe; Re.cmp(_e) !== 0; ) {
        for (var Te = Re, Fe = 0; Te.cmp(_e) !== 0; Fe++)
          Te = Te.redSqr();
        fe(Fe < Oe);
        var je = this.pow(be, new ce(1).iushln(Oe - Fe - 1));
        Me = Me.redMul(je), be = je.redSqr(), Re = Re.redMul(be), Oe = Fe;
      }
      return Me;
    }, ze.prototype.invm = function(le) {
      var pe = le._invmp(this.m);
      return pe.negative !== 0 ? (pe.negative = 0, this.imod(pe).redNeg()) : this.imod(pe);
    }, ze.prototype.pow = function(le, pe) {
      if (pe.isZero())
        return new ce(1).toRed(this);
      if (pe.cmpn(1) === 0)
        return le.clone();
      var ge = 4, ye = new Array(1 << ge);
      ye[0] = new ce(1).toRed(this), ye[1] = le;
      for (var xe = 2; xe < ye.length; xe++)
        ye[xe] = this.mul(ye[xe - 1], le);
      var _e = ye[0], Ae = 0, ve = 0, he = pe.bitLength() % 26;
      for (he === 0 && (he = 26), xe = pe.length - 1; xe >= 0; xe--) {
        for (var be = pe.words[xe], Me = he - 1; Me >= 0; Me--) {
          var Re = be >> Me & 1;
          if (_e !== ye[0] && (_e = this.sqr(_e)), Re === 0 && Ae === 0) {
            ve = 0;
            continue;
          }
          Ae <<= 1, Ae |= Re, ve++, !(ve !== ge && (xe !== 0 || Me !== 0)) && (_e = this.mul(_e, ye[Ae]), ve = 0, Ae = 0);
        }
        he = 26;
      }
      return _e;
    }, ze.prototype.convertTo = function(le) {
      var pe = le.umod(this.m);
      return pe === le ? pe.clone() : pe;
    }, ze.prototype.convertFrom = function(le) {
      var pe = le.clone();
      return pe.red = null, pe;
    }, ce.mont = function(le) {
      return new ot(le);
    };
    function ot($e) {
      ze.call(this, $e), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new ce(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    ue(ot, ze), ot.prototype.convertTo = function(le) {
      return this.imod(le.ushln(this.shift));
    }, ot.prototype.convertFrom = function(le) {
      var pe = this.imod(le.mul(this.rinv));
      return pe.red = null, pe;
    }, ot.prototype.imul = function(le, pe) {
      if (le.isZero() || pe.isZero())
        return le.words[0] = 0, le.length = 1, le;
      var ge = le.imul(pe), ye = ge.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), xe = ge.isub(ye).iushrn(this.shift), _e = xe;
      return xe.cmp(this.m) >= 0 ? _e = xe.isub(this.m) : xe.cmpn(0) < 0 && (_e = xe.iadd(this.m)), _e._forceRed(this);
    }, ot.prototype.mul = function(le, pe) {
      if (le.isZero() || pe.isZero())
        return new ce(0)._forceRed(this);
      var ge = le.mul(pe), ye = ge.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), xe = ge.isub(ye).iushrn(this.shift), _e = xe;
      return xe.cmp(this.m) >= 0 ? _e = xe.isub(this.m) : xe.cmpn(0) < 0 && (_e = xe.iadd(this.m)), _e._forceRed(this);
    }, ot.prototype.invm = function(le) {
      var pe = this.imod(le._invmp(this.m).mul(this.r2));
      return pe._forceRed(this);
    };
  })(ae, commonjsGlobal);
})(bn);
var bnExports = bn.exports, BN$4 = bnExports, Buffer$3 = safeBufferExports.Buffer;
function withPublic$2(ae, ie) {
  return Buffer$3.from(ae.toRed(BN$4.mont(ie.modulus)).redPow(new BN$4(ie.publicExponent)).fromRed().toArray());
}
var withPublic_1 = withPublic$2, parseKeys$1 = parseAsn1, randomBytes$2 = browserExports, createHash$1 = browser$b, mgf$1 = mgf$2, xor$1 = xor$2, BN$3 = bnExports, withPublic$1 = withPublic_1, crt$1 = browserifyRsa, Buffer$2 = safeBufferExports.Buffer, publicEncrypt = function(ie, se, fe) {
  var ue;
  ie.padding ? ue = ie.padding : fe ? ue = 1 : ue = 4;
  var ce = parseKeys$1(ie), de;
  if (ue === 4)
    de = oaep$1(ce, se);
  else if (ue === 1)
    de = pkcs1$1(ce, se, fe);
  else if (ue === 3) {
    if (de = new BN$3(se), de.cmp(ce.modulus) >= 0)
      throw new Error("data too long for modulus");
  } else
    throw new Error("unknown padding");
  return fe ? crt$1(de, ce) : withPublic$1(de, ce);
};
function oaep$1(ae, ie) {
  var se = ae.modulus.byteLength(), fe = ie.length, ue = createHash$1("sha1").update(Buffer$2.alloc(0)).digest(), ce = ue.length, de = 2 * ce;
  if (fe > se - de - 2)
    throw new Error("message too long");
  var me = Buffer$2.alloc(se - fe - de - 2), we = se - ce - 1, Ee = randomBytes$2(ce), Se = xor$1(Buffer$2.concat([ue, me, Buffer$2.alloc(1, 1), ie], we), mgf$1(Ee, we)), Be = xor$1(Ee, mgf$1(Se, ce));
  return new BN$3(Buffer$2.concat([Buffer$2.alloc(1), Be, Se], se));
}
function pkcs1$1(ae, ie, se) {
  var fe = ie.length, ue = ae.modulus.byteLength();
  if (fe > ue - 11)
    throw new Error("message too long");
  var ce;
  return se ? ce = Buffer$2.alloc(ue - fe - 3, 255) : ce = nonZero(ue - fe - 3), new BN$3(Buffer$2.concat([Buffer$2.from([0, se ? 1 : 2]), ce, Buffer$2.alloc(1), ie], ue));
}
function nonZero(ae) {
  for (var ie = Buffer$2.allocUnsafe(ae), se = 0, fe = randomBytes$2(ae * 2), ue = 0, ce; se < ae; )
    ue === fe.length && (fe = randomBytes$2(ae * 2), ue = 0), ce = fe[ue++], ce && (ie[se++] = ce);
  return ie;
}
var parseKeys = parseAsn1, mgf = mgf$2, xor = xor$2, BN$2 = bnExports, crt = browserifyRsa, createHash = browser$b, withPublic = withPublic_1, Buffer$1 = safeBufferExports.Buffer, privateDecrypt = function(ie, se, fe) {
  var ue;
  ie.padding ? ue = ie.padding : fe ? ue = 1 : ue = 4;
  var ce = parseKeys(ie), de = ce.modulus.byteLength();
  if (se.length > de || new BN$2(se).cmp(ce.modulus) >= 0)
    throw new Error("decryption error");
  var me;
  fe ? me = withPublic(new BN$2(se), ce) : me = crt(se, ce);
  var we = Buffer$1.alloc(de - me.length);
  if (me = Buffer$1.concat([we, me], de), ue === 4)
    return oaep(ce, me);
  if (ue === 1)
    return pkcs1(ce, me, fe);
  if (ue === 3)
    return me;
  throw new Error("unknown padding");
};
function oaep(ae, ie) {
  var se = ae.modulus.byteLength(), fe = createHash("sha1").update(Buffer$1.alloc(0)).digest(), ue = fe.length;
  if (ie[0] !== 0)
    throw new Error("decryption error");
  var ce = ie.slice(1, ue + 1), de = ie.slice(ue + 1), me = xor(ce, mgf(de, ue)), we = xor(de, mgf(me, se - ue - 1));
  if (compare$1(fe, we.slice(0, ue)))
    throw new Error("decryption error");
  for (var Ee = ue; we[Ee] === 0; )
    Ee++;
  if (we[Ee++] !== 1)
    throw new Error("decryption error");
  return we.slice(Ee);
}
function pkcs1(ae, ie, se) {
  for (var fe = ie.slice(0, 2), ue = 2, ce = 0; ie[ue++] !== 0; )
    if (ue >= ie.length) {
      ce++;
      break;
    }
  var de = ie.slice(2, ue - 1);
  if ((fe.toString("hex") !== "0002" && !se || fe.toString("hex") !== "0001" && se) && ce++, de.length < 8 && ce++, ce)
    throw new Error("decryption error");
  return ie.slice(ue);
}
function compare$1(ae, ie) {
  ae = Buffer$1.from(ae), ie = Buffer$1.from(ie);
  var se = 0, fe = ae.length;
  ae.length !== ie.length && (se++, fe = Math.min(ae.length, ie.length));
  for (var ue = -1; ++ue < fe; )
    se += ae[ue] ^ ie[ue];
  return se;
}
(function(ae) {
  ae.publicEncrypt = publicEncrypt, ae.privateDecrypt = privateDecrypt, ae.privateEncrypt = function(se, fe) {
    return ae.publicEncrypt(se, fe, !0);
  }, ae.publicDecrypt = function(se, fe) {
    return ae.privateDecrypt(se, fe, !0);
  };
})(browser$3);
var browser$2 = {};
function oldBrowser() {
  throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
}
var safeBuffer = safeBufferExports, randombytes = browserExports, Buffer = safeBuffer.Buffer, kBufferMaxLength = safeBuffer.kMaxLength, crypto$5 = commonjsGlobal.crypto || commonjsGlobal.msCrypto, kMaxUint32 = Math.pow(2, 32) - 1;
function assertOffset(ae, ie) {
  if (typeof ae != "number" || ae !== ae)
    throw new TypeError("offset must be a number");
  if (ae > kMaxUint32 || ae < 0)
    throw new TypeError("offset must be a uint32");
  if (ae > kBufferMaxLength || ae > ie)
    throw new RangeError("offset out of range");
}
function assertSize(ae, ie, se) {
  if (typeof ae != "number" || ae !== ae)
    throw new TypeError("size must be a number");
  if (ae > kMaxUint32 || ae < 0)
    throw new TypeError("size must be a uint32");
  if (ae + ie > se || ae > kBufferMaxLength)
    throw new RangeError("buffer too small");
}
crypto$5 && crypto$5.getRandomValues || !process$1.browser ? (browser$2.randomFill = randomFill, browser$2.randomFillSync = randomFillSync) : (browser$2.randomFill = oldBrowser, browser$2.randomFillSync = oldBrowser);
function randomFill(ae, ie, se, fe) {
  if (!Buffer.isBuffer(ae) && !(ae instanceof commonjsGlobal.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  if (typeof ie == "function")
    fe = ie, ie = 0, se = ae.length;
  else if (typeof se == "function")
    fe = se, se = ae.length - ie;
  else if (typeof fe != "function")
    throw new TypeError('"cb" argument must be a function');
  return assertOffset(ie, ae.length), assertSize(se, ie, ae.length), actualFill(ae, ie, se, fe);
}
function actualFill(ae, ie, se, fe) {
  if (process$1.browser) {
    var ue = ae.buffer, ce = new Uint8Array(ue, ie, se);
    if (crypto$5.getRandomValues(ce), fe) {
      process$1.nextTick(function() {
        fe(null, ae);
      });
      return;
    }
    return ae;
  }
  if (fe) {
    randombytes(se, function(me, we) {
      if (me)
        return fe(me);
      we.copy(ae, ie), fe(null, ae);
    });
    return;
  }
  var de = randombytes(se);
  return de.copy(ae, ie), ae;
}
function randomFillSync(ae, ie, se) {
  if (typeof ie > "u" && (ie = 0), !Buffer.isBuffer(ae) && !(ae instanceof commonjsGlobal.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  return assertOffset(ie, ae.length), se === void 0 && (se = ae.length - ie), assertSize(se, ie, ae.length), actualFill(ae, ie, se);
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify)
    return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = browserExports, cryptoBrowserify.createHash = cryptoBrowserify.Hash = browser$b, cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = browser$a;
  var ae = algos, ie = Object.keys(ae), se = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(ie);
  cryptoBrowserify.getHashes = function() {
    return se;
  };
  var fe = browser$9;
  cryptoBrowserify.pbkdf2 = fe.pbkdf2, cryptoBrowserify.pbkdf2Sync = fe.pbkdf2Sync;
  var ue = browser$8;
  cryptoBrowserify.Cipher = ue.Cipher, cryptoBrowserify.createCipher = ue.createCipher, cryptoBrowserify.Cipheriv = ue.Cipheriv, cryptoBrowserify.createCipheriv = ue.createCipheriv, cryptoBrowserify.Decipher = ue.Decipher, cryptoBrowserify.createDecipher = ue.createDecipher, cryptoBrowserify.Decipheriv = ue.Decipheriv, cryptoBrowserify.createDecipheriv = ue.createDecipheriv, cryptoBrowserify.getCiphers = ue.getCiphers, cryptoBrowserify.listCiphers = ue.listCiphers;
  var ce = requireBrowser$2();
  cryptoBrowserify.DiffieHellmanGroup = ce.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = ce.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = ce.getDiffieHellman, cryptoBrowserify.createDiffieHellman = ce.createDiffieHellman, cryptoBrowserify.DiffieHellman = ce.DiffieHellman;
  var de = requireBrowser$1();
  cryptoBrowserify.createSign = de.createSign, cryptoBrowserify.Sign = de.Sign, cryptoBrowserify.createVerify = de.createVerify, cryptoBrowserify.Verify = de.Verify, cryptoBrowserify.createECDH = requireBrowser();
  var me = browser$3;
  cryptoBrowserify.publicEncrypt = me.publicEncrypt, cryptoBrowserify.privateEncrypt = me.privateEncrypt, cryptoBrowserify.publicDecrypt = me.publicDecrypt, cryptoBrowserify.privateDecrypt = me.privateDecrypt;
  var we = browser$2;
  return cryptoBrowserify.randomFill = we.randomFill, cryptoBrowserify.randomFillSync = we.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error([
      "sorry, createCredentials is not implemented yet",
      "we accept pull requests",
      "https://github.com/crypto-browserify/crypto-browserify"
    ].join(`
`));
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
var cryptoBrowserifyExports = requireCryptoBrowserify();
const crypto$4 = /* @__PURE__ */ getDefaultExportFromCjs$2(cryptoBrowserifyExports), nodeCrypto = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: crypto$4
}, [cryptoBrowserifyExports]);
function buildIrysTransaction(ae) {
  class ie extends ae.arbundles.DataItem {
    Irys;
    signer;
    constructor(fe, ue, ce) {
      super(ce?.dataIsRawTransaction === !0 ? Buffer$F.from(fe) : ue.arbundles.createData(fe, ue.tokenConfig.getSigner(), {
        ...ce,
        anchor: ce?.anchor ?? crypto$4.randomBytes(32).toString("base64").slice(0, 32)
      }).getRaw()), this.Irys = ue, this.signer = ue.tokenConfig.getSigner();
    }
    sign() {
      return super.sign(this.signer);
    }
    get size() {
      return this.getRaw().length;
    }
    /**
     * @deprecated use upload
     */
    async uploadWithReceipt(fe) {
      return (await this.Irys.uploader.uploadTransaction(this, fe)).data;
    }
    async upload(fe) {
      return (await this.Irys.uploader.uploadTransaction(this, fe)).data;
    }
    // static fromRaw(rawTransaction: Buffer, IrysInstance: Irys): IrysTransaction {
    //   return new IrysTransaction(rawTransaction, IrysInstance, { dataIsRawTransaction: true });
    // }
    async getPrice() {
      return this.Irys.utils.getPrice(this.Irys.tokenConfig.name, this.size);
    }
    async isValid() {
      return ae.arbundles.DataItem.verify(this.getRaw());
    }
  }
  return ie;
}
var base64url$3 = { exports: {} }, base64url$2 = {}, padString$1 = {};
Object.defineProperty(padString$1, "__esModule", { value: !0 });
function padString(ae) {
  var ie = 4, se = ae.length, fe = se % ie;
  if (!fe)
    return ae;
  var ue = se, ce = ie - fe, de = se + ce, me = Buffer$F.alloc(de);
  for (me.write(ae); ce--; )
    me.write("=", ue++);
  return me.toString();
}
padString$1.default = padString;
Object.defineProperty(base64url$2, "__esModule", { value: !0 });
var pad_string_1 = padString$1;
function encode$3(ae, ie) {
  return ie === void 0 && (ie = "utf8"), Buffer$F.isBuffer(ae) ? fromBase64(ae.toString("base64")) : fromBase64(Buffer$F.from(ae, ie).toString("base64"));
}
function decode(ae, ie) {
  return ie === void 0 && (ie = "utf8"), Buffer$F.from(toBase64(ae), "base64").toString(ie);
}
function toBase64(ae) {
  return ae = ae.toString(), pad_string_1.default(ae).replace(/\-/g, "+").replace(/_/g, "/");
}
function fromBase64(ae) {
  return ae.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function toBuffer$2(ae) {
  return Buffer$F.from(toBase64(ae), "base64");
}
var base64url$1 = encode$3;
base64url$1.encode = encode$3;
base64url$1.decode = decode;
base64url$1.toBase64 = toBase64;
base64url$1.fromBase64 = fromBase64;
base64url$1.toBuffer = toBuffer$2;
base64url$2.default = base64url$1;
(function(ae) {
  ae.exports = base64url$2.default, ae.exports.default = ae.exports;
})(base64url$3);
var base64urlExports = base64url$3.exports;
const base64url = /* @__PURE__ */ getDefaultExportFromCjs$2(base64urlExports);
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER$1 = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
function clone(ae) {
  var ie, se, fe, ue = De.prototype = { constructor: De, toString: null, valueOf: null }, ce = new De(1), de = 20, me = 4, we = -7, Ee = 21, Se = -1e7, Be = 1e7, Ce = !1, Ie = 1, Pe = 0, Ne = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "",
    // non-breaking space
    suffix: ""
  }, ke = "0123456789abcdefghijklmnopqrstuvwxyz", He = !0;
  function De(qe, ze) {
    var ot, $e, le, pe, ge, ye, xe, _e, Ae = this;
    if (!(Ae instanceof De))
      return new De(qe, ze);
    if (ze == null) {
      if (qe && qe._isBigNumber === !0) {
        Ae.s = qe.s, !qe.c || qe.e > Be ? Ae.c = Ae.e = null : qe.e < Se ? Ae.c = [Ae.e = 0] : (Ae.e = qe.e, Ae.c = qe.c.slice());
        return;
      }
      if ((ye = typeof qe == "number") && qe * 0 == 0) {
        if (Ae.s = 1 / qe < 0 ? (qe = -qe, -1) : 1, qe === ~~qe) {
          for (pe = 0, ge = qe; ge >= 10; ge /= 10, pe++)
            ;
          pe > Be ? Ae.c = Ae.e = null : (Ae.e = pe, Ae.c = [qe]);
          return;
        }
        _e = String(qe);
      } else {
        if (!isNumeric.test(_e = String(qe)))
          return fe(Ae, _e, ye);
        Ae.s = _e.charCodeAt(0) == 45 ? (_e = _e.slice(1), -1) : 1;
      }
      (pe = _e.indexOf(".")) > -1 && (_e = _e.replace(".", "")), (ge = _e.search(/e/i)) > 0 ? (pe < 0 && (pe = ge), pe += +_e.slice(ge + 1), _e = _e.substring(0, ge)) : pe < 0 && (pe = _e.length);
    } else {
      if (intCheck(ze, 2, ke.length, "Base"), ze == 10 && He)
        return Ae = new De(qe), at(Ae, de + Ae.e + 1, me);
      if (_e = String(qe), ye = typeof qe == "number") {
        if (qe * 0 != 0)
          return fe(Ae, _e, ye, ze);
        if (Ae.s = 1 / qe < 0 ? (_e = _e.slice(1), -1) : 1, De.DEBUG && _e.replace(/^0\.0*|\./, "").length > 15)
          throw Error(tooManyDigits + qe);
      } else
        Ae.s = _e.charCodeAt(0) === 45 ? (_e = _e.slice(1), -1) : 1;
      for (ot = ke.slice(0, ze), pe = ge = 0, xe = _e.length; ge < xe; ge++)
        if (ot.indexOf($e = _e.charAt(ge)) < 0) {
          if ($e == ".") {
            if (ge > pe) {
              pe = xe;
              continue;
            }
          } else if (!le && (_e == _e.toUpperCase() && (_e = _e.toLowerCase()) || _e == _e.toLowerCase() && (_e = _e.toUpperCase()))) {
            le = !0, ge = -1, pe = 0;
            continue;
          }
          return fe(Ae, String(qe), ye, ze);
        }
      ye = !1, _e = se(_e, ze, 10, Ae.s), (pe = _e.indexOf(".")) > -1 ? _e = _e.replace(".", "") : pe = _e.length;
    }
    for (ge = 0; _e.charCodeAt(ge) === 48; ge++)
      ;
    for (xe = _e.length; _e.charCodeAt(--xe) === 48; )
      ;
    if (_e = _e.slice(ge, ++xe)) {
      if (xe -= ge, ye && De.DEBUG && xe > 15 && (qe > MAX_SAFE_INTEGER$1 || qe !== mathfloor(qe)))
        throw Error(tooManyDigits + Ae.s * qe);
      if ((pe = pe - ge - 1) > Be)
        Ae.c = Ae.e = null;
      else if (pe < Se)
        Ae.c = [Ae.e = 0];
      else {
        if (Ae.e = pe, Ae.c = [], ge = (pe + 1) % LOG_BASE, pe < 0 && (ge += LOG_BASE), ge < xe) {
          for (ge && Ae.c.push(+_e.slice(0, ge)), xe -= LOG_BASE; ge < xe; )
            Ae.c.push(+_e.slice(ge, ge += LOG_BASE));
          ge = LOG_BASE - (_e = _e.slice(ge)).length;
        } else
          ge -= xe;
        for (; ge--; _e += "0")
          ;
        Ae.c.push(+_e);
      }
    } else
      Ae.c = [Ae.e = 0];
  }
  De.clone = clone, De.ROUND_UP = 0, De.ROUND_DOWN = 1, De.ROUND_CEIL = 2, De.ROUND_FLOOR = 3, De.ROUND_HALF_UP = 4, De.ROUND_HALF_DOWN = 5, De.ROUND_HALF_EVEN = 6, De.ROUND_HALF_CEIL = 7, De.ROUND_HALF_FLOOR = 8, De.EUCLID = 9, De.config = De.set = function(qe) {
    var ze, ot;
    if (qe != null)
      if (typeof qe == "object") {
        if (qe.hasOwnProperty(ze = "DECIMAL_PLACES") && (ot = qe[ze], intCheck(ot, 0, MAX, ze), de = ot), qe.hasOwnProperty(ze = "ROUNDING_MODE") && (ot = qe[ze], intCheck(ot, 0, 8, ze), me = ot), qe.hasOwnProperty(ze = "EXPONENTIAL_AT") && (ot = qe[ze], ot && ot.pop ? (intCheck(ot[0], -MAX, 0, ze), intCheck(ot[1], 0, MAX, ze), we = ot[0], Ee = ot[1]) : (intCheck(ot, -MAX, MAX, ze), we = -(Ee = ot < 0 ? -ot : ot))), qe.hasOwnProperty(ze = "RANGE"))
          if (ot = qe[ze], ot && ot.pop)
            intCheck(ot[0], -MAX, -1, ze), intCheck(ot[1], 1, MAX, ze), Se = ot[0], Be = ot[1];
          else if (intCheck(ot, -MAX, MAX, ze), ot)
            Se = -(Be = ot < 0 ? -ot : ot);
          else
            throw Error(bignumberError + ze + " cannot be zero: " + ot);
        if (qe.hasOwnProperty(ze = "CRYPTO"))
          if (ot = qe[ze], ot === !!ot)
            if (ot)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                Ce = ot;
              else
                throw Ce = !ot, Error(bignumberError + "crypto unavailable");
            else
              Ce = ot;
          else
            throw Error(bignumberError + ze + " not true or false: " + ot);
        if (qe.hasOwnProperty(ze = "MODULO_MODE") && (ot = qe[ze], intCheck(ot, 0, 9, ze), Ie = ot), qe.hasOwnProperty(ze = "POW_PRECISION") && (ot = qe[ze], intCheck(ot, 0, MAX, ze), Pe = ot), qe.hasOwnProperty(ze = "FORMAT"))
          if (ot = qe[ze], typeof ot == "object")
            Ne = ot;
          else
            throw Error(bignumberError + ze + " not an object: " + ot);
        if (qe.hasOwnProperty(ze = "ALPHABET"))
          if (ot = qe[ze], typeof ot == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(ot))
            He = ot.slice(0, 10) == "0123456789", ke = ot;
          else
            throw Error(bignumberError + ze + " invalid: " + ot);
      } else
        throw Error(bignumberError + "Object expected: " + qe);
    return {
      DECIMAL_PLACES: de,
      ROUNDING_MODE: me,
      EXPONENTIAL_AT: [we, Ee],
      RANGE: [Se, Be],
      CRYPTO: Ce,
      MODULO_MODE: Ie,
      POW_PRECISION: Pe,
      FORMAT: Ne,
      ALPHABET: ke
    };
  }, De.isBigNumber = function(qe) {
    if (!qe || qe._isBigNumber !== !0)
      return !1;
    if (!De.DEBUG)
      return !0;
    var ze, ot, $e = qe.c, le = qe.e, pe = qe.s;
    e:
      if ({}.toString.call($e) == "[object Array]") {
        if ((pe === 1 || pe === -1) && le >= -MAX && le <= MAX && le === mathfloor(le)) {
          if ($e[0] === 0) {
            if (le === 0 && $e.length === 1)
              return !0;
            break e;
          }
          if (ze = (le + 1) % LOG_BASE, ze < 1 && (ze += LOG_BASE), String($e[0]).length == ze) {
            for (ze = 0; ze < $e.length; ze++)
              if (ot = $e[ze], ot < 0 || ot >= BASE || ot !== mathfloor(ot))
                break e;
            if (ot !== 0)
              return !0;
          }
        }
      } else if ($e === null && le === null && (pe === null || pe === 1 || pe === -1))
        return !0;
    throw Error(bignumberError + "Invalid BigNumber: " + qe);
  }, De.maximum = De.max = function() {
    return Ye(arguments, -1);
  }, De.minimum = De.min = function() {
    return Ye(arguments, 1);
  }, De.random = function() {
    var qe = 9007199254740992, ze = Math.random() * qe & 2097151 ? function() {
      return mathfloor(Math.random() * qe);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(ot) {
      var $e, le, pe, ge, ye, xe = 0, _e = [], Ae = new De(ce);
      if (ot == null ? ot = de : intCheck(ot, 0, MAX), ge = mathceil(ot / LOG_BASE), Ce)
        if (crypto.getRandomValues) {
          for ($e = crypto.getRandomValues(new Uint32Array(ge *= 2)); xe < ge; )
            ye = $e[xe] * 131072 + ($e[xe + 1] >>> 11), ye >= 9e15 ? (le = crypto.getRandomValues(new Uint32Array(2)), $e[xe] = le[0], $e[xe + 1] = le[1]) : (_e.push(ye % 1e14), xe += 2);
          xe = ge / 2;
        } else if (crypto.randomBytes) {
          for ($e = crypto.randomBytes(ge *= 7); xe < ge; )
            ye = ($e[xe] & 31) * 281474976710656 + $e[xe + 1] * 1099511627776 + $e[xe + 2] * 4294967296 + $e[xe + 3] * 16777216 + ($e[xe + 4] << 16) + ($e[xe + 5] << 8) + $e[xe + 6], ye >= 9e15 ? crypto.randomBytes(7).copy($e, xe) : (_e.push(ye % 1e14), xe += 7);
          xe = ge / 7;
        } else
          throw Ce = !1, Error(bignumberError + "crypto unavailable");
      if (!Ce)
        for (; xe < ge; )
          ye = ze(), ye < 9e15 && (_e[xe++] = ye % 1e14);
      for (ge = _e[--xe], ot %= LOG_BASE, ge && ot && (ye = POWS_TEN[LOG_BASE - ot], _e[xe] = mathfloor(ge / ye) * ye); _e[xe] === 0; _e.pop(), xe--)
        ;
      if (xe < 0)
        _e = [pe = 0];
      else {
        for (pe = -1; _e[0] === 0; _e.splice(0, 1), pe -= LOG_BASE)
          ;
        for (xe = 1, ye = _e[0]; ye >= 10; ye /= 10, xe++)
          ;
        xe < LOG_BASE && (pe -= LOG_BASE - xe);
      }
      return Ae.e = pe, Ae.c = _e, Ae;
    };
  }(), De.sum = function() {
    for (var qe = 1, ze = arguments, ot = new De(ze[0]); qe < ze.length; )
      ot = ot.plus(ze[qe++]);
    return ot;
  }, se = /* @__PURE__ */ function() {
    var qe = "0123456789";
    function ze(ot, $e, le, pe) {
      for (var ge, ye = [0], xe, _e = 0, Ae = ot.length; _e < Ae; ) {
        for (xe = ye.length; xe--; ye[xe] *= $e)
          ;
        for (ye[0] += pe.indexOf(ot.charAt(_e++)), ge = 0; ge < ye.length; ge++)
          ye[ge] > le - 1 && (ye[ge + 1] == null && (ye[ge + 1] = 0), ye[ge + 1] += ye[ge] / le | 0, ye[ge] %= le);
      }
      return ye.reverse();
    }
    return function(ot, $e, le, pe, ge) {
      var ye, xe, _e, Ae, ve, he, be, Me, Re = ot.indexOf("."), Oe = de, Te = me;
      for (Re >= 0 && (Ae = Pe, Pe = 0, ot = ot.replace(".", ""), Me = new De($e), he = Me.pow(ot.length - Re), Pe = Ae, Me.c = ze(
        toFixedPoint(coeffToString(he.c), he.e, "0"),
        10,
        le,
        qe
      ), Me.e = Me.c.length), be = ze(ot, $e, le, ge ? (ye = ke, qe) : (ye = qe, ke)), _e = Ae = be.length; be[--Ae] == 0; be.pop())
        ;
      if (!be[0])
        return ye.charAt(0);
      if (Re < 0 ? --_e : (he.c = be, he.e = _e, he.s = pe, he = ie(he, Me, Oe, Te, le), be = he.c, ve = he.r, _e = he.e), xe = _e + Oe + 1, Re = be[xe], Ae = le / 2, ve = ve || xe < 0 || be[xe + 1] != null, ve = Te < 4 ? (Re != null || ve) && (Te == 0 || Te == (he.s < 0 ? 3 : 2)) : Re > Ae || Re == Ae && (Te == 4 || ve || Te == 6 && be[xe - 1] & 1 || Te == (he.s < 0 ? 8 : 7)), xe < 1 || !be[0])
        ot = ve ? toFixedPoint(ye.charAt(1), -Oe, ye.charAt(0)) : ye.charAt(0);
      else {
        if (be.length = xe, ve)
          for (--le; ++be[--xe] > le; )
            be[xe] = 0, xe || (++_e, be = [1].concat(be));
        for (Ae = be.length; !be[--Ae]; )
          ;
        for (Re = 0, ot = ""; Re <= Ae; ot += ye.charAt(be[Re++]))
          ;
        ot = toFixedPoint(ot, _e, ye.charAt(0));
      }
      return ot;
    };
  }(), ie = /* @__PURE__ */ function() {
    function qe($e, le, pe) {
      var ge, ye, xe, _e, Ae = 0, ve = $e.length, he = le % SQRT_BASE, be = le / SQRT_BASE | 0;
      for ($e = $e.slice(); ve--; )
        xe = $e[ve] % SQRT_BASE, _e = $e[ve] / SQRT_BASE | 0, ge = be * xe + _e * he, ye = he * xe + ge % SQRT_BASE * SQRT_BASE + Ae, Ae = (ye / pe | 0) + (ge / SQRT_BASE | 0) + be * _e, $e[ve] = ye % pe;
      return Ae && ($e = [Ae].concat($e)), $e;
    }
    function ze($e, le, pe, ge) {
      var ye, xe;
      if (pe != ge)
        xe = pe > ge ? 1 : -1;
      else
        for (ye = xe = 0; ye < pe; ye++)
          if ($e[ye] != le[ye]) {
            xe = $e[ye] > le[ye] ? 1 : -1;
            break;
          }
      return xe;
    }
    function ot($e, le, pe, ge) {
      for (var ye = 0; pe--; )
        $e[pe] -= ye, ye = $e[pe] < le[pe] ? 1 : 0, $e[pe] = ye * ge + $e[pe] - le[pe];
      for (; !$e[0] && $e.length > 1; $e.splice(0, 1))
        ;
    }
    return function($e, le, pe, ge, ye) {
      var xe, _e, Ae, ve, he, be, Me, Re, Oe, Te, Fe, je, ct, nt, dt, it, Je, gt = $e.s == le.s ? 1 : -1, Ht = $e.c, $t = le.c;
      if (!Ht || !Ht[0] || !$t || !$t[0])
        return new De(
          // Return NaN if either NaN, or both Infinity or 0.
          !$e.s || !le.s || (Ht ? $t && Ht[0] == $t[0] : !$t) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            Ht && Ht[0] == 0 || !$t ? gt * 0 : gt / 0
          )
        );
      for (Re = new De(gt), Oe = Re.c = [], _e = $e.e - le.e, gt = pe + _e + 1, ye || (ye = BASE, _e = bitFloor($e.e / LOG_BASE) - bitFloor(le.e / LOG_BASE), gt = gt / LOG_BASE | 0), Ae = 0; $t[Ae] == (Ht[Ae] || 0); Ae++)
        ;
      if ($t[Ae] > (Ht[Ae] || 0) && _e--, gt < 0)
        Oe.push(1), ve = !0;
      else {
        for (nt = Ht.length, it = $t.length, Ae = 0, gt += 2, he = mathfloor(ye / ($t[0] + 1)), he > 1 && ($t = qe($t, he, ye), Ht = qe(Ht, he, ye), it = $t.length, nt = Ht.length), ct = it, Te = Ht.slice(0, it), Fe = Te.length; Fe < it; Te[Fe++] = 0)
          ;
        Je = $t.slice(), Je = [0].concat(Je), dt = $t[0], $t[1] >= ye / 2 && dt++;
        do {
          if (he = 0, xe = ze($t, Te, it, Fe), xe < 0) {
            if (je = Te[0], it != Fe && (je = je * ye + (Te[1] || 0)), he = mathfloor(je / dt), he > 1)
              for (he >= ye && (he = ye - 1), be = qe($t, he, ye), Me = be.length, Fe = Te.length; ze(be, Te, Me, Fe) == 1; )
                he--, ot(be, it < Me ? Je : $t, Me, ye), Me = be.length, xe = 1;
            else
              he == 0 && (xe = he = 1), be = $t.slice(), Me = be.length;
            if (Me < Fe && (be = [0].concat(be)), ot(Te, be, Fe, ye), Fe = Te.length, xe == -1)
              for (; ze($t, Te, it, Fe) < 1; )
                he++, ot(Te, it < Fe ? Je : $t, Fe, ye), Fe = Te.length;
          } else
            xe === 0 && (he++, Te = [0]);
          Oe[Ae++] = he, Te[0] ? Te[Fe++] = Ht[ct] || 0 : (Te = [Ht[ct]], Fe = 1);
        } while ((ct++ < nt || Te[0] != null) && gt--);
        ve = Te[0] != null, Oe[0] || Oe.splice(0, 1);
      }
      if (ye == BASE) {
        for (Ae = 1, gt = Oe[0]; gt >= 10; gt /= 10, Ae++)
          ;
        at(Re, pe + (Re.e = Ae + _e * LOG_BASE - 1) + 1, ge, ve);
      } else
        Re.e = _e, Re.r = +ve;
      return Re;
    };
  }();
  function Ge(qe, ze, ot, $e) {
    var le, pe, ge, ye, xe;
    if (ot == null ? ot = me : intCheck(ot, 0, 8), !qe.c)
      return qe.toString();
    if (le = qe.c[0], ge = qe.e, ze == null)
      xe = coeffToString(qe.c), xe = $e == 1 || $e == 2 && (ge <= we || ge >= Ee) ? toExponential(xe, ge) : toFixedPoint(xe, ge, "0");
    else if (qe = at(new De(qe), ze, ot), pe = qe.e, xe = coeffToString(qe.c), ye = xe.length, $e == 1 || $e == 2 && (ze <= pe || pe <= we)) {
      for (; ye < ze; xe += "0", ye++)
        ;
      xe = toExponential(xe, pe);
    } else if (ze -= ge, xe = toFixedPoint(xe, pe, "0"), pe + 1 > ye) {
      if (--ze > 0)
        for (xe += "."; ze--; xe += "0")
          ;
    } else if (ze += pe - ye, ze > 0)
      for (pe + 1 == ye && (xe += "."); ze--; xe += "0")
        ;
    return qe.s < 0 && le ? "-" + xe : xe;
  }
  function Ye(qe, ze) {
    for (var ot, $e, le = 1, pe = new De(qe[0]); le < qe.length; le++)
      $e = new De(qe[le]), (!$e.s || (ot = compare(pe, $e)) === ze || ot === 0 && pe.s === ze) && (pe = $e);
    return pe;
  }
  function st(qe, ze, ot) {
    for (var $e = 1, le = ze.length; !ze[--le]; ze.pop())
      ;
    for (le = ze[0]; le >= 10; le /= 10, $e++)
      ;
    return (ot = $e + ot * LOG_BASE - 1) > Be ? qe.c = qe.e = null : ot < Se ? qe.c = [qe.e = 0] : (qe.e = ot, qe.c = ze), qe;
  }
  fe = /* @__PURE__ */ function() {
    var qe = /^(-?)0([xbo])(?=\w[\w.]*$)/i, ze = /^([^.]+)\.$/, ot = /^\.([^.]+)$/, $e = /^-?(Infinity|NaN)$/, le = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(pe, ge, ye, xe) {
      var _e, Ae = ye ? ge : ge.replace(le, "");
      if ($e.test(Ae))
        pe.s = isNaN(Ae) ? null : Ae < 0 ? -1 : 1;
      else {
        if (!ye && (Ae = Ae.replace(qe, function(ve, he, be) {
          return _e = (be = be.toLowerCase()) == "x" ? 16 : be == "b" ? 2 : 8, !xe || xe == _e ? he : ve;
        }), xe && (_e = xe, Ae = Ae.replace(ze, "$1").replace(ot, "0.$1")), ge != Ae))
          return new De(Ae, _e);
        if (De.DEBUG)
          throw Error(bignumberError + "Not a" + (xe ? " base " + xe : "") + " number: " + ge);
        pe.s = null;
      }
      pe.c = pe.e = null;
    };
  }();
  function at(qe, ze, ot, $e) {
    var le, pe, ge, ye, xe, _e, Ae, ve = qe.c, he = POWS_TEN;
    if (ve) {
      e: {
        for (le = 1, ye = ve[0]; ye >= 10; ye /= 10, le++)
          ;
        if (pe = ze - le, pe < 0)
          pe += LOG_BASE, ge = ze, xe = ve[_e = 0], Ae = mathfloor(xe / he[le - ge - 1] % 10);
        else if (_e = mathceil((pe + 1) / LOG_BASE), _e >= ve.length)
          if ($e) {
            for (; ve.length <= _e; ve.push(0))
              ;
            xe = Ae = 0, le = 1, pe %= LOG_BASE, ge = pe - LOG_BASE + 1;
          } else
            break e;
        else {
          for (xe = ye = ve[_e], le = 1; ye >= 10; ye /= 10, le++)
            ;
          pe %= LOG_BASE, ge = pe - LOG_BASE + le, Ae = ge < 0 ? 0 : mathfloor(xe / he[le - ge - 1] % 10);
        }
        if ($e = $e || ze < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        ve[_e + 1] != null || (ge < 0 ? xe : xe % he[le - ge - 1]), $e = ot < 4 ? (Ae || $e) && (ot == 0 || ot == (qe.s < 0 ? 3 : 2)) : Ae > 5 || Ae == 5 && (ot == 4 || $e || ot == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (pe > 0 ? ge > 0 ? xe / he[le - ge] : 0 : ve[_e - 1]) % 10 & 1 || ot == (qe.s < 0 ? 8 : 7)), ze < 1 || !ve[0])
          return ve.length = 0, $e ? (ze -= qe.e + 1, ve[0] = he[(LOG_BASE - ze % LOG_BASE) % LOG_BASE], qe.e = -ze || 0) : ve[0] = qe.e = 0, qe;
        if (pe == 0 ? (ve.length = _e, ye = 1, _e--) : (ve.length = _e + 1, ye = he[LOG_BASE - pe], ve[_e] = ge > 0 ? mathfloor(xe / he[le - ge] % he[ge]) * ye : 0), $e)
          for (; ; )
            if (_e == 0) {
              for (pe = 1, ge = ve[0]; ge >= 10; ge /= 10, pe++)
                ;
              for (ge = ve[0] += ye, ye = 1; ge >= 10; ge /= 10, ye++)
                ;
              pe != ye && (qe.e++, ve[0] == BASE && (ve[0] = 1));
              break;
            } else {
              if (ve[_e] += ye, ve[_e] != BASE)
                break;
              ve[_e--] = 0, ye = 1;
            }
        for (pe = ve.length; ve[--pe] === 0; ve.pop())
          ;
      }
      qe.e > Be ? qe.c = qe.e = null : qe.e < Se && (qe.c = [qe.e = 0]);
    }
    return qe;
  }
  function mt(qe) {
    var ze, ot = qe.e;
    return ot === null ? qe.toString() : (ze = coeffToString(qe.c), ze = ot <= we || ot >= Ee ? toExponential(ze, ot) : toFixedPoint(ze, ot, "0"), qe.s < 0 ? "-" + ze : ze);
  }
  return ue.absoluteValue = ue.abs = function() {
    var qe = new De(this);
    return qe.s < 0 && (qe.s = 1), qe;
  }, ue.comparedTo = function(qe, ze) {
    return compare(this, new De(qe, ze));
  }, ue.decimalPlaces = ue.dp = function(qe, ze) {
    var ot, $e, le, pe = this;
    if (qe != null)
      return intCheck(qe, 0, MAX), ze == null ? ze = me : intCheck(ze, 0, 8), at(new De(pe), qe + pe.e + 1, ze);
    if (!(ot = pe.c))
      return null;
    if ($e = ((le = ot.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE, le = ot[le])
      for (; le % 10 == 0; le /= 10, $e--)
        ;
    return $e < 0 && ($e = 0), $e;
  }, ue.dividedBy = ue.div = function(qe, ze) {
    return ie(this, new De(qe, ze), de, me);
  }, ue.dividedToIntegerBy = ue.idiv = function(qe, ze) {
    return ie(this, new De(qe, ze), 0, 1);
  }, ue.exponentiatedBy = ue.pow = function(qe, ze) {
    var ot, $e, le, pe, ge, ye, xe, _e, Ae, ve = this;
    if (qe = new De(qe), qe.c && !qe.isInteger())
      throw Error(bignumberError + "Exponent not an integer: " + mt(qe));
    if (ze != null && (ze = new De(ze)), ye = qe.e > 14, !ve.c || !ve.c[0] || ve.c[0] == 1 && !ve.e && ve.c.length == 1 || !qe.c || !qe.c[0])
      return Ae = new De(Math.pow(+mt(ve), ye ? qe.s * (2 - isOdd(qe)) : +mt(qe))), ze ? Ae.mod(ze) : Ae;
    if (xe = qe.s < 0, ze) {
      if (ze.c ? !ze.c[0] : !ze.s)
        return new De(NaN);
      $e = !xe && ve.isInteger() && ze.isInteger(), $e && (ve = ve.mod(ze));
    } else {
      if (qe.e > 9 && (ve.e > 0 || ve.e < -1 || (ve.e == 0 ? ve.c[0] > 1 || ye && ve.c[1] >= 24e7 : ve.c[0] < 8e13 || ye && ve.c[0] <= 9999975e7)))
        return pe = ve.s < 0 && isOdd(qe) ? -0 : 0, ve.e > -1 && (pe = 1 / pe), new De(xe ? 1 / pe : pe);
      Pe && (pe = mathceil(Pe / LOG_BASE + 2));
    }
    for (ye ? (ot = new De(0.5), xe && (qe.s = 1), _e = isOdd(qe)) : (le = Math.abs(+mt(qe)), _e = le % 2), Ae = new De(ce); ; ) {
      if (_e) {
        if (Ae = Ae.times(ve), !Ae.c)
          break;
        pe ? Ae.c.length > pe && (Ae.c.length = pe) : $e && (Ae = Ae.mod(ze));
      }
      if (le) {
        if (le = mathfloor(le / 2), le === 0)
          break;
        _e = le % 2;
      } else if (qe = qe.times(ot), at(qe, qe.e + 1, 1), qe.e > 14)
        _e = isOdd(qe);
      else {
        if (le = +mt(qe), le === 0)
          break;
        _e = le % 2;
      }
      ve = ve.times(ve), pe ? ve.c && ve.c.length > pe && (ve.c.length = pe) : $e && (ve = ve.mod(ze));
    }
    return $e ? Ae : (xe && (Ae = ce.div(Ae)), ze ? Ae.mod(ze) : pe ? at(Ae, Pe, me, ge) : Ae);
  }, ue.integerValue = function(qe) {
    var ze = new De(this);
    return qe == null ? qe = me : intCheck(qe, 0, 8), at(ze, ze.e + 1, qe);
  }, ue.isEqualTo = ue.eq = function(qe, ze) {
    return compare(this, new De(qe, ze)) === 0;
  }, ue.isFinite = function() {
    return !!this.c;
  }, ue.isGreaterThan = ue.gt = function(qe, ze) {
    return compare(this, new De(qe, ze)) > 0;
  }, ue.isGreaterThanOrEqualTo = ue.gte = function(qe, ze) {
    return (ze = compare(this, new De(qe, ze))) === 1 || ze === 0;
  }, ue.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  }, ue.isLessThan = ue.lt = function(qe, ze) {
    return compare(this, new De(qe, ze)) < 0;
  }, ue.isLessThanOrEqualTo = ue.lte = function(qe, ze) {
    return (ze = compare(this, new De(qe, ze))) === -1 || ze === 0;
  }, ue.isNaN = function() {
    return !this.s;
  }, ue.isNegative = function() {
    return this.s < 0;
  }, ue.isPositive = function() {
    return this.s > 0;
  }, ue.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, ue.minus = function(qe, ze) {
    var ot, $e, le, pe, ge = this, ye = ge.s;
    if (qe = new De(qe, ze), ze = qe.s, !ye || !ze)
      return new De(NaN);
    if (ye != ze)
      return qe.s = -ze, ge.plus(qe);
    var xe = ge.e / LOG_BASE, _e = qe.e / LOG_BASE, Ae = ge.c, ve = qe.c;
    if (!xe || !_e) {
      if (!Ae || !ve)
        return Ae ? (qe.s = -ze, qe) : new De(ve ? ge : NaN);
      if (!Ae[0] || !ve[0])
        return ve[0] ? (qe.s = -ze, qe) : new De(Ae[0] ? ge : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          me == 3 ? -0 : 0
        ));
    }
    if (xe = bitFloor(xe), _e = bitFloor(_e), Ae = Ae.slice(), ye = xe - _e) {
      for ((pe = ye < 0) ? (ye = -ye, le = Ae) : (_e = xe, le = ve), le.reverse(), ze = ye; ze--; le.push(0))
        ;
      le.reverse();
    } else
      for ($e = (pe = (ye = Ae.length) < (ze = ve.length)) ? ye : ze, ye = ze = 0; ze < $e; ze++)
        if (Ae[ze] != ve[ze]) {
          pe = Ae[ze] < ve[ze];
          break;
        }
    if (pe && (le = Ae, Ae = ve, ve = le, qe.s = -qe.s), ze = ($e = ve.length) - (ot = Ae.length), ze > 0)
      for (; ze--; Ae[ot++] = 0)
        ;
    for (ze = BASE - 1; $e > ye; ) {
      if (Ae[--$e] < ve[$e]) {
        for (ot = $e; ot && !Ae[--ot]; Ae[ot] = ze)
          ;
        --Ae[ot], Ae[$e] += BASE;
      }
      Ae[$e] -= ve[$e];
    }
    for (; Ae[0] == 0; Ae.splice(0, 1), --_e)
      ;
    return Ae[0] ? st(qe, Ae, _e) : (qe.s = me == 3 ? -1 : 1, qe.c = [qe.e = 0], qe);
  }, ue.modulo = ue.mod = function(qe, ze) {
    var ot, $e, le = this;
    return qe = new De(qe, ze), !le.c || !qe.s || qe.c && !qe.c[0] ? new De(NaN) : !qe.c || le.c && !le.c[0] ? new De(le) : (Ie == 9 ? ($e = qe.s, qe.s = 1, ot = ie(le, qe, 0, 3), qe.s = $e, ot.s *= $e) : ot = ie(le, qe, 0, Ie), qe = le.minus(ot.times(qe)), !qe.c[0] && Ie == 1 && (qe.s = le.s), qe);
  }, ue.multipliedBy = ue.times = function(qe, ze) {
    var ot, $e, le, pe, ge, ye, xe, _e, Ae, ve, he, be, Me, Re, Oe, Te = this, Fe = Te.c, je = (qe = new De(qe, ze)).c;
    if (!Fe || !je || !Fe[0] || !je[0])
      return !Te.s || !qe.s || Fe && !Fe[0] && !je || je && !je[0] && !Fe ? qe.c = qe.e = qe.s = null : (qe.s *= Te.s, !Fe || !je ? qe.c = qe.e = null : (qe.c = [0], qe.e = 0)), qe;
    for ($e = bitFloor(Te.e / LOG_BASE) + bitFloor(qe.e / LOG_BASE), qe.s *= Te.s, xe = Fe.length, ve = je.length, xe < ve && (Me = Fe, Fe = je, je = Me, le = xe, xe = ve, ve = le), le = xe + ve, Me = []; le--; Me.push(0))
      ;
    for (Re = BASE, Oe = SQRT_BASE, le = ve; --le >= 0; ) {
      for (ot = 0, he = je[le] % Oe, be = je[le] / Oe | 0, ge = xe, pe = le + ge; pe > le; )
        _e = Fe[--ge] % Oe, Ae = Fe[ge] / Oe | 0, ye = be * _e + Ae * he, _e = he * _e + ye % Oe * Oe + Me[pe] + ot, ot = (_e / Re | 0) + (ye / Oe | 0) + be * Ae, Me[pe--] = _e % Re;
      Me[pe] = ot;
    }
    return ot ? ++$e : Me.splice(0, 1), st(qe, Me, $e);
  }, ue.negated = function() {
    var qe = new De(this);
    return qe.s = -qe.s || null, qe;
  }, ue.plus = function(qe, ze) {
    var ot, $e = this, le = $e.s;
    if (qe = new De(qe, ze), ze = qe.s, !le || !ze)
      return new De(NaN);
    if (le != ze)
      return qe.s = -ze, $e.minus(qe);
    var pe = $e.e / LOG_BASE, ge = qe.e / LOG_BASE, ye = $e.c, xe = qe.c;
    if (!pe || !ge) {
      if (!ye || !xe)
        return new De(le / 0);
      if (!ye[0] || !xe[0])
        return xe[0] ? qe : new De(ye[0] ? $e : le * 0);
    }
    if (pe = bitFloor(pe), ge = bitFloor(ge), ye = ye.slice(), le = pe - ge) {
      for (le > 0 ? (ge = pe, ot = xe) : (le = -le, ot = ye), ot.reverse(); le--; ot.push(0))
        ;
      ot.reverse();
    }
    for (le = ye.length, ze = xe.length, le - ze < 0 && (ot = xe, xe = ye, ye = ot, ze = le), le = 0; ze; )
      le = (ye[--ze] = ye[ze] + xe[ze] + le) / BASE | 0, ye[ze] = BASE === ye[ze] ? 0 : ye[ze] % BASE;
    return le && (ye = [le].concat(ye), ++ge), st(qe, ye, ge);
  }, ue.precision = ue.sd = function(qe, ze) {
    var ot, $e, le, pe = this;
    if (qe != null && qe !== !!qe)
      return intCheck(qe, 1, MAX), ze == null ? ze = me : intCheck(ze, 0, 8), at(new De(pe), qe, ze);
    if (!(ot = pe.c))
      return null;
    if (le = ot.length - 1, $e = le * LOG_BASE + 1, le = ot[le]) {
      for (; le % 10 == 0; le /= 10, $e--)
        ;
      for (le = ot[0]; le >= 10; le /= 10, $e++)
        ;
    }
    return qe && pe.e + 1 > $e && ($e = pe.e + 1), $e;
  }, ue.shiftedBy = function(qe) {
    return intCheck(qe, -MAX_SAFE_INTEGER$1, MAX_SAFE_INTEGER$1), this.times("1e" + qe);
  }, ue.squareRoot = ue.sqrt = function() {
    var qe, ze, ot, $e, le, pe = this, ge = pe.c, ye = pe.s, xe = pe.e, _e = de + 4, Ae = new De("0.5");
    if (ye !== 1 || !ge || !ge[0])
      return new De(!ye || ye < 0 && (!ge || ge[0]) ? NaN : ge ? pe : 1 / 0);
    if (ye = Math.sqrt(+mt(pe)), ye == 0 || ye == 1 / 0 ? (ze = coeffToString(ge), (ze.length + xe) % 2 == 0 && (ze += "0"), ye = Math.sqrt(+ze), xe = bitFloor((xe + 1) / 2) - (xe < 0 || xe % 2), ye == 1 / 0 ? ze = "5e" + xe : (ze = ye.toExponential(), ze = ze.slice(0, ze.indexOf("e") + 1) + xe), ot = new De(ze)) : ot = new De(ye + ""), ot.c[0]) {
      for (xe = ot.e, ye = xe + _e, ye < 3 && (ye = 0); ; )
        if (le = ot, ot = Ae.times(le.plus(ie(pe, le, _e, 1))), coeffToString(le.c).slice(0, ye) === (ze = coeffToString(ot.c)).slice(0, ye))
          if (ot.e < xe && --ye, ze = ze.slice(ye - 3, ye + 1), ze == "9999" || !$e && ze == "4999") {
            if (!$e && (at(le, le.e + de + 2, 0), le.times(le).eq(pe))) {
              ot = le;
              break;
            }
            _e += 4, ye += 4, $e = 1;
          } else {
            (!+ze || !+ze.slice(1) && ze.charAt(0) == "5") && (at(ot, ot.e + de + 2, 1), qe = !ot.times(ot).eq(pe));
            break;
          }
    }
    return at(ot, ot.e + de + 1, me, qe);
  }, ue.toExponential = function(qe, ze) {
    return qe != null && (intCheck(qe, 0, MAX), qe++), Ge(this, qe, ze, 1);
  }, ue.toFixed = function(qe, ze) {
    return qe != null && (intCheck(qe, 0, MAX), qe = qe + this.e + 1), Ge(this, qe, ze);
  }, ue.toFormat = function(qe, ze, ot) {
    var $e, le = this;
    if (ot == null)
      qe != null && ze && typeof ze == "object" ? (ot = ze, ze = null) : qe && typeof qe == "object" ? (ot = qe, qe = ze = null) : ot = Ne;
    else if (typeof ot != "object")
      throw Error(bignumberError + "Argument not an object: " + ot);
    if ($e = le.toFixed(qe, ze), le.c) {
      var pe, ge = $e.split("."), ye = +ot.groupSize, xe = +ot.secondaryGroupSize, _e = ot.groupSeparator || "", Ae = ge[0], ve = ge[1], he = le.s < 0, be = he ? Ae.slice(1) : Ae, Me = be.length;
      if (xe && (pe = ye, ye = xe, xe = pe, Me -= pe), ye > 0 && Me > 0) {
        for (pe = Me % ye || ye, Ae = be.substr(0, pe); pe < Me; pe += ye)
          Ae += _e + be.substr(pe, ye);
        xe > 0 && (Ae += _e + be.slice(pe)), he && (Ae = "-" + Ae);
      }
      $e = ve ? Ae + (ot.decimalSeparator || "") + ((xe = +ot.fractionGroupSize) ? ve.replace(
        new RegExp("\\d{" + xe + "}\\B", "g"),
        "$&" + (ot.fractionGroupSeparator || "")
      ) : ve) : Ae;
    }
    return (ot.prefix || "") + $e + (ot.suffix || "");
  }, ue.toFraction = function(qe) {
    var ze, ot, $e, le, pe, ge, ye, xe, _e, Ae, ve, he, be = this, Me = be.c;
    if (qe != null && (ye = new De(qe), !ye.isInteger() && (ye.c || ye.s !== 1) || ye.lt(ce)))
      throw Error(bignumberError + "Argument " + (ye.isInteger() ? "out of range: " : "not an integer: ") + mt(ye));
    if (!Me)
      return new De(be);
    for (ze = new De(ce), _e = ot = new De(ce), $e = xe = new De(ce), he = coeffToString(Me), pe = ze.e = he.length - be.e - 1, ze.c[0] = POWS_TEN[(ge = pe % LOG_BASE) < 0 ? LOG_BASE + ge : ge], qe = !qe || ye.comparedTo(ze) > 0 ? pe > 0 ? ze : _e : ye, ge = Be, Be = 1 / 0, ye = new De(he), xe.c[0] = 0; Ae = ie(ye, ze, 0, 1), le = ot.plus(Ae.times($e)), le.comparedTo(qe) != 1; )
      ot = $e, $e = le, _e = xe.plus(Ae.times(le = _e)), xe = le, ze = ye.minus(Ae.times(le = ze)), ye = le;
    return le = ie(qe.minus(ot), $e, 0, 1), xe = xe.plus(le.times(_e)), ot = ot.plus(le.times($e)), xe.s = _e.s = be.s, pe = pe * 2, ve = ie(_e, $e, pe, me).minus(be).abs().comparedTo(
      ie(xe, ot, pe, me).minus(be).abs()
    ) < 1 ? [_e, $e] : [xe, ot], Be = ge, ve;
  }, ue.toNumber = function() {
    return +mt(this);
  }, ue.toPrecision = function(qe, ze) {
    return qe != null && intCheck(qe, 1, MAX), Ge(this, qe, ze, 2);
  }, ue.toString = function(qe) {
    var ze, ot = this, $e = ot.s, le = ot.e;
    return le === null ? $e ? (ze = "Infinity", $e < 0 && (ze = "-" + ze)) : ze = "NaN" : (qe == null ? ze = le <= we || le >= Ee ? toExponential(coeffToString(ot.c), le) : toFixedPoint(coeffToString(ot.c), le, "0") : qe === 10 && He ? (ot = at(new De(ot), de + le + 1, me), ze = toFixedPoint(coeffToString(ot.c), ot.e, "0")) : (intCheck(qe, 2, ke.length, "Base"), ze = se(toFixedPoint(coeffToString(ot.c), le, "0"), 10, qe, $e, !0)), $e < 0 && ot.c[0] && (ze = "-" + ze)), ze;
  }, ue.valueOf = ue.toJSON = function() {
    return mt(this);
  }, ue._isBigNumber = !0, ue[Symbol.toStringTag] = "BigNumber", ue[Symbol.for("nodejs.util.inspect.custom")] = ue.valueOf, ae != null && De.set(ae), De;
}
function bitFloor(ae) {
  var ie = ae | 0;
  return ae > 0 || ae === ie ? ie : ie - 1;
}
function coeffToString(ae) {
  for (var ie, se, fe = 1, ue = ae.length, ce = ae[0] + ""; fe < ue; ) {
    for (ie = ae[fe++] + "", se = LOG_BASE - ie.length; se--; ie = "0" + ie)
      ;
    ce += ie;
  }
  for (ue = ce.length; ce.charCodeAt(--ue) === 48; )
    ;
  return ce.slice(0, ue + 1 || 1);
}
function compare(ae, ie) {
  var se, fe, ue = ae.c, ce = ie.c, de = ae.s, me = ie.s, we = ae.e, Ee = ie.e;
  if (!de || !me)
    return null;
  if (se = ue && !ue[0], fe = ce && !ce[0], se || fe)
    return se ? fe ? 0 : -me : de;
  if (de != me)
    return de;
  if (se = de < 0, fe = we == Ee, !ue || !ce)
    return fe ? 0 : !ue ^ se ? 1 : -1;
  if (!fe)
    return we > Ee ^ se ? 1 : -1;
  for (me = (we = ue.length) < (Ee = ce.length) ? we : Ee, de = 0; de < me; de++)
    if (ue[de] != ce[de])
      return ue[de] > ce[de] ^ se ? 1 : -1;
  return we == Ee ? 0 : we > Ee ^ se ? 1 : -1;
}
function intCheck(ae, ie, se, fe) {
  if (ae < ie || ae > se || ae !== mathfloor(ae))
    throw Error(bignumberError + (fe || "Argument") + (typeof ae == "number" ? ae < ie || ae > se ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(ae));
}
function isOdd(ae) {
  var ie = ae.c.length - 1;
  return bitFloor(ae.e / LOG_BASE) == ie && ae.c[ie] % 2 != 0;
}
function toExponential(ae, ie) {
  return (ae.length > 1 ? ae.charAt(0) + "." + ae.slice(1) : ae) + (ie < 0 ? "e" : "e+") + ie;
}
function toFixedPoint(ae, ie, se) {
  var fe, ue;
  if (ie < 0) {
    for (ue = se + "."; ++ie; ue += se)
      ;
    ae = ue + ae;
  } else if (fe = ae.length, ++ie > fe) {
    for (ue = se, ie -= fe; --ie; ue += se)
      ;
    ae += ue;
  } else
    ie < fe && (ae = ae.slice(0, ie) + "." + ae.slice(ie));
  return ae;
}
var BigNumber$1 = clone(), retry$3 = {};
function RetryOperation(ae, ie) {
  typeof ie == "boolean" && (ie = { forever: ie }), this._originalTimeouts = JSON.parse(JSON.stringify(ae)), this._timeouts = ae, this._options = ie || {}, this._maxRetryTime = ie && ie.maxRetryTime || 1 / 0, this._fn = null, this._errors = [], this._attempts = 1, this._operationTimeout = null, this._operationTimeoutCb = null, this._timeout = null, this._operationStart = null, this._timer = null, this._options.forever && (this._cachedTimeouts = this._timeouts.slice(0));
}
var retry_operation = RetryOperation;
RetryOperation.prototype.reset = function() {
  this._attempts = 1, this._timeouts = this._originalTimeouts.slice(0);
};
RetryOperation.prototype.stop = function() {
  this._timeout && clearTimeout(this._timeout), this._timer && clearTimeout(this._timer), this._timeouts = [], this._cachedTimeouts = null;
};
RetryOperation.prototype.retry = function(ae) {
  if (this._timeout && clearTimeout(this._timeout), !ae)
    return !1;
  var ie = (/* @__PURE__ */ new Date()).getTime();
  if (ae && ie - this._operationStart >= this._maxRetryTime)
    return this._errors.push(ae), this._errors.unshift(new Error("RetryOperation timeout occurred")), !1;
  this._errors.push(ae);
  var se = this._timeouts.shift();
  if (se === void 0)
    if (this._cachedTimeouts)
      this._errors.splice(0, this._errors.length - 1), se = this._cachedTimeouts.slice(-1);
    else
      return !1;
  var fe = this;
  return this._timer = setTimeout(function() {
    fe._attempts++, fe._operationTimeoutCb && (fe._timeout = setTimeout(function() {
      fe._operationTimeoutCb(fe._attempts);
    }, fe._operationTimeout), fe._options.unref && fe._timeout.unref()), fe._fn(fe._attempts);
  }, se), this._options.unref && this._timer.unref(), !0;
};
RetryOperation.prototype.attempt = function(ae, ie) {
  this._fn = ae, ie && (ie.timeout && (this._operationTimeout = ie.timeout), ie.cb && (this._operationTimeoutCb = ie.cb));
  var se = this;
  this._operationTimeoutCb && (this._timeout = setTimeout(function() {
    se._operationTimeoutCb();
  }, se._operationTimeout)), this._operationStart = (/* @__PURE__ */ new Date()).getTime(), this._fn(this._attempts);
};
RetryOperation.prototype.try = function(ae) {
  console.log("Using RetryOperation.try() is deprecated"), this.attempt(ae);
};
RetryOperation.prototype.start = function(ae) {
  console.log("Using RetryOperation.start() is deprecated"), this.attempt(ae);
};
RetryOperation.prototype.start = RetryOperation.prototype.try;
RetryOperation.prototype.errors = function() {
  return this._errors;
};
RetryOperation.prototype.attempts = function() {
  return this._attempts;
};
RetryOperation.prototype.mainError = function() {
  if (this._errors.length === 0)
    return null;
  for (var ae = {}, ie = null, se = 0, fe = 0; fe < this._errors.length; fe++) {
    var ue = this._errors[fe], ce = ue.message, de = (ae[ce] || 0) + 1;
    ae[ce] = de, de >= se && (ie = ue, se = de);
  }
  return ie;
};
(function(ae) {
  var ie = retry_operation;
  ae.operation = function(se) {
    var fe = ae.timeouts(se);
    return new ie(fe, {
      forever: se && (se.forever || se.retries === 1 / 0),
      unref: se && se.unref,
      maxRetryTime: se && se.maxRetryTime
    });
  }, ae.timeouts = function(se) {
    if (se instanceof Array)
      return [].concat(se);
    var fe = {
      retries: 10,
      factor: 2,
      minTimeout: 1 * 1e3,
      maxTimeout: 1 / 0,
      randomize: !1
    };
    for (var ue in se)
      fe[ue] = se[ue];
    if (fe.minTimeout > fe.maxTimeout)
      throw new Error("minTimeout is greater than maxTimeout");
    for (var ce = [], de = 0; de < fe.retries; de++)
      ce.push(this.createTimeout(de, fe));
    return se && se.forever && !ce.length && ce.push(this.createTimeout(de, fe)), ce.sort(function(me, we) {
      return me - we;
    }), ce;
  }, ae.createTimeout = function(se, fe) {
    var ue = fe.randomize ? Math.random() + 1 : 1, ce = Math.round(ue * Math.max(fe.minTimeout, 1) * Math.pow(fe.factor, se));
    return ce = Math.min(ce, fe.maxTimeout), ce;
  }, ae.wrap = function(se, fe, ue) {
    if (fe instanceof Array && (ue = fe, fe = null), !ue) {
      ue = [];
      for (var ce in se)
        typeof se[ce] == "function" && ue.push(ce);
    }
    for (var de = 0; de < ue.length; de++) {
      var me = ue[de], we = se[me];
      se[me] = function(Se) {
        var Be = ae.operation(fe), Ce = Array.prototype.slice.call(arguments, 1), Ie = Ce.pop();
        Ce.push(function(Pe) {
          Be.retry(Pe) || (Pe && (arguments[0] = Be.mainError()), Ie.apply(this, arguments));
        }), Be.attempt(function() {
          Se.apply(se, Ce);
        });
      }.bind(se, we), se[me].options = fe;
    }
  };
})(retry$3);
var retry$2 = retry$3, retrier = retry$2;
function retry(ae, ie) {
  function se(fe, ue) {
    var ce = ie || {}, de;
    "randomize" in ce || (ce.randomize = !0), de = retrier.operation(ce);
    function me(Se) {
      ue(Se || new Error("Aborted"));
    }
    function we(Se, Be) {
      if (Se.bail) {
        me(Se);
        return;
      }
      de.retry(Se) ? ce.onRetry && ce.onRetry(Se, Be) : ue(de.mainError());
    }
    function Ee(Se) {
      var Be;
      try {
        Be = ae(me, Se);
      } catch (Ce) {
        we(Ce, Se);
        return;
      }
      Promise.resolve(Be).then(fe).catch(function(Ie) {
        we(Ie, Se);
      });
    }
    de.attempt(Ee);
  }
  return new Promise(se);
}
var lib$9 = retry;
const retry$1 = /* @__PURE__ */ getDefaultExportFromCjs$2(lib$9);
BigNumber$1.set({ DECIMAL_PLACES: 50 });
const sleep$1 = (ae) => new Promise((ie) => setTimeout(ie, ae));
class Utils {
  api;
  token;
  tokenConfig;
  arbundles;
  constructor(ie, se, fe) {
    this.api = ie, this.token = se, this.tokenConfig = fe, this.arbundles = this.tokenConfig.irys.arbundles;
  }
  /**
   * Throws an error if the provided axios reponse has a status code != 200
   * @param res an axios response
   * @returns nothing if the status code is 200
   */
  static checkAndThrow(ie, se, fe) {
    if (ie?.status && !(fe ?? []).includes(ie.status) && ie.status != 200)
      throw new Error(`HTTP Error: ${se}: ${ie.status} ${typeof ie.data != "string" ? ie.statusText : ie.data}`);
  }
  /**
   * Gets the nonce used for withdrawal request validation from the bundler
   * @returns nonce for the current user
   */
  async getNonce() {
    const ie = await this.api.get(`/account/withdrawals/${this.tokenConfig.name}?address=${this.tokenConfig.address}`);
    return Utils.checkAndThrow(ie, "Getting withdrawal nonce"), ie.data;
  }
  /**
   * Gets the balance on the current bundler for the specified user
   * @param address the user's address to query
   * @returns the balance in winston
   */
  async getBalance(ie) {
    const se = await this.api.get(`/account/balance/${this.tokenConfig.name}?address=${ie}`);
    return Utils.checkAndThrow(se, "Getting balance"), new BigNumber$1(se.data.balance);
  }
  /**
   * Queries the bundler to get it's address for a specific token
   * @returns the bundler's address
   */
  async getBundlerAddress(ie) {
    const se = await this.api.get("/info");
    Utils.checkAndThrow(se, "Getting Bundler address");
    const fe = se.data.addresses[ie];
    if (!fe)
      throw new Error(`Specified bundler does not support token ${ie}`);
    return fe;
  }
  /**
   * Calculates the price for [bytes] bytes paid for with [token] for the loaded Irys node.
   * @param token
   * @param bytes
   * @returns
   */
  async getPrice(ie, se) {
    const fe = await this.api.get(`/price/${ie}/${se}`);
    return Utils.checkAndThrow(fe, "Getting storage cost"), new BigNumber$1(fe.data);
  }
  /**
   * This function *estimates* the cost in atomic units for uploading a given set of files
   * note: this function becomes less accurate the smaller your transactions, unless you provide it with an accurate headerSizeAvg
   * @param folderInfo either an array of file sizes in bytes, or an object containing the total number of files and the sum total size of the files in bytes
   * note: for a more precise estimate, you can create an empty (dataless) transaction (make sure you still set tags and other metadata!) and then pass `tx.size` as `headerSizeAvg`
   */
  async estimateFolderPrice(ie) {
    Array.isArray(ie) && (ie = {
      fileCount: ie.length,
      totalBytes: ie.reduce((de, me) => de + me, 0)
    });
    const se = ie.headerSizeAvg ?? this.arbundles.createData("", this.tokenConfig.getSigner()).getRaw().length, ue = (await this.getPrice(this.tokenConfig.name, se)).multipliedBy(ie.fileCount);
    return (await this.getPrice(this.tokenConfig.name, ie.totalBytes)).plus(ue).decimalPlaces(0);
  }
  /**
   * Returns the decimal values' equivalent in atomic units
   * @example
   * 0.1 ETH -> 100,000,000,000,000,000 wei
   * ```
   * toAtomic(100_000_000_000_000_000) -> 0.1
   * ```
   * @param decimalAmount - amount in decimal
   * @returns amount in atomic units
   */
  toAtomic(ie) {
    return new BigNumber$1(ie).multipliedBy(this.tokenConfig.base[1]);
  }
  /**
   * Returns the atomic amounts' equivalent in decimal units
   * @example
   * 100,000,000,000,000,000 wei -> 0.1 ETH
   * ```
   * fromAtomic(0.1) -> 100_000_000_000_000_000
   * ```
   * @param atomicAmount
   * @returns
   */
  fromAtomic(ie) {
    return new BigNumber$1(ie).dividedBy(this.tokenConfig.base[1]);
  }
  /**
   * Polls for transaction confirmation (or at least pending status) - used for fast currencies (i.e not arweave)
   * before posting the fund request to the server (so the server doesn't have to poll)
   * @param txid
   * @returns
   */
  async confirmationPoll(ie, se = 30) {
    if (this.tokenConfig.isSlow)
      return;
    se < 0 && (se = 0);
    let fe, ue;
    const ce = async () => {
      for (; !ue; ) {
        if (await this.tokenConfig.getTx(ie).then((Ee) => Ee?.confirmed).catch((Ee) => (fe = Ee, !1)))
          return !0;
        await sleep$1(1e3);
      }
      return !1;
    }, de = async () => (await sleep$1(se * 1e3), ue = !0, "RACE"), me = await Promise.race([de(), ce()]);
    return me === "RACE" ? (console.warn(`Tx ${ie} didn't finalize after ${se} seconds ${fe ? ` - ${fe}` : ""}`), fe) : me;
  }
  /**
   * @deprecated this method is deprecated in favour of fromAtomic - removal slated for 0.12.0
   */
  unitConverter(ie) {
    return new BigNumber$1(ie).dividedBy(this.tokenConfig.base[1]);
  }
  async verifyReceipt(ie) {
    return Utils.verifyReceipt(this.arbundles, ie);
  }
  static async verifyReceipt(ie, se) {
    const { id: fe, deadlineHeight: ue, timestamp: ce, public: de, signature: me, version: we } = se, Ee = await ie.deepHash([
      ie.stringToBuffer("Bundlr"),
      ie.stringToBuffer(we),
      ie.stringToBuffer(fe),
      ie.stringToBuffer(ue.toString()),
      ie.stringToBuffer(ce.toString())
    ]);
    return await ie.getCryptoDriver().verify(de, Ee, base64url.toBuffer(me));
  }
  async getReceipt(ie) {
    const se = `query {
      transactions(ids: ["${ie}"]) {
        edges {
          node {
            receipt {
              signature
              timestamp
              version
              deadlineHeight
            }
          }
        }
      }
    }`, ue = (await retry$1(async () => await this.api.post("/graphql", { query: se }, {
      headers: { "content-type": "application/json" },
      validateStatus: (me) => me === 200
    })))?.data?.data?.transactions?.edges?.at(0)?.node?.receipt;
    if (!ue)
      throw new Error(`Missing required receipt data from node for tx: ${ie}`);
    const de = {
      public: (await this.api.get("/public")).data,
      version: ue.version,
      id: ie,
      timestamp: ue.timestamp,
      validatorSignatures: [],
      signature: ue.signature,
      deadlineHeight: ue.deadlineHeight,
      // use stub to conform to type
      verify: async () => !1
    };
    return de.verify = async () => this.verifyReceipt(de), de;
  }
}
const erc20abi = [
  {
    constant: !0,
    inputs: [],
    name: "name",
    outputs: [
      {
        name: "",
        type: "string"
      }
    ],
    payable: !1,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: !1,
    inputs: [
      {
        name: "_spender",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: !1,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: !0,
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: !1,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: !1,
    inputs: [
      {
        name: "_from",
        type: "address"
      },
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: !1,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: !0,
    inputs: [],
    name: "decimals",
    outputs: [
      {
        name: "",
        type: "uint8"
      }
    ],
    payable: !1,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: !0,
    inputs: [
      {
        name: "_owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        name: "balance",
        type: "uint256"
      }
    ],
    payable: !1,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: !0,
    inputs: [],
    name: "symbol",
    outputs: [
      {
        name: "",
        type: "string"
      }
    ],
    payable: !1,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: !1,
    inputs: [
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: !1,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: !0,
    inputs: [
      {
        name: "_owner",
        type: "address"
      },
      {
        name: "_spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: !1,
    stateMutability: "view",
    type: "function"
  },
  {
    payable: !0,
    stateMutability: "payable",
    type: "fallback"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "owner",
        type: "address"
      },
      {
        indexed: !0,
        name: "spender",
        type: "address"
      },
      {
        indexed: !1,
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "from",
        type: "address"
      },
      {
        indexed: !0,
        name: "to",
        type: "address"
      },
      {
        indexed: !1,
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  }
];
async function withdrawBalance(ae, ie, se) {
  const fe = ae.tokenConfig, { deepHash: ue, stringToBuffer: ce } = fe.irys.arbundles, me = {
    publicKey: await fe.getPublicKey(),
    currency: ae.token,
    amount: new BigNumber$1(se).toString(),
    nonce: await ae.getNonce(),
    signature: "",
    sigType: fe.getSigner().signatureType
  }, we = await ue([ce(me.currency), ce(me.amount.toString()), ce(me.nonce.toString())]);
  Buffer$F.isBuffer(me.publicKey) || (me.publicKey = Buffer$F.from(me.publicKey));
  const Ee = await fe.sign(we), Se = await fe.verify(me.publicKey, we, Ee);
  me.publicKey = base64url.encode(me.publicKey), me.signature = base64url.encode(Buffer$F.from(Ee));
  const Be = base64url.toBuffer(me.publicKey), Ce = base64url.toBuffer(me.signature), Ie = await ue([ce(me.currency), ce(me.amount.toString()), ce(me.nonce.toString())]), Pe = await fe.verify(Be, Ie, Ce), Ne = fe.ownerToAddress(fe.name == "arweave" ? base64url.decode(me.publicKey) : base64url.toBuffer(me.publicKey)) === fe.address;
  if (!(Se || Pe || Ne))
    throw new Error(`Internal withdrawal validation failed - please report this!
Debug Info:${JSON.stringify(me)}`);
  const ke = await ie.post("/account/withdraw", me);
  if (ke.status === 202) {
    const He = ke.data.tx_id, De = await ae.confirmationPoll(He);
    if (De !== !0)
      throw new Error(`Unable to confirm withdrawal tx ${He} ${De ? De?.toString() : ""}`);
  } else
    Utils.checkAndThrow(ke, "Withdrawing balance");
  return ke.data;
}
class GraphQLQuery {
  /* implements BuilderMethods<TVars, GraphQLQuery<TQuery, TVars, TReturn>> */
  // query variables
  queryVars = {};
  // query fields
  queryFields;
  // query metadata
  queryInfo;
  // query string, payload sent to node
  _query;
  // url of the node to query
  gqlURL;
  // misc operational config
  config;
  // result tracker object, used to hold state for paging operations
  resultTracker = { numPages: 0, numResults: 0, done: !1 };
  constructor({ url: ie, retryConfig: se, query: fe, queryName: ue, opts: ce }) {
    if (!ie)
      throw new Error("URL is required");
    if (this.gqlURL = new URL(ie), this.config = {
      first: !1,
      userProvided: !1,
      numPages: 1 / 0,
      numResults: 1e3,
      retryOpts: { retries: 3, maxTimeout: 2e3, minTimeout: 500, ...se }
    }, fe === !1)
      return this;
    if (!fe)
      throw new Error(`Unable to find query with name ${ue}`);
    if (this.queryInfo = { ...fe }, this.queryFields = fe.query, ue.includes("arweave") && this.gqlURL.host === "node1.irys.xyz" && (this.gqlURL = new URL("https://arweave.net/graphql")), !ce?.skipVariableSetters)
      for (const de of Object.keys(fe.vars)) {
        if (this[de])
          throw new Error(`Field setter ${de} has a key conflict - disable with opts.skipVariableSetters OR change the field name and add to query.remapVars`);
        this[de] = (me) => (this.queryVars[de] = me, this);
      }
    return this;
  }
  /**
   * Builds a query from fields and variables, formatting it into a GQL compatible string.
   * stores built query under `this.query` (protected) - accessible via `.toQuery`
   * @returns `this` (chainable)
   */
  buildQuery() {
    if (this.config.userProvided)
      return this;
    const ie = (we) => JSON.stringify(we, (Ee, Se) => {
      if (Se instanceof Array)
        return Se[0];
      if (typeof Se == "object")
        return Se;
      if (Se !== !1)
        return "";
    }).replaceAll(":", "").replaceAll('"', "").replaceAll(",", `
          `), se = ie(this.queryFields), fe = ie({ pageInfo: { [this.queryInfo.paging?.hasNextPage ?? "hasNextPage"]: void 0 } }).slice(1, -1), ue = this.queryInfo.enumValues, ce = { ...this.queryInfo.vars, ...this.queryVars };
    for (const [we, Ee] of Object.entries(this.queryInfo.remapVars ?? {}))
      if (ce?.[we] !== void 0) {
        if (typeof Ee == "function") {
          const Se = Ee(we, ce[we], ce);
          if (!Se)
            continue;
          const [Be, Ce] = Se;
          if (ce[Be] = Ce, Be === we)
            continue;
        } else
          ce[Ee] = ce[we];
        ce[we] = void 0;
      }
    const de = JSON.stringify(ce, function(we, Ee) {
      return Ee === void 0 || Ee instanceof Array || typeof Ee == "object" || typeof Ee == "number" || ue?.includes(we) ? Ee : `'${Ee}'`;
    }).replaceAll('"', "").replaceAll("'", '"').slice(1, -1);
    if (!this?.queryInfo?.name)
      throw new Error("Query name is undefined!");
    const me = this.queryInfo.paging ? `query {
      ${this.queryInfo.name}(
        ${de}
      ) {
        edges {
          cursor
          node ${se}
        }
        ${fe}
      }
    }` : `query {
    ${this.queryInfo.name}(
      ${de}
    ) 
    ${se}
  }`;
    return this._query = me, this;
  }
  /**
   * Primary query execution method - builds & runs the query, returning result nodes and updating cursor info in queryVars
   * @returns query result nodes
   */
  async getPage() {
    if (this.resultTracker.done)
      return;
    if (this.buildQuery(), !this._query)
      throw new Error("Unable to run undefined query");
    let ie;
    try {
      ie = await retry$1(async (fe) => {
        const ue = await axios$1(this.gqlURL.toString(), {
          method: "post",
          headers: { "Content-Type": "application/json" },
          data: { query: this._query }
        });
        if (ue.data.errors)
          throw ue;
        return ue;
      }, this.config.retryOpts);
    } catch (fe) {
      throw new Error(`Error running query
 ${this._query} - ${fe.message ? fe.message + " -" : ""} (${JSON.stringify(fe?.data?.errors.map((ue) => ue.message) ?? fe?.errors ?? fe)}) `);
    }
    if (this.config.userProvided)
      return this.trimmer([ie.data.data].flat(20));
    const se = ie.data.data[this.queryInfo.name];
    if (this.queryInfo.paging) {
      const fe = se.pageInfo[this.queryInfo.paging.hasNextPage] ? se.edges.at(-1)[this.queryInfo.paging.cursor] : void 0;
      return this.queryVars.after = fe, this.trimmer(se.edges.map((ue) => ue.node));
    }
    return this.trimmer([se].flat(20));
  }
  // tracks & controls output
  trimmer(ie) {
    const se = ++this.resultTracker.numPages, fe = this.resultTracker.numResults += ie.length;
    if (ie.length === 0)
      return this.resultTracker.done = !0, ie;
    if (se >= this?.config?.numPages && (this.resultTracker.done = !0), fe >= this?.config?.numResults) {
      this.resultTracker.done = !0;
      const ue = this.config.numResults - (fe - ie.length);
      return ie.slice(0, ue);
    }
    return ie;
  }
  // return modifier functions
  /**
   * Get the first result from the query
   * @returns the first result from the query - gets at maximum one page
   */
  async first() {
    return (await this.getPage())?.at(0) ?? void 0;
  }
  /**
   * Limiter on the number of pages a given query should resolve to
   * @param numPages Maximum number of pages to return
   * @returns this (chainable)
   */
  maxPages(ie) {
    return this.config.numPages = ie, this;
  }
  /**
   * Limiter on the maximum number of results a given query should resolve to
   * @param numResults Maximum number of results to return
   * @returns this (chainable)
   */
  limit(ie) {
    return this.config.numResults = ie, this;
  }
  /**
   * Change the URL of the graphql endpoint to use
   * @param url: URL to use
   * @returns this (chainable)
   */
  url(ie) {
    return this.gqlURL = new URL(ie), this;
  }
  // return functions
  /**
   * Gets all results from the built query
   * @returns array of results
   */
  async all() {
    const ie = [];
    do {
      const se = await this.getPage();
      if (!se)
        break;
      ie.push(...se);
    } while (this.queryVars.after);
    return ie;
  }
  /**
   * Async generator, yields individual query result items
   */
  async *generator() {
    do {
      const ie = await this.getPage();
      if (!ie)
        return;
      for (const se of ie)
        yield se;
    } while (this.queryVars.after);
  }
  /**
   * Readable stream produced from `this.generator`
   * @returns a readable instance, with the "data" event yielding individual results
   */
  stream() {
    return streamBrowserify.Readable.from(this.generator());
  }
  /**
   * Provide a custom query string to resolve
   * @param query Query string to use
   * @returns result of the query - this method does not support paging or extraction
   */
  query(ie) {
    return this._query = ie, this.config.userProvided = !0, this;
  }
  // TODO issue: this allows for additional (top level only?!) fields that aren't part of TQuery - for now we perform JS level shape checks and throw.
  /**
   * Set the fields you want the query to return
   * @param fields - Object structured like a graphql query body, truthy values including, falsy excluding
   * @param skipFieldCheck - whether to skip JS level fields object shape validation
   * @returns `this` (chainable)
   */
  fields(ie, se = !1) {
    const fe = (ue, ce, de) => {
      for (const me of Object.keys(de)) {
        let we = ce[me];
        Array.isArray(we) && (we = we[0]);
        const Ee = de[me];
        if (we === void 0)
          throw new Error(`Illegal field ${ue}${me}`);
        typeof Ee == "object" && fe(ue + me + ".", we, Ee);
      }
    };
    return se || fe("", this.queryFields, ie), this.queryFields = ie, this;
  }
  /**
   * Sets variables/filters using an object
   * @param variables variable object to set
   * @returns this (chainable)
   */
  variables(ie) {
    return this.queryVars = { ...this.queryVars, ...ie }, this;
  }
  /**
   * Builds the current query and returns a ready to POST query string
   * @returns string form of the current query
   */
  async toQuery() {
    return await this.buildQuery(), this._query;
  }
  // instance generic type accessors
  /**
   * Dummy method to access the internal `TReturn` generic type
   * @returns "tReturn"
   */
  tReturn() {
    return "tReturn";
  }
  /**
   * Dummy method to access the internal `TQuery` generic type
   * @returns "tQuery"
   */
  tQuery() {
    return "tQuery";
  }
  /**
   * Dummy method to access the internal `TVars` generic type
   * @returns "tVars"
   */
  tVars() {
    return "tVars";
  }
  // Promise contract functions, so users can `await` a GraphQLQuery instance to resolve the built query.
  // very cool, thanks Knex.
  /**
   * Resolves `this` by getting all results for the query (including paging)
   * @param onFulfilled - optional onFulfilled callback
   * @returns - all results for built query
   */
  async then(ie, se) {
    return this.all().then(ie, se);
  }
  async catch(ie) {
    return this.then().catch(ie);
  }
  async finally(ie) {
    return this.then().finally(ie);
  }
}
const block = {
  id: "",
  timestamp: 0,
  height: "",
  previous: ""
}, blocksVars = {
  ids: void 0,
  // height: undefined,
  minHeight: void 0,
  maxHeight: void 0,
  pageSize: 10,
  after: void 0,
  sort: "DESC"
  // REMAPPED
}, arweaveBlocksQuery = {
  name: "blocks",
  query: block,
  vars: blocksVars,
  enumValues: ["sort"],
  remapVars: {
    pageSize: "first",
    // replace ASC/DESC to HEIGHT prefixed versions
    sort: (ae, ie) => [ae, ie === "ASC" ? "HEIGHT_ASC" : "HEIGHT_DESC"],
    minHeight: (ae, ie, se) => {
      se.height = { ...se.height, min: ie }, se.minHeight = void 0;
    },
    maxHeight: (ae, ie, se) => {
      se.height = { ...se.height, max: ie }, se.maxHeight = void 0;
    }
  },
  paging: {
    hasNextPage: "hasNextPage",
    cursor: "cursor"
  }
}, transaction = {
  id: "",
  anchor: "",
  signature: "",
  recipient: "",
  owner: {
    address: "",
    key: ""
  },
  fee: {
    winston: "",
    ar: ""
  },
  quantity: {
    winston: "",
    ar: ""
  },
  data: {
    size: "",
    type: ""
  },
  tags: [{ name: "", value: "" }],
  block: {
    id: "",
    timestamp: 0,
    height: 0,
    previous: ""
  },
  bundledIn: {
    id: ""
  }
}, transactionsVars = {
  ids: void 0,
  from: void 0,
  to: void 0,
  tags: void 0,
  bundledIn: void 0,
  // block: undefined,
  minHeight: void 0,
  maxHeight: void 0,
  pageSize: 10,
  after: void 0,
  sort: "DESC"
  // REMAPPED
}, arweaveTransactionsQuery = {
  name: "transactions",
  query: transaction,
  enumValues: ["sort"],
  vars: transactionsVars,
  remapVars: {
    pageSize: "first",
    from: "owners",
    to: "recipients",
    // replace ASC/DESC to HEIGHT prefixed versions
    sort: (ae, ie) => [ae, ie === "ASC" ? "HEIGHT_ASC" : "HEIGHT_DESC"],
    minHeight: (ae, ie, se) => {
      se.block = { ...se.block, min: ie }, se.minHeight = void 0;
    },
    maxHeight: (ae, ie, se) => {
      se.block = { ...se.block, max: ie }, se.maxHeight = void 0;
    }
  },
  paging: {
    hasNextPage: "hasNextPage",
    cursor: "cursor"
  }
}, transactions = {
  id: "",
  receipt: {
    deadlineHeight: 0,
    signature: "",
    timestamp: 0,
    version: ""
  },
  tags: [{ name: "", value: "" }],
  address: "",
  token: "",
  signature: "",
  timestamp: 0
}, transactionVars = {
  ids: void 0,
  after: void 0,
  token: void 0,
  from: void 0,
  pageSize: 100,
  sort: "ASC",
  // hasTags: undefined,
  tags: void 0,
  fromTimestamp: void 0,
  toTimestamp: void 0
}, irysTransactionsQuery = {
  name: "transactions",
  query: transactions,
  enumValues: ["order"],
  vars: transactionVars,
  remapVars: {
    pageSize: "first",
    sort: "order",
    from: "owners",
    fromTimestamp: (ae, ie, se) => {
      se.timestamp = { ...se.timestamp, from: new Date(ie).getTime() }, se.fromTimestamp = void 0;
    },
    toTimestamp: (ae, ie, se) => {
      se.timestamp = { ...se.timestamp, to: new Date(ie).getTime() }, se.toTimestamp = void 0;
    }
  },
  paging: {
    hasNextPage: "hasNextPage",
    cursor: "cursor"
  }
}, queries = {
  "irys:transactions": irysTransactionsQuery,
  "arweave:transactions": arweaveTransactionsQuery,
  "arweave:blocks": arweaveBlocksQuery
  // "arweave:transaction": arweaveTransactionQuery,
  // "arweave:block": arweaveBlockQuery,
};
class Query {
  opts;
  constructor(ie = { url: new URL("https://node1.irys.xyz/graphql") }) {
    if (!ie.url)
      throw new Error("URL is required");
    ie.url = new URL(ie.url), this.opts = ie;
  }
  search(ie, se) {
    const fe = se?.query ?? queries[ie];
    return new GraphQLQuery({ ...this.opts, query: fe, queryName: ie });
  }
}
class Irys {
  api;
  utils;
  uploader;
  funder;
  address;
  token;
  tokenConfig;
  provenance;
  transactions;
  approval;
  _readyPromise;
  url;
  arbundles;
  IrysTransaction;
  static VERSION = "0.1.16";
  constructor({ url: ie, arbundles: se }) {
    this.url = ie, this.arbundles = se, this.IrysTransaction = buildIrysTransaction(this);
  }
  get signer() {
    return this.tokenConfig.getSigner();
  }
  get search() {
    const ie = new Query({ url: new URL("/graphql", this.url) });
    return ie.search.bind(ie);
  }
  query(ie) {
    return new Query(ie ?? { url: this.url });
  }
  async withdrawBalance(ie) {
    return withdrawBalance(this.utils, this.api, ie);
  }
  /**
   * Gets the balance for the loaded wallet
   * @returns balance (in winston)
   */
  async getLoadedBalance() {
    if (!this.address)
      throw new Error("address is undefined");
    return this.utils.getBalance(this.address);
  }
  /**
   * Gets the balance for the specified address
   * @param address address to query for
   * @returns the balance (in winston)
   */
  async getBalance(ie) {
    return this.utils.getBalance(ie);
  }
  /**
   * Sends amount atomic units to the specified bundler
   * @param amount amount to send in atomic units
   * @returns details about the fund transaction
   */
  async fund(ie, se) {
    return this.funder.fund(ie, se);
  }
  /**
   * Calculates the price for [bytes] bytes for the loaded token and Irys node.
   * @param bytes
   * @returns
   */
  async getPrice(ie) {
    return this.utils.getPrice(this.token, ie);
  }
  async verifyReceipt(ie) {
    return Utils.verifyReceipt(this.arbundles, ie);
  }
  /**
   * Create a new IrysTransactions (flex token arbundles dataItem)
   * @param data
   * @param opts - dataItemCreateOptions
   * @returns - a new IrysTransaction instance
   */
  createTransaction(ie, se) {
    return new this.IrysTransaction(ie, this, se);
  }
  /**
   * Returns the signer for the loaded token
   */
  getSigner() {
    return this.tokenConfig.getSigner();
  }
  async upload(ie, se) {
    return this.uploader.uploadData(ie, se);
  }
  /**
   * @deprecated - use upload instead
   */
  async uploadWithReceipt(ie, se) {
    return this.uploader.uploadData(ie, { ...se });
  }
  async ready() {
    return this.tokenConfig.ready && await this.tokenConfig.ready(), this.address = this.tokenConfig.address, this;
  }
  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  get transaction() {
    const ie = this;
    return {
      fromRaw(se) {
        return new ie.IrysTransaction(se, ie, { dataIsRawTransaction: !0 });
      }
    };
  }
}
let Api$1 = class {
  _instance;
  cookieMap = /* @__PURE__ */ new Map();
  config;
  constructor(ie) {
    ie && this.applyConfig(ie);
  }
  applyConfig(ie) {
    this.config = this.mergeDefaults(ie), this._instance = void 0;
  }
  getConfig() {
    return this.config;
  }
  async requestInterceptor(ie) {
    const se = this.cookieMap.get(new URL(ie.baseURL ?? "").hostname);
    return se && (ie.headers.cookie = se), ie;
  }
  async responseInterceptor(ie) {
    const se = ie.headers?.["set-cookie"];
    return se && this.cookieMap.set(ie.request.host, se), ie;
  }
  mergeDefaults(ie) {
    return {
      url: ie.url,
      timeout: ie.timeout ?? 2e4,
      logging: ie.logging ?? !1,
      logger: ie.logger ?? console.log,
      headers: { ...ie.headers, "x-irys-js-sdk-version": Irys.VERSION },
      withCredentials: ie.withCredentials ?? !1,
      retry: { retries: 3, maxTimeout: 5e3 }
    };
  }
  async get(ie, se) {
    try {
      return await this.request(ie, { ...se, method: "GET" });
    } catch (fe) {
      if (fe.response?.status)
        return fe.response;
      throw fe;
    }
  }
  async post(ie, se, fe) {
    try {
      return await this.request(ie, { data: se, ...fe, method: "POST" });
    } catch (ue) {
      if (ue.response?.status)
        return ue.response;
      throw ue;
    }
  }
  get instance() {
    if (this._instance)
      return this._instance;
    const ie = axios$1.create({
      baseURL: this.config.url.toString(),
      timeout: this.config.timeout,
      maxContentLength: 1024 * 1024 * 512,
      headers: this.config.headers,
      withCredentials: this.config.withCredentials
    });
    return this.config.withCredentials && (ie.interceptors.request.use(this.requestInterceptor.bind(this)), ie.interceptors.response.use(this.responseInterceptor.bind(this))), this.config.logging && (ie.interceptors.request.use((se) => (this.config.logger(`Requesting: ${se.baseURL}/${se.url}`), se)), ie.interceptors.response.use((se) => (this.config.logger(`Response: ${se.config.url} - ${se.status}`), se))), this._instance = ie;
  }
  async request(ie, se) {
    const fe = this.instance, ue = se?.url ?? new URL(ie, this.config.url).toString();
    return fe({ ...se, url: ue });
  }
};
class Fund {
  utils;
  constructor(ie) {
    this.utils = ie;
  }
  /**
   * Function to Fund (send funds to) a Irys node - inherits instance token and node
   * @param amount - amount in base units to send
   * @param multiplier - network tx fee multiplier - only works for specific currencies
   * @returns  - funding receipt
   */
  async fund(ie, se = 1) {
    const fe = new BigNumber$1(ie);
    if (!fe.isInteger())
      throw new Error("must use an integer for funding amount");
    const ue = this.utils.tokenConfig, ce = await this.utils.getBundlerAddress(this.utils.token);
    let de;
    if (ue.needsFee) {
      const Be = await ue.getFee(ue.base[0] === "winston" ? 0 : fe, ce);
      de = BigNumber$1.isBigNumber(Be) ? Be.multipliedBy(se).integerValue(BigNumber$1.ROUND_CEIL) : Be;
    }
    const me = await ue.createTx(fe, ce, de);
    let we;
    try {
      we = await ue.sendTx(me.tx);
    } catch (Be) {
      throw Be;
    }
    if (me.txId ??= we, !me.txId)
      throw new Error("Undefined transaction ID");
    Utils.checkAndThrow(we, `Sending transaction to the ${this.utils.token} network`);
    let Ee = await this.utils.confirmationPoll(me.txId);
    if (!await this.submitTransaction(me.txId).catch((Be) => {
      Ee = Be;
    }))
      throw new Error(`failed to post funding tx - ${me.txId} - keep this id! 
 ${Ee ? ` - ${Ee?.message ?? Ee}` : ""}`);
    return { reward: BigNumber$1.isBigNumber(de) ? de.toString() : JSON.stringify(de), target: ce, quantity: fe.toString(), id: me.txId };
  }
  async submitTransaction(ie) {
    return await retry$1(async () => {
      const se = await this.utils.api.post(`/account/balance/${this.utils.token}`, { tx_id: ie });
      return Utils.checkAndThrow(se, `Posting transaction ${ie} information to the bundler`, [202]), se;
    }, {
      retries: 5,
      maxTimeout: 1e3,
      minTimeout: 100,
      randomize: !0
    });
  }
  async submitFundTransaction(ie) {
    return this.submitTransaction(ie);
  }
}
class Provenance {
  irys;
  constructor(ie) {
    this.irys = ie;
  }
  async upload(ie, se) {
    return this.irys.uploadWithReceipt(ie, se);
  }
  async uploadProof(ie) {
    return await this.irys.uploadWithReceipt("", {
      tags: Object.entries({ dataProtocol: "Provenance-Confirmation", ...ie }).map(([se, fe]) => ({ name: tagMap[se], value: fe }))
    });
  }
  async getAllProofs(ie, se) {
    const fe = Object.entries(ie).map(([me, we]) => ({ name: tagMap[me], values: [we] }));
    if (fe.length === 0)
      throw new Error("Getting a provenance proof requires at least one query element");
    const ue = `
    query ($tags: [TagFilter!]) {
      transactions(tags: $tags) {
        edges {
          node {
            id
            receipt {
              deadlineHeight
              signature
              timestamp
              version
            }
            tags {
              name
              value
            }
          }
        }
      }
    }
    `, ce = [];
    let de = null;
    do {
      const me = await this.irys.api.post("/graphql", {
        query: ue,
        variables: { tags: fe, limit: se?.limit ?? null, after: de }
      }, void 0);
      de = me.data.data.transactions?.pageInfo?.hasNextPage ? me.data.data.transactions.pageInfo.endCursor : null, ce.push(...me.data.data.transactions.edges.map((we) => we.node));
    } while (de);
    return ce;
  }
  async getProof(ie) {
    const se = (await this.getAllProofs(ie, { limit: 1 })).at(0);
    if (!se)
      throw new Error(`Unable to locate proof with fields ${JSON.stringify(ie)}`);
    return se;
  }
}
const tagMap = {
  dataProtocol: "Data-Protocol",
  hashingAlgo: "Hashing-Algo",
  dataHash: "Data-Hash",
  uploadedFor: "Uploaded-For",
  prompt: "Prompt",
  promptHash: "Prompt-Hash",
  model: "Model"
};
let Transaction$2 = class {
  irys;
  constructor(ie) {
    this.irys = ie;
  }
  async getById(ie) {
    const se = (await this.query({ ids: [ie], limit: 1 })).at(0);
    if (!se)
      throw new Error(`Unable to locate tx with id ${ie}`);
    return se;
  }
  async getByOwner(ie) {
    const se = (await this.query({ owners: [ie], limit: 1 })).at(0);
    if (!se)
      throw new Error(`Unable to locate tx with owner ${ie}`);
    return se;
  }
  async getByTag(ie, se) {
    const fe = (await this.query({ tags: [{ name: ie, values: [se] }], limit: 1 })).at(0);
    if (!fe)
      throw new Error(`Unable to locate tx with tag ${ie}:${se}`);
    return fe;
  }
  async query(ie) {
    const se = `
    query ($ids: [String!], $after: String, $currency: String, $owners: [String!], $limit: Int, $order: SortOrder, $hasTags: Boolean, $tags: [TagFilter!]) {
      transactions(ids: $ids, after: $after, currency: $currency, owners: $owners, limit: $limit, order: $order, hasTags: $hasTags, tags: $tags) {
        edges {
          cursor
          node {
            address
            currency
            id
            receipt {
              deadlineHeight
              signature
              timestamp
              version
            }
            signature
            tags {
              name
              value
            }
            timestamp
          }
        }
        pageInfo {
          endCursor
          hasNextPage
        }
      }
    }
    `, fe = [];
    let ue = null;
    do {
      const ce = await this.irys.api.post("/graphql", {
        query: se,
        variables: { ...ie, after: ue ?? ie.after }
      }, void 0);
      ue = ce.data.data.transactions?.pageInfo?.hasNextPage ? ce.data.data.transactions.pageInfo.endCursor : null, fe.push(...ce.data.data.transactions.edges.map((de) => de.node));
    } while (ue);
    return fe;
  }
}, Signer$1 = class {
  publicKey;
  signatureType;
  signatureLength;
  ownerLength;
  pem;
  static verify(ie, se, fe, ue) {
    throw new Error("You must implement verify method on child");
  }
};
var SignatureConfig;
(function(ae) {
  ae[ae.ARWEAVE = 1] = "ARWEAVE", ae[ae.ED25519 = 2] = "ED25519", ae[ae.ETHEREUM = 3] = "ETHEREUM", ae[ae.SOLANA = 4] = "SOLANA", ae[ae.INJECTEDAPTOS = 5] = "INJECTEDAPTOS", ae[ae.MULTIAPTOS = 6] = "MULTIAPTOS", ae[ae.TYPEDETHEREUM = 7] = "TYPEDETHEREUM";
})(SignatureConfig || (SignatureConfig = {}));
const SIG_CONFIG = {
  [SignatureConfig.ARWEAVE]: {
    sigLength: 512,
    pubLength: 512,
    sigName: "arweave"
  },
  [SignatureConfig.ED25519]: {
    sigLength: 64,
    pubLength: 32,
    sigName: "ed25519"
  },
  [SignatureConfig.ETHEREUM]: {
    sigLength: 65,
    pubLength: 65,
    sigName: "ethereum"
  },
  [SignatureConfig.SOLANA]: {
    sigLength: 64,
    pubLength: 32,
    sigName: "solana"
  },
  [SignatureConfig.INJECTEDAPTOS]: {
    sigLength: 64,
    pubLength: 32,
    sigName: "injectedAptos"
  },
  [SignatureConfig.MULTIAPTOS]: {
    sigLength: 64 * 32 + 4,
    pubLength: 32 * 32 + 1,
    sigName: "multiAptos"
  },
  [SignatureConfig.TYPEDETHEREUM]: {
    sigLength: 65,
    pubLength: 42,
    sigName: "typedEthereum"
  }
};
/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
const _0n$6 = BigInt(0), _1n$8 = BigInt(1), _2n$6 = BigInt(2), _8n$2 = BigInt(8), CU_O = BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"), CURVE = Object.freeze({
  a: BigInt(-1),
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  P: BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),
  l: CU_O,
  n: CU_O,
  h: BigInt(8),
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")
}), POW_2_256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000"), SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742");
const SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"), INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"), ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"), D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
class ExtendedPoint {
  constructor(ie, se, fe, ue) {
    this.x = ie, this.y = se, this.z = fe, this.t = ue;
  }
  static fromAffine(ie) {
    if (!(ie instanceof Point$2))
      throw new TypeError("ExtendedPoint#fromAffine: expected Point");
    return ie.equals(Point$2.ZERO) ? ExtendedPoint.ZERO : new ExtendedPoint(ie.x, ie.y, _1n$8, mod$1(ie.x * ie.y));
  }
  static toAffineBatch(ie) {
    const se = invertBatch(ie.map((fe) => fe.z));
    return ie.map((fe, ue) => fe.toAffine(se[ue]));
  }
  static normalizeZ(ie) {
    return this.toAffineBatch(ie).map(this.fromAffine);
  }
  equals(ie) {
    assertExtPoint(ie);
    const { x: se, y: fe, z: ue } = this, { x: ce, y: de, z: me } = ie, we = mod$1(se * me), Ee = mod$1(ce * ue), Se = mod$1(fe * me), Be = mod$1(de * ue);
    return we === Ee && Se === Be;
  }
  negate() {
    return new ExtendedPoint(mod$1(-this.x), this.y, this.z, mod$1(-this.t));
  }
  double() {
    const { x: ie, y: se, z: fe } = this, { a: ue } = CURVE, ce = mod$1(ie * ie), de = mod$1(se * se), me = mod$1(_2n$6 * mod$1(fe * fe)), we = mod$1(ue * ce), Ee = ie + se, Se = mod$1(mod$1(Ee * Ee) - ce - de), Be = we + de, Ce = Be - me, Ie = we - de, Pe = mod$1(Se * Ce), Ne = mod$1(Be * Ie), ke = mod$1(Se * Ie), He = mod$1(Ce * Be);
    return new ExtendedPoint(Pe, Ne, He, ke);
  }
  add(ie) {
    assertExtPoint(ie);
    const { x: se, y: fe, z: ue, t: ce } = this, { x: de, y: me, z: we, t: Ee } = ie, Se = mod$1((fe - se) * (me + de)), Be = mod$1((fe + se) * (me - de)), Ce = mod$1(Be - Se);
    if (Ce === _0n$6)
      return this.double();
    const Ie = mod$1(ue * _2n$6 * Ee), Pe = mod$1(ce * _2n$6 * we), Ne = Pe + Ie, ke = Be + Se, He = Pe - Ie, De = mod$1(Ne * Ce), Ge = mod$1(ke * He), Ye = mod$1(Ne * He), st = mod$1(Ce * ke);
    return new ExtendedPoint(De, Ge, st, Ye);
  }
  subtract(ie) {
    return this.add(ie.negate());
  }
  precomputeWindow(ie) {
    const se = 1 + 256 / ie, fe = [];
    let ue = this, ce = ue;
    for (let de = 0; de < se; de++) {
      ce = ue, fe.push(ce);
      for (let me = 1; me < 2 ** (ie - 1); me++)
        ce = ce.add(ue), fe.push(ce);
      ue = ce.double();
    }
    return fe;
  }
  wNAF(ie, se) {
    !se && this.equals(ExtendedPoint.BASE) && (se = Point$2.BASE);
    const fe = se && se._WINDOW_SIZE || 1;
    if (256 % fe)
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    let ue = se && pointPrecomputes.get(se);
    ue || (ue = this.precomputeWindow(fe), se && fe !== 1 && (ue = ExtendedPoint.normalizeZ(ue), pointPrecomputes.set(se, ue)));
    let ce = ExtendedPoint.ZERO, de = ExtendedPoint.BASE;
    const me = 1 + 256 / fe, we = 2 ** (fe - 1), Ee = BigInt(2 ** fe - 1), Se = 2 ** fe, Be = BigInt(fe);
    for (let Ce = 0; Ce < me; Ce++) {
      const Ie = Ce * we;
      let Pe = Number(ie & Ee);
      ie >>= Be, Pe > we && (Pe -= Se, ie += _1n$8);
      const Ne = Ie, ke = Ie + Math.abs(Pe) - 1, He = Ce % 2 !== 0, De = Pe < 0;
      Pe === 0 ? de = de.add(constTimeNegate(He, ue[Ne])) : ce = ce.add(constTimeNegate(De, ue[ke]));
    }
    return ExtendedPoint.normalizeZ([ce, de])[0];
  }
  multiply(ie, se) {
    return this.wNAF(normalizeScalar(ie, CURVE.l), se);
  }
  multiplyUnsafe(ie) {
    let se = normalizeScalar(ie, CURVE.l, !1);
    const fe = ExtendedPoint.BASE, ue = ExtendedPoint.ZERO;
    if (se === _0n$6)
      return ue;
    if (this.equals(ue) || se === _1n$8)
      return this;
    if (this.equals(fe))
      return this.wNAF(se);
    let ce = ue, de = this;
    for (; se > _0n$6; )
      se & _1n$8 && (ce = ce.add(de)), de = de.double(), se >>= _1n$8;
    return ce;
  }
  isSmallOrder() {
    return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
  }
  isTorsionFree() {
    let ie = this.multiplyUnsafe(CURVE.l / _2n$6).double();
    return CURVE.l % _2n$6 && (ie = ie.add(this)), ie.equals(ExtendedPoint.ZERO);
  }
  toAffine(ie) {
    const { x: se, y: fe, z: ue } = this, ce = this.equals(ExtendedPoint.ZERO);
    ie == null && (ie = ce ? _8n$2 : invert$1(ue));
    const de = mod$1(se * ie), me = mod$1(fe * ie), we = mod$1(ue * ie);
    if (ce)
      return Point$2.ZERO;
    if (we !== _1n$8)
      throw new Error("invZ was invalid");
    return new Point$2(de, me);
  }
  fromRistrettoBytes() {
    legacyRist();
  }
  toRistrettoBytes() {
    legacyRist();
  }
  fromRistrettoHash() {
    legacyRist();
  }
}
ExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n$8, mod$1(CURVE.Gx * CURVE.Gy));
ExtendedPoint.ZERO = new ExtendedPoint(_0n$6, _1n$8, _1n$8, _0n$6);
function constTimeNegate(ae, ie) {
  const se = ie.negate();
  return ae ? se : ie;
}
function assertExtPoint(ae) {
  if (!(ae instanceof ExtendedPoint))
    throw new TypeError("ExtendedPoint expected");
}
function assertRstPoint(ae) {
  if (!(ae instanceof RistrettoPoint))
    throw new TypeError("RistrettoPoint expected");
}
function legacyRist() {
  throw new Error("Legacy method: switch to RistrettoPoint");
}
class RistrettoPoint {
  constructor(ie) {
    this.ep = ie;
  }
  static calcElligatorRistrettoMap(ie) {
    const { d: se } = CURVE, fe = mod$1(SQRT_M1 * ie * ie), ue = mod$1((fe + _1n$8) * ONE_MINUS_D_SQ);
    let ce = BigInt(-1);
    const de = mod$1((ce - se * fe) * mod$1(fe + se));
    let { isValid: me, value: we } = uvRatio$1(ue, de), Ee = mod$1(we * ie);
    edIsNegative(Ee) || (Ee = mod$1(-Ee)), me || (we = Ee), me || (ce = fe);
    const Se = mod$1(ce * (fe - _1n$8) * D_MINUS_ONE_SQ - de), Be = we * we, Ce = mod$1((we + we) * de), Ie = mod$1(Se * SQRT_AD_MINUS_ONE), Pe = mod$1(_1n$8 - Be), Ne = mod$1(_1n$8 + Be);
    return new ExtendedPoint(mod$1(Ce * Ne), mod$1(Pe * Ie), mod$1(Ie * Ne), mod$1(Ce * Pe));
  }
  static hashToCurve(ie) {
    ie = ensureBytes$1(ie, 64);
    const se = bytes255ToNumberLE(ie.slice(0, 32)), fe = this.calcElligatorRistrettoMap(se), ue = bytes255ToNumberLE(ie.slice(32, 64)), ce = this.calcElligatorRistrettoMap(ue);
    return new RistrettoPoint(fe.add(ce));
  }
  static fromHex(ie) {
    ie = ensureBytes$1(ie, 32);
    const { a: se, d: fe } = CURVE, ue = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint", ce = bytes255ToNumberLE(ie);
    if (!equalBytes$1(numberTo32BytesLE(ce), ie) || edIsNegative(ce))
      throw new Error(ue);
    const de = mod$1(ce * ce), me = mod$1(_1n$8 + se * de), we = mod$1(_1n$8 - se * de), Ee = mod$1(me * me), Se = mod$1(we * we), Be = mod$1(se * fe * Ee - Se), { isValid: Ce, value: Ie } = invertSqrt(mod$1(Be * Se)), Pe = mod$1(Ie * we), Ne = mod$1(Ie * Pe * Be);
    let ke = mod$1((ce + ce) * Pe);
    edIsNegative(ke) && (ke = mod$1(-ke));
    const He = mod$1(me * Ne), De = mod$1(ke * He);
    if (!Ce || edIsNegative(De) || He === _0n$6)
      throw new Error(ue);
    return new RistrettoPoint(new ExtendedPoint(ke, He, _1n$8, De));
  }
  toRawBytes() {
    let { x: ie, y: se, z: fe, t: ue } = this.ep;
    const ce = mod$1(mod$1(fe + se) * mod$1(fe - se)), de = mod$1(ie * se), me = mod$1(de * de), { value: we } = invertSqrt(mod$1(ce * me)), Ee = mod$1(we * ce), Se = mod$1(we * de), Be = mod$1(Ee * Se * ue);
    let Ce;
    if (edIsNegative(ue * Be)) {
      let Pe = mod$1(se * SQRT_M1), Ne = mod$1(ie * SQRT_M1);
      ie = Pe, se = Ne, Ce = mod$1(Ee * INVSQRT_A_MINUS_D);
    } else
      Ce = Se;
    edIsNegative(ie * Be) && (se = mod$1(-se));
    let Ie = mod$1((fe - se) * Ce);
    return edIsNegative(Ie) && (Ie = mod$1(-Ie)), numberTo32BytesLE(Ie);
  }
  toHex() {
    return bytesToHex$2(this.toRawBytes());
  }
  toString() {
    return this.toHex();
  }
  equals(ie) {
    assertRstPoint(ie);
    const se = this.ep, fe = ie.ep, ue = mod$1(se.x * fe.y) === mod$1(se.y * fe.x), ce = mod$1(se.y * fe.y) === mod$1(se.x * fe.x);
    return ue || ce;
  }
  add(ie) {
    return assertRstPoint(ie), new RistrettoPoint(this.ep.add(ie.ep));
  }
  subtract(ie) {
    return assertRstPoint(ie), new RistrettoPoint(this.ep.subtract(ie.ep));
  }
  multiply(ie) {
    return new RistrettoPoint(this.ep.multiply(ie));
  }
  multiplyUnsafe(ie) {
    return new RistrettoPoint(this.ep.multiplyUnsafe(ie));
  }
}
RistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);
RistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);
const pointPrecomputes = /* @__PURE__ */ new WeakMap();
let Point$2 = class Kn {
  constructor(ie, se) {
    this.x = ie, this.y = se;
  }
  _setWindowSize(ie) {
    this._WINDOW_SIZE = ie, pointPrecomputes.delete(this);
  }
  static fromHex(ie, se = !0) {
    const { d: fe, P: ue } = CURVE;
    ie = ensureBytes$1(ie, 32);
    const ce = ie.slice();
    ce[31] = ie[31] & -129;
    const de = bytesToNumberLE$1(ce);
    if (se && de >= ue)
      throw new Error("Expected 0 < hex < P");
    if (!se && de >= POW_2_256)
      throw new Error("Expected 0 < hex < 2**256");
    const me = mod$1(de * de), we = mod$1(me - _1n$8), Ee = mod$1(fe * me + _1n$8);
    let { isValid: Se, value: Be } = uvRatio$1(we, Ee);
    if (!Se)
      throw new Error("Point.fromHex: invalid y coordinate");
    const Ce = (Be & _1n$8) === _1n$8;
    return (ie[31] & 128) !== 0 !== Ce && (Be = mod$1(-Be)), new Kn(Be, de);
  }
  static async fromPrivateKey(ie) {
    return (await getExtendedPublicKey(ie)).point;
  }
  toRawBytes() {
    const ie = numberTo32BytesLE(this.y);
    return ie[31] |= this.x & _1n$8 ? 128 : 0, ie;
  }
  toHex() {
    return bytesToHex$2(this.toRawBytes());
  }
  toX25519() {
    const { y: ie } = this, se = mod$1((_1n$8 + ie) * invert$1(_1n$8 - ie));
    return numberTo32BytesLE(se);
  }
  isTorsionFree() {
    return ExtendedPoint.fromAffine(this).isTorsionFree();
  }
  equals(ie) {
    return this.x === ie.x && this.y === ie.y;
  }
  negate() {
    return new Kn(mod$1(-this.x), this.y);
  }
  add(ie) {
    return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(ie)).toAffine();
  }
  subtract(ie) {
    return this.add(ie.negate());
  }
  multiply(ie) {
    return ExtendedPoint.fromAffine(this).multiply(ie, this).toAffine();
  }
};
Point$2.BASE = new Point$2(CURVE.Gx, CURVE.Gy);
Point$2.ZERO = new Point$2(_0n$6, _1n$8);
let Signature$2 = class Qn {
  constructor(ie, se) {
    this.r = ie, this.s = se, this.assertValidity();
  }
  static fromHex(ie) {
    const se = ensureBytes$1(ie, 64), fe = Point$2.fromHex(se.slice(0, 32), !1), ue = bytesToNumberLE$1(se.slice(32, 64));
    return new Qn(fe, ue);
  }
  assertValidity() {
    const { r: ie, s: se } = this;
    if (!(ie instanceof Point$2))
      throw new Error("Expected Point instance");
    return normalizeScalar(se, CURVE.l, !1), this;
  }
  toRawBytes() {
    const ie = new Uint8Array(64);
    return ie.set(this.r.toRawBytes()), ie.set(numberTo32BytesLE(this.s), 32), ie;
  }
  toHex() {
    return bytesToHex$2(this.toRawBytes());
  }
};
function concatBytes$2(...ae) {
  if (!ae.every((fe) => fe instanceof Uint8Array))
    throw new Error("Expected Uint8Array list");
  if (ae.length === 1)
    return ae[0];
  const ie = ae.reduce((fe, ue) => fe + ue.length, 0), se = new Uint8Array(ie);
  for (let fe = 0, ue = 0; fe < ae.length; fe++) {
    const ce = ae[fe];
    se.set(ce, ue), ue += ce.length;
  }
  return se;
}
const hexes$2 = Array.from({ length: 256 }, (ae, ie) => ie.toString(16).padStart(2, "0"));
function bytesToHex$2(ae) {
  if (!(ae instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  let ie = "";
  for (let se = 0; se < ae.length; se++)
    ie += hexes$2[ae[se]];
  return ie;
}
function hexToBytes$2(ae) {
  if (typeof ae != "string")
    throw new TypeError("hexToBytes: expected string, got " + typeof ae);
  if (ae.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const ie = new Uint8Array(ae.length / 2);
  for (let se = 0; se < ie.length; se++) {
    const fe = se * 2, ue = ae.slice(fe, fe + 2), ce = Number.parseInt(ue, 16);
    if (Number.isNaN(ce) || ce < 0)
      throw new Error("Invalid byte sequence");
    ie[se] = ce;
  }
  return ie;
}
function numberTo32BytesBE(ae) {
  const se = ae.toString(16).padStart(64, "0");
  return hexToBytes$2(se);
}
function numberTo32BytesLE(ae) {
  return numberTo32BytesBE(ae).reverse();
}
function edIsNegative(ae) {
  return (mod$1(ae) & _1n$8) === _1n$8;
}
function bytesToNumberLE$1(ae) {
  if (!(ae instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  return BigInt("0x" + bytesToHex$2(Uint8Array.from(ae).reverse()));
}
const MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function bytes255ToNumberLE(ae) {
  return mod$1(bytesToNumberLE$1(ae) & MAX_255B);
}
function mod$1(ae, ie = CURVE.P) {
  const se = ae % ie;
  return se >= _0n$6 ? se : ie + se;
}
function invert$1(ae, ie = CURVE.P) {
  if (ae === _0n$6 || ie <= _0n$6)
    throw new Error(`invert: expected positive integers, got n=${ae} mod=${ie}`);
  let se = mod$1(ae, ie), fe = ie, ue = _0n$6, ce = _1n$8;
  for (; se !== _0n$6; ) {
    const me = fe / se, we = fe % se, Ee = ue - ce * me;
    fe = se, se = we, ue = ce, ce = Ee;
  }
  if (fe !== _1n$8)
    throw new Error("invert: does not exist");
  return mod$1(ue, ie);
}
function invertBatch(ae, ie = CURVE.P) {
  const se = new Array(ae.length), fe = ae.reduce((ce, de, me) => de === _0n$6 ? ce : (se[me] = ce, mod$1(ce * de, ie)), _1n$8), ue = invert$1(fe, ie);
  return ae.reduceRight((ce, de, me) => de === _0n$6 ? ce : (se[me] = mod$1(ce * se[me], ie), mod$1(ce * de, ie)), ue), se;
}
function pow2$1(ae, ie) {
  const { P: se } = CURVE;
  let fe = ae;
  for (; ie-- > _0n$6; )
    fe *= fe, fe %= se;
  return fe;
}
function pow_2_252_3(ae) {
  const { P: ie } = CURVE, se = BigInt(5), fe = BigInt(10), ue = BigInt(20), ce = BigInt(40), de = BigInt(80), we = ae * ae % ie * ae % ie, Ee = pow2$1(we, _2n$6) * we % ie, Se = pow2$1(Ee, _1n$8) * ae % ie, Be = pow2$1(Se, se) * Se % ie, Ce = pow2$1(Be, fe) * Be % ie, Ie = pow2$1(Ce, ue) * Ce % ie, Pe = pow2$1(Ie, ce) * Ie % ie, Ne = pow2$1(Pe, de) * Pe % ie, ke = pow2$1(Ne, de) * Pe % ie, He = pow2$1(ke, fe) * Be % ie;
  return { pow_p_5_8: pow2$1(He, _2n$6) * ae % ie, b2: we };
}
function uvRatio$1(ae, ie) {
  const se = mod$1(ie * ie * ie), fe = mod$1(se * se * ie), ue = pow_2_252_3(ae * fe).pow_p_5_8;
  let ce = mod$1(ae * se * ue);
  const de = mod$1(ie * ce * ce), me = ce, we = mod$1(ce * SQRT_M1), Ee = de === ae, Se = de === mod$1(-ae), Be = de === mod$1(-ae * SQRT_M1);
  return Ee && (ce = me), (Se || Be) && (ce = we), edIsNegative(ce) && (ce = mod$1(-ce)), { isValid: Ee || Se, value: ce };
}
function invertSqrt(ae) {
  return uvRatio$1(_1n$8, ae);
}
function modlLE(ae) {
  return mod$1(bytesToNumberLE$1(ae), CURVE.l);
}
function equalBytes$1(ae, ie) {
  if (ae.length !== ie.length)
    return !1;
  for (let se = 0; se < ae.length; se++)
    if (ae[se] !== ie[se])
      return !1;
  return !0;
}
function ensureBytes$1(ae, ie) {
  const se = ae instanceof Uint8Array ? Uint8Array.from(ae) : hexToBytes$2(ae);
  if (typeof ie == "number" && se.length !== ie)
    throw new Error(`Expected ${ie} bytes`);
  return se;
}
function normalizeScalar(ae, ie, se = !0) {
  if (!ie)
    throw new TypeError("Specify max value");
  if (typeof ae == "number" && Number.isSafeInteger(ae) && (ae = BigInt(ae)), typeof ae == "bigint" && ae < ie) {
    if (se) {
      if (_0n$6 < ae)
        return ae;
    } else if (_0n$6 <= ae)
      return ae;
  }
  throw new TypeError("Expected valid scalar: 0 < scalar < max");
}
function adjustBytes25519(ae) {
  return ae[0] &= 248, ae[31] &= 127, ae[31] |= 64, ae;
}
function checkPrivateKey(ae) {
  if (ae = typeof ae == "bigint" || typeof ae == "number" ? numberTo32BytesBE(normalizeScalar(ae, POW_2_256)) : ensureBytes$1(ae), ae.length !== 32)
    throw new Error("Expected 32 bytes");
  return ae;
}
function getKeyFromHash(ae) {
  const ie = adjustBytes25519(ae.slice(0, 32)), se = ae.slice(32, 64), fe = modlLE(ie), ue = Point$2.BASE.multiply(fe), ce = ue.toRawBytes();
  return { head: ie, prefix: se, scalar: fe, point: ue, pointBytes: ce };
}
let _sha512Sync;
async function getExtendedPublicKey(ae) {
  return getKeyFromHash(await utils$3.sha512(checkPrivateKey(ae)));
}
async function sign$3(ae, ie) {
  ae = ensureBytes$1(ae);
  const { prefix: se, scalar: fe, pointBytes: ue } = await getExtendedPublicKey(ie), ce = modlLE(await utils$3.sha512(se, ae)), de = Point$2.BASE.multiply(ce), me = modlLE(await utils$3.sha512(de.toRawBytes(), ue, ae)), we = mod$1(ce + me * fe, CURVE.l);
  return new Signature$2(de, we).toRawBytes();
}
function prepareVerification(ae, ie, se) {
  ie = ensureBytes$1(ie), se instanceof Point$2 || (se = Point$2.fromHex(se, !1));
  const { r: fe, s: ue } = ae instanceof Signature$2 ? ae.assertValidity() : Signature$2.fromHex(ae), ce = ExtendedPoint.BASE.multiplyUnsafe(ue);
  return { r: fe, s: ue, SB: ce, pub: se, msg: ie };
}
function finishVerification(ae, ie, se, fe) {
  const ue = modlLE(fe), ce = ExtendedPoint.fromAffine(ae).multiplyUnsafe(ue);
  return ExtendedPoint.fromAffine(ie).add(ce).subtract(se).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
}
async function verify$1(ae, ie, se) {
  const { r: fe, SB: ue, msg: ce, pub: de } = prepareVerification(ae, ie, se), me = await utils$3.sha512(fe.toRawBytes(), de.toRawBytes(), ce);
  return finishVerification(de, fe, ue, me);
}
Point$2.BASE._setWindowSize(8);
const crypto$3 = {
  node: nodeCrypto,
  web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
}, utils$3 = {
  bytesToHex: bytesToHex$2,
  hexToBytes: hexToBytes$2,
  concatBytes: concatBytes$2,
  getExtendedPublicKey,
  mod: mod$1,
  invert: invert$1,
  TORSION_SUBGROUP: [
    "0100000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
    "0000000000000000000000000000000000000000000000000000000000000080",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
    "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
    "0000000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
  ],
  hashToPrivateScalar: (ae) => {
    if (ae = ensureBytes$1(ae), ae.length < 40 || ae.length > 1024)
      throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
    return mod$1(bytesToNumberLE$1(ae), CURVE.l - _1n$8) + _1n$8;
  },
  randomBytes: (ae = 32) => {
    if (crypto$3.web)
      return crypto$3.web.getRandomValues(new Uint8Array(ae));
    if (crypto$3.node) {
      const { randomBytes: ie } = crypto$3.node;
      return new Uint8Array(ie(ae).buffer);
    } else
      throw new Error("The environment doesn't have randomBytes function");
  },
  randomPrivateKey: () => utils$3.randomBytes(32),
  sha512: async (...ae) => {
    const ie = concatBytes$2(...ae);
    if (crypto$3.web) {
      const se = await crypto$3.web.subtle.digest("SHA-512", ie.buffer);
      return new Uint8Array(se);
    } else {
      if (crypto$3.node)
        return Uint8Array.from(crypto$3.node.createHash("sha512").update(ie).digest());
      throw new Error("The environment doesn't have sha512 function");
    }
  },
  precompute(ae = 8, ie = Point$2.BASE) {
    const se = ie.equals(Point$2.BASE) ? ie : new Point$2(ie.x, ie.y);
    return se._setWindowSize(ae), se.multiply(_2n$6), se;
  },
  sha512Sync: void 0
};
Object.defineProperties(utils$3, {
  sha512Sync: {
    configurable: !1,
    get() {
      return _sha512Sync;
    },
    set(ae) {
      _sha512Sync || (_sha512Sync = ae);
    }
  }
});
class Curve25519 {
  _key;
  pk;
  ownerLength = SIG_CONFIG[2].pubLength;
  signatureLength = SIG_CONFIG[2].sigLength;
  _publicKey;
  get publicKey() {
    return this._publicKey;
  }
  signatureType = 2;
  constructor(ie, se) {
    this._key = ie, this.pk = se;
  }
  get key() {
    throw new Error("You must implement `key`");
  }
  sign(ie) {
    return sign$3(Buffer$F.from(ie), Buffer$F.from(this.key));
  }
  static async verify(ie, se, fe) {
    let ue = ie;
    return typeof ie == "string" && (ue = base64url.toBuffer(ie)), verify$1(Buffer$F.from(fe), Buffer$F.from(se), Buffer$F.from(ue));
  }
}
var toByteArray_1 = toByteArray, fromByteArray_1 = fromByteArray, lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$a = 0, len = code.length; i$a < len; ++i$a)
  lookup[i$a] = code[i$a], revLookup[code.charCodeAt(i$a)] = i$a;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(ae) {
  var ie = ae.length;
  if (ie % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var se = ae.indexOf("=");
  se === -1 && (se = ie);
  var fe = se === ie ? 0 : 4 - se % 4;
  return [se, fe];
}
function _byteLength(ae, ie, se) {
  return (ie + se) * 3 / 4 - se;
}
function toByteArray(ae) {
  var ie, se = getLens(ae), fe = se[0], ue = se[1], ce = new Arr(_byteLength(ae, fe, ue)), de = 0, me = ue > 0 ? fe - 4 : fe, we;
  for (we = 0; we < me; we += 4)
    ie = revLookup[ae.charCodeAt(we)] << 18 | revLookup[ae.charCodeAt(we + 1)] << 12 | revLookup[ae.charCodeAt(we + 2)] << 6 | revLookup[ae.charCodeAt(we + 3)], ce[de++] = ie >> 16 & 255, ce[de++] = ie >> 8 & 255, ce[de++] = ie & 255;
  return ue === 2 && (ie = revLookup[ae.charCodeAt(we)] << 2 | revLookup[ae.charCodeAt(we + 1)] >> 4, ce[de++] = ie & 255), ue === 1 && (ie = revLookup[ae.charCodeAt(we)] << 10 | revLookup[ae.charCodeAt(we + 1)] << 4 | revLookup[ae.charCodeAt(we + 2)] >> 2, ce[de++] = ie >> 8 & 255, ce[de++] = ie & 255), ce;
}
function tripletToBase64(ae) {
  return lookup[ae >> 18 & 63] + lookup[ae >> 12 & 63] + lookup[ae >> 6 & 63] + lookup[ae & 63];
}
function encodeChunk(ae, ie, se) {
  for (var fe, ue = [], ce = ie; ce < se; ce += 3)
    fe = (ae[ce] << 16 & 16711680) + (ae[ce + 1] << 8 & 65280) + (ae[ce + 2] & 255), ue.push(tripletToBase64(fe));
  return ue.join("");
}
function fromByteArray(ae) {
  for (var ie, se = ae.length, fe = se % 3, ue = [], ce = 16383, de = 0, me = se - fe; de < me; de += ce)
    ue.push(encodeChunk(ae, de, de + ce > me ? me : de + ce));
  return fe === 1 ? (ie = ae[se - 1], ue.push(
    lookup[ie >> 2] + lookup[ie << 4 & 63] + "=="
  )) : fe === 2 && (ie = (ae[se - 2] << 8) + ae[se - 1], ue.push(
    lookup[ie >> 10] + lookup[ie >> 4 & 63] + lookup[ie << 2 & 63] + "="
  )), ue.join("");
}
function concatBuffers(ae) {
  let ie = 0;
  for (const ue of ae)
    ie += ue.byteLength;
  const se = new Uint8Array(ie);
  let fe = 0;
  se.set(new Uint8Array(ae[0]), fe), fe += ae[0].byteLength;
  for (let ue = 1; ue < ae.length; ue++)
    se.set(new Uint8Array(ae[ue]), fe), fe += ae[ue].byteLength;
  return se;
}
function b64UrlToString(ae) {
  const ie = b64UrlToBuffer(ae);
  return bufferToString(ie);
}
function bufferToString(ae) {
  return new TextDecoder("utf-8", { fatal: !0 }).decode(ae);
}
function stringToBuffer(ae) {
  return new TextEncoder().encode(ae);
}
function stringToB64Url(ae) {
  return bufferTob64Url(stringToBuffer(ae));
}
function b64UrlToBuffer(ae) {
  return new Uint8Array(toByteArray_1(b64UrlDecode(ae)));
}
function bufferTob64(ae) {
  return fromByteArray_1(new Uint8Array(ae));
}
function bufferTob64Url(ae) {
  return b64UrlEncode(bufferTob64(ae));
}
function b64UrlEncode(ae) {
  return ae.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
}
function b64UrlDecode(ae) {
  ae = ae.replace(/\-/g, "+").replace(/\_/g, "/");
  let ie;
  return ae.length % 4 == 0 ? ie = 0 : ie = 4 - ae.length % 4, ae.concat("=".repeat(ie));
}
function winstonToAr(ae) {
  return new BigNumber$1(ae).shiftedBy(-12);
}
function arToWinston(ae) {
  return new BigNumber$1(ae).shiftedBy(12);
}
const ArweaveUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arToWinston,
  b64UrlDecode,
  b64UrlEncode,
  b64UrlToBuffer,
  b64UrlToString,
  bufferToString,
  bufferTob64,
  bufferTob64Url,
  concatBuffers,
  stringToB64Url,
  stringToBuffer,
  winstonToAr
}, Symbol.toStringTag, { value: "Module" }));
class WebCryptoDriver {
  keyLength = 4096;
  publicExponent = 65537;
  hashAlgorithm = "sha256";
  driver;
  constructor() {
    this.driver = crypto?.subtle;
  }
  async generateJWK() {
    const ie = await this.driver.generateKey({
      name: "RSA-PSS",
      modulusLength: 4096,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: {
        name: "SHA-256"
      }
    }, !0, ["sign"]), se = await this.driver.exportKey("jwk", ie.privateKey);
    return {
      kty: se.kty,
      e: se.e,
      n: se.n,
      d: se.d,
      p: se.p,
      q: se.q,
      dp: se.dp,
      dq: se.dq,
      qi: se.qi
    };
  }
  async sign(ie, se, { saltLength: fe } = { saltLength: 32 }) {
    const ue = await this.driver.sign({
      name: "RSA-PSS",
      saltLength: fe
    }, await this.jwkToCryptoKey(ie), se);
    return new Uint8Array(ue);
  }
  async hash(ie, se = "SHA-256") {
    const fe = await this.driver.digest(se, ie);
    return new Uint8Array(fe);
  }
  async verify(ie, se, fe) {
    const ue = {
      kty: "RSA",
      e: "AQAB",
      n: ie
    }, ce = await this.jwkToPublicCryptoKey(ue), de = await this.driver.digest("SHA-256", se), me = await this.driver.verify({
      name: "RSA-PSS",
      saltLength: 0
    }, ce, fe, se), we = await this.driver.verify({
      name: "RSA-PSS",
      saltLength: 32
    }, ce, fe, se), Ee = await this.driver.verify({
      name: "RSA-PSS",
      saltLength: Math.ceil((ce.algorithm.modulusLength - 1) / 8) - de.byteLength - 2
    }, ce, fe, se);
    return me || we || Ee;
  }
  async jwkToCryptoKey(ie) {
    return this.driver.importKey("jwk", ie, {
      name: "RSA-PSS",
      hash: {
        name: "SHA-256"
      }
    }, !1, ["sign"]);
  }
  async jwkToPublicCryptoKey(ie) {
    return this.driver.importKey("jwk", ie, {
      name: "RSA-PSS",
      hash: {
        name: "SHA-256"
      }
    }, !1, ["verify"]);
  }
  // private detectWebCrypto() {
  //   if (typeof crypto === "undefined") {
  //     return false;
  //   }
  //   const subtle = crypto?.subtle;
  //   if (subtle === undefined) {
  //     return false;
  //   }
  //   const names = ["generateKey", "importKey", "exportKey", "digest", "sign"] as const;
  //   return names.every((name) => typeof subtle[name] === "function");
  // }
  async encrypt(ie, se, fe) {
    const ue = await this.driver.importKey("raw", typeof se == "string" ? stringToBuffer(se) : se, {
      name: "PBKDF2",
      length: 32
    }, !1, ["deriveKey"]), ce = await this.driver.deriveKey({
      name: "PBKDF2",
      salt: stringToBuffer(fe || "salt"),
      iterations: 1e5,
      hash: "SHA-256"
    }, ue, {
      name: "AES-CBC",
      length: 256
    }, !1, ["encrypt", "decrypt"]), de = new Uint8Array(16);
    crypto.getRandomValues(de);
    const me = await this.driver.encrypt({
      name: "AES-CBC",
      iv: de
    }, ce, ie);
    return concatBuffers([de, me]);
  }
  async decrypt(ie, se, fe) {
    const ue = await this.driver.importKey("raw", typeof se == "string" ? stringToBuffer(se) : se, {
      name: "PBKDF2",
      length: 32
    }, !1, ["deriveKey"]), ce = await this.driver.deriveKey({
      name: "PBKDF2",
      salt: stringToBuffer(fe || "salt"),
      iterations: 1e5,
      hash: "SHA-256"
    }, ue, {
      name: "AES-CBC",
      length: 256
    }, !1, ["encrypt", "decrypt"]), de = ie.slice(0, 16), me = await this.driver.decrypt({
      name: "AES-CBC",
      iv: de
    }, ce, ie.slice(16));
    return concatBuffers([me]);
  }
}
async function deepHash(ae) {
  if (typeof ae[Symbol.asyncIterator] == "function") {
    const ue = ae, ce = cryptoBrowserifyExports.createHash("sha384");
    let de = 0;
    for await (const Ee of ue)
      de += Ee.byteLength, ce.update(Ee);
    const me = concatBuffers([stringToBuffer("blob"), stringToBuffer(de.toString())]), we = concatBuffers([await getCryptoDriver().hash(me, "SHA-384"), ce.digest()]);
    return await getCryptoDriver().hash(we, "SHA-384");
  } else if (Array.isArray(ae)) {
    const ue = concatBuffers([stringToBuffer("list"), stringToBuffer(ae.length.toString())]);
    return await deepHashChunks(ae, await getCryptoDriver().hash(ue, "SHA-384"));
  }
  const ie = ae, se = concatBuffers([stringToBuffer("blob"), stringToBuffer(ie.byteLength.toString())]), fe = concatBuffers([await getCryptoDriver().hash(se, "SHA-384"), await getCryptoDriver().hash(ie, "SHA-384")]);
  return await getCryptoDriver().hash(fe, "SHA-384");
}
async function deepHashChunks(ae, ie) {
  if (ae.length < 1)
    return ie;
  const se = concatBuffers([ie, await deepHash(ae[0])]), fe = await getCryptoDriver().hash(se, "SHA-384");
  return await deepHashChunks(ae.slice(1), fe);
}
class ArweaveError extends Error {
  type;
  response;
  constructor(ie, se = {}) {
    se.message ? super(se.message) : super(), this.type = ie, this.response = se.response;
  }
  getType() {
    return this.type;
  }
}
function getError(ae) {
  let ie = ae.data;
  if (typeof ae.data == "string")
    try {
      ie = JSON.parse(ae.data);
    } catch {
    }
  if (ae.data instanceof ArrayBuffer || ae.data instanceof Uint8Array)
    try {
      ie = JSON.parse(ie.toString());
    } catch {
    }
  return ie ? ie.error || ie : ae.statusText || "unknown";
}
class Blocks {
  api;
  network;
  constructor(ie, se) {
    this.api = ie, this.network = se;
  }
  /**
   * Gets a block by its "indep_hash"
   */
  async getByHash(ie) {
    const se = await this.api.get(`block/hash/${ie}`);
    if (se.status === 200)
      return se.data;
    throw se.status === 404 ? new ArweaveError(
      "BLOCK_NOT_FOUND"
      /* ArweaveErrorType.BLOCK_NOT_FOUND */
    ) : new Error(`Error while loading block data: ${se}`);
  }
  /**
   * Gets a block by its "indep_hash"
   */
  async getByHeight(ie) {
    const se = await this.api.get(`block/height/${ie}`);
    if (se.status === 200)
      return se.data;
    throw se.status === 404 ? new ArweaveError(
      "BLOCK_NOT_FOUND"
      /* ArweaveErrorType.BLOCK_NOT_FOUND */
    ) : new Error(`Error while loading block data: ${se}`);
  }
  /**
   * Gets current block data (ie. block with indep_hash = Network.getInfo().current)
   */
  async getCurrent() {
    const { current: ie } = await this.network.getInfo();
    return await this.getByHash(ie);
  }
}
const MAX_CHUNK_SIZE = 256 * 1024, MIN_CHUNK_SIZE = 32 * 1024, NOTE_SIZE = 32, HASH_SIZE = 32;
class Merkle {
  crypto;
  constructor(ie) {
    this.crypto = ie.deps.crypto;
  }
  /**
   * Takes the input data and chunks it into (mostly) equal sized chunks.
   * The last chunk will be a bit smaller as it contains the remainder
   * from the chunking process.
   */
  async chunkData(ie) {
    const se = [];
    let fe = ie, ue = 0;
    for (; fe.byteLength >= MAX_CHUNK_SIZE; ) {
      let ce = MAX_CHUNK_SIZE;
      const de = fe.byteLength - MAX_CHUNK_SIZE;
      de > 0 && de < MIN_CHUNK_SIZE && (ce = Math.ceil(fe.byteLength / 2));
      const me = fe.slice(0, ce), we = await this.crypto.hash(me);
      ue += me.byteLength, se.push({
        dataHash: we,
        minByteRange: ue - me.byteLength,
        maxByteRange: ue
      }), fe = fe.slice(ce);
    }
    return se.push({
      dataHash: await this.crypto.hash(fe),
      minByteRange: ue,
      maxByteRange: ue + fe.byteLength
    }), se;
  }
  async generateLeaves(ie) {
    return Promise.all(ie.map(async ({ dataHash: se, minByteRange: fe, maxByteRange: ue }) => ({
      type: "leaf",
      id: await this.hash(await Promise.all([this.hash(se), this.hash(intToBuffer$1(ue))])),
      dataHash: se,
      minByteRange: fe,
      maxByteRange: ue
    })));
  }
  /**
   * Builds an arweave merkle tree and gets the root hash for the given input.
   */
  async computeRootHash(ie) {
    return (await this.generateTree(ie)).id;
  }
  async generateTree(ie) {
    return await this.buildLayers(await this.generateLeaves(await this.chunkData(ie)));
  }
  /**
   * Generates the data_root, chunks & proofs
   * needed for a transaction.
   *
   * This also checks if the last chunk is a zero-length
   * chunk and discards that chunk and proof if so.
   * (we do not need to upload this zero length chunk)
   *
   * @param data
   */
  async generateTransactionChunks(ie) {
    const se = await this.chunkData(ie), fe = await this.generateLeaves(se), ue = await this.buildLayers(fe), ce = await this.generateProofs(ue), de = se.slice(-1)[0];
    return de.maxByteRange - de.minByteRange === 0 && (se.splice(se.length - 1, 1), ce.splice(ce.length - 1, 1)), {
      data_root: ue.id,
      chunks: se,
      proofs: ce
    };
  }
  /**
   * Starting with the bottom layer of leaf nodes, hash every second pair
   * into a new branch node, push those branch nodes onto a new layer,
   * and then recurse, building up the tree to it's root, where the
   * layer only consists of two items.
   */
  async buildLayers(ie, se = 0) {
    if (ie.length < 2)
      return ie[0];
    const fe = [];
    for (let ue = 0; ue < ie.length; ue += 2)
      fe.push(await this.hashBranch(ie[ue], ie[ue + 1]));
    return this.buildLayers(fe, se + 1);
  }
  /**
   * Recursively search through all branches of the tree,
   * and generate a proof for each leaf node.
   */
  generateProofs(ie) {
    const se = this.resolveBranchProofs(ie);
    return Array.isArray(se) ? arrayFlatten(se) : [se];
  }
  resolveBranchProofs(ie, se = new Uint8Array(), fe = 0) {
    if (ie.type == "leaf")
      return {
        offset: ie.maxByteRange - 1,
        proof: concatBuffers([se, ie.dataHash, intToBuffer$1(ie.maxByteRange)])
      };
    if (ie.type == "branch") {
      const ue = concatBuffers([se, ie.leftChild.id, ie.rightChild.id, intToBuffer$1(ie.byteRange)]);
      return [
        this.resolveBranchProofs(ie.leftChild, ue, fe + 1),
        this.resolveBranchProofs(ie.rightChild, ue, fe + 1)
      ];
    }
    throw new Error("Unexpected node type");
  }
  async validatePath(ie, se, fe, ue, ce) {
    if (ue <= 0)
      return !1;
    if (se >= ue)
      return this.validatePath(ie, 0, ue - 1, ue, ce);
    if (se < 0)
      return this.validatePath(ie, 0, 0, ue, ce);
    if (ce.length == HASH_SIZE + NOTE_SIZE) {
      const Ce = ce.slice(0, HASH_SIZE), Ie = ce.slice(Ce.length, Ce.length + NOTE_SIZE), Pe = await this.hash([await this.hash(Ce), await this.hash(Ie)]);
      return arrayCompare(ie, Pe) ? {
        offset: ue - 1,
        leftBound: fe,
        rightBound: ue,
        chunkSize: ue - fe
      } : !1;
    }
    const de = ce.slice(0, HASH_SIZE), me = ce.slice(de.length, de.length + HASH_SIZE), we = ce.slice(de.length + me.length, de.length + me.length + NOTE_SIZE), Ee = bufferToInt(we), Se = ce.slice(de.length + me.length + we.length), Be = await this.hash([await this.hash(de), await this.hash(me), await this.hash(we)]);
    return arrayCompare(ie, Be) ? se < Ee ? await this.validatePath(de, se, fe, Math.min(ue, Ee), Se) : await this.validatePath(me, se, Math.max(fe, Ee), ue, Se) : !1;
  }
  async hashBranch(ie, se) {
    return se ? {
      type: "branch",
      id: await this.hash([await this.hash(ie.id), await this.hash(se.id), await this.hash(intToBuffer$1(ie.maxByteRange))]),
      byteRange: ie.maxByteRange,
      maxByteRange: se.maxByteRange,
      leftChild: ie,
      rightChild: se
    } : ie;
  }
  async hash(ie) {
    return Array.isArray(ie) && (ie = Arweave$2.utils.concatBuffers(ie)), new Uint8Array(await this.crypto.hash(ie));
  }
  /**
   * Inspect an arweave chunk proof.
   * Takes proof, parses, reads and displays the values for console logging.
   * One proof section per line
   * Format: left,right,offset => hash
   */
  async debug(ie, se = "") {
    if (ie.byteLength < 1)
      return se;
    const fe = ie.slice(0, HASH_SIZE), ue = ie.slice(fe.length, fe.length + HASH_SIZE), ce = ie.slice(fe.length + ue.length, fe.length + ue.length + NOTE_SIZE), de = bufferToInt(ce), me = ie.slice(fe.length + ue.length + ce.length), we = await this.hash([await this.hash(fe), await this.hash(ue), await this.hash(ce)]), Ee = `${se}
${JSON.stringify(Buffer$F.from(fe))},${JSON.stringify(Buffer$F.from(ue))},${de} => ${JSON.stringify(we)}`;
    return this.debug(me, Ee);
  }
}
function arrayFlatten(ae) {
  const ie = [];
  return ae.forEach((se) => {
    Array.isArray(se) ? ie.push(...arrayFlatten(se)) : ie.push(se);
  }), ie;
}
function intToBuffer$1(ae) {
  const ie = new Uint8Array(NOTE_SIZE);
  for (let se = ie.length - 1; se >= 0; se--) {
    const fe = ae % 256;
    ie[se] = fe, ae = (ae - fe) / 256;
  }
  return ie;
}
function bufferToInt(ae) {
  let ie = 0;
  for (let se = 0; se < ae.length; se++)
    ie *= 256, ie += ae[se];
  return ie;
}
const arrayCompare = (ae, ie) => ae.every((se, fe) => ie[fe] === se);
class Chunks {
  api;
  constructor(ie) {
    this.api = ie;
  }
  async getTransactionMetadata(ie) {
    const se = await this.api.get(`tx/${ie}/offset`);
    if (se.status === 200)
      return se.data;
    throw new Error(`Unable to get transaction offset: ${getError(se)}`);
  }
  async getChunk(ie) {
    const se = await this.api.get(`chunk/${ie}`);
    if (se.status === 200)
      return se.data;
    throw new Error(`Unable to get chunk: ${getError(se)}`);
  }
  async getChunkData(ie) {
    const se = await this.getChunk(ie);
    return b64UrlToBuffer(se.chunk);
  }
  firstChunkOffset(ie) {
    return parseInt(ie.offset) - parseInt(ie.size) + 1;
  }
  /**
   * Downloads chunks from the configured API peers, with a default concurrency of 10
   * @param id - ID of the transaction to download
   * @param options - Options object for configuring the downloader
   * @param options.concurrency - The number of chunks to download simultaneously. reduce on slower connections.
   * @returns
   */
  async downloadChunkedData(ie, se) {
    const fe = await this.getTransactionMetadata(ie), ue = parseInt(fe.size), ce = new Uint8Array(ue);
    let de = 0;
    for await (const me of this.concurrentChunkDownloader(ie, se))
      ce.set(me, de), de += me.length;
    return ce;
  }
  async *concurrentChunkDownloader(ie, se) {
    const fe = { concurrency: 10, ...se }, ue = await this.getTransactionMetadata(ie), ce = new BigNumber$1(ue.offset), de = new BigNumber$1(ue.size), me = ce.minus(de).plus(1);
    let we = 0;
    const Ee = Math.ceil(de.dividedBy(MAX_CHUNK_SIZE).toNumber()), Se = (Ne) => this.getChunkData(Ne.toString()).then((ke) => (we += ke.length, ke)), Be = [], Ce = Ee - 2, Ie = Math.min(Ce, fe.concurrency);
    let Pe = 0;
    for (let Ne = 0; Ne < Ie; Ne++)
      Be.push(Se(me.plus(MAX_CHUNK_SIZE * Pe++)));
    for (; Pe < Ce; )
      Be.push(Se(me.plus(MAX_CHUNK_SIZE * Pe++))), yield Be.shift();
    for (; Be.length > 0; )
      yield Be.shift();
    if (yield Se(me.plus(MAX_CHUNK_SIZE * Pe++)), de.isGreaterThan(we) && (yield Se(me.plus(MAX_CHUNK_SIZE * Pe++))), !de.isEqualTo(we))
      throw new Error(`got ${we}B, expected ${de.toString()}B`);
  }
}
function augmentCrypto(ae, ie) {
  const se = ae;
  return se.deepHash = new ie.deepHash({ deps: { utils: { stringToBuffer, concatBuffers }, crypto: ae } }), se;
}
class DeepHash {
  crypto;
  utils;
  constructor({ deps: ie }) {
    this.crypto = ie.crypto, this.utils = ie.utils;
  }
  async deepHash(ie) {
    if (Array.isArray(ie)) {
      const ue = this.utils.concatBuffers([this.utils.stringToBuffer("list"), this.utils.stringToBuffer(ie.length.toString())]);
      return await this.deepHashChunks(ie, await this.crypto.hash(ue, "SHA-384"));
    }
    const se = this.utils.concatBuffers([this.utils.stringToBuffer("blob"), this.utils.stringToBuffer(ie.byteLength.toString())]), fe = this.utils.concatBuffers([await this.crypto.hash(se, "SHA-384"), await this.crypto.hash(ie, "SHA-384")]);
    return await this.crypto.hash(fe, "SHA-384");
  }
  async deepHashChunks(ie, se) {
    if (ie.length < 1)
      return se;
    const fe = this.utils.concatBuffers([se, await this.deepHash(ie[0])]), ue = await this.crypto.hash(fe, "SHA-384");
    return await this.deepHashChunks(ie.slice(1), ue);
  }
}
class Api {
  _instance;
  cookieMap = /* @__PURE__ */ new Map();
  config;
  constructor(ie) {
    ie && this.applyConfig(ie);
  }
  applyConfig(ie) {
    this.config = this.mergeDefaults(ie), this._instance = void 0;
  }
  getConfig() {
    return this.config;
  }
  async requestInterceptor(ie) {
    const se = this.cookieMap.get(new URL(ie.baseURL ?? "").host);
    return se && (ie.headers.cookie = se), ie;
  }
  async responseInterceptor(ie) {
    const se = ie.headers?.["set-cookie"];
    return se && this.cookieMap.set(ie.request.host, se), ie;
  }
  mergeDefaults(ie) {
    return ie.headers ??= {}, ie.network && !Object.keys(ie.headers).includes("x-network") && (ie.headers["x-network"] = ie.network), {
      url: ie.url,
      timeout: ie.timeout ?? 2e4,
      logging: ie.logging ?? !1,
      logger: ie.logger ?? console.log,
      headers: { ...ie.headers, "x-irys-arweave-version": Arweave$2.VERSION },
      withCredentials: ie.withCredentials ?? !1,
      retry: { retries: 3, maxTimeout: 5e3 }
    };
  }
  async get(ie, se) {
    try {
      return await this.request(ie, { ...se, method: "GET" });
    } catch (fe) {
      if (fe.response?.status)
        return fe.response;
      throw fe;
    }
  }
  async post(ie, se, fe) {
    try {
      return await this.request(ie, { data: se, ...fe, method: "POST" });
    } catch (ue) {
      if (ue.response?.status)
        return ue.response;
      throw ue;
    }
  }
  get instance() {
    if (this._instance)
      return this._instance;
    const ie = axios$1.create({
      baseURL: this.config.url.toString(),
      timeout: this.config.timeout,
      maxContentLength: 1024 * 1024 * 512,
      headers: this.config.headers,
      withCredentials: this.config.withCredentials
    });
    return this.config.withCredentials && (ie.interceptors.request.use(this.requestInterceptor.bind(this)), ie.interceptors.response.use(this.responseInterceptor.bind(this))), this.config.logging && (ie.interceptors.request.use((se) => (this.config.logger(`Requesting: ${se.baseURL}/${se.url}`), se)), ie.interceptors.response.use((se) => (this.config.logger(`Response: ${se.config.url} - ${se.status}`), se))), this._instance = ie;
  }
  async request(ie, se) {
    const fe = this.instance, ue = se?.url ?? new URL(ie, this.config.url).toString();
    return retry$1((ce) => fe({ ...se, url: ue }), {
      ...this.config.retry,
      ...se?.retry
    });
  }
}
const isApiConfig = (ae) => typeof ae != "string" && "url" in ae, defaultFallbackConfig = {
  maxAttempts: 15,
  randomlySelect: !0
};
class FallbackApi {
  minerInstances = [];
  globalConfig;
  gatewayInstances = [];
  constructor({ gateways: ie, miners: se, opts: fe }) {
    this.globalConfig = fe?.globalConfig ?? {}, se && this.addMiners(se), ie && this.addGateways(ie);
  }
  async addPeersFrom(ie, se) {
    const fe = (await this.get("", { url: new URL("/peers", ie).toString() })).data;
    this.addMiners(fe.slice(0, se?.limit).map((ue) => `http://${ue}`));
  }
  addMiners(ie) {
    ie.forEach((se) => this.minerInstances.push(new Api(isApiConfig(se) ? se : { url: new URL(se), ...this.globalConfig })));
  }
  addGateways(ie) {
    ie.forEach((se) => this.gatewayInstances.push(new Api(isApiConfig(se) ? se : { url: new URL(se), ...this.globalConfig })));
  }
  async get(ie, se) {
    return this.request(ie, { ...se, method: "GET" });
  }
  async post(ie, se, fe) {
    return this.request(ie, { data: se, ...fe, method: "POST" });
  }
  async request(ie, se) {
    const fe = { ...defaultFallbackConfig, ...se?.fallback };
    let ue = 0;
    const ce = se?.gatewayOnly ? this.gatewayInstances : this.gatewayInstances.concat(this.minerInstances), de = Math.min(Math.max(fe?.maxAttempts, 1), ce.length), me = fe?.onFallback;
    if (ce.length === 0)
      throw new Error("Unable to run request due to 0 configured gateways/miners.");
    for (; ue++ < de; ) {
      const we = ce.at(fe?.randomlySelect ? Math.floor(Math.random() * ce.length) : ue - 1);
      if (we)
        try {
          return await we.request(ie, { ...se });
        } catch (Ee) {
          if (me?.(Ee, we), ue >= de)
            throw Ee;
        }
    }
    throw new Error("unreachable");
  }
}
class BaseObject {
  get(ie, se) {
    if (!Object.getOwnPropertyNames(this).includes(ie))
      throw new Error(`Field "${ie}" is not a property of the Arweave Transaction class.`);
    if (this[ie] instanceof Uint8Array)
      return se && se.decode && se.string ? bufferToString(this[ie]) : se && se.decode && !se.string ? this[ie] : bufferTob64Url(this[ie]);
    if (this[ie] instanceof Array) {
      if (se?.decode !== void 0 || se?.string !== void 0)
        throw ie === "tags" && console.warn(`Did you mean to use 'transaction["tags"]' ?`), new Error("Cannot decode or stringify an array.");
      return this[ie];
    }
    return se && se.decode == !0 ? se && se.string ? b64UrlToString(this[ie]) : b64UrlToBuffer(this[ie]) : this[ie];
  }
}
class ArweaveTag extends BaseObject {
  name;
  value;
  constructor(ie, se) {
    super(), this.name = ie, this.value = se;
  }
}
let Transaction$1 = class extends BaseObject {
  format = 2;
  id = "";
  last_tx = "";
  owner = "";
  tags = [];
  target = "";
  quantity = "0";
  data_size = "0";
  data = new Uint8Array();
  data_root = "";
  reward = "0";
  signature = "";
  merkle;
  deepHash;
  // Computed when needed.
  chunks;
  constructor({ attributes: ie, deps: se }) {
    super(), this.merkle = se.merkle, this.deepHash = se.deepHash, Object.assign(this, ie), typeof this.data == "string" && (this.data = b64UrlToBuffer(this.data)), ie.tags && (this.tags = ie.tags);
  }
  addTag(ie, se) {
    this.tags.push({ name: stringToB64Url(ie), value: stringToB64Url(se) });
  }
  toJSON() {
    return {
      format: this.format,
      id: this.id,
      last_tx: this.last_tx,
      owner: this.owner,
      tags: this.tags,
      target: this.target,
      quantity: this.quantity,
      data: bufferTob64Url(this.data),
      data_size: this.data_size,
      data_root: this.data_root,
      data_tree: this.data_tree,
      reward: this.reward,
      signature: this.signature
    };
  }
  setOwner(ie) {
    this.owner = ie;
  }
  setSignature({ id: ie, owner: se, reward: fe, tags: ue, signature: ce }) {
    this.id = ie, this.owner = se, fe && (this.reward = fe), ue && (this.tags = ue), this.signature = ce;
  }
  async prepareChunks(ie) {
    !this.chunks && ie.byteLength > 0 && (this.chunks = await this.merkle.generateTransactionChunks(ie), this.data_root = bufferTob64Url(this.chunks.data_root)), !this.chunks && ie.byteLength === 0 && (this.chunks = {
      chunks: [],
      data_root: new Uint8Array(),
      proofs: []
    }, this.data_root = "");
  }
  // Returns a chunk in a format suitable for posting to /chunk.
  // Similar to `prepareChunks()` this does not operate `this.data`,
  // instead using the data passed in.
  getChunk(ie, se) {
    if (!this.chunks)
      throw new Error("Chunks have not been prepared");
    const fe = this.chunks.proofs[ie], ue = this.chunks.chunks[ie];
    return {
      data_root: this.data_root,
      data_size: this.data_size,
      data_path: bufferTob64Url(fe.proof),
      offset: fe.offset.toString(),
      chunk: bufferTob64Url(se.slice(ue.minByteRange, ue.maxByteRange))
    };
  }
  async getSignatureData() {
    switch (this.format) {
      case 1:
        const ie = this.tags.reduce((fe, ue) => concatBuffers([fe, b64UrlToBuffer(ue.name), b64UrlToBuffer(ue.value)]), new Uint8Array());
        return concatBuffers([
          this.get("owner", { decode: !0, string: !1 }),
          this.get("target", { decode: !0, string: !1 }),
          this.get("data", { decode: !0, string: !1 }),
          stringToBuffer(this.quantity),
          stringToBuffer(this.reward),
          this.get("last_tx", { decode: !0, string: !1 }),
          ie
        ]);
      case 2:
        this.data_root || await this.prepareChunks(this.data);
        const se = this.tags.map((fe) => [b64UrlToBuffer(fe.name), b64UrlToBuffer(fe.value)]);
        return await this.deepHash.deepHash([
          stringToBuffer(this.format.toString()),
          this.get("owner", { decode: !0, string: !1 }),
          this.get("target", { decode: !0, string: !1 }),
          stringToBuffer(this.quantity),
          stringToBuffer(this.reward),
          this.get("last_tx", { decode: !0, string: !1 }),
          se,
          stringToBuffer(this.data_size),
          this.get("data_root", { decode: !0, string: !1 })
        ]);
      default:
        throw new Error(`Unexpected transaction format: ${this.format}`);
    }
  }
};
class Network {
  api;
  constructor(ie) {
    this.api = ie;
  }
  getInfo() {
    return this.api.get("info").then((ie) => ie.data);
  }
  getPeers() {
    return this.api.get("peers").then((ie) => ie.data);
  }
}
const MAX_CHUNKS_IN_BODY = 1, FATAL_CHUNK_UPLOAD_ERRORS = [
  "invalid_json",
  "chunk_too_big",
  "data_path_too_big",
  "offset_too_big",
  "data_size_too_big",
  "chunk_proof_ratio_not_attractive",
  "invalid_proof"
], ERROR_DELAY = 1e3 * 40;
class TransactionUploader {
  chunkIndex = 0;
  txPosted = !1;
  transaction;
  lastRequestTimeEnd = 0;
  totalErrors = 0;
  // Not serialized.
  data;
  lastResponseStatus = 0;
  lastResponseError = "";
  get isComplete() {
    return this.txPosted && this.chunkIndex === this.transaction.chunks.chunks.length;
  }
  get totalChunks() {
    return this.transaction.chunks.chunks.length;
  }
  get uploadedChunks() {
    return this.chunkIndex;
  }
  get pctComplete() {
    return Math.trunc(this.uploadedChunks / this.totalChunks * 100);
  }
  crypto;
  api;
  merkle;
  deepHash;
  constructor({ deps: ie, transaction: se }) {
    if (!se.id)
      throw new Error("Transaction is not signed");
    if (!se.chunks)
      throw new Error("Transaction chunks not prepared");
    this.api = ie.api, this.crypto = ie.crypto, this.merkle = ie.merkle, this.deepHash = ie.deepHash, this.data = se.data, this.transaction = new Transaction$1({
      attributes: Object.assign({}, se, { data: new Uint8Array(0) }),
      deps: { merkle: ie.merkle, deepHash: ie.deepHash }
    });
  }
  /**
   * Uploads the next part of the transaction.
   * On the first call this posts the transaction
   * itself and on any subsequent calls uploads the
   * next chunk until it completes.
   */
  async uploadChunk(ie) {
    if (this.isComplete)
      throw new Error("Upload is already complete");
    if (this.lastResponseError !== "" ? this.totalErrors++ : this.totalErrors = 0, this.totalErrors === 100)
      throw new Error(`Unable to complete upload: ${this.lastResponseStatus}: ${this.lastResponseError}`);
    let se = this.lastResponseError === "" ? 0 : Math.max(this.lastRequestTimeEnd + ERROR_DELAY - Date.now(), ERROR_DELAY);
    if (se > 0 && (se = se - se * Math.random() * 0.3, await new Promise((de) => setTimeout(de, se))), this.lastResponseError = "", !this.txPosted) {
      await this.postTransaction();
      return;
    }
    ie && (this.chunkIndex = ie);
    const fe = this.transaction.getChunk(ie || this.chunkIndex, this.data);
    if (!await this.merkle.validatePath(this.transaction.chunks.data_root, parseInt(fe.offset), 0, parseInt(fe.data_size), b64UrlToBuffer(fe.data_path)))
      throw new Error(`Unable to validate chunk ${this.chunkIndex}`);
    const ce = await this.api.post("chunk", this.transaction.getChunk(this.chunkIndex, this.data)).catch((de) => (console.error(de.message), { status: -1, data: { error: de.message } }));
    if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = ce.status, this.lastResponseStatus == 200)
      this.chunkIndex++;
    else if (this.lastResponseError = getError(ce), FATAL_CHUNK_UPLOAD_ERRORS.includes(this.lastResponseError))
      throw new Error(`Fatal error uploading chunk ${this.chunkIndex}: ${this.lastResponseError}`);
  }
  /**
   * Reconstructs an upload from its serialized state and data.
   * Checks if data matches the expected data_root.
   *
   * @param serialized
   * @param data
   */
  static async fromSerialized({ serialized: ie, data: se, deps: fe }) {
    if (!ie || typeof ie.chunkIndex != "number" || typeof ie.transaction != "object")
      throw new Error("Serialized object does not match expected format.");
    const ue = new Transaction$1(ie.transaction);
    ue.chunks || await ue.prepareChunks(se);
    const ce = new TransactionUploader({
      deps: fe,
      transaction: ue
    });
    if (ce.chunkIndex = ie.chunkIndex, ce.lastRequestTimeEnd = ie.lastRequestTimeEnd, ce.lastResponseError = ie.lastResponseError, ce.lastResponseStatus = ie.lastResponseStatus, ce.txPosted = ie.txPosted, ce.data = se, ce.transaction.data_root !== ie.transaction.data_root)
      throw new Error("Data mismatch: Uploader doesn't match provided data.");
    return ce;
  }
  /**
   * Reconstruct an upload from the tx metadata, ie /tx/<id>.
   *
   * @param api
   * @param id
   * @param data
   */
  static async fromTransactionId(ie, se) {
    const fe = await ie.get(`tx/${se}`);
    if (fe.status !== 200)
      throw new Error(`Tx ${se} not found: ${fe.status}`);
    const ue = fe.data;
    return ue.data = new Uint8Array(0), {
      txPosted: !0,
      chunkIndex: 0,
      lastResponseError: "",
      lastRequestTimeEnd: 0,
      lastResponseStatus: 0,
      transaction: ue
    };
  }
  toJSON() {
    return {
      chunkIndex: this.chunkIndex,
      transaction: this.transaction,
      lastRequestTimeEnd: this.lastRequestTimeEnd,
      lastResponseStatus: this.lastResponseStatus,
      lastResponseError: this.lastResponseError,
      txPosted: this.txPosted
    };
  }
  // POST to /tx
  async postTransaction() {
    if (this.totalChunks <= MAX_CHUNKS_IN_BODY) {
      this.transaction.data = this.data;
      const fe = await this.api.post("tx", this.transaction).catch((ue) => (console.error(ue), { status: -1, data: { error: ue.message } }));
      if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = fe.status, this.transaction.data = new Uint8Array(0), fe.status >= 200 && fe.status < 300) {
        this.txPosted = !0, this.chunkIndex = MAX_CHUNKS_IN_BODY;
        return;
      }
      throw this.lastResponseError = getError(fe), new Error(`Unable to upload transaction: ${fe.status}, ${this.lastResponseError}`);
    }
    const se = await this.api.post("tx", this.transaction);
    if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = se.status, !(se.status >= 200 && se.status < 300))
      throw this.lastResponseError = getError(se), new Error(`Unable to upload transaction: ${se.status}, ${this.lastResponseError}`);
    this.txPosted = !0;
  }
}
class Transactions {
  api;
  crypto;
  chunks;
  merkle;
  deepHash;
  constructor({ deps: ie }) {
    this.api = ie.api, this.crypto = ie.crypto, this.chunks = ie.chunks, this.merkle = ie.merkle, this.deepHash = ie.deepHash;
  }
  getTransactionAnchor() {
    return this.api.get("tx_anchor", { transformResponse: [] }).then((ie) => ie.data);
  }
  getPrice(ie, se) {
    const fe = se ? `price/${ie}/${se}` : `price/${ie}`;
    return this.api.get(fe, {
      transformResponse: [
        /**
         * We need to specify a response transformer to override
         * the default JSON.parse behavior, as this causes
         * winston to be converted to a number and we want to
         * return it as a winston string.
         * @param data
         */
        function(ue) {
          return ue;
        }
      ]
    }).then((ue) => ue.data);
  }
  async get(ie) {
    const se = await this.api.get(`tx/${ie}`);
    if (se.status == 200) {
      const fe = parseInt(se.data.data_size);
      if (se.data.format >= 2 && fe > 0 && fe <= 1024 * 1024 * 12) {
        const ue = await this.getData(ie);
        return new Transaction$1({
          attributes: {
            ...se.data,
            data: ue
          },
          deps: { merkle: this.merkle, deepHash: this.deepHash }
        });
      }
      return new Transaction$1({
        attributes: {
          ...se.data,
          format: se.data.format || 1
        },
        deps: { merkle: this.merkle, deepHash: this.deepHash }
      });
    }
    throw se.status === 404 ? new ArweaveError(
      "TX_NOT_FOUND"
      /* ArweaveErrorType.TX_NOT_FOUND */
    ) : se.status === 410 ? new ArweaveError(
      "TX_FAILED"
      /* ArweaveErrorType.TX_FAILED */
    ) : new ArweaveError(
      "TX_INVALID"
      /* ArweaveErrorType.TX_INVALID */
    );
  }
  fromRaw(ie) {
    return new Transaction$1({ attributes: ie, deps: { merkle: this.merkle, deepHash: this.deepHash } });
  }
  getStatus(ie) {
    return this.api.get(`tx/${ie}/status`).then((se) => se.status === 200 ? {
      status: 200,
      confirmed: se.data
    } : {
      status: se.status,
      confirmed: null
    });
  }
  async getData(ie) {
    let se;
    try {
      se = (await this.api.get(`/${ie}`, { responseType: "arraybuffer" })).data;
    } catch (fe) {
      console.error(`Error while trying to download contiguous data from gateway cache for ${ie}`), console.error(fe);
    }
    if (!se) {
      console.warn(`Falling back to chunks for ${ie}`);
      try {
        se = await this.chunks.downloadChunkedData(ie);
      } catch (fe) {
        console.error(`Error while trying to download chunked data for ${ie}`), console.error(fe);
      }
    }
    if (!se)
      throw new Error(`${ie} data was not found!`);
    return se;
  }
  async getDataStream(ie) {
    let se;
    try {
      const fe = (await this.api.get(`/${ie}`, { responseType: "arraybuffer" })).data;
      se = async function* () {
        yield fe;
      }();
    } catch (fe) {
      console.error(`Error while trying to download contiguous data from gateway cache for ${ie}`), console.error(fe);
    }
    if (!se) {
      console.warn(`Falling back to chunks for ${ie}`);
      try {
        se = this.chunks.concurrentChunkDownloader(ie);
      } catch (fe) {
        console.error(`Error while trying to download chunked data for ${ie}`), console.error(fe);
      }
    }
    if (!se)
      throw new Error(`${ie} data was not found!`);
    return se;
  }
  async sign(ie, se, fe) {
    const ce = typeof se == "object" && ((me) => {
      let we = !0;
      return ["n", "e", "d", "p", "q", "dp", "dq", "qi"].map((Ee) => !(Ee in me) && (we = !1)), we;
    })(se), de = typeof arweaveWallet == "object";
    if (!ce && !de)
      throw new Error("No valid JWK or external wallet found to sign transaction.");
    if (de) {
      try {
        (await arweaveWallet.getPermissions()).includes("SIGN_TRANSACTION") || await arweaveWallet.connect(["SIGN_TRANSACTION"]);
      } catch {
      }
      ie.tags = ie.tags.map((we) => new ArweaveTag(we.name, we.value));
      const me = await arweaveWallet.sign(ie, fe);
      ie.setSignature({
        id: me.id,
        owner: me.owner,
        reward: me.reward,
        tags: me.tags,
        signature: me.signature
      });
    } else if (ce) {
      ie.setOwner(se.n);
      const me = await ie.getSignatureData(), we = await this.crypto.sign(se, me, fe), Ee = await this.crypto.hash(we);
      ie.setSignature({
        id: bufferTob64Url(Ee),
        owner: se.n,
        signature: bufferTob64Url(we)
      });
    } else
      throw new Error("An error occurred while signing. Check wallet is valid");
  }
  async verify(ie) {
    const se = await ie.getSignatureData(), fe = ie.get("signature", {
      decode: !0,
      string: !1
    }), ue = bufferTob64Url(await this.crypto.hash(fe));
    if (ie.id !== ue)
      throw new Error("Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.");
    return this.crypto.verify(ie.owner, se, fe);
  }
  async post(ie) {
    if (typeof ie == "string" ? ie = new Transaction$1({ attributes: JSON.parse(ie), deps: { merkle: this.merkle, deepHash: this.deepHash } }) : typeof ie.readInt32BE == "function" ? ie = new Transaction$1({ attributes: JSON.parse(ie.toString()), deps: { merkle: this.merkle, deepHash: this.deepHash } }) : typeof ie == "object" && !(ie instanceof Transaction$1) && (ie = new Transaction$1({ attributes: ie, deps: { merkle: this.merkle, deepHash: this.deepHash } })), !(ie instanceof Transaction$1))
      throw new Error("Must be Transaction object");
    ie.chunks || await ie.prepareChunks(ie.data);
    const se = await this.getUploader(ie, ie.data);
    try {
      for (; !se.isComplete; )
        await se.uploadChunk();
    } catch (fe) {
      if (se.lastResponseStatus > 0)
        return {
          status: se.lastResponseStatus,
          statusText: se.lastResponseError,
          data: {
            error: se.lastResponseError
          }
        };
      throw fe;
    }
    return {
      status: 200,
      statusText: "OK",
      data: {}
    };
  }
  /**
   * Gets an uploader than can be used to upload a transaction chunk by chunk, giving progress
   * and the ability to resume.
   *
   * Usage example:
   *
   * ```
   * const uploader = arweave.transactions.getUploader(transaction);
   * while (!uploader.isComplete) {
   *   await uploader.uploadChunk();
   *   console.log(`${uploader.pctComplete}%`);
   * }
   * ```
   *
   * @param upload a Transaction object, a previously save progress object, or a transaction id.
   * @param data the data of the transaction. Required when resuming an upload.
   */
  async getUploader(ie, se) {
    let fe;
    if (se instanceof ArrayBuffer && (se = new Uint8Array(se)), ie instanceof Transaction$1) {
      if (se || (se = ie.data), !(se instanceof Uint8Array))
        throw new Error("Data format is invalid");
      ie.chunks || await ie.prepareChunks(se), fe = new TransactionUploader({
        transaction: ie,
        deps: { api: this.api, crypto: this.crypto, merkle: this.merkle, deepHash: this.deepHash }
      }), (!fe.data || fe.data.length === 0) && (fe.data = se);
    } else {
      if (typeof ie == "string" && (ie = await TransactionUploader.fromTransactionId(this.api, ie)), !se || !(se instanceof Uint8Array))
        throw new Error("Must provide data when resuming upload");
      fe = await TransactionUploader.fromSerialized({
        deps: { api: this.api, merkle: this.merkle, crypto: this.crypto, deepHash: this.deepHash },
        serialized: ie,
        data: se
      });
    }
    return fe;
  }
  /**
   * Async generator version of uploader
   *
   * Usage example:
   *
   * ```
   * for await (const uploader of arweave.transactions.upload(tx)) {
   *  console.log(`${uploader.pctComplete}%`);
   * }
   * ```
   *
   * @param upload a Transaction object, a previously save uploader, or a transaction id.
   * @param data the data of the transaction. Required when resuming an upload.
   */
  async *upload(ie, se) {
    const fe = await this.getUploader(ie, se);
    for (; !fe.isComplete; )
      await fe.uploadChunk(), yield fe;
    return fe;
  }
}
class Wallets {
  api;
  crypto;
  constructor(ie, se) {
    this.api = ie, this.crypto = se;
  }
  /**
   * Get the wallet balance for the given address.
   *
   * @param {string} address - The arweave address to get the balance for.
   *
   * @returns {Promise<string>} - Promise which resolves with a winston string balance.
   */
  getBalance(ie) {
    return this.api.get(`wallet/${ie}/balance`, {
      transformResponse: [
        /**
         * We need to specify a response transformer to override
         * the default JSON.parse behaviour, as this causes
         * balances to be converted to a number and we want to
         * return it as a winston string.
         * @param data
         */
        function(se) {
          return se;
        }
      ]
    }).then((se) => se.data);
  }
  /**
   * Get the last transaction ID for the given wallet address.
   *
   * @param {string} address - The arweave address to get the transaction for.
   *
   * @returns {Promise<string>} - Promise which resolves with a transaction ID.
   */
  getLastTransactionID(ie) {
    return this.api.get(`wallet/${ie}/last_tx`).then((se) => se.data);
  }
  generate() {
    return this.crypto.generateJWK();
  }
  async jwkToAddress(ie) {
    return !ie || ie === "use_wallet" ? this.getAddress() : this.getAddress(ie);
  }
  async getAddress(ie) {
    if (!ie || ie === "use_wallet") {
      try {
        await arweaveWallet.connect(["ACCESS_ADDRESS"]);
      } catch {
      }
      return arweaveWallet.getActiveAddress();
    } else
      return this.ownerToAddress(ie.n);
  }
  async ownerToAddress(ie) {
    return bufferTob64Url(await this.crypto.hash(b64UrlToBuffer(ie)));
  }
}
let Arweave$1 = class ei {
  config;
  api;
  wallets;
  transactions;
  network;
  blocks;
  chunks;
  static init;
  static utils = ArweaveUtils;
  crypto;
  deepHash;
  merkle;
  static VERSION = "0.0.1";
  constructor(ie) {
    if (this.config = ie, !ie.crypto)
      throw new Error("config.crypto is required");
    this.crypto = augmentCrypto(ie.crypto, { deepHash: DeepHash }), this.deepHash = this.crypto.deepHash;
    const se = ie.gateways ? Array.isArray(ie.gateways) ? ie.gateways : [ie.gateways] : void 0;
    this.api = new FallbackApi({ gateways: se, miners: ie.miners }), this.wallets = new Wallets(this.api, this.crypto), this.chunks = new Chunks(this.api), this.network = new Network(this.api), this.blocks = new Blocks(this.api, this.network), this.merkle = new Merkle({ deps: { crypto: this.crypto } }), this.transactions = new Transactions({
      deps: { api: this.api, crypto: ie.crypto, chunks: this.chunks, merkle: this.merkle, deepHash: this.deepHash }
    });
  }
  get utils() {
    return ei.utils;
  }
  getConfig() {
    return this.config;
  }
  async createTransaction(ie, se) {
    const fe = {};
    if (Object.assign(fe, ie), !ie.data && !(ie.target && ie.quantity))
      throw new Error("A new Arweave transaction must have a 'data' value, or 'target' and 'quantity' values.");
    if (ie.owner == null && se && se !== "use_wallet" && (fe.owner = se.n), ie.last_tx == null && (fe.last_tx = await this.transactions.getTransactionAnchor()), typeof ie.data == "string" && (ie.data = stringToBuffer(ie.data)), ie.data instanceof ArrayBuffer && (ie.data = new Uint8Array(ie.data)), ie.data && !(ie.data instanceof Uint8Array))
      throw new Error("Expected data to be a string, Uint8Array or ArrayBuffer");
    if (ie.reward == null) {
      const ce = ie.data ? ie.data.byteLength : 0;
      fe.reward = await this.transactions.getPrice(ce, fe.target);
    }
    fe.data_root = "", fe.data_size = ie.data ? ie.data.byteLength.toString() : "0", fe.data = ie.data || new Uint8Array(0);
    const ue = new Transaction$1({
      attributes: fe,
      deps: { merkle: this.merkle, deepHash: this.deepHash }
    });
    return await ue.getSignatureData(), ue;
  }
};
const Arweave$2 = Arweave$1;
class Arweave extends Arweave$1 {
  /**
   * Constructor for a new `Arweave` instance - this one uses the web crypto driver
   * @param gatways - Specify the Arweave gateway(s) you want to use for requests
   * @param options - Other configuration options
   * @param options.miners - A list of Arweave miners (peers) to use for requests
   * @param options.gateways - A list of Arweave miners (peers) to use for requests
   */
  constructor(ie, se) {
    super({ crypto: se?.crypto ?? new WebCryptoDriver(), ...se, gateways: ie ?? "https://arweave.net" });
  }
  static init(ie) {
    return new Arweave(ie);
  }
}
const driver = WebCryptoDriver.default ? WebCryptoDriver.default : WebCryptoDriver;
class CryptoDriver extends driver {
  getPublicKey(ie) {
    throw new Error("Unimplemented");
  }
}
let driverInstance;
function getCryptoDriver() {
  return driverInstance ??= new CryptoDriver();
}
class Rsa4096Pss {
  _key;
  pk;
  signatureType = 1;
  ownerLength = SIG_CONFIG[1].pubLength;
  signatureLength = SIG_CONFIG[1].sigLength;
  _publicKey;
  get publicKey() {
    return this._publicKey;
  }
  constructor(ie, se) {
    this._key = ie, this.pk = se, se || (this.pk = getCryptoDriver().getPublicKey(JSON.parse(ie)));
  }
  sign(ie) {
    return cryptoBrowserifyExports.createSign("sha256").update(ie).sign({
      key: this._key,
      padding: cryptoBrowserifyExports.constants.RSA_PKCS1_PSS_PADDING
    });
  }
  static async verify(ie, se, fe) {
    return await getCryptoDriver().verify(Buffer$F.isBuffer(ie) ? base64url.encode(ie) : ie, se, fe);
  }
}
const define$1 = api$1.define, RSAPublicKey = define$1("RSAPublicKey", function() {
  this.seq().obj(this.key("n").int(), this.key("e").int());
}), AlgorithmIdentifier = define$1("AlgorithmIdentifier", function() {
  this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional().any());
});
define$1("PublicKeyInfo", function() {
  this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("publicKey").bitstr());
});
const Version = define$1("Version", function() {
  this.int({
    0: "two-prime",
    1: "multi"
  });
}), OtherPrimeInfos = define$1("OtherPrimeInfos", function() {
  this.seq().obj(this.key("ri").int(), this.key("di").int(), this.key("ti").int());
}), RSAPrivateKey = define$1("RSAPrivateKey", function() {
  this.seq().obj(this.key("version").use(Version), this.key("n").int(), this.key("e").int(), this.key("d").int(), this.key("p").int(), this.key("q").int(), this.key("dp").int(), this.key("dq").int(), this.key("qi").int(), this.key("other").optional().use(OtherPrimeInfos));
});
define$1("PrivateKeyInfo", function() {
  this.seq().obj(this.key("version").use(Version), this.key("algorithm").use(AlgorithmIdentifier), this.key("privateKey").bitstr());
});
function parse$1(ae) {
  return {
    n: string2bn(ae.n),
    e: string2bn(ae.e),
    d: ae.d && string2bn(ae.d),
    p: ae.p && string2bn(ae.p),
    q: ae.q && string2bn(ae.q),
    dp: ae.dp && string2bn(ae.dp),
    dq: ae.dq && string2bn(ae.dq),
    qi: ae.qi && string2bn(ae.qi)
  };
}
function base64url2bn(ae) {
  return new BN$d(Buffer$F.from(ae, "base64"));
}
function string2bn(ae) {
  return /^[0-9]+$/.test(ae) ? new BN$d(ae, 10) : base64url2bn(ae);
}
function jwkTopem(ae) {
  const ie = parse$1(ae), se = !!ie.d, fe = se ? "PRIVATE" : "PUBLIC", ue = "-----BEGIN RSA " + fe + ` KEY-----
`, ce = `
-----END RSA ` + fe + ` KEY-----
`;
  let de = Buffer$F.alloc(0);
  se ? (ie.version = "two-prime", de = RSAPrivateKey.encode(ie, "der")) : de = RSAPublicKey.encode(ie, "der");
  const me = de.toString("base64").match(/.{1,64}/g).join(`
`);
  return ue + me + ce;
}
class ArweaveSigner extends Rsa4096Pss {
  jwk;
  constructor(ie) {
    super(jwkTopem(ie), ie.n), this.jwk = ie;
  }
  get publicKey() {
    if (!this.pk)
      throw new Error("ArweaveSigner - pk is undefined");
    return base64url.toBuffer(this.pk);
  }
  sign(ie) {
    return getCryptoDriver().sign(this.jwk, ie);
  }
  static async verify(ie, se, fe) {
    return await getCryptoDriver().verify(ie, se, fe);
  }
}
class InjectedSolanaSigner {
  _publicKey;
  ownerLength = SIG_CONFIG[2].pubLength;
  signatureLength = SIG_CONFIG[2].sigLength;
  signatureType = 2;
  pem;
  provider;
  constructor(ie) {
    if (this.provider = ie, !this.provider.publicKey)
      throw new Error("InjectedSolanaSigner - provider.publicKey is undefined");
    this._publicKey = this.provider.publicKey.toBuffer();
  }
  get publicKey() {
    return this._publicKey;
  }
  async sign(ie) {
    if (!this.provider.signMessage)
      throw new Error("Selected Wallet does not support message signing");
    return await this.provider.signMessage(ie);
  }
  static async verify(ie, se, fe) {
    let ue = ie;
    return typeof ie == "string" && (ue = base64url.toBuffer(ie)), verify$1(Buffer$F.from(fe), Buffer$F.from(se), Buffer$F.from(ue));
  }
}
var sha3$1 = { exports: {} };
(function(ae) {
  (function() {
    var ie = "input is invalid type", se = "finalize already called", fe = typeof window == "object", ue = fe ? window : {};
    ue.JS_SHA3_NO_WINDOW && (fe = !1);
    var ce = !fe && typeof self == "object", de = !ue.JS_SHA3_NO_NODE_JS && typeof process$1 == "object" && process$1.versions && process$1.versions.node;
    de ? ue = commonjsGlobal : ce && (ue = self);
    var me = !ue.JS_SHA3_NO_COMMON_JS && !0 && ae.exports, we = !ue.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", Ee = "0123456789abcdef".split(""), Se = [31, 7936, 2031616, 520093696], Be = [4, 1024, 262144, 67108864], Ce = [1, 256, 65536, 16777216], Ie = [6, 1536, 393216, 100663296], Pe = [0, 8, 16, 24], Ne = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ], ke = [224, 256, 384, 512], He = [128, 256], De = ["hex", "buffer", "arrayBuffer", "array", "digest"], Ge = {
      128: 168,
      256: 136
    };
    (ue.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(Te) {
      return Object.prototype.toString.call(Te) === "[object Array]";
    }), we && (ue.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(Te) {
      return typeof Te == "object" && Te.buffer && Te.buffer.constructor === ArrayBuffer;
    });
    for (var Ye = function(Te, Fe, je) {
      return function(ct) {
        return new Me(Te, Fe, Te).update(ct)[je]();
      };
    }, st = function(Te, Fe, je) {
      return function(ct, nt) {
        return new Me(Te, Fe, nt).update(ct)[je]();
      };
    }, at = function(Te, Fe, je) {
      return function(ct, nt, dt, it) {
        return ge["cshake" + Te].update(ct, nt, dt, it)[je]();
      };
    }, mt = function(Te, Fe, je) {
      return function(ct, nt, dt, it) {
        return ge["kmac" + Te].update(ct, nt, dt, it)[je]();
      };
    }, qe = function(Te, Fe, je, ct) {
      for (var nt = 0; nt < De.length; ++nt) {
        var dt = De[nt];
        Te[dt] = Fe(je, ct, dt);
      }
      return Te;
    }, ze = function(Te, Fe) {
      var je = Ye(Te, Fe, "hex");
      return je.create = function() {
        return new Me(Te, Fe, Te);
      }, je.update = function(ct) {
        return je.create().update(ct);
      }, qe(je, Ye, Te, Fe);
    }, ot = function(Te, Fe) {
      var je = st(Te, Fe, "hex");
      return je.create = function(ct) {
        return new Me(Te, Fe, ct);
      }, je.update = function(ct, nt) {
        return je.create(nt).update(ct);
      }, qe(je, st, Te, Fe);
    }, $e = function(Te, Fe) {
      var je = Ge[Te], ct = at(Te, Fe, "hex");
      return ct.create = function(nt, dt, it) {
        return !dt && !it ? ge["shake" + Te].create(nt) : new Me(Te, Fe, nt).bytepad([dt, it], je);
      }, ct.update = function(nt, dt, it, Je) {
        return ct.create(dt, it, Je).update(nt);
      }, qe(ct, at, Te, Fe);
    }, le = function(Te, Fe) {
      var je = Ge[Te], ct = mt(Te, Fe, "hex");
      return ct.create = function(nt, dt, it) {
        return new Re(Te, Fe, dt).bytepad(["KMAC", it], je).bytepad([nt], je);
      }, ct.update = function(nt, dt, it, Je) {
        return ct.create(nt, it, Je).update(dt);
      }, qe(ct, mt, Te, Fe);
    }, pe = [
      { name: "keccak", padding: Ce, bits: ke, createMethod: ze },
      { name: "sha3", padding: Ie, bits: ke, createMethod: ze },
      { name: "shake", padding: Se, bits: He, createMethod: ot },
      { name: "cshake", padding: Be, bits: He, createMethod: $e },
      { name: "kmac", padding: Be, bits: He, createMethod: le }
    ], ge = {}, ye = [], xe = 0; xe < pe.length; ++xe)
      for (var _e = pe[xe], Ae = _e.bits, ve = 0; ve < Ae.length; ++ve) {
        var he = _e.name + "_" + Ae[ve];
        if (ye.push(he), ge[he] = _e.createMethod(Ae[ve], _e.padding), _e.name !== "sha3") {
          var be = _e.name + Ae[ve];
          ye.push(be), ge[be] = ge[he];
        }
      }
    function Me(Te, Fe, je) {
      this.blocks = [], this.s = [], this.padding = Fe, this.outputBits = je, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (Te << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = je >> 5, this.extraBytes = (je & 31) >> 3;
      for (var ct = 0; ct < 50; ++ct)
        this.s[ct] = 0;
    }
    Me.prototype.update = function(Te) {
      if (this.finalized)
        throw new Error(se);
      var Fe, je = typeof Te;
      if (je !== "string") {
        if (je === "object") {
          if (Te === null)
            throw new Error(ie);
          if (we && Te.constructor === ArrayBuffer)
            Te = new Uint8Array(Te);
          else if (!Array.isArray(Te) && (!we || !ArrayBuffer.isView(Te)))
            throw new Error(ie);
        } else
          throw new Error(ie);
        Fe = !0;
      }
      for (var ct = this.blocks, nt = this.byteCount, dt = Te.length, it = this.blockCount, Je = 0, gt = this.s, Ht, $t; Je < dt; ) {
        if (this.reset)
          for (this.reset = !1, ct[0] = this.block, Ht = 1; Ht < it + 1; ++Ht)
            ct[Ht] = 0;
        if (Fe)
          for (Ht = this.start; Je < dt && Ht < nt; ++Je)
            ct[Ht >> 2] |= Te[Je] << Pe[Ht++ & 3];
        else
          for (Ht = this.start; Je < dt && Ht < nt; ++Je)
            $t = Te.charCodeAt(Je), $t < 128 ? ct[Ht >> 2] |= $t << Pe[Ht++ & 3] : $t < 2048 ? (ct[Ht >> 2] |= (192 | $t >> 6) << Pe[Ht++ & 3], ct[Ht >> 2] |= (128 | $t & 63) << Pe[Ht++ & 3]) : $t < 55296 || $t >= 57344 ? (ct[Ht >> 2] |= (224 | $t >> 12) << Pe[Ht++ & 3], ct[Ht >> 2] |= (128 | $t >> 6 & 63) << Pe[Ht++ & 3], ct[Ht >> 2] |= (128 | $t & 63) << Pe[Ht++ & 3]) : ($t = 65536 + (($t & 1023) << 10 | Te.charCodeAt(++Je) & 1023), ct[Ht >> 2] |= (240 | $t >> 18) << Pe[Ht++ & 3], ct[Ht >> 2] |= (128 | $t >> 12 & 63) << Pe[Ht++ & 3], ct[Ht >> 2] |= (128 | $t >> 6 & 63) << Pe[Ht++ & 3], ct[Ht >> 2] |= (128 | $t & 63) << Pe[Ht++ & 3]);
        if (this.lastByteIndex = Ht, Ht >= nt) {
          for (this.start = Ht - nt, this.block = ct[it], Ht = 0; Ht < it; ++Ht)
            gt[Ht] ^= ct[Ht];
          Oe(gt), this.reset = !0;
        } else
          this.start = Ht;
      }
      return this;
    }, Me.prototype.encode = function(Te, Fe) {
      var je = Te & 255, ct = 1, nt = [je];
      for (Te = Te >> 8, je = Te & 255; je > 0; )
        nt.unshift(je), Te = Te >> 8, je = Te & 255, ++ct;
      return Fe ? nt.push(ct) : nt.unshift(ct), this.update(nt), nt.length;
    }, Me.prototype.encodeString = function(Te) {
      var Fe, je = typeof Te;
      if (je !== "string") {
        if (je === "object") {
          if (Te === null)
            throw new Error(ie);
          if (we && Te.constructor === ArrayBuffer)
            Te = new Uint8Array(Te);
          else if (!Array.isArray(Te) && (!we || !ArrayBuffer.isView(Te)))
            throw new Error(ie);
        } else
          throw new Error(ie);
        Fe = !0;
      }
      var ct = 0, nt = Te.length;
      if (Fe)
        ct = nt;
      else
        for (var dt = 0; dt < Te.length; ++dt) {
          var it = Te.charCodeAt(dt);
          it < 128 ? ct += 1 : it < 2048 ? ct += 2 : it < 55296 || it >= 57344 ? ct += 3 : (it = 65536 + ((it & 1023) << 10 | Te.charCodeAt(++dt) & 1023), ct += 4);
        }
      return ct += this.encode(ct * 8), this.update(Te), ct;
    }, Me.prototype.bytepad = function(Te, Fe) {
      for (var je = this.encode(Fe), ct = 0; ct < Te.length; ++ct)
        je += this.encodeString(Te[ct]);
      var nt = Fe - je % Fe, dt = [];
      return dt.length = nt, this.update(dt), this;
    }, Me.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var Te = this.blocks, Fe = this.lastByteIndex, je = this.blockCount, ct = this.s;
        if (Te[Fe >> 2] |= this.padding[Fe & 3], this.lastByteIndex === this.byteCount)
          for (Te[0] = Te[je], Fe = 1; Fe < je + 1; ++Fe)
            Te[Fe] = 0;
        for (Te[je - 1] |= 2147483648, Fe = 0; Fe < je; ++Fe)
          ct[Fe] ^= Te[Fe];
        Oe(ct);
      }
    }, Me.prototype.toString = Me.prototype.hex = function() {
      this.finalize();
      for (var Te = this.blockCount, Fe = this.s, je = this.outputBlocks, ct = this.extraBytes, nt = 0, dt = 0, it = "", Je; dt < je; ) {
        for (nt = 0; nt < Te && dt < je; ++nt, ++dt)
          Je = Fe[nt], it += Ee[Je >> 4 & 15] + Ee[Je & 15] + Ee[Je >> 12 & 15] + Ee[Je >> 8 & 15] + Ee[Je >> 20 & 15] + Ee[Je >> 16 & 15] + Ee[Je >> 28 & 15] + Ee[Je >> 24 & 15];
        dt % Te === 0 && (Oe(Fe), nt = 0);
      }
      return ct && (Je = Fe[nt], it += Ee[Je >> 4 & 15] + Ee[Je & 15], ct > 1 && (it += Ee[Je >> 12 & 15] + Ee[Je >> 8 & 15]), ct > 2 && (it += Ee[Je >> 20 & 15] + Ee[Je >> 16 & 15])), it;
    }, Me.prototype.arrayBuffer = function() {
      this.finalize();
      var Te = this.blockCount, Fe = this.s, je = this.outputBlocks, ct = this.extraBytes, nt = 0, dt = 0, it = this.outputBits >> 3, Je;
      ct ? Je = new ArrayBuffer(je + 1 << 2) : Je = new ArrayBuffer(it);
      for (var gt = new Uint32Array(Je); dt < je; ) {
        for (nt = 0; nt < Te && dt < je; ++nt, ++dt)
          gt[dt] = Fe[nt];
        dt % Te === 0 && Oe(Fe);
      }
      return ct && (gt[nt] = Fe[nt], Je = Je.slice(0, it)), Je;
    }, Me.prototype.buffer = Me.prototype.arrayBuffer, Me.prototype.digest = Me.prototype.array = function() {
      this.finalize();
      for (var Te = this.blockCount, Fe = this.s, je = this.outputBlocks, ct = this.extraBytes, nt = 0, dt = 0, it = [], Je, gt; dt < je; ) {
        for (nt = 0; nt < Te && dt < je; ++nt, ++dt)
          Je = dt << 2, gt = Fe[nt], it[Je] = gt & 255, it[Je + 1] = gt >> 8 & 255, it[Je + 2] = gt >> 16 & 255, it[Je + 3] = gt >> 24 & 255;
        dt % Te === 0 && Oe(Fe);
      }
      return ct && (Je = dt << 2, gt = Fe[nt], it[Je] = gt & 255, ct > 1 && (it[Je + 1] = gt >> 8 & 255), ct > 2 && (it[Je + 2] = gt >> 16 & 255)), it;
    };
    function Re(Te, Fe, je) {
      Me.call(this, Te, Fe, je);
    }
    Re.prototype = new Me(), Re.prototype.finalize = function() {
      return this.encode(this.outputBits, !0), Me.prototype.finalize.call(this);
    };
    var Oe = function(Te) {
      var Fe, je, ct, nt, dt, it, Je, gt, Ht, $t, Lt, Tr, Zt, wt, Hr, tr, cr, qr, Wt, ar, Dr, Jt, ir, Gr, We, Le, Ke, rt, lt, It, yt, jt, Lr, zt, rr, Cr, fr, pr, jr, nr, ur, Wr, or, lr, Zr, Xt, dr, Ve, Ze, Xe, Ue, Qe, pt, Ct, bt, Tt, br, gr, Fr, wr, Rr, kr, Pr;
      for (ct = 0; ct < 48; ct += 2)
        nt = Te[0] ^ Te[10] ^ Te[20] ^ Te[30] ^ Te[40], dt = Te[1] ^ Te[11] ^ Te[21] ^ Te[31] ^ Te[41], it = Te[2] ^ Te[12] ^ Te[22] ^ Te[32] ^ Te[42], Je = Te[3] ^ Te[13] ^ Te[23] ^ Te[33] ^ Te[43], gt = Te[4] ^ Te[14] ^ Te[24] ^ Te[34] ^ Te[44], Ht = Te[5] ^ Te[15] ^ Te[25] ^ Te[35] ^ Te[45], $t = Te[6] ^ Te[16] ^ Te[26] ^ Te[36] ^ Te[46], Lt = Te[7] ^ Te[17] ^ Te[27] ^ Te[37] ^ Te[47], Tr = Te[8] ^ Te[18] ^ Te[28] ^ Te[38] ^ Te[48], Zt = Te[9] ^ Te[19] ^ Te[29] ^ Te[39] ^ Te[49], Fe = Tr ^ (it << 1 | Je >>> 31), je = Zt ^ (Je << 1 | it >>> 31), Te[0] ^= Fe, Te[1] ^= je, Te[10] ^= Fe, Te[11] ^= je, Te[20] ^= Fe, Te[21] ^= je, Te[30] ^= Fe, Te[31] ^= je, Te[40] ^= Fe, Te[41] ^= je, Fe = nt ^ (gt << 1 | Ht >>> 31), je = dt ^ (Ht << 1 | gt >>> 31), Te[2] ^= Fe, Te[3] ^= je, Te[12] ^= Fe, Te[13] ^= je, Te[22] ^= Fe, Te[23] ^= je, Te[32] ^= Fe, Te[33] ^= je, Te[42] ^= Fe, Te[43] ^= je, Fe = it ^ ($t << 1 | Lt >>> 31), je = Je ^ (Lt << 1 | $t >>> 31), Te[4] ^= Fe, Te[5] ^= je, Te[14] ^= Fe, Te[15] ^= je, Te[24] ^= Fe, Te[25] ^= je, Te[34] ^= Fe, Te[35] ^= je, Te[44] ^= Fe, Te[45] ^= je, Fe = gt ^ (Tr << 1 | Zt >>> 31), je = Ht ^ (Zt << 1 | Tr >>> 31), Te[6] ^= Fe, Te[7] ^= je, Te[16] ^= Fe, Te[17] ^= je, Te[26] ^= Fe, Te[27] ^= je, Te[36] ^= Fe, Te[37] ^= je, Te[46] ^= Fe, Te[47] ^= je, Fe = $t ^ (nt << 1 | dt >>> 31), je = Lt ^ (dt << 1 | nt >>> 31), Te[8] ^= Fe, Te[9] ^= je, Te[18] ^= Fe, Te[19] ^= je, Te[28] ^= Fe, Te[29] ^= je, Te[38] ^= Fe, Te[39] ^= je, Te[48] ^= Fe, Te[49] ^= je, wt = Te[0], Hr = Te[1], Xt = Te[11] << 4 | Te[10] >>> 28, dr = Te[10] << 4 | Te[11] >>> 28, rt = Te[20] << 3 | Te[21] >>> 29, lt = Te[21] << 3 | Te[20] >>> 29, wr = Te[31] << 9 | Te[30] >>> 23, Rr = Te[30] << 9 | Te[31] >>> 23, Wr = Te[40] << 18 | Te[41] >>> 14, or = Te[41] << 18 | Te[40] >>> 14, zt = Te[2] << 1 | Te[3] >>> 31, rr = Te[3] << 1 | Te[2] >>> 31, tr = Te[13] << 12 | Te[12] >>> 20, cr = Te[12] << 12 | Te[13] >>> 20, Ve = Te[22] << 10 | Te[23] >>> 22, Ze = Te[23] << 10 | Te[22] >>> 22, It = Te[33] << 13 | Te[32] >>> 19, yt = Te[32] << 13 | Te[33] >>> 19, kr = Te[42] << 2 | Te[43] >>> 30, Pr = Te[43] << 2 | Te[42] >>> 30, Ct = Te[5] << 30 | Te[4] >>> 2, bt = Te[4] << 30 | Te[5] >>> 2, Cr = Te[14] << 6 | Te[15] >>> 26, fr = Te[15] << 6 | Te[14] >>> 26, qr = Te[25] << 11 | Te[24] >>> 21, Wt = Te[24] << 11 | Te[25] >>> 21, Xe = Te[34] << 15 | Te[35] >>> 17, Ue = Te[35] << 15 | Te[34] >>> 17, jt = Te[45] << 29 | Te[44] >>> 3, Lr = Te[44] << 29 | Te[45] >>> 3, Gr = Te[6] << 28 | Te[7] >>> 4, We = Te[7] << 28 | Te[6] >>> 4, Tt = Te[17] << 23 | Te[16] >>> 9, br = Te[16] << 23 | Te[17] >>> 9, pr = Te[26] << 25 | Te[27] >>> 7, jr = Te[27] << 25 | Te[26] >>> 7, ar = Te[36] << 21 | Te[37] >>> 11, Dr = Te[37] << 21 | Te[36] >>> 11, Qe = Te[47] << 24 | Te[46] >>> 8, pt = Te[46] << 24 | Te[47] >>> 8, lr = Te[8] << 27 | Te[9] >>> 5, Zr = Te[9] << 27 | Te[8] >>> 5, Le = Te[18] << 20 | Te[19] >>> 12, Ke = Te[19] << 20 | Te[18] >>> 12, gr = Te[29] << 7 | Te[28] >>> 25, Fr = Te[28] << 7 | Te[29] >>> 25, nr = Te[38] << 8 | Te[39] >>> 24, ur = Te[39] << 8 | Te[38] >>> 24, Jt = Te[48] << 14 | Te[49] >>> 18, ir = Te[49] << 14 | Te[48] >>> 18, Te[0] = wt ^ ~tr & qr, Te[1] = Hr ^ ~cr & Wt, Te[10] = Gr ^ ~Le & rt, Te[11] = We ^ ~Ke & lt, Te[20] = zt ^ ~Cr & pr, Te[21] = rr ^ ~fr & jr, Te[30] = lr ^ ~Xt & Ve, Te[31] = Zr ^ ~dr & Ze, Te[40] = Ct ^ ~Tt & gr, Te[41] = bt ^ ~br & Fr, Te[2] = tr ^ ~qr & ar, Te[3] = cr ^ ~Wt & Dr, Te[12] = Le ^ ~rt & It, Te[13] = Ke ^ ~lt & yt, Te[22] = Cr ^ ~pr & nr, Te[23] = fr ^ ~jr & ur, Te[32] = Xt ^ ~Ve & Xe, Te[33] = dr ^ ~Ze & Ue, Te[42] = Tt ^ ~gr & wr, Te[43] = br ^ ~Fr & Rr, Te[4] = qr ^ ~ar & Jt, Te[5] = Wt ^ ~Dr & ir, Te[14] = rt ^ ~It & jt, Te[15] = lt ^ ~yt & Lr, Te[24] = pr ^ ~nr & Wr, Te[25] = jr ^ ~ur & or, Te[34] = Ve ^ ~Xe & Qe, Te[35] = Ze ^ ~Ue & pt, Te[44] = gr ^ ~wr & kr, Te[45] = Fr ^ ~Rr & Pr, Te[6] = ar ^ ~Jt & wt, Te[7] = Dr ^ ~ir & Hr, Te[16] = It ^ ~jt & Gr, Te[17] = yt ^ ~Lr & We, Te[26] = nr ^ ~Wr & zt, Te[27] = ur ^ ~or & rr, Te[36] = Xe ^ ~Qe & lr, Te[37] = Ue ^ ~pt & Zr, Te[46] = wr ^ ~kr & Ct, Te[47] = Rr ^ ~Pr & bt, Te[8] = Jt ^ ~wt & tr, Te[9] = ir ^ ~Hr & cr, Te[18] = jt ^ ~Gr & Le, Te[19] = Lr ^ ~We & Ke, Te[28] = Wr ^ ~zt & Cr, Te[29] = or ^ ~rr & fr, Te[38] = Qe ^ ~lr & Xt, Te[39] = pt ^ ~Zr & dr, Te[48] = kr ^ ~Ct & Tt, Te[49] = Pr ^ ~bt & br, Te[0] ^= Ne[ct], Te[1] ^= Ne[ct + 1];
    };
    if (me)
      ae.exports = ge;
    else
      for (xe = 0; xe < ye.length; ++xe)
        ue[ye[xe]] = ge[ye[xe]];
  })();
})(sha3$1);
var sha3Exports = sha3$1.exports;
const sha3 = /* @__PURE__ */ getDefaultExportFromCjs$2(sha3Exports), version$k = "logger/5.7.0";
let _permanentCensorErrors = !1, _censorErrors = !1;
const LogLevels = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels.default, _globalLogger = null;
function _checkNormalize() {
  try {
    const ae = [];
    if (["NFD", "NFC", "NFKD", "NFKC"].forEach((ie) => {
      try {
        if ("test".normalize(ie) !== "test")
          throw new Error("bad normalize");
      } catch {
        ae.push(ie);
      }
    }), ae.length)
      throw new Error("missing " + ae.join(", "));
    if ("".normalize("NFD") !== "e")
      throw new Error("broken implementation");
  } catch (ae) {
    return ae.message;
  }
  return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function(ae) {
  ae.DEBUG = "DEBUG", ae.INFO = "INFO", ae.WARNING = "WARNING", ae.ERROR = "ERROR", ae.OFF = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(ae) {
  ae.UNKNOWN_ERROR = "UNKNOWN_ERROR", ae.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", ae.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", ae.NETWORK_ERROR = "NETWORK_ERROR", ae.SERVER_ERROR = "SERVER_ERROR", ae.TIMEOUT = "TIMEOUT", ae.BUFFER_OVERRUN = "BUFFER_OVERRUN", ae.NUMERIC_FAULT = "NUMERIC_FAULT", ae.MISSING_NEW = "MISSING_NEW", ae.INVALID_ARGUMENT = "INVALID_ARGUMENT", ae.MISSING_ARGUMENT = "MISSING_ARGUMENT", ae.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", ae.CALL_EXCEPTION = "CALL_EXCEPTION", ae.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", ae.NONCE_EXPIRED = "NONCE_EXPIRED", ae.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", ae.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", ae.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", ae.ACTION_REJECTED = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
const HEX = "0123456789abcdef";
class Logger {
  constructor(ie) {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      value: ie,
      writable: !1
    });
  }
  _log(ie, se) {
    const fe = ie.toLowerCase();
    LogLevels[fe] == null && this.throwArgumentError("invalid log level name", "logLevel", ie), !(_logLevel > LogLevels[fe]) && console.log.apply(console, se);
  }
  debug(...ie) {
    this._log(Logger.levels.DEBUG, ie);
  }
  info(...ie) {
    this._log(Logger.levels.INFO, ie);
  }
  warn(...ie) {
    this._log(Logger.levels.WARNING, ie);
  }
  makeError(ie, se, fe) {
    if (_censorErrors)
      return this.makeError("censored error", se, {});
    se || (se = Logger.errors.UNKNOWN_ERROR), fe || (fe = {});
    const ue = [];
    Object.keys(fe).forEach((we) => {
      const Ee = fe[we];
      try {
        if (Ee instanceof Uint8Array) {
          let Se = "";
          for (let Be = 0; Be < Ee.length; Be++)
            Se += HEX[Ee[Be] >> 4], Se += HEX[Ee[Be] & 15];
          ue.push(we + "=Uint8Array(0x" + Se + ")");
        } else
          ue.push(we + "=" + JSON.stringify(Ee));
      } catch {
        ue.push(we + "=" + JSON.stringify(fe[we].toString()));
      }
    }), ue.push(`code=${se}`), ue.push(`version=${this.version}`);
    const ce = ie;
    let de = "";
    switch (se) {
      case ErrorCode.NUMERIC_FAULT: {
        de = "NUMERIC_FAULT";
        const we = ie;
        switch (we) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            de += "-" + we;
            break;
          case "negative-power":
          case "negative-width":
            de += "-unsupported";
            break;
          case "unbound-bitwise-result":
            de += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        de = se;
        break;
    }
    de && (ie += " [ See: https://links.ethers.org/v5-errors-" + de + " ]"), ue.length && (ie += " (" + ue.join(", ") + ")");
    const me = new Error(ie);
    return me.reason = ce, me.code = se, Object.keys(fe).forEach(function(we) {
      me[we] = fe[we];
    }), me;
  }
  throwError(ie, se, fe) {
    throw this.makeError(ie, se, fe);
  }
  throwArgumentError(ie, se, fe) {
    return this.throwError(ie, Logger.errors.INVALID_ARGUMENT, {
      argument: se,
      value: fe
    });
  }
  assert(ie, se, fe, ue) {
    ie || this.throwError(se, fe, ue);
  }
  assertArgument(ie, se, fe, ue) {
    ie || this.throwArgumentError(se, fe, ue);
  }
  checkNormalize(ie) {
    _normalizeError && this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "String.prototype.normalize",
      form: _normalizeError
    });
  }
  checkSafeUint53(ie, se) {
    typeof ie == "number" && (se == null && (se = "value not safe"), (ie < 0 || ie >= 9007199254740991) && this.throwError(se, Logger.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "out-of-safe-range",
      value: ie
    }), ie % 1 && this.throwError(se, Logger.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "non-integer",
      value: ie
    }));
  }
  checkArgumentCount(ie, se, fe) {
    fe ? fe = ": " + fe : fe = "", ie < se && this.throwError("missing argument" + fe, Logger.errors.MISSING_ARGUMENT, {
      count: ie,
      expectedCount: se
    }), ie > se && this.throwError("too many arguments" + fe, Logger.errors.UNEXPECTED_ARGUMENT, {
      count: ie,
      expectedCount: se
    });
  }
  checkNew(ie, se) {
    (ie === Object || ie == null) && this.throwError("missing new", Logger.errors.MISSING_NEW, { name: se.name });
  }
  checkAbstract(ie, se) {
    ie === se ? this.throwError("cannot instantiate abstract class " + JSON.stringify(se.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: ie.name, operation: "new" }) : (ie === Object || ie == null) && this.throwError("missing new", Logger.errors.MISSING_NEW, { name: se.name });
  }
  static globalLogger() {
    return _globalLogger || (_globalLogger = new Logger(version$k)), _globalLogger;
  }
  static setCensorship(ie, se) {
    if (!ie && se && this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setCensorship"
    }), _permanentCensorErrors) {
      if (!ie)
        return;
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!ie, _permanentCensorErrors = !!se;
  }
  static setLogLevel(ie) {
    const se = LogLevels[ie.toLowerCase()];
    if (se == null) {
      Logger.globalLogger().warn("invalid log level - " + ie);
      return;
    }
    _logLevel = se;
  }
  static from(ie) {
    return new Logger(ie);
  }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;
const version$j = "bytes/5.7.0", logger$n = new Logger(version$j);
function isHexable(ae) {
  return !!ae.toHexString;
}
function addSlice(ae) {
  return ae.slice || (ae.slice = function() {
    const ie = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(ae, ie)));
  }), ae;
}
function isBytesLike(ae) {
  return isHexString$1(ae) && !(ae.length % 2) || isBytes$4(ae);
}
function isInteger(ae) {
  return typeof ae == "number" && ae == ae && ae % 1 === 0;
}
function isBytes$4(ae) {
  if (ae == null)
    return !1;
  if (ae.constructor === Uint8Array)
    return !0;
  if (typeof ae == "string" || !isInteger(ae.length) || ae.length < 0)
    return !1;
  for (let ie = 0; ie < ae.length; ie++) {
    const se = ae[ie];
    if (!isInteger(se) || se < 0 || se >= 256)
      return !1;
  }
  return !0;
}
function arrayify(ae, ie) {
  if (ie || (ie = {}), typeof ae == "number") {
    logger$n.checkSafeUint53(ae, "invalid arrayify value");
    const se = [];
    for (; ae; )
      se.unshift(ae & 255), ae = parseInt(String(ae / 256));
    return se.length === 0 && se.push(0), addSlice(new Uint8Array(se));
  }
  if (ie.allowMissingPrefix && typeof ae == "string" && ae.substring(0, 2) !== "0x" && (ae = "0x" + ae), isHexable(ae) && (ae = ae.toHexString()), isHexString$1(ae)) {
    let se = ae.substring(2);
    se.length % 2 && (ie.hexPad === "left" ? se = "0" + se : ie.hexPad === "right" ? se += "0" : logger$n.throwArgumentError("hex data is odd-length", "value", ae));
    const fe = [];
    for (let ue = 0; ue < se.length; ue += 2)
      fe.push(parseInt(se.substring(ue, ue + 2), 16));
    return addSlice(new Uint8Array(fe));
  }
  return isBytes$4(ae) ? addSlice(new Uint8Array(ae)) : logger$n.throwArgumentError("invalid arrayify value", "value", ae);
}
function concat(ae) {
  const ie = ae.map((ue) => arrayify(ue)), se = ie.reduce((ue, ce) => ue + ce.length, 0), fe = new Uint8Array(se);
  return ie.reduce((ue, ce) => (fe.set(ce, ue), ue + ce.length), 0), addSlice(fe);
}
function stripZeros(ae) {
  let ie = arrayify(ae);
  if (ie.length === 0)
    return ie;
  let se = 0;
  for (; se < ie.length && ie[se] === 0; )
    se++;
  return se && (ie = ie.slice(se)), ie;
}
function zeroPad(ae, ie) {
  ae = arrayify(ae), ae.length > ie && logger$n.throwArgumentError("value out of range", "value", arguments[0]);
  const se = new Uint8Array(ie);
  return se.set(ae, ie - ae.length), addSlice(se);
}
function isHexString$1(ae, ie) {
  return !(typeof ae != "string" || !ae.match(/^0x[0-9A-Fa-f]*$/) || ie && ae.length !== 2 + 2 * ie);
}
const HexCharacters = "0123456789abcdef";
function hexlify(ae, ie) {
  if (ie || (ie = {}), typeof ae == "number") {
    logger$n.checkSafeUint53(ae, "invalid hexlify value");
    let se = "";
    for (; ae; )
      se = HexCharacters[ae & 15] + se, ae = Math.floor(ae / 16);
    return se.length ? (se.length % 2 && (se = "0" + se), "0x" + se) : "0x00";
  }
  if (typeof ae == "bigint")
    return ae = ae.toString(16), ae.length % 2 ? "0x0" + ae : "0x" + ae;
  if (ie.allowMissingPrefix && typeof ae == "string" && ae.substring(0, 2) !== "0x" && (ae = "0x" + ae), isHexable(ae))
    return ae.toHexString();
  if (isHexString$1(ae))
    return ae.length % 2 && (ie.hexPad === "left" ? ae = "0x0" + ae.substring(2) : ie.hexPad === "right" ? ae += "0" : logger$n.throwArgumentError("hex data is odd-length", "value", ae)), ae.toLowerCase();
  if (isBytes$4(ae)) {
    let se = "0x";
    for (let fe = 0; fe < ae.length; fe++) {
      let ue = ae[fe];
      se += HexCharacters[(ue & 240) >> 4] + HexCharacters[ue & 15];
    }
    return se;
  }
  return logger$n.throwArgumentError("invalid hexlify value", "value", ae);
}
function hexDataLength(ae) {
  if (typeof ae != "string")
    ae = hexlify(ae);
  else if (!isHexString$1(ae) || ae.length % 2)
    return null;
  return (ae.length - 2) / 2;
}
function hexDataSlice(ae, ie, se) {
  return typeof ae != "string" ? ae = hexlify(ae) : (!isHexString$1(ae) || ae.length % 2) && logger$n.throwArgumentError("invalid hexData", "value", ae), ie = 2 + 2 * ie, se != null ? "0x" + ae.substring(ie, 2 + 2 * se) : "0x" + ae.substring(ie);
}
function hexConcat(ae) {
  let ie = "0x";
  return ae.forEach((se) => {
    ie += hexlify(se).substring(2);
  }), ie;
}
function hexZeroPad(ae, ie) {
  for (typeof ae != "string" ? ae = hexlify(ae) : isHexString$1(ae) || logger$n.throwArgumentError("invalid hex string", "value", ae), ae.length > 2 * ie + 2 && logger$n.throwArgumentError("value out of range", "value", arguments[1]); ae.length < 2 * ie + 2; )
    ae = "0x0" + ae.substring(2);
  return ae;
}
function splitSignature(ae) {
  const ie = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(ae)) {
    let se = arrayify(ae);
    se.length === 64 ? (ie.v = 27 + (se[32] >> 7), se[32] &= 127, ie.r = hexlify(se.slice(0, 32)), ie.s = hexlify(se.slice(32, 64))) : se.length === 65 ? (ie.r = hexlify(se.slice(0, 32)), ie.s = hexlify(se.slice(32, 64)), ie.v = se[64]) : logger$n.throwArgumentError("invalid signature string", "signature", ae), ie.v < 27 && (ie.v === 0 || ie.v === 1 ? ie.v += 27 : logger$n.throwArgumentError("signature invalid v byte", "signature", ae)), ie.recoveryParam = 1 - ie.v % 2, ie.recoveryParam && (se[32] |= 128), ie._vs = hexlify(se.slice(32, 64));
  } else {
    if (ie.r = ae.r, ie.s = ae.s, ie.v = ae.v, ie.recoveryParam = ae.recoveryParam, ie._vs = ae._vs, ie._vs != null) {
      const ue = zeroPad(arrayify(ie._vs), 32);
      ie._vs = hexlify(ue);
      const ce = ue[0] >= 128 ? 1 : 0;
      ie.recoveryParam == null ? ie.recoveryParam = ce : ie.recoveryParam !== ce && logger$n.throwArgumentError("signature recoveryParam mismatch _vs", "signature", ae), ue[0] &= 127;
      const de = hexlify(ue);
      ie.s == null ? ie.s = de : ie.s !== de && logger$n.throwArgumentError("signature v mismatch _vs", "signature", ae);
    }
    if (ie.recoveryParam == null)
      ie.v == null ? logger$n.throwArgumentError("signature missing v and recoveryParam", "signature", ae) : ie.v === 0 || ie.v === 1 ? ie.recoveryParam = ie.v : ie.recoveryParam = 1 - ie.v % 2;
    else if (ie.v == null)
      ie.v = 27 + ie.recoveryParam;
    else {
      const ue = ie.v === 0 || ie.v === 1 ? ie.v : 1 - ie.v % 2;
      ie.recoveryParam !== ue && logger$n.throwArgumentError("signature recoveryParam mismatch v", "signature", ae);
    }
    ie.r == null || !isHexString$1(ie.r) ? logger$n.throwArgumentError("signature missing or invalid r", "signature", ae) : ie.r = hexZeroPad(ie.r, 32), ie.s == null || !isHexString$1(ie.s) ? logger$n.throwArgumentError("signature missing or invalid s", "signature", ae) : ie.s = hexZeroPad(ie.s, 32);
    const se = arrayify(ie.s);
    se[0] >= 128 && logger$n.throwArgumentError("signature s out of range", "signature", ae), ie.recoveryParam && (se[0] |= 128);
    const fe = hexlify(se);
    ie._vs && (isHexString$1(ie._vs) || logger$n.throwArgumentError("signature invalid _vs", "signature", ae), ie._vs = hexZeroPad(ie._vs, 32)), ie._vs == null ? ie._vs = fe : ie._vs !== fe && logger$n.throwArgumentError("signature _vs mismatch v and s", "signature", ae);
  }
  return ie.yParityAndS = ie._vs, ie.compact = ie.r + ie.yParityAndS.substring(2), ie;
}
function joinSignature(ae) {
  return ae = splitSignature(ae), hexlify(concat([
    ae.r,
    ae.s,
    ae.recoveryParam ? "0x1c" : "0x1b"
  ]));
}
function keccak256$1(ae) {
  return "0x" + sha3.keccak_256(arrayify(ae));
}
const version$i = "bignumber/5.7.0";
var BN$1 = BN$d.BN;
const logger$m = new Logger(version$i), _constructorGuard$2 = {}, MAX_SAFE = 9007199254740991;
let _warnedToStringRadix = !1;
class BigNumber {
  constructor(ie, se) {
    ie !== _constructorGuard$2 && logger$m.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new (BigNumber)"
    }), this._hex = se, this._isBigNumber = !0, Object.freeze(this);
  }
  fromTwos(ie) {
    return toBigNumber(toBN(this).fromTwos(ie));
  }
  toTwos(ie) {
    return toBigNumber(toBN(this).toTwos(ie));
  }
  abs() {
    return this._hex[0] === "-" ? BigNumber.from(this._hex.substring(1)) : this;
  }
  add(ie) {
    return toBigNumber(toBN(this).add(toBN(ie)));
  }
  sub(ie) {
    return toBigNumber(toBN(this).sub(toBN(ie)));
  }
  div(ie) {
    return BigNumber.from(ie).isZero() && throwFault("division-by-zero", "div"), toBigNumber(toBN(this).div(toBN(ie)));
  }
  mul(ie) {
    return toBigNumber(toBN(this).mul(toBN(ie)));
  }
  mod(ie) {
    const se = toBN(ie);
    return se.isNeg() && throwFault("division-by-zero", "mod"), toBigNumber(toBN(this).umod(se));
  }
  pow(ie) {
    const se = toBN(ie);
    return se.isNeg() && throwFault("negative-power", "pow"), toBigNumber(toBN(this).pow(se));
  }
  and(ie) {
    const se = toBN(ie);
    return (this.isNegative() || se.isNeg()) && throwFault("unbound-bitwise-result", "and"), toBigNumber(toBN(this).and(se));
  }
  or(ie) {
    const se = toBN(ie);
    return (this.isNegative() || se.isNeg()) && throwFault("unbound-bitwise-result", "or"), toBigNumber(toBN(this).or(se));
  }
  xor(ie) {
    const se = toBN(ie);
    return (this.isNegative() || se.isNeg()) && throwFault("unbound-bitwise-result", "xor"), toBigNumber(toBN(this).xor(se));
  }
  mask(ie) {
    return (this.isNegative() || ie < 0) && throwFault("negative-width", "mask"), toBigNumber(toBN(this).maskn(ie));
  }
  shl(ie) {
    return (this.isNegative() || ie < 0) && throwFault("negative-width", "shl"), toBigNumber(toBN(this).shln(ie));
  }
  shr(ie) {
    return (this.isNegative() || ie < 0) && throwFault("negative-width", "shr"), toBigNumber(toBN(this).shrn(ie));
  }
  eq(ie) {
    return toBN(this).eq(toBN(ie));
  }
  lt(ie) {
    return toBN(this).lt(toBN(ie));
  }
  lte(ie) {
    return toBN(this).lte(toBN(ie));
  }
  gt(ie) {
    return toBN(this).gt(toBN(ie));
  }
  gte(ie) {
    return toBN(this).gte(toBN(ie));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN(this).isZero();
  }
  toNumber() {
    try {
      return toBN(this).toNumber();
    } catch {
      throwFault("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch {
    }
    return logger$m.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    return arguments.length > 0 && (arguments[0] === 10 ? _warnedToStringRadix || (_warnedToStringRadix = !0, logger$m.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? logger$m.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {}) : logger$m.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {})), toBN(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(ie) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(ie) {
    if (ie instanceof BigNumber)
      return ie;
    if (typeof ie == "string")
      return ie.match(/^-?0x[0-9a-f]+$/i) ? new BigNumber(_constructorGuard$2, toHex(ie)) : ie.match(/^-?[0-9]+$/) ? new BigNumber(_constructorGuard$2, toHex(new BN$1(ie))) : logger$m.throwArgumentError("invalid BigNumber string", "value", ie);
    if (typeof ie == "number")
      return ie % 1 && throwFault("underflow", "BigNumber.from", ie), (ie >= MAX_SAFE || ie <= -MAX_SAFE) && throwFault("overflow", "BigNumber.from", ie), BigNumber.from(String(ie));
    const se = ie;
    if (typeof se == "bigint")
      return BigNumber.from(se.toString());
    if (isBytes$4(se))
      return BigNumber.from(hexlify(se));
    if (se)
      if (se.toHexString) {
        const fe = se.toHexString();
        if (typeof fe == "string")
          return BigNumber.from(fe);
      } else {
        let fe = se._hex;
        if (fe == null && se.type === "BigNumber" && (fe = se.hex), typeof fe == "string" && (isHexString$1(fe) || fe[0] === "-" && isHexString$1(fe.substring(1))))
          return BigNumber.from(fe);
      }
    return logger$m.throwArgumentError("invalid BigNumber value", "value", ie);
  }
  static isBigNumber(ie) {
    return !!(ie && ie._isBigNumber);
  }
}
function toHex(ae) {
  if (typeof ae != "string")
    return toHex(ae.toString(16));
  if (ae[0] === "-")
    return ae = ae.substring(1), ae[0] === "-" && logger$m.throwArgumentError("invalid hex", "value", ae), ae = toHex(ae), ae === "0x00" ? ae : "-" + ae;
  if (ae.substring(0, 2) !== "0x" && (ae = "0x" + ae), ae === "0x")
    return "0x00";
  for (ae.length % 2 && (ae = "0x0" + ae.substring(2)); ae.length > 4 && ae.substring(0, 4) === "0x00"; )
    ae = "0x" + ae.substring(4);
  return ae;
}
function toBigNumber(ae) {
  return BigNumber.from(toHex(ae));
}
function toBN(ae) {
  const ie = BigNumber.from(ae).toHexString();
  return ie[0] === "-" ? new BN$1("-" + ie.substring(3), 16) : new BN$1(ie.substring(2), 16);
}
function throwFault(ae, ie, se) {
  const fe = { fault: ae, operation: ie };
  return se != null && (fe.value = se), logger$m.throwError(ae, Logger.errors.NUMERIC_FAULT, fe);
}
function _base36To16(ae) {
  return new BN$1(ae, 36).toString(16);
}
const NegativeOne$1 = /* @__PURE__ */ BigNumber.from(-1), Zero$1 = /* @__PURE__ */ BigNumber.from(0), One$1 = /* @__PURE__ */ BigNumber.from(1), MaxUint256$1 = /* @__PURE__ */ BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), version$h = "strings/5.7.0", logger$l = new Logger(version$h);
var UnicodeNormalizationForm;
(function(ae) {
  ae.current = "", ae.NFC = "NFC", ae.NFD = "NFD", ae.NFKC = "NFKC", ae.NFKD = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(ae) {
  ae.UNEXPECTED_CONTINUE = "unexpected continuation byte", ae.BAD_PREFIX = "bad codepoint prefix", ae.OVERRUN = "string overrun", ae.MISSING_CONTINUE = "missing continuation byte", ae.OUT_OF_RANGE = "out of UTF-8 range", ae.UTF16_SURROGATE = "UTF-16 surrogate", ae.OVERLONG = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(ae, ie, se, fe, ue) {
  return logger$l.throwArgumentError(`invalid codepoint at offset ${ie}; ${ae}`, "bytes", se);
}
function ignoreFunc(ae, ie, se, fe, ue) {
  if (ae === Utf8ErrorReason.BAD_PREFIX || ae === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let ce = 0;
    for (let de = ie + 1; de < se.length && se[de] >> 6 === 2; de++)
      ce++;
    return ce;
  }
  return ae === Utf8ErrorReason.OVERRUN ? se.length - ie - 1 : 0;
}
function replaceFunc(ae, ie, se, fe, ue) {
  return ae === Utf8ErrorReason.OVERLONG ? (fe.push(ue), 0) : (fe.push(65533), ignoreFunc(ae, ie, se));
}
const Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(ae, ie) {
  ie == null && (ie = Utf8ErrorFuncs.error), ae = arrayify(ae);
  const se = [];
  let fe = 0;
  for (; fe < ae.length; ) {
    const ue = ae[fe++];
    if (!(ue >> 7)) {
      se.push(ue);
      continue;
    }
    let ce = null, de = null;
    if ((ue & 224) === 192)
      ce = 1, de = 127;
    else if ((ue & 240) === 224)
      ce = 2, de = 2047;
    else if ((ue & 248) === 240)
      ce = 3, de = 65535;
    else {
      (ue & 192) === 128 ? fe += ie(Utf8ErrorReason.UNEXPECTED_CONTINUE, fe - 1, ae, se) : fe += ie(Utf8ErrorReason.BAD_PREFIX, fe - 1, ae, se);
      continue;
    }
    if (fe - 1 + ce >= ae.length) {
      fe += ie(Utf8ErrorReason.OVERRUN, fe - 1, ae, se);
      continue;
    }
    let me = ue & (1 << 8 - ce - 1) - 1;
    for (let we = 0; we < ce; we++) {
      let Ee = ae[fe];
      if ((Ee & 192) != 128) {
        fe += ie(Utf8ErrorReason.MISSING_CONTINUE, fe, ae, se), me = null;
        break;
      }
      me = me << 6 | Ee & 63, fe++;
    }
    if (me !== null) {
      if (me > 1114111) {
        fe += ie(Utf8ErrorReason.OUT_OF_RANGE, fe - 1 - ce, ae, se, me);
        continue;
      }
      if (me >= 55296 && me <= 57343) {
        fe += ie(Utf8ErrorReason.UTF16_SURROGATE, fe - 1 - ce, ae, se, me);
        continue;
      }
      if (me <= de) {
        fe += ie(Utf8ErrorReason.OVERLONG, fe - 1 - ce, ae, se, me);
        continue;
      }
      se.push(me);
    }
  }
  return se;
}
function toUtf8Bytes(ae, ie = UnicodeNormalizationForm.current) {
  ie != UnicodeNormalizationForm.current && (logger$l.checkNormalize(), ae = ae.normalize(ie));
  let se = [];
  for (let fe = 0; fe < ae.length; fe++) {
    const ue = ae.charCodeAt(fe);
    if (ue < 128)
      se.push(ue);
    else if (ue < 2048)
      se.push(ue >> 6 | 192), se.push(ue & 63 | 128);
    else if ((ue & 64512) == 55296) {
      fe++;
      const ce = ae.charCodeAt(fe);
      if (fe >= ae.length || (ce & 64512) !== 56320)
        throw new Error("invalid utf-8 string");
      const de = 65536 + ((ue & 1023) << 10) + (ce & 1023);
      se.push(de >> 18 | 240), se.push(de >> 12 & 63 | 128), se.push(de >> 6 & 63 | 128), se.push(de & 63 | 128);
    } else
      se.push(ue >> 12 | 224), se.push(ue >> 6 & 63 | 128), se.push(ue & 63 | 128);
  }
  return arrayify(se);
}
function _toUtf8String(ae) {
  return ae.map((ie) => ie <= 65535 ? String.fromCharCode(ie) : (ie -= 65536, String.fromCharCode((ie >> 10 & 1023) + 55296, (ie & 1023) + 56320))).join("");
}
function toUtf8String(ae, ie) {
  return _toUtf8String(getUtf8CodePoints(ae, ie));
}
function id(ae) {
  return keccak256$1(toUtf8Bytes(ae));
}
const version$g = "hash/5.7.0", messagePrefix = `Ethereum Signed Message:
`;
function hashMessage(ae) {
  return typeof ae == "string" && (ae = toUtf8Bytes(ae)), keccak256$1(concat([
    toUtf8Bytes(messagePrefix),
    toUtf8Bytes(String(ae.length)),
    ae
  ]));
}
const version$f = "rlp/5.7.0", logger$k = new Logger(version$f);
function arrayifyInteger(ae) {
  const ie = [];
  for (; ae; )
    ie.unshift(ae & 255), ae >>= 8;
  return ie;
}
function _encode(ae) {
  if (Array.isArray(ae)) {
    let fe = [];
    if (ae.forEach(function(ce) {
      fe = fe.concat(_encode(ce));
    }), fe.length <= 55)
      return fe.unshift(192 + fe.length), fe;
    const ue = arrayifyInteger(fe.length);
    return ue.unshift(247 + ue.length), ue.concat(fe);
  }
  isBytesLike(ae) || logger$k.throwArgumentError("RLP object must be BytesLike", "object", ae);
  const ie = Array.prototype.slice.call(arrayify(ae));
  if (ie.length === 1 && ie[0] <= 127)
    return ie;
  if (ie.length <= 55)
    return ie.unshift(128 + ie.length), ie;
  const se = arrayifyInteger(ie.length);
  return se.unshift(183 + se.length), se.concat(ie);
}
function encode$2(ae) {
  return hexlify(_encode(ae));
}
const version$e = "address/5.7.0", logger$j = new Logger(version$e);
function getChecksumAddress(ae) {
  isHexString$1(ae, 20) || logger$j.throwArgumentError("invalid address", "address", ae), ae = ae.toLowerCase();
  const ie = ae.substring(2).split(""), se = new Uint8Array(40);
  for (let ue = 0; ue < 40; ue++)
    se[ue] = ie[ue].charCodeAt(0);
  const fe = arrayify(keccak256$1(se));
  for (let ue = 0; ue < 40; ue += 2)
    fe[ue >> 1] >> 4 >= 8 && (ie[ue] = ie[ue].toUpperCase()), (fe[ue >> 1] & 15) >= 8 && (ie[ue + 1] = ie[ue + 1].toUpperCase());
  return "0x" + ie.join("");
}
const MAX_SAFE_INTEGER = 9007199254740991;
function log10(ae) {
  return Math.log10 ? Math.log10(ae) : Math.log(ae) / Math.LN10;
}
const ibanLookup = {};
for (let ae = 0; ae < 10; ae++)
  ibanLookup[String(ae)] = String(ae);
for (let ae = 0; ae < 26; ae++)
  ibanLookup[String.fromCharCode(65 + ae)] = String(10 + ae);
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(ae) {
  ae = ae.toUpperCase(), ae = ae.substring(4) + ae.substring(0, 2) + "00";
  let ie = ae.split("").map((fe) => ibanLookup[fe]).join("");
  for (; ie.length >= safeDigits; ) {
    let fe = ie.substring(0, safeDigits);
    ie = parseInt(fe, 10) % 97 + ie.substring(fe.length);
  }
  let se = String(98 - parseInt(ie, 10) % 97);
  for (; se.length < 2; )
    se = "0" + se;
  return se;
}
function getAddress(ae) {
  let ie = null;
  if (typeof ae != "string" && logger$j.throwArgumentError("invalid address", "address", ae), ae.match(/^(0x)?[0-9a-fA-F]{40}$/))
    ae.substring(0, 2) !== "0x" && (ae = "0x" + ae), ie = getChecksumAddress(ae), ae.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && ie !== ae && logger$j.throwArgumentError("bad address checksum", "address", ae);
  else if (ae.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    for (ae.substring(2, 4) !== ibanChecksum(ae) && logger$j.throwArgumentError("bad icap checksum", "address", ae), ie = _base36To16(ae.substring(4)); ie.length < 40; )
      ie = "0" + ie;
    ie = getChecksumAddress("0x" + ie);
  } else
    logger$j.throwArgumentError("invalid address", "address", ae);
  return ie;
}
function getContractAddress(ae) {
  let ie = null;
  try {
    ie = getAddress(ae.from);
  } catch {
    logger$j.throwArgumentError("missing from address", "transaction", ae);
  }
  const se = stripZeros(arrayify(BigNumber.from(ae.nonce).toHexString()));
  return getAddress(hexDataSlice(keccak256$1(encode$2([ie, se])), 12));
}
const version$d = "properties/5.7.0";
var __awaiter$e = function(ae, ie, se, fe) {
  function ue(ce) {
    return ce instanceof se ? ce : new se(function(de) {
      de(ce);
    });
  }
  return new (se || (se = Promise))(function(ce, de) {
    function me(Se) {
      try {
        Ee(fe.next(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function we(Se) {
      try {
        Ee(fe.throw(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function Ee(Se) {
      Se.done ? ce(Se.value) : ue(Se.value).then(me, we);
    }
    Ee((fe = fe.apply(ae, ie || [])).next());
  });
};
const logger$i = new Logger(version$d);
function defineReadOnly(ae, ie, se) {
  Object.defineProperty(ae, ie, {
    enumerable: !0,
    value: se,
    writable: !1
  });
}
function getStatic(ae, ie) {
  for (let se = 0; se < 32; se++) {
    if (ae[ie])
      return ae[ie];
    if (!ae.prototype || typeof ae.prototype != "object")
      break;
    ae = Object.getPrototypeOf(ae.prototype).constructor;
  }
  return null;
}
function resolveProperties(ae) {
  return __awaiter$e(this, void 0, void 0, function* () {
    const ie = Object.keys(ae).map((fe) => {
      const ue = ae[fe];
      return Promise.resolve(ue).then((ce) => ({ key: fe, value: ce }));
    });
    return (yield Promise.all(ie)).reduce((fe, ue) => (fe[ue.key] = ue.value, fe), {});
  });
}
function checkProperties(ae, ie) {
  (!ae || typeof ae != "object") && logger$i.throwArgumentError("invalid object", "object", ae), Object.keys(ae).forEach((se) => {
    ie[se] || logger$i.throwArgumentError("invalid object key - " + se, "transaction:" + se, ae);
  });
}
function shallowCopy(ae) {
  const ie = {};
  for (const se in ae)
    ie[se] = ae[se];
  return ie;
}
const opaque = { bigint: !0, boolean: !0, function: !0, number: !0, string: !0 };
function _isFrozen(ae) {
  if (ae == null || opaque[typeof ae])
    return !0;
  if (Array.isArray(ae) || typeof ae == "object") {
    if (!Object.isFrozen(ae))
      return !1;
    const ie = Object.keys(ae);
    for (let se = 0; se < ie.length; se++) {
      let fe = null;
      try {
        fe = ae[ie[se]];
      } catch {
        continue;
      }
      if (!_isFrozen(fe))
        return !1;
    }
    return !0;
  }
  return logger$i.throwArgumentError(`Cannot deepCopy ${typeof ae}`, "object", ae);
}
function _deepCopy(ae) {
  if (_isFrozen(ae))
    return ae;
  if (Array.isArray(ae))
    return Object.freeze(ae.map((ie) => deepCopy(ie)));
  if (typeof ae == "object") {
    const ie = {};
    for (const se in ae) {
      const fe = ae[se];
      fe !== void 0 && defineReadOnly(ie, se, deepCopy(fe));
    }
    return ie;
  }
  return logger$i.throwArgumentError(`Cannot deepCopy ${typeof ae}`, "object", ae);
}
function deepCopy(ae) {
  return _deepCopy(ae);
}
class Description {
  constructor(ie) {
    for (const se in ie)
      this[se] = deepCopy(ie[se]);
  }
}
var __awaiter$d = function(ae, ie, se, fe) {
  function ue(ce) {
    return ce instanceof se ? ce : new se(function(de) {
      de(ce);
    });
  }
  return new (se || (se = Promise))(function(ce, de) {
    function me(Se) {
      try {
        Ee(fe.next(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function we(Se) {
      try {
        Ee(fe.throw(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function Ee(Se) {
      Se.done ? ce(Se.value) : ue(Se.value).then(me, we);
    }
    Ee((fe = fe.apply(ae, ie || [])).next());
  });
};
const logger$h = new Logger(version$g), padding = new Uint8Array(32);
padding.fill(0);
const NegativeOne = BigNumber.from(-1), Zero = BigNumber.from(0), One = BigNumber.from(1), MaxUint256 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(ae) {
  const ie = arrayify(ae), se = ie.length % 32;
  return se ? hexConcat([ie, padding.slice(se)]) : hexlify(ie);
}
const hexTrue = hexZeroPad(One.toHexString(), 32), hexFalse = hexZeroPad(Zero.toHexString(), 32), domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
}, domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(ae) {
  return function(ie) {
    return typeof ie != "string" && logger$h.throwArgumentError(`invalid domain value for ${JSON.stringify(ae)}`, `domain.${ae}`, ie), ie;
  };
}
const domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(ae) {
    try {
      return BigNumber.from(ae).toString();
    } catch {
    }
    return logger$h.throwArgumentError('invalid domain value for "chainId"', "domain.chainId", ae);
  },
  verifyingContract: function(ae) {
    try {
      return getAddress(ae).toLowerCase();
    } catch {
    }
    return logger$h.throwArgumentError('invalid domain value "verifyingContract"', "domain.verifyingContract", ae);
  },
  salt: function(ae) {
    try {
      const ie = arrayify(ae);
      if (ie.length !== 32)
        throw new Error("bad length");
      return hexlify(ie);
    } catch {
    }
    return logger$h.throwArgumentError('invalid domain value "salt"', "domain.salt", ae);
  }
};
function getBaseEncoder(ae) {
  {
    const ie = ae.match(/^(u?)int(\d*)$/);
    if (ie) {
      const se = ie[1] === "", fe = parseInt(ie[2] || "256");
      (fe % 8 !== 0 || fe > 256 || ie[2] && ie[2] !== String(fe)) && logger$h.throwArgumentError("invalid numeric width", "type", ae);
      const ue = MaxUint256.mask(se ? fe - 1 : fe), ce = se ? ue.add(One).mul(NegativeOne) : Zero;
      return function(de) {
        const me = BigNumber.from(de);
        return (me.lt(ce) || me.gt(ue)) && logger$h.throwArgumentError(`value out-of-bounds for ${ae}`, "value", de), hexZeroPad(me.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const ie = ae.match(/^bytes(\d+)$/);
    if (ie) {
      const se = parseInt(ie[1]);
      return (se === 0 || se > 32 || ie[1] !== String(se)) && logger$h.throwArgumentError("invalid bytes width", "type", ae), function(fe) {
        return arrayify(fe).length !== se && logger$h.throwArgumentError(`invalid length for ${ae}`, "value", fe), hexPadRight(fe);
      };
    }
  }
  switch (ae) {
    case "address":
      return function(ie) {
        return hexZeroPad(getAddress(ie), 32);
      };
    case "bool":
      return function(ie) {
        return ie ? hexTrue : hexFalse;
      };
    case "bytes":
      return function(ie) {
        return keccak256$1(ie);
      };
    case "string":
      return function(ie) {
        return id(ie);
      };
  }
  return null;
}
function encodeType(ae, ie) {
  return `${ae}(${ie.map(({ name: se, type: fe }) => fe + " " + se).join(",")})`;
}
class TypedDataEncoder {
  constructor(ie) {
    defineReadOnly(this, "types", Object.freeze(deepCopy(ie))), defineReadOnly(this, "_encoderCache", {}), defineReadOnly(this, "_types", {});
    const se = {}, fe = {}, ue = {};
    Object.keys(ie).forEach((me) => {
      se[me] = {}, fe[me] = [], ue[me] = {};
    });
    for (const me in ie) {
      const we = {};
      ie[me].forEach((Ee) => {
        we[Ee.name] && logger$h.throwArgumentError(`duplicate variable name ${JSON.stringify(Ee.name)} in ${JSON.stringify(me)}`, "types", ie), we[Ee.name] = !0;
        const Se = Ee.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        Se === me && logger$h.throwArgumentError(`circular type reference to ${JSON.stringify(Se)}`, "types", ie), !getBaseEncoder(Se) && (fe[Se] || logger$h.throwArgumentError(`unknown type ${JSON.stringify(Se)}`, "types", ie), fe[Se].push(me), se[me][Se] = !0);
      });
    }
    const ce = Object.keys(fe).filter((me) => fe[me].length === 0);
    ce.length === 0 ? logger$h.throwArgumentError("missing primary type", "types", ie) : ce.length > 1 && logger$h.throwArgumentError(`ambiguous primary types or unused types: ${ce.map((me) => JSON.stringify(me)).join(", ")}`, "types", ie), defineReadOnly(this, "primaryType", ce[0]);
    function de(me, we) {
      we[me] && logger$h.throwArgumentError(`circular type reference to ${JSON.stringify(me)}`, "types", ie), we[me] = !0, Object.keys(se[me]).forEach((Ee) => {
        fe[Ee] && (de(Ee, we), Object.keys(we).forEach((Se) => {
          ue[Se][Ee] = !0;
        }));
      }), delete we[me];
    }
    de(this.primaryType, {});
    for (const me in ue) {
      const we = Object.keys(ue[me]);
      we.sort(), this._types[me] = encodeType(me, ie[me]) + we.map((Ee) => encodeType(Ee, ie[Ee])).join("");
    }
  }
  getEncoder(ie) {
    let se = this._encoderCache[ie];
    return se || (se = this._encoderCache[ie] = this._getEncoder(ie)), se;
  }
  _getEncoder(ie) {
    {
      const ue = getBaseEncoder(ie);
      if (ue)
        return ue;
    }
    const se = ie.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (se) {
      const ue = se[1], ce = this.getEncoder(ue), de = parseInt(se[3]);
      return (me) => {
        de >= 0 && me.length !== de && logger$h.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", me);
        let we = me.map(ce);
        return this._types[ue] && (we = we.map(keccak256$1)), keccak256$1(hexConcat(we));
      };
    }
    const fe = this.types[ie];
    if (fe) {
      const ue = id(this._types[ie]);
      return (ce) => {
        const de = fe.map(({ name: me, type: we }) => {
          const Ee = this.getEncoder(we)(ce[me]);
          return this._types[we] ? keccak256$1(Ee) : Ee;
        });
        return de.unshift(ue), hexConcat(de);
      };
    }
    return logger$h.throwArgumentError(`unknown type: ${ie}`, "type", ie);
  }
  encodeType(ie) {
    const se = this._types[ie];
    return se || logger$h.throwArgumentError(`unknown type: ${JSON.stringify(ie)}`, "name", ie), se;
  }
  encodeData(ie, se) {
    return this.getEncoder(ie)(se);
  }
  hashStruct(ie, se) {
    return keccak256$1(this.encodeData(ie, se));
  }
  encode(ie) {
    return this.encodeData(this.primaryType, ie);
  }
  hash(ie) {
    return this.hashStruct(this.primaryType, ie);
  }
  _visit(ie, se, fe) {
    if (getBaseEncoder(ie))
      return fe(ie, se);
    const ue = ie.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (ue) {
      const de = ue[1], me = parseInt(ue[3]);
      return me >= 0 && se.length !== me && logger$h.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", se), se.map((we) => this._visit(de, we, fe));
    }
    const ce = this.types[ie];
    return ce ? ce.reduce((de, { name: me, type: we }) => (de[me] = this._visit(we, se[me], fe), de), {}) : logger$h.throwArgumentError(`unknown type: ${ie}`, "type", ie);
  }
  visit(ie, se) {
    return this._visit(this.primaryType, ie, se);
  }
  static from(ie) {
    return new TypedDataEncoder(ie);
  }
  static getPrimaryType(ie) {
    return TypedDataEncoder.from(ie).primaryType;
  }
  static hashStruct(ie, se, fe) {
    return TypedDataEncoder.from(se).hashStruct(ie, fe);
  }
  static hashDomain(ie) {
    const se = [];
    for (const fe in ie) {
      const ue = domainFieldTypes[fe];
      ue || logger$h.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(fe)}`, "domain", ie), se.push({ name: fe, type: ue });
    }
    return se.sort((fe, ue) => domainFieldNames.indexOf(fe.name) - domainFieldNames.indexOf(ue.name)), TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: se }, ie);
  }
  static encode(ie, se, fe) {
    return hexConcat([
      "0x1901",
      TypedDataEncoder.hashDomain(ie),
      TypedDataEncoder.from(se).hash(fe)
    ]);
  }
  static hash(ie, se, fe) {
    return keccak256$1(TypedDataEncoder.encode(ie, se, fe));
  }
  // Replaces all address types with ENS names with their looked up address
  static resolveNames(ie, se, fe, ue) {
    return __awaiter$d(this, void 0, void 0, function* () {
      ie = shallowCopy(ie);
      const ce = {};
      ie.verifyingContract && !isHexString$1(ie.verifyingContract, 20) && (ce[ie.verifyingContract] = "0x");
      const de = TypedDataEncoder.from(se);
      de.visit(fe, (me, we) => (me === "address" && !isHexString$1(we, 20) && (ce[we] = "0x"), we));
      for (const me in ce)
        ce[me] = yield ue(me);
      return ie.verifyingContract && ce[ie.verifyingContract] && (ie.verifyingContract = ce[ie.verifyingContract]), fe = de.visit(fe, (me, we) => me === "address" && ce[we] ? ce[we] : we), { domain: ie, value: fe };
    });
  }
  static getPayload(ie, se, fe) {
    TypedDataEncoder.hashDomain(ie);
    const ue = {}, ce = [];
    domainFieldNames.forEach((we) => {
      const Ee = ie[we];
      Ee != null && (ue[we] = domainChecks[we](Ee), ce.push({ name: we, type: domainFieldTypes[we] }));
    });
    const de = TypedDataEncoder.from(se), me = shallowCopy(se);
    return me.EIP712Domain ? logger$h.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", se) : me.EIP712Domain = ce, de.encode(fe), {
      types: me,
      domain: ue,
      primaryType: de.primaryType,
      message: de.visit(fe, (we, Ee) => {
        if (we.match(/^bytes(\d*)/))
          return hexlify(arrayify(Ee));
        if (we.match(/^u?int/))
          return BigNumber.from(Ee).toString();
        switch (we) {
          case "address":
            return Ee.toLowerCase();
          case "bool":
            return !!Ee;
          case "string":
            return typeof Ee != "string" && logger$h.throwArgumentError("invalid string", "value", Ee), Ee;
        }
        return logger$h.throwArgumentError("unsupported type", "type", we);
      })
    };
  }
}
function createCommonjsModule(ae, ie, se) {
  return se = {
    path: ie,
    exports: {},
    require: function(fe, ue) {
      return commonjsRequire$1(fe, ue ?? se.path);
    }
  }, ae(se, se.exports), se.exports;
}
function commonjsRequire$1() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert = assert$3;
function assert$3(ae, ie) {
  if (!ae)
    throw new Error(ie || "Assertion failed");
}
assert$3.equal = function(ie, se, fe) {
  if (ie != se)
    throw new Error(fe || "Assertion failed: " + ie + " != " + se);
};
var utils_1 = createCommonjsModule(function(ae, ie) {
  var se = ie;
  function fe(de, me) {
    if (Array.isArray(de))
      return de.slice();
    if (!de)
      return [];
    var we = [];
    if (typeof de != "string") {
      for (var Ee = 0; Ee < de.length; Ee++)
        we[Ee] = de[Ee] | 0;
      return we;
    }
    if (me === "hex") {
      de = de.replace(/[^a-z0-9]+/ig, ""), de.length % 2 !== 0 && (de = "0" + de);
      for (var Ee = 0; Ee < de.length; Ee += 2)
        we.push(parseInt(de[Ee] + de[Ee + 1], 16));
    } else
      for (var Ee = 0; Ee < de.length; Ee++) {
        var Se = de.charCodeAt(Ee), Be = Se >> 8, Ce = Se & 255;
        Be ? we.push(Be, Ce) : we.push(Ce);
      }
    return we;
  }
  se.toArray = fe;
  function ue(de) {
    return de.length === 1 ? "0" + de : de;
  }
  se.zero2 = ue;
  function ce(de) {
    for (var me = "", we = 0; we < de.length; we++)
      me += ue(de[we].toString(16));
    return me;
  }
  se.toHex = ce, se.encode = function(me, we) {
    return we === "hex" ? ce(me) : me;
  };
}), utils_1$1 = createCommonjsModule(function(ae, ie) {
  var se = ie;
  se.assert = minimalisticAssert, se.toArray = utils_1.toArray, se.zero2 = utils_1.zero2, se.toHex = utils_1.toHex, se.encode = utils_1.encode;
  function fe(we, Ee, Se) {
    var Be = new Array(Math.max(we.bitLength(), Se) + 1);
    Be.fill(0);
    for (var Ce = 1 << Ee + 1, Ie = we.clone(), Pe = 0; Pe < Be.length; Pe++) {
      var Ne, ke = Ie.andln(Ce - 1);
      Ie.isOdd() ? (ke > (Ce >> 1) - 1 ? Ne = (Ce >> 1) - ke : Ne = ke, Ie.isubn(Ne)) : Ne = 0, Be[Pe] = Ne, Ie.iushrn(1);
    }
    return Be;
  }
  se.getNAF = fe;
  function ue(we, Ee) {
    var Se = [
      [],
      []
    ];
    we = we.clone(), Ee = Ee.clone();
    for (var Be = 0, Ce = 0, Ie; we.cmpn(-Be) > 0 || Ee.cmpn(-Ce) > 0; ) {
      var Pe = we.andln(3) + Be & 3, Ne = Ee.andln(3) + Ce & 3;
      Pe === 3 && (Pe = -1), Ne === 3 && (Ne = -1);
      var ke;
      Pe & 1 ? (Ie = we.andln(7) + Be & 7, (Ie === 3 || Ie === 5) && Ne === 2 ? ke = -Pe : ke = Pe) : ke = 0, Se[0].push(ke);
      var He;
      Ne & 1 ? (Ie = Ee.andln(7) + Ce & 7, (Ie === 3 || Ie === 5) && Pe === 2 ? He = -Ne : He = Ne) : He = 0, Se[1].push(He), 2 * Be === ke + 1 && (Be = 1 - Be), 2 * Ce === He + 1 && (Ce = 1 - Ce), we.iushrn(1), Ee.iushrn(1);
    }
    return Se;
  }
  se.getJSF = ue;
  function ce(we, Ee, Se) {
    var Be = "_" + Ee;
    we.prototype[Ee] = function() {
      return this[Be] !== void 0 ? this[Be] : this[Be] = Se.call(this);
    };
  }
  se.cachedProperty = ce;
  function de(we) {
    return typeof we == "string" ? se.toArray(we, "hex") : we;
  }
  se.parseBytes = de;
  function me(we) {
    return new BN$d(we, "hex", "le");
  }
  se.intFromLE = me;
}), getNAF = utils_1$1.getNAF, getJSF = utils_1$1.getJSF, assert$1$1 = utils_1$1.assert;
function BaseCurve(ae, ie) {
  this.type = ae, this.p = new BN$d(ie.p, 16), this.red = ie.prime ? BN$d.red(ie.prime) : BN$d.mont(this.p), this.zero = new BN$d(0).toRed(this.red), this.one = new BN$d(1).toRed(this.red), this.two = new BN$d(2).toRed(this.red), this.n = ie.n && new BN$d(ie.n, 16), this.g = ie.g && this.pointFromJSON(ie.g, ie.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var se = this.n && this.p.div(this.n);
  !se || se.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var base$4 = BaseCurve;
BaseCurve.prototype.point = function() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function(ie, se) {
  assert$1$1(ie.precomputed);
  var fe = ie._getDoubles(), ue = getNAF(se, 1, this._bitLength), ce = (1 << fe.step + 1) - (fe.step % 2 === 0 ? 2 : 1);
  ce /= 3;
  var de = [], me, we;
  for (me = 0; me < ue.length; me += fe.step) {
    we = 0;
    for (var Ee = me + fe.step - 1; Ee >= me; Ee--)
      we = (we << 1) + ue[Ee];
    de.push(we);
  }
  for (var Se = this.jpoint(null, null, null), Be = this.jpoint(null, null, null), Ce = ce; Ce > 0; Ce--) {
    for (me = 0; me < de.length; me++)
      we = de[me], we === Ce ? Be = Be.mixedAdd(fe.points[me]) : we === -Ce && (Be = Be.mixedAdd(fe.points[me].neg()));
    Se = Se.add(Be);
  }
  return Se.toP();
};
BaseCurve.prototype._wnafMul = function(ie, se) {
  var fe = 4, ue = ie._getNAFPoints(fe);
  fe = ue.wnd;
  for (var ce = ue.points, de = getNAF(se, fe, this._bitLength), me = this.jpoint(null, null, null), we = de.length - 1; we >= 0; we--) {
    for (var Ee = 0; we >= 0 && de[we] === 0; we--)
      Ee++;
    if (we >= 0 && Ee++, me = me.dblp(Ee), we < 0)
      break;
    var Se = de[we];
    assert$1$1(Se !== 0), ie.type === "affine" ? Se > 0 ? me = me.mixedAdd(ce[Se - 1 >> 1]) : me = me.mixedAdd(ce[-Se - 1 >> 1].neg()) : Se > 0 ? me = me.add(ce[Se - 1 >> 1]) : me = me.add(ce[-Se - 1 >> 1].neg());
  }
  return ie.type === "affine" ? me.toP() : me;
};
BaseCurve.prototype._wnafMulAdd = function(ie, se, fe, ue, ce) {
  var de = this._wnafT1, me = this._wnafT2, we = this._wnafT3, Ee = 0, Se, Be, Ce;
  for (Se = 0; Se < ue; Se++) {
    Ce = se[Se];
    var Ie = Ce._getNAFPoints(ie);
    de[Se] = Ie.wnd, me[Se] = Ie.points;
  }
  for (Se = ue - 1; Se >= 1; Se -= 2) {
    var Pe = Se - 1, Ne = Se;
    if (de[Pe] !== 1 || de[Ne] !== 1) {
      we[Pe] = getNAF(fe[Pe], de[Pe], this._bitLength), we[Ne] = getNAF(fe[Ne], de[Ne], this._bitLength), Ee = Math.max(we[Pe].length, Ee), Ee = Math.max(we[Ne].length, Ee);
      continue;
    }
    var ke = [
      se[Pe],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      se[Ne]
      /* 7 */
    ];
    se[Pe].y.cmp(se[Ne].y) === 0 ? (ke[1] = se[Pe].add(se[Ne]), ke[2] = se[Pe].toJ().mixedAdd(se[Ne].neg())) : se[Pe].y.cmp(se[Ne].y.redNeg()) === 0 ? (ke[1] = se[Pe].toJ().mixedAdd(se[Ne]), ke[2] = se[Pe].add(se[Ne].neg())) : (ke[1] = se[Pe].toJ().mixedAdd(se[Ne]), ke[2] = se[Pe].toJ().mixedAdd(se[Ne].neg()));
    var He = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], De = getJSF(fe[Pe], fe[Ne]);
    for (Ee = Math.max(De[0].length, Ee), we[Pe] = new Array(Ee), we[Ne] = new Array(Ee), Be = 0; Be < Ee; Be++) {
      var Ge = De[0][Be] | 0, Ye = De[1][Be] | 0;
      we[Pe][Be] = He[(Ge + 1) * 3 + (Ye + 1)], we[Ne][Be] = 0, me[Pe] = ke;
    }
  }
  var st = this.jpoint(null, null, null), at = this._wnafT4;
  for (Se = Ee; Se >= 0; Se--) {
    for (var mt = 0; Se >= 0; ) {
      var qe = !0;
      for (Be = 0; Be < ue; Be++)
        at[Be] = we[Be][Se] | 0, at[Be] !== 0 && (qe = !1);
      if (!qe)
        break;
      mt++, Se--;
    }
    if (Se >= 0 && mt++, st = st.dblp(mt), Se < 0)
      break;
    for (Be = 0; Be < ue; Be++) {
      var ze = at[Be];
      ze !== 0 && (ze > 0 ? Ce = me[Be][ze - 1 >> 1] : ze < 0 && (Ce = me[Be][-ze - 1 >> 1].neg()), Ce.type === "affine" ? st = st.mixedAdd(Ce) : st = st.add(Ce));
    }
  }
  for (Se = 0; Se < ue; Se++)
    me[Se] = null;
  return ce ? st : st.toP();
};
function BasePoint(ae, ie) {
  this.curve = ae, this.type = ie, this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function(ie, se) {
  ie = utils_1$1.toArray(ie, se);
  var fe = this.p.byteLength();
  if ((ie[0] === 4 || ie[0] === 6 || ie[0] === 7) && ie.length - 1 === 2 * fe) {
    ie[0] === 6 ? assert$1$1(ie[ie.length - 1] % 2 === 0) : ie[0] === 7 && assert$1$1(ie[ie.length - 1] % 2 === 1);
    var ue = this.point(
      ie.slice(1, 1 + fe),
      ie.slice(1 + fe, 1 + 2 * fe)
    );
    return ue;
  } else if ((ie[0] === 2 || ie[0] === 3) && ie.length - 1 === fe)
    return this.pointFromX(ie.slice(1, 1 + fe), ie[0] === 3);
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function(ie) {
  return this.encode(ie, !0);
};
BasePoint.prototype._encode = function(ie) {
  var se = this.curve.p.byteLength(), fe = this.getX().toArray("be", se);
  return ie ? [this.getY().isEven() ? 2 : 3].concat(fe) : [4].concat(fe, this.getY().toArray("be", se));
};
BasePoint.prototype.encode = function(ie, se) {
  return utils_1$1.encode(this._encode(se), ie);
};
BasePoint.prototype.precompute = function(ie) {
  if (this.precomputed)
    return this;
  var se = {
    doubles: null,
    naf: null,
    beta: null
  };
  return se.naf = this._getNAFPoints(8), se.doubles = this._getDoubles(4, ie), se.beta = this._getBeta(), this.precomputed = se, this;
};
BasePoint.prototype._hasDoubles = function(ie) {
  if (!this.precomputed)
    return !1;
  var se = this.precomputed.doubles;
  return se ? se.points.length >= Math.ceil((ie.bitLength() + 1) / se.step) : !1;
};
BasePoint.prototype._getDoubles = function(ie, se) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var fe = [this], ue = this, ce = 0; ce < se; ce += ie) {
    for (var de = 0; de < ie; de++)
      ue = ue.dbl();
    fe.push(ue);
  }
  return {
    step: ie,
    points: fe
  };
};
BasePoint.prototype._getNAFPoints = function(ie) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var se = [this], fe = (1 << ie) - 1, ue = fe === 1 ? null : this.dbl(), ce = 1; ce < fe; ce++)
    se[ce] = se[ce - 1].add(ue);
  return {
    wnd: ie,
    points: se
  };
};
BasePoint.prototype._getBeta = function() {
  return null;
};
BasePoint.prototype.dblp = function(ie) {
  for (var se = this, fe = 0; fe < ie; fe++)
    se = se.dbl();
  return se;
};
var inherits_browser = createCommonjsModule(function(ae) {
  typeof Object.create == "function" ? ae.exports = function(se, fe) {
    fe && (se.super_ = fe, se.prototype = Object.create(fe.prototype, {
      constructor: {
        value: se,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : ae.exports = function(se, fe) {
    if (fe) {
      se.super_ = fe;
      var ue = function() {
      };
      ue.prototype = fe.prototype, se.prototype = new ue(), se.prototype.constructor = se;
    }
  };
}), assert$2$1 = utils_1$1.assert;
function ShortCurve(ae) {
  base$4.call(this, "short", ae), this.a = new BN$d(ae.a, 16).toRed(this.red), this.b = new BN$d(ae.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(ae), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
inherits_browser(ShortCurve, base$4);
var short_1 = ShortCurve;
ShortCurve.prototype._getEndomorphism = function(ie) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var se, fe;
    if (ie.beta)
      se = new BN$d(ie.beta, 16).toRed(this.red);
    else {
      var ue = this._getEndoRoots(this.p);
      se = ue[0].cmp(ue[1]) < 0 ? ue[0] : ue[1], se = se.toRed(this.red);
    }
    if (ie.lambda)
      fe = new BN$d(ie.lambda, 16);
    else {
      var ce = this._getEndoRoots(this.n);
      this.g.mul(ce[0]).x.cmp(this.g.x.redMul(se)) === 0 ? fe = ce[0] : (fe = ce[1], assert$2$1(this.g.mul(fe).x.cmp(this.g.x.redMul(se)) === 0));
    }
    var de;
    return ie.basis ? de = ie.basis.map(function(me) {
      return {
        a: new BN$d(me.a, 16),
        b: new BN$d(me.b, 16)
      };
    }) : de = this._getEndoBasis(fe), {
      beta: se,
      lambda: fe,
      basis: de
    };
  }
};
ShortCurve.prototype._getEndoRoots = function(ie) {
  var se = ie === this.p ? this.red : BN$d.mont(ie), fe = new BN$d(2).toRed(se).redInvm(), ue = fe.redNeg(), ce = new BN$d(3).toRed(se).redNeg().redSqrt().redMul(fe), de = ue.redAdd(ce).fromRed(), me = ue.redSub(ce).fromRed();
  return [de, me];
};
ShortCurve.prototype._getEndoBasis = function(ie) {
  for (var se = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), fe = ie, ue = this.n.clone(), ce = new BN$d(1), de = new BN$d(0), me = new BN$d(0), we = new BN$d(1), Ee, Se, Be, Ce, Ie, Pe, Ne, ke = 0, He, De; fe.cmpn(0) !== 0; ) {
    var Ge = ue.div(fe);
    He = ue.sub(Ge.mul(fe)), De = me.sub(Ge.mul(ce));
    var Ye = we.sub(Ge.mul(de));
    if (!Be && He.cmp(se) < 0)
      Ee = Ne.neg(), Se = ce, Be = He.neg(), Ce = De;
    else if (Be && ++ke === 2)
      break;
    Ne = He, ue = fe, fe = He, me = ce, ce = De, we = de, de = Ye;
  }
  Ie = He.neg(), Pe = De;
  var st = Be.sqr().add(Ce.sqr()), at = Ie.sqr().add(Pe.sqr());
  return at.cmp(st) >= 0 && (Ie = Ee, Pe = Se), Be.negative && (Be = Be.neg(), Ce = Ce.neg()), Ie.negative && (Ie = Ie.neg(), Pe = Pe.neg()), [
    { a: Be, b: Ce },
    { a: Ie, b: Pe }
  ];
};
ShortCurve.prototype._endoSplit = function(ie) {
  var se = this.endo.basis, fe = se[0], ue = se[1], ce = ue.b.mul(ie).divRound(this.n), de = fe.b.neg().mul(ie).divRound(this.n), me = ce.mul(fe.a), we = de.mul(ue.a), Ee = ce.mul(fe.b), Se = de.mul(ue.b), Be = ie.sub(me).sub(we), Ce = Ee.add(Se).neg();
  return { k1: Be, k2: Ce };
};
ShortCurve.prototype.pointFromX = function(ie, se) {
  ie = new BN$d(ie, 16), ie.red || (ie = ie.toRed(this.red));
  var fe = ie.redSqr().redMul(ie).redIAdd(ie.redMul(this.a)).redIAdd(this.b), ue = fe.redSqrt();
  if (ue.redSqr().redSub(fe).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var ce = ue.fromRed().isOdd();
  return (se && !ce || !se && ce) && (ue = ue.redNeg()), this.point(ie, ue);
};
ShortCurve.prototype.validate = function(ie) {
  if (ie.inf)
    return !0;
  var se = ie.x, fe = ie.y, ue = this.a.redMul(se), ce = se.redSqr().redMul(se).redIAdd(ue).redIAdd(this.b);
  return fe.redSqr().redISub(ce).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function(ie, se, fe) {
  for (var ue = this._endoWnafT1, ce = this._endoWnafT2, de = 0; de < ie.length; de++) {
    var me = this._endoSplit(se[de]), we = ie[de], Ee = we._getBeta();
    me.k1.negative && (me.k1.ineg(), we = we.neg(!0)), me.k2.negative && (me.k2.ineg(), Ee = Ee.neg(!0)), ue[de * 2] = we, ue[de * 2 + 1] = Ee, ce[de * 2] = me.k1, ce[de * 2 + 1] = me.k2;
  }
  for (var Se = this._wnafMulAdd(1, ue, ce, de * 2, fe), Be = 0; Be < de * 2; Be++)
    ue[Be] = null, ce[Be] = null;
  return Se;
};
function Point$1(ae, ie, se, fe) {
  base$4.BasePoint.call(this, ae, "affine"), ie === null && se === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN$d(ie, 16), this.y = new BN$d(se, 16), fe && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
inherits_browser(Point$1, base$4.BasePoint);
ShortCurve.prototype.point = function(ie, se, fe) {
  return new Point$1(this, ie, se, fe);
};
ShortCurve.prototype.pointFromJSON = function(ie, se) {
  return Point$1.fromJSON(this, ie, se);
};
Point$1.prototype._getBeta = function() {
  if (this.curve.endo) {
    var ie = this.precomputed;
    if (ie && ie.beta)
      return ie.beta;
    var se = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (ie) {
      var fe = this.curve, ue = function(ce) {
        return fe.point(ce.x.redMul(fe.endo.beta), ce.y);
      };
      ie.beta = se, se.precomputed = {
        beta: null,
        naf: ie.naf && {
          wnd: ie.naf.wnd,
          points: ie.naf.points.map(ue)
        },
        doubles: ie.doubles && {
          step: ie.doubles.step,
          points: ie.doubles.points.map(ue)
        }
      };
    }
    return se;
  }
};
Point$1.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Point$1.fromJSON = function(ie, se, fe) {
  typeof se == "string" && (se = JSON.parse(se));
  var ue = ie.point(se[0], se[1], fe);
  if (!se[2])
    return ue;
  function ce(me) {
    return ie.point(me[0], me[1], fe);
  }
  var de = se[2];
  return ue.precomputed = {
    beta: null,
    doubles: de.doubles && {
      step: de.doubles.step,
      points: [ue].concat(de.doubles.points.map(ce))
    },
    naf: de.naf && {
      wnd: de.naf.wnd,
      points: [ue].concat(de.naf.points.map(ce))
    }
  }, ue;
};
Point$1.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point$1.prototype.isInfinity = function() {
  return this.inf;
};
Point$1.prototype.add = function(ie) {
  if (this.inf)
    return ie;
  if (ie.inf)
    return this;
  if (this.eq(ie))
    return this.dbl();
  if (this.neg().eq(ie))
    return this.curve.point(null, null);
  if (this.x.cmp(ie.x) === 0)
    return this.curve.point(null, null);
  var se = this.y.redSub(ie.y);
  se.cmpn(0) !== 0 && (se = se.redMul(this.x.redSub(ie.x).redInvm()));
  var fe = se.redSqr().redISub(this.x).redISub(ie.x), ue = se.redMul(this.x.redSub(fe)).redISub(this.y);
  return this.curve.point(fe, ue);
};
Point$1.prototype.dbl = function() {
  if (this.inf)
    return this;
  var ie = this.y.redAdd(this.y);
  if (ie.cmpn(0) === 0)
    return this.curve.point(null, null);
  var se = this.curve.a, fe = this.x.redSqr(), ue = ie.redInvm(), ce = fe.redAdd(fe).redIAdd(fe).redIAdd(se).redMul(ue), de = ce.redSqr().redISub(this.x.redAdd(this.x)), me = ce.redMul(this.x.redSub(de)).redISub(this.y);
  return this.curve.point(de, me);
};
Point$1.prototype.getX = function() {
  return this.x.fromRed();
};
Point$1.prototype.getY = function() {
  return this.y.fromRed();
};
Point$1.prototype.mul = function(ie) {
  return ie = new BN$d(ie, 16), this.isInfinity() ? this : this._hasDoubles(ie) ? this.curve._fixedNafMul(this, ie) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [ie]) : this.curve._wnafMul(this, ie);
};
Point$1.prototype.mulAdd = function(ie, se, fe) {
  var ue = [this, se], ce = [ie, fe];
  return this.curve.endo ? this.curve._endoWnafMulAdd(ue, ce) : this.curve._wnafMulAdd(1, ue, ce, 2);
};
Point$1.prototype.jmulAdd = function(ie, se, fe) {
  var ue = [this, se], ce = [ie, fe];
  return this.curve.endo ? this.curve._endoWnafMulAdd(ue, ce, !0) : this.curve._wnafMulAdd(1, ue, ce, 2, !0);
};
Point$1.prototype.eq = function(ie) {
  return this === ie || this.inf === ie.inf && (this.inf || this.x.cmp(ie.x) === 0 && this.y.cmp(ie.y) === 0);
};
Point$1.prototype.neg = function(ie) {
  if (this.inf)
    return this;
  var se = this.curve.point(this.x, this.y.redNeg());
  if (ie && this.precomputed) {
    var fe = this.precomputed, ue = function(ce) {
      return ce.neg();
    };
    se.precomputed = {
      naf: fe.naf && {
        wnd: fe.naf.wnd,
        points: fe.naf.points.map(ue)
      },
      doubles: fe.doubles && {
        step: fe.doubles.step,
        points: fe.doubles.points.map(ue)
      }
    };
  }
  return se;
};
Point$1.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var ie = this.curve.jpoint(this.x, this.y, this.curve.one);
  return ie;
};
function JPoint(ae, ie, se, fe) {
  base$4.BasePoint.call(this, ae, "jacobian"), ie === null && se === null && fe === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN$d(0)) : (this.x = new BN$d(ie, 16), this.y = new BN$d(se, 16), this.z = new BN$d(fe, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
inherits_browser(JPoint, base$4.BasePoint);
ShortCurve.prototype.jpoint = function(ie, se, fe) {
  return new JPoint(this, ie, se, fe);
};
JPoint.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var ie = this.z.redInvm(), se = ie.redSqr(), fe = this.x.redMul(se), ue = this.y.redMul(se).redMul(ie);
  return this.curve.point(fe, ue);
};
JPoint.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function(ie) {
  if (this.isInfinity())
    return ie;
  if (ie.isInfinity())
    return this;
  var se = ie.z.redSqr(), fe = this.z.redSqr(), ue = this.x.redMul(se), ce = ie.x.redMul(fe), de = this.y.redMul(se.redMul(ie.z)), me = ie.y.redMul(fe.redMul(this.z)), we = ue.redSub(ce), Ee = de.redSub(me);
  if (we.cmpn(0) === 0)
    return Ee.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var Se = we.redSqr(), Be = Se.redMul(we), Ce = ue.redMul(Se), Ie = Ee.redSqr().redIAdd(Be).redISub(Ce).redISub(Ce), Pe = Ee.redMul(Ce.redISub(Ie)).redISub(de.redMul(Be)), Ne = this.z.redMul(ie.z).redMul(we);
  return this.curve.jpoint(Ie, Pe, Ne);
};
JPoint.prototype.mixedAdd = function(ie) {
  if (this.isInfinity())
    return ie.toJ();
  if (ie.isInfinity())
    return this;
  var se = this.z.redSqr(), fe = this.x, ue = ie.x.redMul(se), ce = this.y, de = ie.y.redMul(se).redMul(this.z), me = fe.redSub(ue), we = ce.redSub(de);
  if (me.cmpn(0) === 0)
    return we.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var Ee = me.redSqr(), Se = Ee.redMul(me), Be = fe.redMul(Ee), Ce = we.redSqr().redIAdd(Se).redISub(Be).redISub(Be), Ie = we.redMul(Be.redISub(Ce)).redISub(ce.redMul(Se)), Pe = this.z.redMul(me);
  return this.curve.jpoint(Ce, Ie, Pe);
};
JPoint.prototype.dblp = function(ie) {
  if (ie === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!ie)
    return this.dbl();
  var se;
  if (this.curve.zeroA || this.curve.threeA) {
    var fe = this;
    for (se = 0; se < ie; se++)
      fe = fe.dbl();
    return fe;
  }
  var ue = this.curve.a, ce = this.curve.tinv, de = this.x, me = this.y, we = this.z, Ee = we.redSqr().redSqr(), Se = me.redAdd(me);
  for (se = 0; se < ie; se++) {
    var Be = de.redSqr(), Ce = Se.redSqr(), Ie = Ce.redSqr(), Pe = Be.redAdd(Be).redIAdd(Be).redIAdd(ue.redMul(Ee)), Ne = de.redMul(Ce), ke = Pe.redSqr().redISub(Ne.redAdd(Ne)), He = Ne.redISub(ke), De = Pe.redMul(He);
    De = De.redIAdd(De).redISub(Ie);
    var Ge = Se.redMul(we);
    se + 1 < ie && (Ee = Ee.redMul(Ie)), de = ke, we = Ge, Se = De;
  }
  return this.curve.jpoint(de, Se.redMul(ce), we);
};
JPoint.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
JPoint.prototype._zeroDbl = function() {
  var ie, se, fe;
  if (this.zOne) {
    var ue = this.x.redSqr(), ce = this.y.redSqr(), de = ce.redSqr(), me = this.x.redAdd(ce).redSqr().redISub(ue).redISub(de);
    me = me.redIAdd(me);
    var we = ue.redAdd(ue).redIAdd(ue), Ee = we.redSqr().redISub(me).redISub(me), Se = de.redIAdd(de);
    Se = Se.redIAdd(Se), Se = Se.redIAdd(Se), ie = Ee, se = we.redMul(me.redISub(Ee)).redISub(Se), fe = this.y.redAdd(this.y);
  } else {
    var Be = this.x.redSqr(), Ce = this.y.redSqr(), Ie = Ce.redSqr(), Pe = this.x.redAdd(Ce).redSqr().redISub(Be).redISub(Ie);
    Pe = Pe.redIAdd(Pe);
    var Ne = Be.redAdd(Be).redIAdd(Be), ke = Ne.redSqr(), He = Ie.redIAdd(Ie);
    He = He.redIAdd(He), He = He.redIAdd(He), ie = ke.redISub(Pe).redISub(Pe), se = Ne.redMul(Pe.redISub(ie)).redISub(He), fe = this.y.redMul(this.z), fe = fe.redIAdd(fe);
  }
  return this.curve.jpoint(ie, se, fe);
};
JPoint.prototype._threeDbl = function() {
  var ie, se, fe;
  if (this.zOne) {
    var ue = this.x.redSqr(), ce = this.y.redSqr(), de = ce.redSqr(), me = this.x.redAdd(ce).redSqr().redISub(ue).redISub(de);
    me = me.redIAdd(me);
    var we = ue.redAdd(ue).redIAdd(ue).redIAdd(this.curve.a), Ee = we.redSqr().redISub(me).redISub(me);
    ie = Ee;
    var Se = de.redIAdd(de);
    Se = Se.redIAdd(Se), Se = Se.redIAdd(Se), se = we.redMul(me.redISub(Ee)).redISub(Se), fe = this.y.redAdd(this.y);
  } else {
    var Be = this.z.redSqr(), Ce = this.y.redSqr(), Ie = this.x.redMul(Ce), Pe = this.x.redSub(Be).redMul(this.x.redAdd(Be));
    Pe = Pe.redAdd(Pe).redIAdd(Pe);
    var Ne = Ie.redIAdd(Ie);
    Ne = Ne.redIAdd(Ne);
    var ke = Ne.redAdd(Ne);
    ie = Pe.redSqr().redISub(ke), fe = this.y.redAdd(this.z).redSqr().redISub(Ce).redISub(Be);
    var He = Ce.redSqr();
    He = He.redIAdd(He), He = He.redIAdd(He), He = He.redIAdd(He), se = Pe.redMul(Ne.redISub(ie)).redISub(He);
  }
  return this.curve.jpoint(ie, se, fe);
};
JPoint.prototype._dbl = function() {
  var ie = this.curve.a, se = this.x, fe = this.y, ue = this.z, ce = ue.redSqr().redSqr(), de = se.redSqr(), me = fe.redSqr(), we = de.redAdd(de).redIAdd(de).redIAdd(ie.redMul(ce)), Ee = se.redAdd(se);
  Ee = Ee.redIAdd(Ee);
  var Se = Ee.redMul(me), Be = we.redSqr().redISub(Se.redAdd(Se)), Ce = Se.redISub(Be), Ie = me.redSqr();
  Ie = Ie.redIAdd(Ie), Ie = Ie.redIAdd(Ie), Ie = Ie.redIAdd(Ie);
  var Pe = we.redMul(Ce).redISub(Ie), Ne = fe.redAdd(fe).redMul(ue);
  return this.curve.jpoint(Be, Pe, Ne);
};
JPoint.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var ie = this.x.redSqr(), se = this.y.redSqr(), fe = this.z.redSqr(), ue = se.redSqr(), ce = ie.redAdd(ie).redIAdd(ie), de = ce.redSqr(), me = this.x.redAdd(se).redSqr().redISub(ie).redISub(ue);
  me = me.redIAdd(me), me = me.redAdd(me).redIAdd(me), me = me.redISub(de);
  var we = me.redSqr(), Ee = ue.redIAdd(ue);
  Ee = Ee.redIAdd(Ee), Ee = Ee.redIAdd(Ee), Ee = Ee.redIAdd(Ee);
  var Se = ce.redIAdd(me).redSqr().redISub(de).redISub(we).redISub(Ee), Be = se.redMul(Se);
  Be = Be.redIAdd(Be), Be = Be.redIAdd(Be);
  var Ce = this.x.redMul(we).redISub(Be);
  Ce = Ce.redIAdd(Ce), Ce = Ce.redIAdd(Ce);
  var Ie = this.y.redMul(Se.redMul(Ee.redISub(Se)).redISub(me.redMul(we)));
  Ie = Ie.redIAdd(Ie), Ie = Ie.redIAdd(Ie), Ie = Ie.redIAdd(Ie);
  var Pe = this.z.redAdd(me).redSqr().redISub(fe).redISub(we);
  return this.curve.jpoint(Ce, Ie, Pe);
};
JPoint.prototype.mul = function(ie, se) {
  return ie = new BN$d(ie, se), this.curve._wnafMul(this, ie);
};
JPoint.prototype.eq = function(ie) {
  if (ie.type === "affine")
    return this.eq(ie.toJ());
  if (this === ie)
    return !0;
  var se = this.z.redSqr(), fe = ie.z.redSqr();
  if (this.x.redMul(fe).redISub(ie.x.redMul(se)).cmpn(0) !== 0)
    return !1;
  var ue = se.redMul(this.z), ce = fe.redMul(ie.z);
  return this.y.redMul(ce).redISub(ie.y.redMul(ue)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function(ie) {
  var se = this.z.redSqr(), fe = ie.toRed(this.curve.red).redMul(se);
  if (this.x.cmp(fe) === 0)
    return !0;
  for (var ue = ie.clone(), ce = this.curve.redN.redMul(se); ; ) {
    if (ue.iadd(this.curve.n), ue.cmp(this.curve.p) >= 0)
      return !1;
    if (fe.redIAdd(ce), this.x.cmp(fe) === 0)
      return !0;
  }
};
JPoint.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var curve_1 = createCommonjsModule(function(ae, ie) {
  var se = ie;
  se.base = base$4, se.short = short_1, se.mont = /*RicMoo:ethers:require(./mont)*/
  null, se.edwards = /*RicMoo:ethers:require(./edwards)*/
  null;
}), curves_1 = createCommonjsModule(function(ae, ie) {
  var se = ie, fe = utils_1$1.assert;
  function ue(me) {
    me.type === "short" ? this.curve = new curve_1.short(me) : me.type === "edwards" ? this.curve = new curve_1.edwards(me) : this.curve = new curve_1.mont(me), this.g = this.curve.g, this.n = this.curve.n, this.hash = me.hash, fe(this.g.validate(), "Invalid curve"), fe(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  se.PresetCurve = ue;
  function ce(me, we) {
    Object.defineProperty(se, me, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var Ee = new ue(we);
        return Object.defineProperty(se, me, {
          configurable: !0,
          enumerable: !0,
          value: Ee
        }), Ee;
      }
    });
  }
  ce("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash$3.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), ce("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash$3.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), ce("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash$3.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), ce("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash$3.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), ce("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash$3.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), ce("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$3.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), ce("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$3.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var de;
  try {
    de = /*RicMoo:ethers:require(./precomputed/secp256k1)*/
    null.crash();
  } catch {
    de = void 0;
  }
  ce("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash$3.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      de
    ]
  });
});
function HmacDRBG(ae) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(ae);
  this.hash = ae.hash, this.predResist = !!ae.predResist, this.outLen = this.hash.outSize, this.minEntropy = ae.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var ie = utils_1.toArray(ae.entropy, ae.entropyEnc || "hex"), se = utils_1.toArray(ae.nonce, ae.nonceEnc || "hex"), fe = utils_1.toArray(ae.pers, ae.persEnc || "hex");
  minimalisticAssert(
    ie.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(ie, se, fe);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function(ie, se, fe) {
  var ue = ie.concat(se).concat(fe);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var ce = 0; ce < this.V.length; ce++)
    this.K[ce] = 0, this.V[ce] = 1;
  this._update(ue), this._reseed = 1, this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function() {
  return new hash$3.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function(ie) {
  var se = this._hmac().update(this.V).update([0]);
  ie && (se = se.update(ie)), this.K = se.digest(), this.V = this._hmac().update(this.V).digest(), ie && (this.K = this._hmac().update(this.V).update([1]).update(ie).digest(), this.V = this._hmac().update(this.V).digest());
};
HmacDRBG.prototype.reseed = function(ie, se, fe, ue) {
  typeof se != "string" && (ue = fe, fe = se, se = null), ie = utils_1.toArray(ie, se), fe = utils_1.toArray(fe, ue), minimalisticAssert(
    ie.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(ie.concat(fe || [])), this._reseed = 1;
};
HmacDRBG.prototype.generate = function(ie, se, fe, ue) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof se != "string" && (ue = fe, fe = se, se = null), fe && (fe = utils_1.toArray(fe, ue || "hex"), this._update(fe));
  for (var ce = []; ce.length < ie; )
    this.V = this._hmac().update(this.V).digest(), ce = ce.concat(this.V);
  var de = ce.slice(0, ie);
  return this._update(fe), this._reseed++, utils_1.encode(de, se);
};
var assert$3$1 = utils_1$1.assert;
function KeyPair$2(ae, ie) {
  this.ec = ae, this.priv = null, this.pub = null, ie.priv && this._importPrivate(ie.priv, ie.privEnc), ie.pub && this._importPublic(ie.pub, ie.pubEnc);
}
var key = KeyPair$2;
KeyPair$2.fromPublic = function(ie, se, fe) {
  return se instanceof KeyPair$2 ? se : new KeyPair$2(ie, {
    pub: se,
    pubEnc: fe
  });
};
KeyPair$2.fromPrivate = function(ie, se, fe) {
  return se instanceof KeyPair$2 ? se : new KeyPair$2(ie, {
    priv: se,
    privEnc: fe
  });
};
KeyPair$2.prototype.validate = function() {
  var ie = this.getPublic();
  return ie.isInfinity() ? { result: !1, reason: "Invalid public key" } : ie.validate() ? ie.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
KeyPair$2.prototype.getPublic = function(ie, se) {
  return typeof ie == "string" && (se = ie, ie = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), se ? this.pub.encode(se, ie) : this.pub;
};
KeyPair$2.prototype.getPrivate = function(ie) {
  return ie === "hex" ? this.priv.toString(16, 2) : this.priv;
};
KeyPair$2.prototype._importPrivate = function(ie, se) {
  this.priv = new BN$d(ie, se || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair$2.prototype._importPublic = function(ie, se) {
  if (ie.x || ie.y) {
    this.ec.curve.type === "mont" ? assert$3$1(ie.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && assert$3$1(ie.x && ie.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(ie.x, ie.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(ie, se);
};
KeyPair$2.prototype.derive = function(ie) {
  return ie.validate() || assert$3$1(ie.validate(), "public point not validated"), ie.mul(this.priv).getX();
};
KeyPair$2.prototype.sign = function(ie, se, fe) {
  return this.ec.sign(ie, this, se, fe);
};
KeyPair$2.prototype.verify = function(ie, se) {
  return this.ec.verify(ie, se, this);
};
KeyPair$2.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$4 = utils_1$1.assert;
function Signature$1(ae, ie) {
  if (ae instanceof Signature$1)
    return ae;
  this._importDER(ae, ie) || (assert$4(ae.r && ae.s, "Signature without r or s"), this.r = new BN$d(ae.r, 16), this.s = new BN$d(ae.s, 16), ae.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = ae.recoveryParam);
}
var signature$2 = Signature$1;
function Position() {
  this.place = 0;
}
function getLength(ae, ie) {
  var se = ae[ie.place++];
  if (!(se & 128))
    return se;
  var fe = se & 15;
  if (fe === 0 || fe > 4)
    return !1;
  for (var ue = 0, ce = 0, de = ie.place; ce < fe; ce++, de++)
    ue <<= 8, ue |= ae[de], ue >>>= 0;
  return ue <= 127 ? !1 : (ie.place = de, ue);
}
function rmPadding(ae) {
  for (var ie = 0, se = ae.length - 1; !ae[ie] && !(ae[ie + 1] & 128) && ie < se; )
    ie++;
  return ie === 0 ? ae : ae.slice(ie);
}
Signature$1.prototype._importDER = function(ie, se) {
  ie = utils_1$1.toArray(ie, se);
  var fe = new Position();
  if (ie[fe.place++] !== 48)
    return !1;
  var ue = getLength(ie, fe);
  if (ue === !1 || ue + fe.place !== ie.length || ie[fe.place++] !== 2)
    return !1;
  var ce = getLength(ie, fe);
  if (ce === !1)
    return !1;
  var de = ie.slice(fe.place, ce + fe.place);
  if (fe.place += ce, ie[fe.place++] !== 2)
    return !1;
  var me = getLength(ie, fe);
  if (me === !1 || ie.length !== me + fe.place)
    return !1;
  var we = ie.slice(fe.place, me + fe.place);
  if (de[0] === 0)
    if (de[1] & 128)
      de = de.slice(1);
    else
      return !1;
  if (we[0] === 0)
    if (we[1] & 128)
      we = we.slice(1);
    else
      return !1;
  return this.r = new BN$d(de), this.s = new BN$d(we), this.recoveryParam = null, !0;
};
function constructLength(ae, ie) {
  if (ie < 128) {
    ae.push(ie);
    return;
  }
  var se = 1 + (Math.log(ie) / Math.LN2 >>> 3);
  for (ae.push(se | 128); --se; )
    ae.push(ie >>> (se << 3) & 255);
  ae.push(ie);
}
Signature$1.prototype.toDER = function(ie) {
  var se = this.r.toArray(), fe = this.s.toArray();
  for (se[0] & 128 && (se = [0].concat(se)), fe[0] & 128 && (fe = [0].concat(fe)), se = rmPadding(se), fe = rmPadding(fe); !fe[0] && !(fe[1] & 128); )
    fe = fe.slice(1);
  var ue = [2];
  constructLength(ue, se.length), ue = ue.concat(se), ue.push(2), constructLength(ue, fe.length);
  var ce = ue.concat(fe), de = [48];
  return constructLength(de, ce.length), de = de.concat(ce), utils_1$1.encode(de, ie);
};
var rand = (
  /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }
), assert$5 = utils_1$1.assert;
function EC$1(ae) {
  if (!(this instanceof EC$1))
    return new EC$1(ae);
  typeof ae == "string" && (assert$5(
    Object.prototype.hasOwnProperty.call(curves_1, ae),
    "Unknown curve " + ae
  ), ae = curves_1[ae]), ae instanceof curves_1.PresetCurve && (ae = { curve: ae }), this.curve = ae.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = ae.curve.g, this.g.precompute(ae.curve.n.bitLength() + 1), this.hash = ae.hash || ae.curve.hash;
}
var ec$1 = EC$1;
EC$1.prototype.keyPair = function(ie) {
  return new key(this, ie);
};
EC$1.prototype.keyFromPrivate = function(ie, se) {
  return key.fromPrivate(this, ie, se);
};
EC$1.prototype.keyFromPublic = function(ie, se) {
  return key.fromPublic(this, ie, se);
};
EC$1.prototype.genKeyPair = function(ie) {
  ie || (ie = {});
  for (var se = new hmacDrbg({
    hash: this.hash,
    pers: ie.pers,
    persEnc: ie.persEnc || "utf8",
    entropy: ie.entropy || rand(this.hash.hmacStrength),
    entropyEnc: ie.entropy && ie.entropyEnc || "utf8",
    nonce: this.n.toArray()
  }), fe = this.n.byteLength(), ue = this.n.sub(new BN$d(2)); ; ) {
    var ce = new BN$d(se.generate(fe));
    if (!(ce.cmp(ue) > 0))
      return ce.iaddn(1), this.keyFromPrivate(ce);
  }
};
EC$1.prototype._truncateToN = function(ie, se) {
  var fe = ie.byteLength() * 8 - this.n.bitLength();
  return fe > 0 && (ie = ie.ushrn(fe)), !se && ie.cmp(this.n) >= 0 ? ie.sub(this.n) : ie;
};
EC$1.prototype.sign = function(ie, se, fe, ue) {
  typeof fe == "object" && (ue = fe, fe = null), ue || (ue = {}), se = this.keyFromPrivate(se, fe), ie = this._truncateToN(new BN$d(ie, 16));
  for (var ce = this.n.byteLength(), de = se.getPrivate().toArray("be", ce), me = ie.toArray("be", ce), we = new hmacDrbg({
    hash: this.hash,
    entropy: de,
    nonce: me,
    pers: ue.pers,
    persEnc: ue.persEnc || "utf8"
  }), Ee = this.n.sub(new BN$d(1)), Se = 0; ; Se++) {
    var Be = ue.k ? ue.k(Se) : new BN$d(we.generate(this.n.byteLength()));
    if (Be = this._truncateToN(Be, !0), !(Be.cmpn(1) <= 0 || Be.cmp(Ee) >= 0)) {
      var Ce = this.g.mul(Be);
      if (!Ce.isInfinity()) {
        var Ie = Ce.getX(), Pe = Ie.umod(this.n);
        if (Pe.cmpn(0) !== 0) {
          var Ne = Be.invm(this.n).mul(Pe.mul(se.getPrivate()).iadd(ie));
          if (Ne = Ne.umod(this.n), Ne.cmpn(0) !== 0) {
            var ke = (Ce.getY().isOdd() ? 1 : 0) | (Ie.cmp(Pe) !== 0 ? 2 : 0);
            return ue.canonical && Ne.cmp(this.nh) > 0 && (Ne = this.n.sub(Ne), ke ^= 1), new signature$2({ r: Pe, s: Ne, recoveryParam: ke });
          }
        }
      }
    }
  }
};
EC$1.prototype.verify = function(ie, se, fe, ue) {
  ie = this._truncateToN(new BN$d(ie, 16)), fe = this.keyFromPublic(fe, ue), se = new signature$2(se, "hex");
  var ce = se.r, de = se.s;
  if (ce.cmpn(1) < 0 || ce.cmp(this.n) >= 0 || de.cmpn(1) < 0 || de.cmp(this.n) >= 0)
    return !1;
  var me = de.invm(this.n), we = me.mul(ie).umod(this.n), Ee = me.mul(ce).umod(this.n), Se;
  return this.curve._maxwellTrick ? (Se = this.g.jmulAdd(we, fe.getPublic(), Ee), Se.isInfinity() ? !1 : Se.eqXToP(ce)) : (Se = this.g.mulAdd(we, fe.getPublic(), Ee), Se.isInfinity() ? !1 : Se.getX().umod(this.n).cmp(ce) === 0);
};
EC$1.prototype.recoverPubKey = function(ae, ie, se, fe) {
  assert$5((3 & se) === se, "The recovery param is more than two bits"), ie = new signature$2(ie, fe);
  var ue = this.n, ce = new BN$d(ae), de = ie.r, me = ie.s, we = se & 1, Ee = se >> 1;
  if (de.cmp(this.curve.p.umod(this.curve.n)) >= 0 && Ee)
    throw new Error("Unable to find sencond key candinate");
  Ee ? de = this.curve.pointFromX(de.add(this.curve.n), we) : de = this.curve.pointFromX(de, we);
  var Se = ie.r.invm(ue), Be = ue.sub(ce).mul(Se).umod(ue), Ce = me.mul(Se).umod(ue);
  return this.g.mulAdd(Be, de, Ce);
};
EC$1.prototype.getKeyRecoveryParam = function(ae, ie, se, fe) {
  if (ie = new signature$2(ie, fe), ie.recoveryParam !== null)
    return ie.recoveryParam;
  for (var ue = 0; ue < 4; ue++) {
    var ce;
    try {
      ce = this.recoverPubKey(ae, ie, ue);
    } catch {
      continue;
    }
    if (ce.eq(se))
      return ue;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_1 = createCommonjsModule(function(ae, ie) {
  var se = ie;
  se.version = "6.5.4", se.utils = utils_1$1, se.rand = /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }, se.curve = curve_1, se.curves = curves_1, se.ec = ec$1, se.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/
  null;
}), EC$1$1 = elliptic_1.ec;
const version$c = "signing-key/5.7.0", logger$g = new Logger(version$c);
let _curve = null;
function getCurve() {
  return _curve || (_curve = new EC$1$1("secp256k1")), _curve;
}
class SigningKey {
  constructor(ie) {
    defineReadOnly(this, "curve", "secp256k1"), defineReadOnly(this, "privateKey", hexlify(ie)), hexDataLength(this.privateKey) !== 32 && logger$g.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    const se = getCurve().keyFromPrivate(arrayify(this.privateKey));
    defineReadOnly(this, "publicKey", "0x" + se.getPublic(!1, "hex")), defineReadOnly(this, "compressedPublicKey", "0x" + se.getPublic(!0, "hex")), defineReadOnly(this, "_isSigningKey", !0);
  }
  _addPoint(ie) {
    const se = getCurve().keyFromPublic(arrayify(this.publicKey)), fe = getCurve().keyFromPublic(arrayify(ie));
    return "0x" + se.pub.add(fe.pub).encodeCompressed("hex");
  }
  signDigest(ie) {
    const se = getCurve().keyFromPrivate(arrayify(this.privateKey)), fe = arrayify(ie);
    fe.length !== 32 && logger$g.throwArgumentError("bad digest length", "digest", ie);
    const ue = se.sign(fe, { canonical: !0 });
    return splitSignature({
      recoveryParam: ue.recoveryParam,
      r: hexZeroPad("0x" + ue.r.toString(16), 32),
      s: hexZeroPad("0x" + ue.s.toString(16), 32)
    });
  }
  computeSharedSecret(ie) {
    const se = getCurve().keyFromPrivate(arrayify(this.privateKey)), fe = getCurve().keyFromPublic(arrayify(computePublicKey(ie)));
    return hexZeroPad("0x" + se.derive(fe.getPublic()).toString(16), 32);
  }
  static isSigningKey(ie) {
    return !!(ie && ie._isSigningKey);
  }
}
function recoverPublicKey(ae, ie) {
  const se = splitSignature(ie), fe = { r: arrayify(se.r), s: arrayify(se.s) };
  return "0x" + getCurve().recoverPubKey(arrayify(ae), fe, se.recoveryParam).encode("hex", !1);
}
function computePublicKey(ae, ie) {
  const se = arrayify(ae);
  if (se.length === 32) {
    const fe = new SigningKey(se);
    return ie ? "0x" + getCurve().keyFromPrivate(se).getPublic(!0, "hex") : fe.publicKey;
  } else {
    if (se.length === 33)
      return ie ? hexlify(se) : "0x" + getCurve().keyFromPublic(se).getPublic(!1, "hex");
    if (se.length === 65)
      return ie ? "0x" + getCurve().keyFromPublic(se).getPublic(!0, "hex") : hexlify(se);
  }
  return logger$g.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
const version$b = "transactions/5.7.0", logger$f = new Logger(version$b);
var TransactionTypes;
(function(ae) {
  ae[ae.legacy = 0] = "legacy", ae[ae.eip2930 = 1] = "eip2930", ae[ae.eip1559 = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
const transactionFields = [
  { name: "nonce", maxLength: 32, numeric: !0 },
  { name: "gasPrice", maxLength: 32, numeric: !0 },
  { name: "gasLimit", maxLength: 32, numeric: !0 },
  { name: "to", length: 20 },
  { name: "value", maxLength: 32, numeric: !0 },
  { name: "data" }
], allowedTransactionKeys$1 = {
  chainId: !0,
  data: !0,
  gasLimit: !0,
  gasPrice: !0,
  nonce: !0,
  to: !0,
  type: !0,
  value: !0
};
function computeAddress(ae) {
  const ie = computePublicKey(ae);
  return getAddress(hexDataSlice(keccak256$1(hexDataSlice(ie, 1)), 12));
}
function recoverAddress(ae, ie) {
  return computeAddress(recoverPublicKey(arrayify(ae), ie));
}
function formatNumber(ae, ie) {
  const se = stripZeros(BigNumber.from(ae).toHexString());
  return se.length > 32 && logger$f.throwArgumentError("invalid length for " + ie, "transaction:" + ie, ae), se;
}
function accessSetify(ae, ie) {
  return {
    address: getAddress(ae),
    storageKeys: (ie || []).map((se, fe) => (hexDataLength(se) !== 32 && logger$f.throwArgumentError("invalid access list storageKey", `accessList[${ae}:${fe}]`, se), se.toLowerCase()))
  };
}
function accessListify(ae) {
  if (Array.isArray(ae))
    return ae.map((se, fe) => Array.isArray(se) ? (se.length > 2 && logger$f.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${fe}]`, se), accessSetify(se[0], se[1])) : accessSetify(se.address, se.storageKeys));
  const ie = Object.keys(ae).map((se) => {
    const fe = ae[se].reduce((ue, ce) => (ue[ce] = !0, ue), {});
    return accessSetify(se, Object.keys(fe).sort());
  });
  return ie.sort((se, fe) => se.address.localeCompare(fe.address)), ie;
}
function formatAccessList(ae) {
  return accessListify(ae).map((ie) => [ie.address, ie.storageKeys]);
}
function _serializeEip1559(ae, ie) {
  if (ae.gasPrice != null) {
    const fe = BigNumber.from(ae.gasPrice), ue = BigNumber.from(ae.maxFeePerGas || 0);
    fe.eq(ue) || logger$f.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
      gasPrice: fe,
      maxFeePerGas: ue
    });
  }
  const se = [
    formatNumber(ae.chainId || 0, "chainId"),
    formatNumber(ae.nonce || 0, "nonce"),
    formatNumber(ae.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(ae.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(ae.gasLimit || 0, "gasLimit"),
    ae.to != null ? getAddress(ae.to) : "0x",
    formatNumber(ae.value || 0, "value"),
    ae.data || "0x",
    formatAccessList(ae.accessList || [])
  ];
  if (ie) {
    const fe = splitSignature(ie);
    se.push(formatNumber(fe.recoveryParam, "recoveryParam")), se.push(stripZeros(fe.r)), se.push(stripZeros(fe.s));
  }
  return hexConcat(["0x02", encode$2(se)]);
}
function _serializeEip2930(ae, ie) {
  const se = [
    formatNumber(ae.chainId || 0, "chainId"),
    formatNumber(ae.nonce || 0, "nonce"),
    formatNumber(ae.gasPrice || 0, "gasPrice"),
    formatNumber(ae.gasLimit || 0, "gasLimit"),
    ae.to != null ? getAddress(ae.to) : "0x",
    formatNumber(ae.value || 0, "value"),
    ae.data || "0x",
    formatAccessList(ae.accessList || [])
  ];
  if (ie) {
    const fe = splitSignature(ie);
    se.push(formatNumber(fe.recoveryParam, "recoveryParam")), se.push(stripZeros(fe.r)), se.push(stripZeros(fe.s));
  }
  return hexConcat(["0x01", encode$2(se)]);
}
function _serialize(ae, ie) {
  checkProperties(ae, allowedTransactionKeys$1);
  const se = [];
  transactionFields.forEach(function(de) {
    let me = ae[de.name] || [];
    const we = {};
    de.numeric && (we.hexPad = "left"), me = arrayify(hexlify(me, we)), de.length && me.length !== de.length && me.length > 0 && logger$f.throwArgumentError("invalid length for " + de.name, "transaction:" + de.name, me), de.maxLength && (me = stripZeros(me), me.length > de.maxLength && logger$f.throwArgumentError("invalid length for " + de.name, "transaction:" + de.name, me)), se.push(hexlify(me));
  });
  let fe = 0;
  if (ae.chainId != null ? (fe = ae.chainId, typeof fe != "number" && logger$f.throwArgumentError("invalid transaction.chainId", "transaction", ae)) : ie && !isBytesLike(ie) && ie.v > 28 && (fe = Math.floor((ie.v - 35) / 2)), fe !== 0 && (se.push(hexlify(fe)), se.push("0x"), se.push("0x")), !ie)
    return encode$2(se);
  const ue = splitSignature(ie);
  let ce = 27 + ue.recoveryParam;
  return fe !== 0 ? (se.pop(), se.pop(), se.pop(), ce += fe * 2 + 8, ue.v > 28 && ue.v !== ce && logger$f.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", ie)) : ue.v !== ce && logger$f.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", ie), se.push(hexlify(ce)), se.push(stripZeros(arrayify(ue.r))), se.push(stripZeros(arrayify(ue.s))), encode$2(se);
}
function serialize$1(ae, ie) {
  if (ae.type == null || ae.type === 0)
    return ae.accessList != null && logger$f.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", ae), _serialize(ae, ie);
  switch (ae.type) {
    case 1:
      return _serializeEip2930(ae, ie);
    case 2:
      return _serializeEip1559(ae, ie);
  }
  return logger$f.throwError(`unsupported transaction type: ${ae.type}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "serializeTransaction",
    transactionType: ae.type
  });
}
const version$a = "abstract-provider/5.7.0";
var __awaiter$c = function(ae, ie, se, fe) {
  function ue(ce) {
    return ce instanceof se ? ce : new se(function(de) {
      de(ce);
    });
  }
  return new (se || (se = Promise))(function(ce, de) {
    function me(Se) {
      try {
        Ee(fe.next(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function we(Se) {
      try {
        Ee(fe.throw(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function Ee(Se) {
      Se.done ? ce(Se.value) : ue(Se.value).then(me, we);
    }
    Ee((fe = fe.apply(ae, ie || [])).next());
  });
};
const logger$e = new Logger(version$a);
class Provider {
  constructor() {
    logger$e.checkAbstract(new.target, Provider), defineReadOnly(this, "_isProvider", !0);
  }
  getFeeData() {
    return __awaiter$c(this, void 0, void 0, function* () {
      const { block: ie, gasPrice: se } = yield resolveProperties({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((de) => null)
      });
      let fe = null, ue = null, ce = null;
      return ie && ie.baseFeePerGas && (fe = ie.baseFeePerGas, ce = BigNumber.from("1500000000"), ue = ie.baseFeePerGas.mul(2).add(ce)), { lastBaseFeePerGas: fe, maxFeePerGas: ue, maxPriorityFeePerGas: ce, gasPrice: se };
    });
  }
  // Alias for "on"
  addListener(ie, se) {
    return this.on(ie, se);
  }
  // Alias for "off"
  removeListener(ie, se) {
    return this.off(ie, se);
  }
  static isProvider(ie) {
    return !!(ie && ie._isProvider);
  }
}
const version$9 = "abstract-signer/5.7.0";
var __awaiter$b = function(ae, ie, se, fe) {
  function ue(ce) {
    return ce instanceof se ? ce : new se(function(de) {
      de(ce);
    });
  }
  return new (se || (se = Promise))(function(ce, de) {
    function me(Se) {
      try {
        Ee(fe.next(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function we(Se) {
      try {
        Ee(fe.throw(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function Ee(Se) {
      Se.done ? ce(Se.value) : ue(Se.value).then(me, we);
    }
    Ee((fe = fe.apply(ae, ie || [])).next());
  });
};
const logger$d = new Logger(version$9), allowedTransactionKeys = [
  "accessList",
  "ccipReadEnabled",
  "chainId",
  "customData",
  "data",
  "from",
  "gasLimit",
  "gasPrice",
  "maxFeePerGas",
  "maxPriorityFeePerGas",
  "nonce",
  "to",
  "type",
  "value"
], forwardErrors = [
  Logger.errors.INSUFFICIENT_FUNDS,
  Logger.errors.NONCE_EXPIRED,
  Logger.errors.REPLACEMENT_UNDERPRICED
];
class Signer {
  ///////////////////
  // Sub-classes MUST call super
  constructor() {
    logger$d.checkAbstract(new.target, Signer), defineReadOnly(this, "_isSigner", !0);
  }
  ///////////////////
  // Sub-classes MAY override these
  getBalance(ie) {
    return __awaiter$b(this, void 0, void 0, function* () {
      return this._checkProvider("getBalance"), yield this.provider.getBalance(this.getAddress(), ie);
    });
  }
  getTransactionCount(ie) {
    return __awaiter$b(this, void 0, void 0, function* () {
      return this._checkProvider("getTransactionCount"), yield this.provider.getTransactionCount(this.getAddress(), ie);
    });
  }
  // Populates "from" if unspecified, and estimates the gas for the transaction
  estimateGas(ie) {
    return __awaiter$b(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const se = yield resolveProperties(this.checkTransaction(ie));
      return yield this.provider.estimateGas(se);
    });
  }
  // Populates "from" if unspecified, and calls with the transaction
  call(ie, se) {
    return __awaiter$b(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const fe = yield resolveProperties(this.checkTransaction(ie));
      return yield this.provider.call(fe, se);
    });
  }
  // Populates all fields in a transaction, signs it and sends it to the network
  sendTransaction(ie) {
    return __awaiter$b(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const se = yield this.populateTransaction(ie), fe = yield this.signTransaction(se);
      return yield this.provider.sendTransaction(fe);
    });
  }
  getChainId() {
    return __awaiter$b(this, void 0, void 0, function* () {
      return this._checkProvider("getChainId"), (yield this.provider.getNetwork()).chainId;
    });
  }
  getGasPrice() {
    return __awaiter$b(this, void 0, void 0, function* () {
      return this._checkProvider("getGasPrice"), yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return __awaiter$b(this, void 0, void 0, function* () {
      return this._checkProvider("getFeeData"), yield this.provider.getFeeData();
    });
  }
  resolveName(ie) {
    return __awaiter$b(this, void 0, void 0, function* () {
      return this._checkProvider("resolveName"), yield this.provider.resolveName(ie);
    });
  }
  // Checks a transaction does not contain invalid keys and if
  // no "from" is provided, populates it.
  // - does NOT require a provider
  // - adds "from" is not present
  // - returns a COPY (safe to mutate the result)
  // By default called from: (overriding these prevents it)
  //   - call
  //   - estimateGas
  //   - populateTransaction (and therefor sendTransaction)
  checkTransaction(ie) {
    for (const fe in ie)
      allowedTransactionKeys.indexOf(fe) === -1 && logger$d.throwArgumentError("invalid transaction key: " + fe, "transaction", ie);
    const se = shallowCopy(ie);
    return se.from == null ? se.from = this.getAddress() : se.from = Promise.all([
      Promise.resolve(se.from),
      this.getAddress()
    ]).then((fe) => (fe[0].toLowerCase() !== fe[1].toLowerCase() && logger$d.throwArgumentError("from address mismatch", "transaction", ie), fe[0])), se;
  }
  // Populates ALL keys for a transaction and checks that "from" matches
  // this Signer. Should be used by sendTransaction but NOT by signTransaction.
  // By default called from: (overriding these prevents it)
  //   - sendTransaction
  //
  // Notes:
  //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas
  populateTransaction(ie) {
    return __awaiter$b(this, void 0, void 0, function* () {
      const se = yield resolveProperties(this.checkTransaction(ie));
      se.to != null && (se.to = Promise.resolve(se.to).then((ue) => __awaiter$b(this, void 0, void 0, function* () {
        if (ue == null)
          return null;
        const ce = yield this.resolveName(ue);
        return ce == null && logger$d.throwArgumentError("provided ENS name resolves to null", "tx.to", ue), ce;
      })), se.to.catch((ue) => {
      }));
      const fe = se.maxFeePerGas != null || se.maxPriorityFeePerGas != null;
      if (se.gasPrice != null && (se.type === 2 || fe) ? logger$d.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", ie) : (se.type === 0 || se.type === 1) && fe && logger$d.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", ie), (se.type === 2 || se.type == null) && se.maxFeePerGas != null && se.maxPriorityFeePerGas != null)
        se.type = 2;
      else if (se.type === 0 || se.type === 1)
        se.gasPrice == null && (se.gasPrice = this.getGasPrice());
      else {
        const ue = yield this.getFeeData();
        if (se.type == null)
          if (ue.maxFeePerGas != null && ue.maxPriorityFeePerGas != null)
            if (se.type = 2, se.gasPrice != null) {
              const ce = se.gasPrice;
              delete se.gasPrice, se.maxFeePerGas = ce, se.maxPriorityFeePerGas = ce;
            } else
              se.maxFeePerGas == null && (se.maxFeePerGas = ue.maxFeePerGas), se.maxPriorityFeePerGas == null && (se.maxPriorityFeePerGas = ue.maxPriorityFeePerGas);
          else
            ue.gasPrice != null ? (fe && logger$d.throwError("network does not support EIP-1559", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "populateTransaction"
            }), se.gasPrice == null && (se.gasPrice = ue.gasPrice), se.type = 0) : logger$d.throwError("failed to get consistent fee data", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "signer.getFeeData"
            });
        else
          se.type === 2 && (se.maxFeePerGas == null && (se.maxFeePerGas = ue.maxFeePerGas), se.maxPriorityFeePerGas == null && (se.maxPriorityFeePerGas = ue.maxPriorityFeePerGas));
      }
      return se.nonce == null && (se.nonce = this.getTransactionCount("pending")), se.gasLimit == null && (se.gasLimit = this.estimateGas(se).catch((ue) => {
        if (forwardErrors.indexOf(ue.code) >= 0)
          throw ue;
        return logger$d.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
          error: ue,
          tx: se
        });
      })), se.chainId == null ? se.chainId = this.getChainId() : se.chainId = Promise.all([
        Promise.resolve(se.chainId),
        this.getChainId()
      ]).then((ue) => (ue[1] !== 0 && ue[0] !== ue[1] && logger$d.throwArgumentError("chainId address mismatch", "transaction", ie), ue[0])), yield resolveProperties(se);
    });
  }
  ///////////////////
  // Sub-classes SHOULD leave these alone
  _checkProvider(ie) {
    this.provider || logger$d.throwError("missing provider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: ie || "_checkProvider"
    });
  }
  static isSigner(ie) {
    return !!(ie && ie._isSigner);
  }
}
class VoidSigner extends Signer {
  constructor(ie, se) {
    super(), defineReadOnly(this, "address", ie), defineReadOnly(this, "provider", se || null);
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  _fail(ie, se) {
    return Promise.resolve().then(() => {
      logger$d.throwError(ie, Logger.errors.UNSUPPORTED_OPERATION, { operation: se });
    });
  }
  signMessage(ie) {
    return this._fail("VoidSigner cannot sign messages", "signMessage");
  }
  signTransaction(ie) {
    return this._fail("VoidSigner cannot sign transactions", "signTransaction");
  }
  _signTypedData(ie, se, fe) {
    return this._fail("VoidSigner cannot sign typed data", "signTypedData");
  }
  connect(ie) {
    return new VoidSigner(this.address, ie);
  }
}
class BaseX {
  constructor(ie) {
    defineReadOnly(this, "alphabet", ie), defineReadOnly(this, "base", ie.length), defineReadOnly(this, "_alphabetMap", {}), defineReadOnly(this, "_leader", ie.charAt(0));
    for (let se = 0; se < ie.length; se++)
      this._alphabetMap[ie.charAt(se)] = se;
  }
  encode(ie) {
    let se = arrayify(ie);
    if (se.length === 0)
      return "";
    let fe = [0];
    for (let ce = 0; ce < se.length; ++ce) {
      let de = se[ce];
      for (let me = 0; me < fe.length; ++me)
        de += fe[me] << 8, fe[me] = de % this.base, de = de / this.base | 0;
      for (; de > 0; )
        fe.push(de % this.base), de = de / this.base | 0;
    }
    let ue = "";
    for (let ce = 0; se[ce] === 0 && ce < se.length - 1; ++ce)
      ue += this._leader;
    for (let ce = fe.length - 1; ce >= 0; --ce)
      ue += this.alphabet[fe[ce]];
    return ue;
  }
  decode(ie) {
    if (typeof ie != "string")
      throw new TypeError("Expected String");
    let se = [];
    if (ie.length === 0)
      return new Uint8Array(se);
    se.push(0);
    for (let fe = 0; fe < ie.length; fe++) {
      let ue = this._alphabetMap[ie[fe]];
      if (ue === void 0)
        throw new Error("Non-base" + this.base + " character");
      let ce = ue;
      for (let de = 0; de < se.length; ++de)
        ce += se[de] * this.base, se[de] = ce & 255, ce >>= 8;
      for (; ce > 0; )
        se.push(ce & 255), ce >>= 8;
    }
    for (let fe = 0; ie[fe] === this._leader && fe < ie.length - 1; ++fe)
      se.push(0);
    return arrayify(new Uint8Array(se.reverse()));
  }
}
new BaseX("abcdefghijklmnopqrstuvwxyz234567");
const Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var SupportedAlgorithm;
(function(ae) {
  ae.sha256 = "sha256", ae.sha512 = "sha512";
})(SupportedAlgorithm || (SupportedAlgorithm = {}));
const version$8 = "sha2/5.7.0", logger$c = new Logger(version$8);
function ripemd160$1(ae) {
  return "0x" + hash$3.ripemd160().update(arrayify(ae)).digest("hex");
}
function sha256$2(ae) {
  return "0x" + hash$3.sha256().update(arrayify(ae)).digest("hex");
}
function computeHmac(ae, ie, se) {
  return SupportedAlgorithm[ae] || logger$c.throwError("unsupported algorithm " + ae, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "hmac",
    algorithm: ae
  }), "0x" + hash$3.hmac(hash$3[ae], arrayify(ie)).update(arrayify(se)).digest("hex");
}
function pbkdf2$2(ae, ie, se, fe, ue) {
  ae = arrayify(ae), ie = arrayify(ie);
  let ce, de = 1;
  const me = new Uint8Array(fe), we = new Uint8Array(ie.length + 4);
  we.set(ie);
  let Ee, Se;
  for (let Be = 1; Be <= de; Be++) {
    we[ie.length] = Be >> 24 & 255, we[ie.length + 1] = Be >> 16 & 255, we[ie.length + 2] = Be >> 8 & 255, we[ie.length + 3] = Be & 255;
    let Ce = arrayify(computeHmac(ue, ae, we));
    ce || (ce = Ce.length, Se = new Uint8Array(ce), de = Math.ceil(fe / ce), Ee = fe - (de - 1) * ce), Se.set(Ce);
    for (let Ne = 1; Ne < se; Ne++) {
      Ce = arrayify(computeHmac(ue, ae, Ce));
      for (let ke = 0; ke < ce; ke++)
        Se[ke] ^= Ce[ke];
    }
    const Ie = (Be - 1) * ce, Pe = Be === de ? Ee : ce;
    me.set(arrayify(Se).slice(0, Pe), Ie);
  }
  return hexlify(me);
}
const version$7 = "wordlists/5.7.0", logger$b = new Logger(version$7);
class Wordlist {
  constructor(ie) {
    logger$b.checkAbstract(new.target, Wordlist), defineReadOnly(this, "locale", ie);
  }
  // Subclasses may override this
  split(ie) {
    return ie.toLowerCase().split(/ +/g);
  }
  // Subclasses may override this
  join(ie) {
    return ie.join(" ");
  }
  static check(ie) {
    const se = [];
    for (let fe = 0; fe < 2048; fe++) {
      const ue = ie.getWord(fe);
      if (fe !== ie.getWordIndex(ue))
        return "0x";
      se.push(ue);
    }
    return id(se.join(`
`) + `
`);
  }
  static register(ie, se) {
    se || (se = ie.locale);
  }
}
const words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
let wordlist = null;
function loadWords(ae) {
  if (wordlist == null && (wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" "), Wordlist.check(ae) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60"))
    throw wordlist = null, new Error("BIP39 Wordlist for en (English) FAILED");
}
class LangEn extends Wordlist {
  constructor() {
    super("en");
  }
  getWord(ie) {
    return loadWords(this), wordlist[ie];
  }
  getWordIndex(ie) {
    return loadWords(this), wordlist.indexOf(ie);
  }
}
const langEn = new LangEn();
Wordlist.register(langEn);
const wordlists = {
  en: langEn
}, version$6 = "hdnode/5.7.0", logger$a = new Logger(version$6), N$6 = BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), MasterSecret = toUtf8Bytes("Bitcoin seed"), HardenedBit = 2147483648;
function getUpperMask(ae) {
  return (1 << ae) - 1 << 8 - ae;
}
function getLowerMask(ae) {
  return (1 << ae) - 1;
}
function bytes32(ae) {
  return hexZeroPad(hexlify(ae), 32);
}
function base58check$1(ae) {
  return Base58.encode(concat([ae, hexDataSlice(sha256$2(sha256$2(ae)), 0, 4)]));
}
function getWordlist(ae) {
  if (ae == null)
    return wordlists.en;
  if (typeof ae == "string") {
    const ie = wordlists[ae];
    return ie == null && logger$a.throwArgumentError("unknown locale", "wordlist", ae), ie;
  }
  return ae;
}
const _constructorGuard$1 = {}, defaultPath = "m/44'/60'/0'/0/0";
class HDNode {
  /**
   *  This constructor should not be called directly.
   *
   *  Please use:
   *   - fromMnemonic
   *   - fromSeed
   */
  constructor(ie, se, fe, ue, ce, de, me, we) {
    if (ie !== _constructorGuard$1)
      throw new Error("HDNode constructor cannot be called directly");
    if (se) {
      const Ee = new SigningKey(se);
      defineReadOnly(this, "privateKey", Ee.privateKey), defineReadOnly(this, "publicKey", Ee.compressedPublicKey);
    } else
      defineReadOnly(this, "privateKey", null), defineReadOnly(this, "publicKey", hexlify(fe));
    defineReadOnly(this, "parentFingerprint", ue), defineReadOnly(this, "fingerprint", hexDataSlice(ripemd160$1(sha256$2(this.publicKey)), 0, 4)), defineReadOnly(this, "address", computeAddress(this.publicKey)), defineReadOnly(this, "chainCode", ce), defineReadOnly(this, "index", de), defineReadOnly(this, "depth", me), we == null ? (defineReadOnly(this, "mnemonic", null), defineReadOnly(this, "path", null)) : typeof we == "string" ? (defineReadOnly(this, "mnemonic", null), defineReadOnly(this, "path", we)) : (defineReadOnly(this, "mnemonic", we), defineReadOnly(this, "path", we.path));
  }
  get extendedKey() {
    if (this.depth >= 256)
      throw new Error("Depth too large!");
    return base58check$1(concat([
      this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
      hexlify(this.depth),
      this.parentFingerprint,
      hexZeroPad(hexlify(this.index), 4),
      this.chainCode,
      this.privateKey != null ? concat(["0x00", this.privateKey]) : this.publicKey
    ]));
  }
  neuter() {
    return new HDNode(_constructorGuard$1, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
  }
  _derive(ie) {
    if (ie > 4294967295)
      throw new Error("invalid index - " + String(ie));
    let se = this.path;
    se && (se += "/" + (ie & ~HardenedBit));
    const fe = new Uint8Array(37);
    if (ie & HardenedBit) {
      if (!this.privateKey)
        throw new Error("cannot derive child of neutered node");
      fe.set(arrayify(this.privateKey), 1), se && (se += "'");
    } else
      fe.set(arrayify(this.publicKey));
    for (let Be = 24; Be >= 0; Be -= 8)
      fe[33 + (Be >> 3)] = ie >> 24 - Be & 255;
    const ue = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, fe)), ce = ue.slice(0, 32), de = ue.slice(32);
    let me = null, we = null;
    this.privateKey ? me = bytes32(BigNumber.from(ce).add(this.privateKey).mod(N$6)) : we = new SigningKey(hexlify(ce))._addPoint(this.publicKey);
    let Ee = se;
    const Se = this.mnemonic;
    return Se && (Ee = Object.freeze({
      phrase: Se.phrase,
      path: se,
      locale: Se.locale || "en"
    })), new HDNode(_constructorGuard$1, me, we, this.fingerprint, bytes32(de), ie, this.depth + 1, Ee);
  }
  derivePath(ie) {
    const se = ie.split("/");
    if (se.length === 0 || se[0] === "m" && this.depth !== 0)
      throw new Error("invalid path - " + ie);
    se[0] === "m" && se.shift();
    let fe = this;
    for (let ue = 0; ue < se.length; ue++) {
      const ce = se[ue];
      if (ce.match(/^[0-9]+'$/)) {
        const de = parseInt(ce.substring(0, ce.length - 1));
        if (de >= HardenedBit)
          throw new Error("invalid path index - " + ce);
        fe = fe._derive(HardenedBit + de);
      } else if (ce.match(/^[0-9]+$/)) {
        const de = parseInt(ce);
        if (de >= HardenedBit)
          throw new Error("invalid path index - " + ce);
        fe = fe._derive(de);
      } else
        throw new Error("invalid path component - " + ce);
    }
    return fe;
  }
  static _fromSeed(ie, se) {
    const fe = arrayify(ie);
    if (fe.length < 16 || fe.length > 64)
      throw new Error("invalid seed");
    const ue = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, fe));
    return new HDNode(_constructorGuard$1, bytes32(ue.slice(0, 32)), null, "0x00000000", bytes32(ue.slice(32)), 0, 0, se);
  }
  static fromMnemonic(ie, se, fe) {
    return fe = getWordlist(fe), ie = entropyToMnemonic(mnemonicToEntropy(ie, fe), fe), HDNode._fromSeed(mnemonicToSeed(ie, se), {
      phrase: ie,
      path: "m",
      locale: fe.locale
    });
  }
  static fromSeed(ie) {
    return HDNode._fromSeed(ie, null);
  }
  static fromExtendedKey(ie) {
    const se = Base58.decode(ie);
    (se.length !== 82 || base58check$1(se.slice(0, 78)) !== ie) && logger$a.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
    const fe = se[4], ue = hexlify(se.slice(5, 9)), ce = parseInt(hexlify(se.slice(9, 13)).substring(2), 16), de = hexlify(se.slice(13, 45)), me = se.slice(45, 78);
    switch (hexlify(se.slice(0, 4))) {
      case "0x0488b21e":
      case "0x043587cf":
        return new HDNode(_constructorGuard$1, null, hexlify(me), ue, de, ce, fe, null);
      case "0x0488ade4":
      case "0x04358394 ":
        if (me[0] !== 0)
          break;
        return new HDNode(_constructorGuard$1, hexlify(me.slice(1)), null, ue, de, ce, fe, null);
    }
    return logger$a.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
  }
}
function mnemonicToSeed(ae, ie) {
  ie || (ie = "");
  const se = toUtf8Bytes("mnemonic" + ie, UnicodeNormalizationForm.NFKD);
  return pbkdf2$2(toUtf8Bytes(ae, UnicodeNormalizationForm.NFKD), se, 2048, 64, "sha512");
}
function mnemonicToEntropy(ae, ie) {
  ie = getWordlist(ie), logger$a.checkNormalize();
  const se = ie.split(ae);
  if (se.length % 3 !== 0)
    throw new Error("invalid mnemonic");
  const fe = arrayify(new Uint8Array(Math.ceil(11 * se.length / 8)));
  let ue = 0;
  for (let Ee = 0; Ee < se.length; Ee++) {
    let Se = ie.getWordIndex(se[Ee].normalize("NFKD"));
    if (Se === -1)
      throw new Error("invalid mnemonic");
    for (let Be = 0; Be < 11; Be++)
      Se & 1 << 10 - Be && (fe[ue >> 3] |= 1 << 7 - ue % 8), ue++;
  }
  const ce = 32 * se.length / 3, de = se.length / 3, me = getUpperMask(de);
  if ((arrayify(sha256$2(fe.slice(0, ce / 8)))[0] & me) !== (fe[fe.length - 1] & me))
    throw new Error("invalid checksum");
  return hexlify(fe.slice(0, ce / 8));
}
function entropyToMnemonic(ae, ie) {
  if (ie = getWordlist(ie), ae = arrayify(ae), ae.length % 4 !== 0 || ae.length < 16 || ae.length > 32)
    throw new Error("invalid entropy");
  const se = [0];
  let fe = 11;
  for (let de = 0; de < ae.length; de++)
    fe > 8 ? (se[se.length - 1] <<= 8, se[se.length - 1] |= ae[de], fe -= 8) : (se[se.length - 1] <<= fe, se[se.length - 1] |= ae[de] >> 8 - fe, se.push(ae[de] & getLowerMask(8 - fe)), fe += 3);
  const ue = ae.length / 4, ce = arrayify(sha256$2(ae))[0] & getUpperMask(ue);
  return se[se.length - 1] <<= ue, se[se.length - 1] |= ce >> 8 - ue, ie.join(se.map((de) => ie.getWord(de)));
}
const version$5 = "random/5.7.0", logger$9 = new Logger(version$5);
function getGlobal() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global$1 < "u")
    return global$1;
  throw new Error("unable to locate global object");
}
const anyGlobal = getGlobal();
let crypto$2 = anyGlobal.crypto || anyGlobal.msCrypto;
(!crypto$2 || !crypto$2.getRandomValues) && (logger$9.warn("WARNING: Missing strong random number source"), crypto$2 = {
  getRandomValues: function(ae) {
    return logger$9.throwError("no secure random source avaialble", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "crypto.getRandomValues"
    });
  }
});
function randomBytes$1(ae) {
  (ae <= 0 || ae > 1024 || ae % 1 || ae != ae) && logger$9.throwArgumentError("invalid length", "length", ae);
  const ie = new Uint8Array(ae);
  return crypto$2.getRandomValues(ie), arrayify(ie);
}
var aesJs = { exports: {} };
(function(ae, ie) {
  (function(se) {
    function fe(be) {
      return parseInt(be) === be;
    }
    function ue(be) {
      if (!fe(be.length))
        return !1;
      for (var Me = 0; Me < be.length; Me++)
        if (!fe(be[Me]) || be[Me] < 0 || be[Me] > 255)
          return !1;
      return !0;
    }
    function ce(be, Me) {
      if (be.buffer && ArrayBuffer.isView(be) && be.name === "Uint8Array")
        return Me && (be.slice ? be = be.slice() : be = Array.prototype.slice.call(be)), be;
      if (Array.isArray(be)) {
        if (!ue(be))
          throw new Error("Array contains invalid value: " + be);
        return new Uint8Array(be);
      }
      if (fe(be.length) && ue(be))
        return new Uint8Array(be);
      throw new Error("unsupported array-like object");
    }
    function de(be) {
      return new Uint8Array(be);
    }
    function me(be, Me, Re, Oe, Te) {
      (Oe != null || Te != null) && (be.slice ? be = be.slice(Oe, Te) : be = Array.prototype.slice.call(be, Oe, Te)), Me.set(be, Re);
    }
    var we = /* @__PURE__ */ function() {
      function be(Re) {
        var Oe = [], Te = 0;
        for (Re = encodeURI(Re); Te < Re.length; ) {
          var Fe = Re.charCodeAt(Te++);
          Fe === 37 ? (Oe.push(parseInt(Re.substr(Te, 2), 16)), Te += 2) : Oe.push(Fe);
        }
        return ce(Oe);
      }
      function Me(Re) {
        for (var Oe = [], Te = 0; Te < Re.length; ) {
          var Fe = Re[Te];
          Fe < 128 ? (Oe.push(String.fromCharCode(Fe)), Te++) : Fe > 191 && Fe < 224 ? (Oe.push(String.fromCharCode((Fe & 31) << 6 | Re[Te + 1] & 63)), Te += 2) : (Oe.push(String.fromCharCode((Fe & 15) << 12 | (Re[Te + 1] & 63) << 6 | Re[Te + 2] & 63)), Te += 3);
        }
        return Oe.join("");
      }
      return {
        toBytes: be,
        fromBytes: Me
      };
    }(), Ee = /* @__PURE__ */ function() {
      function be(Oe) {
        for (var Te = [], Fe = 0; Fe < Oe.length; Fe += 2)
          Te.push(parseInt(Oe.substr(Fe, 2), 16));
        return Te;
      }
      var Me = "0123456789abcdef";
      function Re(Oe) {
        for (var Te = [], Fe = 0; Fe < Oe.length; Fe++) {
          var je = Oe[Fe];
          Te.push(Me[(je & 240) >> 4] + Me[je & 15]);
        }
        return Te.join("");
      }
      return {
        toBytes: be,
        fromBytes: Re
      };
    }(), Se = { 16: 10, 24: 12, 32: 14 }, Be = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145], Ce = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22], Ie = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125], Pe = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986], Ne = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766], ke = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126], He = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436], De = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890], Ge = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935], Ye = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600], st = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480], at = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795], mt = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855], qe = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150], ze = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
    function ot(be) {
      for (var Me = [], Re = 0; Re < be.length; Re += 4)
        Me.push(
          be[Re] << 24 | be[Re + 1] << 16 | be[Re + 2] << 8 | be[Re + 3]
        );
      return Me;
    }
    var $e = function(be) {
      if (!(this instanceof $e))
        throw Error("AES must be instanitated with `new`");
      Object.defineProperty(this, "key", {
        value: ce(be, !0)
      }), this._prepare();
    };
    $e.prototype._prepare = function() {
      var be = Se[this.key.length];
      if (be == null)
        throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
      this._Ke = [], this._Kd = [];
      for (var Me = 0; Me <= be; Me++)
        this._Ke.push([0, 0, 0, 0]), this._Kd.push([0, 0, 0, 0]);
      for (var Re = (be + 1) * 4, Oe = this.key.length / 4, Te = ot(this.key), Fe, Me = 0; Me < Oe; Me++)
        Fe = Me >> 2, this._Ke[Fe][Me % 4] = Te[Me], this._Kd[be - Fe][Me % 4] = Te[Me];
      for (var je = 0, ct = Oe, nt; ct < Re; ) {
        if (nt = Te[Oe - 1], Te[0] ^= Ce[nt >> 16 & 255] << 24 ^ Ce[nt >> 8 & 255] << 16 ^ Ce[nt & 255] << 8 ^ Ce[nt >> 24 & 255] ^ Be[je] << 24, je += 1, Oe != 8)
          for (var Me = 1; Me < Oe; Me++)
            Te[Me] ^= Te[Me - 1];
        else {
          for (var Me = 1; Me < Oe / 2; Me++)
            Te[Me] ^= Te[Me - 1];
          nt = Te[Oe / 2 - 1], Te[Oe / 2] ^= Ce[nt & 255] ^ Ce[nt >> 8 & 255] << 8 ^ Ce[nt >> 16 & 255] << 16 ^ Ce[nt >> 24 & 255] << 24;
          for (var Me = Oe / 2 + 1; Me < Oe; Me++)
            Te[Me] ^= Te[Me - 1];
        }
        for (var Me = 0, dt, it; Me < Oe && ct < Re; )
          dt = ct >> 2, it = ct % 4, this._Ke[dt][it] = Te[Me], this._Kd[be - dt][it] = Te[Me++], ct++;
      }
      for (var dt = 1; dt < be; dt++)
        for (var it = 0; it < 4; it++)
          nt = this._Kd[dt][it], this._Kd[dt][it] = at[nt >> 24 & 255] ^ mt[nt >> 16 & 255] ^ qe[nt >> 8 & 255] ^ ze[nt & 255];
    }, $e.prototype.encrypt = function(be) {
      if (be.length != 16)
        throw new Error("invalid plaintext size (must be 16 bytes)");
      for (var Me = this._Ke.length - 1, Re = [0, 0, 0, 0], Oe = ot(be), Te = 0; Te < 4; Te++)
        Oe[Te] ^= this._Ke[0][Te];
      for (var Fe = 1; Fe < Me; Fe++) {
        for (var Te = 0; Te < 4; Te++)
          Re[Te] = Pe[Oe[Te] >> 24 & 255] ^ Ne[Oe[(Te + 1) % 4] >> 16 & 255] ^ ke[Oe[(Te + 2) % 4] >> 8 & 255] ^ He[Oe[(Te + 3) % 4] & 255] ^ this._Ke[Fe][Te];
        Oe = Re.slice();
      }
      for (var je = de(16), ct, Te = 0; Te < 4; Te++)
        ct = this._Ke[Me][Te], je[4 * Te] = (Ce[Oe[Te] >> 24 & 255] ^ ct >> 24) & 255, je[4 * Te + 1] = (Ce[Oe[(Te + 1) % 4] >> 16 & 255] ^ ct >> 16) & 255, je[4 * Te + 2] = (Ce[Oe[(Te + 2) % 4] >> 8 & 255] ^ ct >> 8) & 255, je[4 * Te + 3] = (Ce[Oe[(Te + 3) % 4] & 255] ^ ct) & 255;
      return je;
    }, $e.prototype.decrypt = function(be) {
      if (be.length != 16)
        throw new Error("invalid ciphertext size (must be 16 bytes)");
      for (var Me = this._Kd.length - 1, Re = [0, 0, 0, 0], Oe = ot(be), Te = 0; Te < 4; Te++)
        Oe[Te] ^= this._Kd[0][Te];
      for (var Fe = 1; Fe < Me; Fe++) {
        for (var Te = 0; Te < 4; Te++)
          Re[Te] = De[Oe[Te] >> 24 & 255] ^ Ge[Oe[(Te + 3) % 4] >> 16 & 255] ^ Ye[Oe[(Te + 2) % 4] >> 8 & 255] ^ st[Oe[(Te + 1) % 4] & 255] ^ this._Kd[Fe][Te];
        Oe = Re.slice();
      }
      for (var je = de(16), ct, Te = 0; Te < 4; Te++)
        ct = this._Kd[Me][Te], je[4 * Te] = (Ie[Oe[Te] >> 24 & 255] ^ ct >> 24) & 255, je[4 * Te + 1] = (Ie[Oe[(Te + 3) % 4] >> 16 & 255] ^ ct >> 16) & 255, je[4 * Te + 2] = (Ie[Oe[(Te + 2) % 4] >> 8 & 255] ^ ct >> 8) & 255, je[4 * Te + 3] = (Ie[Oe[(Te + 1) % 4] & 255] ^ ct) & 255;
      return je;
    };
    var le = function(be) {
      if (!(this instanceof le))
        throw Error("AES must be instanitated with `new`");
      this.description = "Electronic Code Block", this.name = "ecb", this._aes = new $e(be);
    };
    le.prototype.encrypt = function(be) {
      if (be = ce(be), be.length % 16 !== 0)
        throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
      for (var Me = de(be.length), Re = de(16), Oe = 0; Oe < be.length; Oe += 16)
        me(be, Re, 0, Oe, Oe + 16), Re = this._aes.encrypt(Re), me(Re, Me, Oe);
      return Me;
    }, le.prototype.decrypt = function(be) {
      if (be = ce(be), be.length % 16 !== 0)
        throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
      for (var Me = de(be.length), Re = de(16), Oe = 0; Oe < be.length; Oe += 16)
        me(be, Re, 0, Oe, Oe + 16), Re = this._aes.decrypt(Re), me(Re, Me, Oe);
      return Me;
    };
    var pe = function(be, Me) {
      if (!(this instanceof pe))
        throw Error("AES must be instanitated with `new`");
      if (this.description = "Cipher Block Chaining", this.name = "cbc", !Me)
        Me = de(16);
      else if (Me.length != 16)
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      this._lastCipherblock = ce(Me, !0), this._aes = new $e(be);
    };
    pe.prototype.encrypt = function(be) {
      if (be = ce(be), be.length % 16 !== 0)
        throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
      for (var Me = de(be.length), Re = de(16), Oe = 0; Oe < be.length; Oe += 16) {
        me(be, Re, 0, Oe, Oe + 16);
        for (var Te = 0; Te < 16; Te++)
          Re[Te] ^= this._lastCipherblock[Te];
        this._lastCipherblock = this._aes.encrypt(Re), me(this._lastCipherblock, Me, Oe);
      }
      return Me;
    }, pe.prototype.decrypt = function(be) {
      if (be = ce(be), be.length % 16 !== 0)
        throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
      for (var Me = de(be.length), Re = de(16), Oe = 0; Oe < be.length; Oe += 16) {
        me(be, Re, 0, Oe, Oe + 16), Re = this._aes.decrypt(Re);
        for (var Te = 0; Te < 16; Te++)
          Me[Oe + Te] = Re[Te] ^ this._lastCipherblock[Te];
        me(be, this._lastCipherblock, 0, Oe, Oe + 16);
      }
      return Me;
    };
    var ge = function(be, Me, Re) {
      if (!(this instanceof ge))
        throw Error("AES must be instanitated with `new`");
      if (this.description = "Cipher Feedback", this.name = "cfb", !Me)
        Me = de(16);
      else if (Me.length != 16)
        throw new Error("invalid initialation vector size (must be 16 size)");
      Re || (Re = 1), this.segmentSize = Re, this._shiftRegister = ce(Me, !0), this._aes = new $e(be);
    };
    ge.prototype.encrypt = function(be) {
      if (be.length % this.segmentSize != 0)
        throw new Error("invalid plaintext size (must be segmentSize bytes)");
      for (var Me = ce(be, !0), Re, Oe = 0; Oe < Me.length; Oe += this.segmentSize) {
        Re = this._aes.encrypt(this._shiftRegister);
        for (var Te = 0; Te < this.segmentSize; Te++)
          Me[Oe + Te] ^= Re[Te];
        me(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), me(Me, this._shiftRegister, 16 - this.segmentSize, Oe, Oe + this.segmentSize);
      }
      return Me;
    }, ge.prototype.decrypt = function(be) {
      if (be.length % this.segmentSize != 0)
        throw new Error("invalid ciphertext size (must be segmentSize bytes)");
      for (var Me = ce(be, !0), Re, Oe = 0; Oe < Me.length; Oe += this.segmentSize) {
        Re = this._aes.encrypt(this._shiftRegister);
        for (var Te = 0; Te < this.segmentSize; Te++)
          Me[Oe + Te] ^= Re[Te];
        me(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), me(be, this._shiftRegister, 16 - this.segmentSize, Oe, Oe + this.segmentSize);
      }
      return Me;
    };
    var ye = function(be, Me) {
      if (!(this instanceof ye))
        throw Error("AES must be instanitated with `new`");
      if (this.description = "Output Feedback", this.name = "ofb", !Me)
        Me = de(16);
      else if (Me.length != 16)
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      this._lastPrecipher = ce(Me, !0), this._lastPrecipherIndex = 16, this._aes = new $e(be);
    };
    ye.prototype.encrypt = function(be) {
      for (var Me = ce(be, !0), Re = 0; Re < Me.length; Re++)
        this._lastPrecipherIndex === 16 && (this._lastPrecipher = this._aes.encrypt(this._lastPrecipher), this._lastPrecipherIndex = 0), Me[Re] ^= this._lastPrecipher[this._lastPrecipherIndex++];
      return Me;
    }, ye.prototype.decrypt = ye.prototype.encrypt;
    var xe = function(be) {
      if (!(this instanceof xe))
        throw Error("Counter must be instanitated with `new`");
      be !== 0 && !be && (be = 1), typeof be == "number" ? (this._counter = de(16), this.setValue(be)) : this.setBytes(be);
    };
    xe.prototype.setValue = function(be) {
      if (typeof be != "number" || parseInt(be) != be)
        throw new Error("invalid counter value (must be an integer)");
      for (var Me = 15; Me >= 0; --Me)
        this._counter[Me] = be % 256, be = be >> 8;
    }, xe.prototype.setBytes = function(be) {
      if (be = ce(be, !0), be.length != 16)
        throw new Error("invalid counter bytes size (must be 16 bytes)");
      this._counter = be;
    }, xe.prototype.increment = function() {
      for (var be = 15; be >= 0; be--)
        if (this._counter[be] === 255)
          this._counter[be] = 0;
        else {
          this._counter[be]++;
          break;
        }
    };
    var _e = function(be, Me) {
      if (!(this instanceof _e))
        throw Error("AES must be instanitated with `new`");
      this.description = "Counter", this.name = "ctr", Me instanceof xe || (Me = new xe(Me)), this._counter = Me, this._remainingCounter = null, this._remainingCounterIndex = 16, this._aes = new $e(be);
    };
    _e.prototype.encrypt = function(be) {
      for (var Me = ce(be, !0), Re = 0; Re < Me.length; Re++)
        this._remainingCounterIndex === 16 && (this._remainingCounter = this._aes.encrypt(this._counter._counter), this._remainingCounterIndex = 0, this._counter.increment()), Me[Re] ^= this._remainingCounter[this._remainingCounterIndex++];
      return Me;
    }, _e.prototype.decrypt = _e.prototype.encrypt;
    function Ae(be) {
      be = ce(be, !0);
      var Me = 16 - be.length % 16, Re = de(be.length + Me);
      me(be, Re);
      for (var Oe = be.length; Oe < Re.length; Oe++)
        Re[Oe] = Me;
      return Re;
    }
    function ve(be) {
      if (be = ce(be, !0), be.length < 16)
        throw new Error("PKCS#7 invalid length");
      var Me = be[be.length - 1];
      if (Me > 16)
        throw new Error("PKCS#7 padding byte out of range");
      for (var Re = be.length - Me, Oe = 0; Oe < Me; Oe++)
        if (be[Re + Oe] !== Me)
          throw new Error("PKCS#7 invalid padding byte");
      var Te = de(Re);
      return me(be, Te, 0, 0, Re), Te;
    }
    var he = {
      AES: $e,
      Counter: xe,
      ModeOfOperation: {
        ecb: le,
        cbc: pe,
        cfb: ge,
        ofb: ye,
        ctr: _e
      },
      utils: {
        hex: Ee,
        utf8: we
      },
      padding: {
        pkcs7: {
          pad: Ae,
          strip: ve
        }
      },
      _arrayTest: {
        coerceArray: ce,
        createArray: de,
        copyArray: me
      }
    };
    ae.exports = he;
  })();
})(aesJs);
var aesJsExports = aesJs.exports;
const aes = /* @__PURE__ */ getDefaultExportFromCjs$2(aesJsExports), version$4 = "json-wallets/5.7.0";
function looseArrayify(ae) {
  return typeof ae == "string" && ae.substring(0, 2) !== "0x" && (ae = "0x" + ae), arrayify(ae);
}
function zpad(ae, ie) {
  for (ae = String(ae); ae.length < ie; )
    ae = "0" + ae;
  return ae;
}
function getPassword(ae) {
  return typeof ae == "string" ? toUtf8Bytes(ae, UnicodeNormalizationForm.NFKC) : arrayify(ae);
}
function searchPath(ae, ie) {
  let se = ae;
  const fe = ie.toLowerCase().split("/");
  for (let ue = 0; ue < fe.length; ue++) {
    let ce = null;
    for (const de in se)
      if (de.toLowerCase() === fe[ue]) {
        ce = se[de];
        break;
      }
    if (ce === null)
      return null;
    se = ce;
  }
  return se;
}
function uuidV4(ae) {
  const ie = arrayify(ae);
  ie[6] = ie[6] & 15 | 64, ie[8] = ie[8] & 63 | 128;
  const se = hexlify(ie);
  return [
    se.substring(2, 10),
    se.substring(10, 14),
    se.substring(14, 18),
    se.substring(18, 22),
    se.substring(22, 34)
  ].join("-");
}
const logger$8 = new Logger(version$4);
class CrowdsaleAccount extends Description {
  isCrowdsaleAccount(ie) {
    return !!(ie && ie._isCrowdsaleAccount);
  }
}
function decrypt$1(ae, ie) {
  const se = JSON.parse(ae);
  ie = getPassword(ie);
  const fe = getAddress(searchPath(se, "ethaddr")), ue = looseArrayify(searchPath(se, "encseed"));
  (!ue || ue.length % 16 !== 0) && logger$8.throwArgumentError("invalid encseed", "json", ae);
  const ce = arrayify(pbkdf2$2(ie, ie, 2e3, 32, "sha256")).slice(0, 16), de = ue.slice(0, 16), me = ue.slice(16), we = new aes.ModeOfOperation.cbc(ce, de), Ee = aes.padding.pkcs7.strip(arrayify(we.decrypt(me)));
  let Se = "";
  for (let Ie = 0; Ie < Ee.length; Ie++)
    Se += String.fromCharCode(Ee[Ie]);
  const Be = toUtf8Bytes(Se), Ce = keccak256$1(Be);
  return new CrowdsaleAccount({
    _isCrowdsaleAccount: !0,
    address: fe,
    privateKey: Ce
  });
}
function isCrowdsaleWallet(ae) {
  let ie = null;
  try {
    ie = JSON.parse(ae);
  } catch {
    return !1;
  }
  return ie.encseed && ie.ethaddr;
}
function isKeystoreWallet(ae) {
  let ie = null;
  try {
    ie = JSON.parse(ae);
  } catch {
    return !1;
  }
  return !(!ie.version || parseInt(ie.version) !== ie.version || parseInt(ie.version) !== 3);
}
var scrypt$1 = { exports: {} };
(function(ae, ie) {
  (function(se) {
    function ue(Ne) {
      const ke = new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      let He = 1779033703, De = 3144134277, Ge = 1013904242, Ye = 2773480762, st = 1359893119, at = 2600822924, mt = 528734635, qe = 1541459225;
      const ze = new Uint32Array(64);
      function ot(_e) {
        let Ae = 0, ve = _e.length;
        for (; ve >= 64; ) {
          let he = He, be = De, Me = Ge, Re = Ye, Oe = st, Te = at, Fe = mt, je = qe, ct, nt, dt, it, Je;
          for (nt = 0; nt < 16; nt++)
            dt = Ae + nt * 4, ze[nt] = (_e[dt] & 255) << 24 | (_e[dt + 1] & 255) << 16 | (_e[dt + 2] & 255) << 8 | _e[dt + 3] & 255;
          for (nt = 16; nt < 64; nt++)
            ct = ze[nt - 2], it = (ct >>> 17 | ct << 15) ^ (ct >>> 19 | ct << 13) ^ ct >>> 10, ct = ze[nt - 15], Je = (ct >>> 7 | ct << 25) ^ (ct >>> 18 | ct << 14) ^ ct >>> 3, ze[nt] = (it + ze[nt - 7] | 0) + (Je + ze[nt - 16] | 0) | 0;
          for (nt = 0; nt < 64; nt++)
            it = (((Oe >>> 6 | Oe << 26) ^ (Oe >>> 11 | Oe << 21) ^ (Oe >>> 25 | Oe << 7)) + (Oe & Te ^ ~Oe & Fe) | 0) + (je + (ke[nt] + ze[nt] | 0) | 0) | 0, Je = ((he >>> 2 | he << 30) ^ (he >>> 13 | he << 19) ^ (he >>> 22 | he << 10)) + (he & be ^ he & Me ^ be & Me) | 0, je = Fe, Fe = Te, Te = Oe, Oe = Re + it | 0, Re = Me, Me = be, be = he, he = it + Je | 0;
          He = He + he | 0, De = De + be | 0, Ge = Ge + Me | 0, Ye = Ye + Re | 0, st = st + Oe | 0, at = at + Te | 0, mt = mt + Fe | 0, qe = qe + je | 0, Ae += 64, ve -= 64;
        }
      }
      ot(Ne);
      let $e, le = Ne.length % 64, pe = Ne.length / 536870912 | 0, ge = Ne.length << 3, ye = le < 56 ? 56 : 120, xe = Ne.slice(Ne.length - le, Ne.length);
      for (xe.push(128), $e = le + 1; $e < ye; $e++)
        xe.push(0);
      return xe.push(pe >>> 24 & 255), xe.push(pe >>> 16 & 255), xe.push(pe >>> 8 & 255), xe.push(pe >>> 0 & 255), xe.push(ge >>> 24 & 255), xe.push(ge >>> 16 & 255), xe.push(ge >>> 8 & 255), xe.push(ge >>> 0 & 255), ot(xe), [
        He >>> 24 & 255,
        He >>> 16 & 255,
        He >>> 8 & 255,
        He >>> 0 & 255,
        De >>> 24 & 255,
        De >>> 16 & 255,
        De >>> 8 & 255,
        De >>> 0 & 255,
        Ge >>> 24 & 255,
        Ge >>> 16 & 255,
        Ge >>> 8 & 255,
        Ge >>> 0 & 255,
        Ye >>> 24 & 255,
        Ye >>> 16 & 255,
        Ye >>> 8 & 255,
        Ye >>> 0 & 255,
        st >>> 24 & 255,
        st >>> 16 & 255,
        st >>> 8 & 255,
        st >>> 0 & 255,
        at >>> 24 & 255,
        at >>> 16 & 255,
        at >>> 8 & 255,
        at >>> 0 & 255,
        mt >>> 24 & 255,
        mt >>> 16 & 255,
        mt >>> 8 & 255,
        mt >>> 0 & 255,
        qe >>> 24 & 255,
        qe >>> 16 & 255,
        qe >>> 8 & 255,
        qe >>> 0 & 255
      ];
    }
    function ce(Ne, ke, He) {
      Ne = Ne.length <= 64 ? Ne : ue(Ne);
      const De = 64 + ke.length + 4, Ge = new Array(De), Ye = new Array(64);
      let st, at = [];
      for (st = 0; st < 64; st++)
        Ge[st] = 54;
      for (st = 0; st < Ne.length; st++)
        Ge[st] ^= Ne[st];
      for (st = 0; st < ke.length; st++)
        Ge[64 + st] = ke[st];
      for (st = De - 4; st < De; st++)
        Ge[st] = 0;
      for (st = 0; st < 64; st++)
        Ye[st] = 92;
      for (st = 0; st < Ne.length; st++)
        Ye[st] ^= Ne[st];
      function mt() {
        for (let qe = De - 1; qe >= De - 4; qe--) {
          if (Ge[qe]++, Ge[qe] <= 255)
            return;
          Ge[qe] = 0;
        }
      }
      for (; He >= 32; )
        mt(), at = at.concat(ue(Ye.concat(ue(Ge)))), He -= 32;
      return He > 0 && (mt(), at = at.concat(ue(Ye.concat(ue(Ge))).slice(0, He))), at;
    }
    function de(Ne, ke, He, De, Ge) {
      let Ye;
      for (Se(Ne, (2 * He - 1) * 16, Ge, 0, 16), Ye = 0; Ye < 2 * He; Ye++)
        Ee(Ne, Ye * 16, Ge, 16), we(Ge, De), Se(Ge, 0, Ne, ke + Ye * 16, 16);
      for (Ye = 0; Ye < He; Ye++)
        Se(Ne, ke + Ye * 2 * 16, Ne, Ye * 16, 16);
      for (Ye = 0; Ye < He; Ye++)
        Se(Ne, ke + (Ye * 2 + 1) * 16, Ne, (Ye + He) * 16, 16);
    }
    function me(Ne, ke) {
      return Ne << ke | Ne >>> 32 - ke;
    }
    function we(Ne, ke) {
      Se(Ne, 0, ke, 0, 16);
      for (let He = 8; He > 0; He -= 2)
        ke[4] ^= me(ke[0] + ke[12], 7), ke[8] ^= me(ke[4] + ke[0], 9), ke[12] ^= me(ke[8] + ke[4], 13), ke[0] ^= me(ke[12] + ke[8], 18), ke[9] ^= me(ke[5] + ke[1], 7), ke[13] ^= me(ke[9] + ke[5], 9), ke[1] ^= me(ke[13] + ke[9], 13), ke[5] ^= me(ke[1] + ke[13], 18), ke[14] ^= me(ke[10] + ke[6], 7), ke[2] ^= me(ke[14] + ke[10], 9), ke[6] ^= me(ke[2] + ke[14], 13), ke[10] ^= me(ke[6] + ke[2], 18), ke[3] ^= me(ke[15] + ke[11], 7), ke[7] ^= me(ke[3] + ke[15], 9), ke[11] ^= me(ke[7] + ke[3], 13), ke[15] ^= me(ke[11] + ke[7], 18), ke[1] ^= me(ke[0] + ke[3], 7), ke[2] ^= me(ke[1] + ke[0], 9), ke[3] ^= me(ke[2] + ke[1], 13), ke[0] ^= me(ke[3] + ke[2], 18), ke[6] ^= me(ke[5] + ke[4], 7), ke[7] ^= me(ke[6] + ke[5], 9), ke[4] ^= me(ke[7] + ke[6], 13), ke[5] ^= me(ke[4] + ke[7], 18), ke[11] ^= me(ke[10] + ke[9], 7), ke[8] ^= me(ke[11] + ke[10], 9), ke[9] ^= me(ke[8] + ke[11], 13), ke[10] ^= me(ke[9] + ke[8], 18), ke[12] ^= me(ke[15] + ke[14], 7), ke[13] ^= me(ke[12] + ke[15], 9), ke[14] ^= me(ke[13] + ke[12], 13), ke[15] ^= me(ke[14] + ke[13], 18);
      for (let He = 0; He < 16; ++He)
        Ne[He] += ke[He];
    }
    function Ee(Ne, ke, He, De) {
      for (let Ge = 0; Ge < De; Ge++)
        He[Ge] ^= Ne[ke + Ge];
    }
    function Se(Ne, ke, He, De, Ge) {
      for (; Ge--; )
        He[De++] = Ne[ke++];
    }
    function Be(Ne) {
      if (!Ne || typeof Ne.length != "number")
        return !1;
      for (let ke = 0; ke < Ne.length; ke++) {
        const He = Ne[ke];
        if (typeof He != "number" || He % 1 || He < 0 || He >= 256)
          return !1;
      }
      return !0;
    }
    function Ce(Ne, ke) {
      if (typeof Ne != "number" || Ne % 1)
        throw new Error("invalid " + ke);
      return Ne;
    }
    function Ie(Ne, ke, He, De, Ge, Ye, st) {
      if (He = Ce(He, "N"), De = Ce(De, "r"), Ge = Ce(Ge, "p"), Ye = Ce(Ye, "dkLen"), He === 0 || He & He - 1)
        throw new Error("N must be power of 2");
      if (He > 2147483647 / 128 / De)
        throw new Error("N too large");
      if (De > 2147483647 / 128 / Ge)
        throw new Error("r too large");
      if (!Be(Ne))
        throw new Error("password must be an array or buffer");
      if (Ne = Array.prototype.slice.call(Ne), !Be(ke))
        throw new Error("salt must be an array or buffer");
      ke = Array.prototype.slice.call(ke);
      let at = ce(Ne, ke, Ge * 128 * De);
      const mt = new Uint32Array(Ge * 32 * De);
      for (let Oe = 0; Oe < mt.length; Oe++) {
        const Te = Oe * 4;
        mt[Oe] = (at[Te + 3] & 255) << 24 | (at[Te + 2] & 255) << 16 | (at[Te + 1] & 255) << 8 | (at[Te + 0] & 255) << 0;
      }
      const qe = new Uint32Array(64 * De), ze = new Uint32Array(32 * De * He), ot = 32 * De, $e = new Uint32Array(16), le = new Uint32Array(16), pe = Ge * He * 2;
      let ge = 0, ye = null, xe = !1, _e = 0, Ae = 0, ve, he;
      const be = st ? parseInt(1e3 / De) : 4294967295, Me = typeof setImmediate < "u" ? setImmediate : setTimeout, Re = function() {
        if (xe)
          return st(new Error("cancelled"), ge / pe);
        let Oe;
        switch (_e) {
          case 0:
            he = Ae * 32 * De, Se(mt, he, qe, 0, ot), _e = 1, ve = 0;
          case 1:
            Oe = He - ve, Oe > be && (Oe = be);
            for (let Fe = 0; Fe < Oe; Fe++)
              Se(qe, 0, ze, (ve + Fe) * ot, ot), de(qe, ot, De, $e, le);
            if (ve += Oe, ge += Oe, st) {
              const Fe = parseInt(1e3 * ge / pe);
              if (Fe !== ye) {
                if (xe = st(null, ge / pe), xe)
                  break;
                ye = Fe;
              }
            }
            if (ve < He)
              break;
            ve = 0, _e = 2;
          case 2:
            Oe = He - ve, Oe > be && (Oe = be);
            for (let Fe = 0; Fe < Oe; Fe++) {
              const je = (2 * De - 1) * 16, ct = qe[je] & He - 1;
              Ee(ze, ct * ot, qe, ot), de(qe, ot, De, $e, le);
            }
            if (ve += Oe, ge += Oe, st) {
              const Fe = parseInt(1e3 * ge / pe);
              if (Fe !== ye) {
                if (xe = st(null, ge / pe), xe)
                  break;
                ye = Fe;
              }
            }
            if (ve < He)
              break;
            if (Se(qe, 0, mt, he, ot), Ae++, Ae < Ge) {
              _e = 0;
              break;
            }
            at = [];
            for (let Fe = 0; Fe < mt.length; Fe++)
              at.push(mt[Fe] >> 0 & 255), at.push(mt[Fe] >> 8 & 255), at.push(mt[Fe] >> 16 & 255), at.push(mt[Fe] >> 24 & 255);
            const Te = ce(Ne, at, Ye);
            return st && st(null, 1, Te), Te;
        }
        st && Me(Re);
      };
      if (!st)
        for (; ; ) {
          const Oe = Re();
          if (Oe != null)
            return Oe;
        }
      Re();
    }
    const Pe = {
      scrypt: function(Ne, ke, He, De, Ge, Ye, st) {
        return new Promise(function(at, mt) {
          let qe = 0;
          st && st(0), Ie(Ne, ke, He, De, Ge, Ye, function(ze, ot, $e) {
            if (ze)
              mt(ze);
            else if ($e)
              st && qe !== 1 && st(1), at(new Uint8Array($e));
            else if (st && ot !== qe)
              return qe = ot, st(ot);
          });
        });
      },
      syncScrypt: function(Ne, ke, He, De, Ge, Ye) {
        return new Uint8Array(Ie(Ne, ke, He, De, Ge, Ye));
      }
    };
    ae.exports = Pe;
  })();
})(scrypt$1);
var scryptExports = scrypt$1.exports;
const scrypt = /* @__PURE__ */ getDefaultExportFromCjs$2(scryptExports);
var __awaiter$a = function(ae, ie, se, fe) {
  function ue(ce) {
    return ce instanceof se ? ce : new se(function(de) {
      de(ce);
    });
  }
  return new (se || (se = Promise))(function(ce, de) {
    function me(Se) {
      try {
        Ee(fe.next(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function we(Se) {
      try {
        Ee(fe.throw(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function Ee(Se) {
      Se.done ? ce(Se.value) : ue(Se.value).then(me, we);
    }
    Ee((fe = fe.apply(ae, ie || [])).next());
  });
};
const logger$7 = new Logger(version$4);
function hasMnemonic$1(ae) {
  return ae != null && ae.mnemonic && ae.mnemonic.phrase;
}
class KeystoreAccount extends Description {
  isKeystoreAccount(ie) {
    return !!(ie && ie._isKeystoreAccount);
  }
}
function _decrypt(ae, ie, se) {
  if (searchPath(ae, "crypto/cipher") === "aes-128-ctr") {
    const ue = looseArrayify(searchPath(ae, "crypto/cipherparams/iv")), ce = new aes.Counter(ue), de = new aes.ModeOfOperation.ctr(ie, ce);
    return arrayify(de.decrypt(se));
  }
  return null;
}
function _getAccount(ae, ie) {
  const se = looseArrayify(searchPath(ae, "crypto/ciphertext"));
  if (hexlify(keccak256$1(concat([ie.slice(16, 32), se]))).substring(2) !== searchPath(ae, "crypto/mac").toLowerCase())
    throw new Error("invalid password");
  const ue = _decrypt(ae, ie.slice(0, 16), se);
  ue || logger$7.throwError("unsupported cipher", Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "decrypt"
  });
  const ce = ie.slice(32, 64), de = computeAddress(ue);
  if (ae.address) {
    let we = ae.address.toLowerCase();
    if (we.substring(0, 2) !== "0x" && (we = "0x" + we), getAddress(we) !== de)
      throw new Error("address mismatch");
  }
  const me = {
    _isKeystoreAccount: !0,
    address: de,
    privateKey: hexlify(ue)
  };
  if (searchPath(ae, "x-ethers/version") === "0.1") {
    const we = looseArrayify(searchPath(ae, "x-ethers/mnemonicCiphertext")), Ee = looseArrayify(searchPath(ae, "x-ethers/mnemonicCounter")), Se = new aes.Counter(Ee), Be = new aes.ModeOfOperation.ctr(ce, Se), Ce = searchPath(ae, "x-ethers/path") || defaultPath, Ie = searchPath(ae, "x-ethers/locale") || "en", Pe = arrayify(Be.decrypt(we));
    try {
      const Ne = entropyToMnemonic(Pe, Ie), ke = HDNode.fromMnemonic(Ne, null, Ie).derivePath(Ce);
      if (ke.privateKey != me.privateKey)
        throw new Error("mnemonic mismatch");
      me.mnemonic = ke.mnemonic;
    } catch (Ne) {
      if (Ne.code !== Logger.errors.INVALID_ARGUMENT || Ne.argument !== "wordlist")
        throw Ne;
    }
  }
  return new KeystoreAccount(me);
}
function pbkdf2Sync(ae, ie, se, fe, ue) {
  return arrayify(pbkdf2$2(ae, ie, se, fe, ue));
}
function pbkdf2$1(ae, ie, se, fe, ue) {
  return Promise.resolve(pbkdf2Sync(ae, ie, se, fe, ue));
}
function _computeKdfKey(ae, ie, se, fe, ue) {
  const ce = getPassword(ie), de = searchPath(ae, "crypto/kdf");
  if (de && typeof de == "string") {
    const me = function(we, Ee) {
      return logger$7.throwArgumentError("invalid key-derivation function parameters", we, Ee);
    };
    if (de.toLowerCase() === "scrypt") {
      const we = looseArrayify(searchPath(ae, "crypto/kdfparams/salt")), Ee = parseInt(searchPath(ae, "crypto/kdfparams/n")), Se = parseInt(searchPath(ae, "crypto/kdfparams/r")), Be = parseInt(searchPath(ae, "crypto/kdfparams/p"));
      (!Ee || !Se || !Be) && me("kdf", de), Ee & Ee - 1 && me("N", Ee);
      const Ce = parseInt(searchPath(ae, "crypto/kdfparams/dklen"));
      return Ce !== 32 && me("dklen", Ce), fe(ce, we, Ee, Se, Be, 64, ue);
    } else if (de.toLowerCase() === "pbkdf2") {
      const we = looseArrayify(searchPath(ae, "crypto/kdfparams/salt"));
      let Ee = null;
      const Se = searchPath(ae, "crypto/kdfparams/prf");
      Se === "hmac-sha256" ? Ee = "sha256" : Se === "hmac-sha512" ? Ee = "sha512" : me("prf", Se);
      const Be = parseInt(searchPath(ae, "crypto/kdfparams/c")), Ce = parseInt(searchPath(ae, "crypto/kdfparams/dklen"));
      return Ce !== 32 && me("dklen", Ce), se(ce, we, Be, Ce, Ee);
    }
  }
  return logger$7.throwArgumentError("unsupported key-derivation function", "kdf", de);
}
function decryptSync(ae, ie) {
  const se = JSON.parse(ae), fe = _computeKdfKey(se, ie, pbkdf2Sync, scrypt.syncScrypt);
  return _getAccount(se, fe);
}
function decrypt(ae, ie, se) {
  return __awaiter$a(this, void 0, void 0, function* () {
    const fe = JSON.parse(ae), ue = yield _computeKdfKey(fe, ie, pbkdf2$1, scrypt.scrypt, se);
    return _getAccount(fe, ue);
  });
}
function encrypt(ae, ie, se, fe) {
  try {
    if (getAddress(ae.address) !== computeAddress(ae.privateKey))
      throw new Error("address/privateKey mismatch");
    if (hasMnemonic$1(ae)) {
      const ke = ae.mnemonic;
      if (HDNode.fromMnemonic(ke.phrase, null, ke.locale).derivePath(ke.path || defaultPath).privateKey != ae.privateKey)
        throw new Error("mnemonic mismatch");
    }
  } catch (ke) {
    return Promise.reject(ke);
  }
  typeof se == "function" && !fe && (fe = se, se = {}), se || (se = {});
  const ue = arrayify(ae.privateKey), ce = getPassword(ie);
  let de = null, me = null, we = null;
  if (hasMnemonic$1(ae)) {
    const ke = ae.mnemonic;
    de = arrayify(mnemonicToEntropy(ke.phrase, ke.locale || "en")), me = ke.path || defaultPath, we = ke.locale || "en";
  }
  let Ee = se.client;
  Ee || (Ee = "ethers.js");
  let Se = null;
  se.salt ? Se = arrayify(se.salt) : Se = randomBytes$1(32);
  let Be = null;
  if (se.iv) {
    if (Be = arrayify(se.iv), Be.length !== 16)
      throw new Error("invalid iv");
  } else
    Be = randomBytes$1(16);
  let Ce = null;
  if (se.uuid) {
    if (Ce = arrayify(se.uuid), Ce.length !== 16)
      throw new Error("invalid uuid");
  } else
    Ce = randomBytes$1(16);
  let Ie = 1 << 17, Pe = 8, Ne = 1;
  return se.scrypt && (se.scrypt.N && (Ie = se.scrypt.N), se.scrypt.r && (Pe = se.scrypt.r), se.scrypt.p && (Ne = se.scrypt.p)), scrypt.scrypt(ce, Se, Ie, Pe, Ne, 64, fe).then((ke) => {
    ke = arrayify(ke);
    const He = ke.slice(0, 16), De = ke.slice(16, 32), Ge = ke.slice(32, 64), Ye = new aes.Counter(Be), st = new aes.ModeOfOperation.ctr(He, Ye), at = arrayify(st.encrypt(ue)), mt = keccak256$1(concat([De, at])), qe = {
      address: ae.address.substring(2).toLowerCase(),
      id: uuidV4(Ce),
      version: 3,
      crypto: {
        cipher: "aes-128-ctr",
        cipherparams: {
          iv: hexlify(Be).substring(2)
        },
        ciphertext: hexlify(at).substring(2),
        kdf: "scrypt",
        kdfparams: {
          salt: hexlify(Se).substring(2),
          n: Ie,
          dklen: 32,
          p: Ne,
          r: Pe
        },
        mac: mt.substring(2)
      }
    };
    if (de) {
      const ze = randomBytes$1(16), ot = new aes.Counter(ze), $e = new aes.ModeOfOperation.ctr(Ge, ot), le = arrayify($e.encrypt(de)), pe = /* @__PURE__ */ new Date(), ge = pe.getUTCFullYear() + "-" + zpad(pe.getUTCMonth() + 1, 2) + "-" + zpad(pe.getUTCDate(), 2) + "T" + zpad(pe.getUTCHours(), 2) + "-" + zpad(pe.getUTCMinutes(), 2) + "-" + zpad(pe.getUTCSeconds(), 2) + ".0Z";
      qe["x-ethers"] = {
        client: Ee,
        gethFilename: "UTC--" + ge + "--" + qe.address,
        mnemonicCounter: hexlify(ze).substring(2),
        mnemonicCiphertext: hexlify(le).substring(2),
        path: me,
        locale: we,
        version: "0.1"
      };
    }
    return JSON.stringify(qe);
  });
}
function decryptJsonWallet(ae, ie, se) {
  if (isCrowdsaleWallet(ae)) {
    se && se(0);
    const fe = decrypt$1(ae, ie);
    return se && se(1), Promise.resolve(fe);
  }
  return isKeystoreWallet(ae) ? decrypt(ae, ie, se) : Promise.reject(new Error("invalid JSON wallet"));
}
function decryptJsonWalletSync(ae, ie) {
  if (isCrowdsaleWallet(ae))
    return decrypt$1(ae, ie);
  if (isKeystoreWallet(ae))
    return decryptSync(ae, ie);
  throw new Error("invalid JSON wallet");
}
const version$3 = "wallet/5.7.0";
var __awaiter$9 = function(ae, ie, se, fe) {
  function ue(ce) {
    return ce instanceof se ? ce : new se(function(de) {
      de(ce);
    });
  }
  return new (se || (se = Promise))(function(ce, de) {
    function me(Se) {
      try {
        Ee(fe.next(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function we(Se) {
      try {
        Ee(fe.throw(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function Ee(Se) {
      Se.done ? ce(Se.value) : ue(Se.value).then(me, we);
    }
    Ee((fe = fe.apply(ae, ie || [])).next());
  });
};
const logger$6 = new Logger(version$3);
function isAccount(ae) {
  return ae != null && isHexString$1(ae.privateKey, 32) && ae.address != null;
}
function hasMnemonic(ae) {
  const ie = ae.mnemonic;
  return ie && ie.phrase;
}
let Wallet$1 = class kn extends Signer {
  constructor(ie, se) {
    if (super(), isAccount(ie)) {
      const fe = new SigningKey(ie.privateKey);
      if (defineReadOnly(this, "_signingKey", () => fe), defineReadOnly(this, "address", computeAddress(this.publicKey)), this.address !== getAddress(ie.address) && logger$6.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]"), hasMnemonic(ie)) {
        const ue = ie.mnemonic;
        defineReadOnly(this, "_mnemonic", () => ({
          phrase: ue.phrase,
          path: ue.path || defaultPath,
          locale: ue.locale || "en"
        }));
        const ce = this.mnemonic, de = HDNode.fromMnemonic(ce.phrase, null, ce.locale).derivePath(ce.path);
        computeAddress(de.privateKey) !== this.address && logger$6.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
      } else
        defineReadOnly(this, "_mnemonic", () => null);
    } else {
      if (SigningKey.isSigningKey(ie))
        ie.curve !== "secp256k1" && logger$6.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]"), defineReadOnly(this, "_signingKey", () => ie);
      else {
        typeof ie == "string" && ie.match(/^[0-9a-f]*$/i) && ie.length === 64 && (ie = "0x" + ie);
        const fe = new SigningKey(ie);
        defineReadOnly(this, "_signingKey", () => fe);
      }
      defineReadOnly(this, "_mnemonic", () => null), defineReadOnly(this, "address", computeAddress(this.publicKey));
    }
    se && !Provider.isProvider(se) && logger$6.throwArgumentError("invalid provider", "provider", se), defineReadOnly(this, "provider", se || null);
  }
  get mnemonic() {
    return this._mnemonic();
  }
  get privateKey() {
    return this._signingKey().privateKey;
  }
  get publicKey() {
    return this._signingKey().publicKey;
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  connect(ie) {
    return new kn(this, ie);
  }
  signTransaction(ie) {
    return resolveProperties(ie).then((se) => {
      se.from != null && (getAddress(se.from) !== this.address && logger$6.throwArgumentError("transaction from address mismatch", "transaction.from", ie.from), delete se.from);
      const fe = this._signingKey().signDigest(keccak256$1(serialize$1(se)));
      return serialize$1(se, fe);
    });
  }
  signMessage(ie) {
    return __awaiter$9(this, void 0, void 0, function* () {
      return joinSignature(this._signingKey().signDigest(hashMessage(ie)));
    });
  }
  _signTypedData(ie, se, fe) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const ue = yield TypedDataEncoder.resolveNames(ie, se, fe, (ce) => (this.provider == null && logger$6.throwError("cannot resolve ENS names without a provider", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName",
        value: ce
      }), this.provider.resolveName(ce)));
      return joinSignature(this._signingKey().signDigest(TypedDataEncoder.hash(ue.domain, se, ue.value)));
    });
  }
  encrypt(ie, se, fe) {
    if (typeof se == "function" && !fe && (fe = se, se = {}), fe && typeof fe != "function")
      throw new Error("invalid callback");
    return se || (se = {}), encrypt(this, ie, se, fe);
  }
  /**
   *  Static methods to create Wallet instances.
   */
  static createRandom(ie) {
    let se = randomBytes$1(16);
    ie || (ie = {}), ie.extraEntropy && (se = arrayify(hexDataSlice(keccak256$1(concat([se, ie.extraEntropy])), 0, 16)));
    const fe = entropyToMnemonic(se, ie.locale);
    return kn.fromMnemonic(fe, ie.path, ie.locale);
  }
  static fromEncryptedJson(ie, se, fe) {
    return decryptJsonWallet(ie, se, fe).then((ue) => new kn(ue));
  }
  static fromEncryptedJsonSync(ie, se) {
    return new kn(decryptJsonWalletSync(ie, se));
  }
  static fromMnemonic(ie, se, fe) {
    return se || (se = defaultPath), new kn(HDNode.fromMnemonic(ie, null, fe).derivePath(se));
  }
};
function verifyMessage(ae, ie) {
  return recoverAddress(hashMessage(ae), ie);
}
function verifyTypedData(ae, ie, se, fe) {
  return recoverAddress(TypedDataEncoder.hash(ae, ie, se), fe);
}
class InjectedEthereumSigner {
  // protected signer: JsonRpcSigner;
  signer;
  publicKey;
  ownerLength = SIG_CONFIG[SignatureConfig.ETHEREUM].pubLength;
  signatureLength = SIG_CONFIG[SignatureConfig.ETHEREUM].sigLength;
  signatureType = SignatureConfig.ETHEREUM;
  constructor(ie) {
    this.signer = ie.getSigner();
  }
  async setPublicKey() {
    const ie = "sign this message to connect to Bundlr.Network", se = await this.signer.signMessage(ie), fe = await hashMessage(ie), ue = recoverPublicKey(arrayify(fe), se);
    this.publicKey = Buffer$F.from(arrayify(ue));
  }
  async sign(ie) {
    this.publicKey || await this.setPublicKey();
    const se = await this.signer.signMessage(ie);
    return Buffer$F.from(se.slice(2), "hex");
  }
  static verify(ie, se, fe) {
    const ue = computeAddress(ie);
    return verifyMessage(se, fe) === ue;
  }
}
var _Buffer$2 = safeBufferExports.Buffer;
function base$3(ae) {
  if (ae.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var ie = new Uint8Array(256), se = 0; se < ie.length; se++)
    ie[se] = 255;
  for (var fe = 0; fe < ae.length; fe++) {
    var ue = ae.charAt(fe), ce = ue.charCodeAt(0);
    if (ie[ce] !== 255)
      throw new TypeError(ue + " is ambiguous");
    ie[ce] = fe;
  }
  var de = ae.length, me = ae.charAt(0), we = Math.log(de) / Math.log(256), Ee = Math.log(256) / Math.log(de);
  function Se(Ie) {
    if ((Array.isArray(Ie) || Ie instanceof Uint8Array) && (Ie = _Buffer$2.from(Ie)), !_Buffer$2.isBuffer(Ie))
      throw new TypeError("Expected Buffer");
    if (Ie.length === 0)
      return "";
    for (var Pe = 0, Ne = 0, ke = 0, He = Ie.length; ke !== He && Ie[ke] === 0; )
      ke++, Pe++;
    for (var De = (He - ke) * Ee + 1 >>> 0, Ge = new Uint8Array(De); ke !== He; ) {
      for (var Ye = Ie[ke], st = 0, at = De - 1; (Ye !== 0 || st < Ne) && at !== -1; at--, st++)
        Ye += 256 * Ge[at] >>> 0, Ge[at] = Ye % de >>> 0, Ye = Ye / de >>> 0;
      if (Ye !== 0)
        throw new Error("Non-zero carry");
      Ne = st, ke++;
    }
    for (var mt = De - Ne; mt !== De && Ge[mt] === 0; )
      mt++;
    for (var qe = me.repeat(Pe); mt < De; ++mt)
      qe += ae.charAt(Ge[mt]);
    return qe;
  }
  function Be(Ie) {
    if (typeof Ie != "string")
      throw new TypeError("Expected String");
    if (Ie.length === 0)
      return _Buffer$2.alloc(0);
    for (var Pe = 0, Ne = 0, ke = 0; Ie[Pe] === me; )
      Ne++, Pe++;
    for (var He = (Ie.length - Pe) * we + 1 >>> 0, De = new Uint8Array(He); Ie[Pe]; ) {
      var Ge = ie[Ie.charCodeAt(Pe)];
      if (Ge === 255)
        return;
      for (var Ye = 0, st = He - 1; (Ge !== 0 || Ye < ke) && st !== -1; st--, Ye++)
        Ge += de * De[st] >>> 0, De[st] = Ge % 256 >>> 0, Ge = Ge / 256 >>> 0;
      if (Ge !== 0)
        throw new Error("Non-zero carry");
      ke = Ye, Pe++;
    }
    for (var at = He - ke; at !== He && De[at] === 0; )
      at++;
    var mt = _Buffer$2.allocUnsafe(Ne + (He - at));
    mt.fill(0, 0, Ne);
    for (var qe = Ne; at !== He; )
      mt[qe++] = De[at++];
    return mt;
  }
  function Ce(Ie) {
    var Pe = Be(Ie);
    if (Pe)
      return Pe;
    throw new Error("Non-base" + de + " character");
  }
  return {
    encode: Se,
    decodeUnsafe: Be,
    decode: Ce
  };
}
var src$3 = base$3, basex$3 = src$3, ALPHABET$4 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", bs58$5 = basex$3(ALPHABET$4);
const bs58$6 = /* @__PURE__ */ getDefaultExportFromCjs$2(bs58$5);
class SolanaSigner extends Curve25519 {
  get publicKey() {
    return bs58$6.decode(this.pk);
  }
  get key() {
    return bs58$6.decode(this._key);
  }
  constructor(ie) {
    const se = bs58$6.decode(ie);
    super(bs58$6.encode(se.subarray(0, 32)), bs58$6.encode(se.subarray(32, 64)));
  }
}
const errors$2 = {
  IMPOSSIBLE_CASE: "Impossible case. Please create issue.",
  TWEAK_ADD: "The tweak was out of range or the resulted private key is invalid",
  TWEAK_MUL: "The tweak was out of range or equal to zero",
  CONTEXT_RANDOMIZE_UNKNOW: "Unknow error on context randomization",
  SECKEY_INVALID: "Private Key is invalid",
  PUBKEY_PARSE: "Public Key could not be parsed",
  PUBKEY_SERIALIZE: "Public Key serialization error",
  PUBKEY_COMBINE: "The sum of the public keys is not valid",
  SIG_PARSE: "Signature could not be parsed",
  SIGN: "The nonce generation function failed, or the private key was invalid",
  RECOVER: "Public key could not be recover",
  ECDH: "Scalar was invalid (zero or overflow)"
};
function assert$2(ae, ie) {
  if (!ae)
    throw new Error(ie);
}
function isUint8Array(ae, ie, se) {
  if (assert$2(ie instanceof Uint8Array, `Expected ${ae} to be an Uint8Array`), se !== void 0)
    if (Array.isArray(se)) {
      const fe = se.join(", "), ue = `Expected ${ae} to be an Uint8Array with length [${fe}]`;
      assert$2(se.includes(ie.length), ue);
    } else {
      const fe = `Expected ${ae} to be an Uint8Array with length ${se}`;
      assert$2(ie.length === se, fe);
    }
}
function isCompressed(ae) {
  assert$2(toTypeString(ae) === "Boolean", "Expected compressed to be a Boolean");
}
function getAssertedOutput(ae = (se) => new Uint8Array(se), ie) {
  return typeof ae == "function" && (ae = ae(ie)), isUint8Array("output", ae, ie), ae;
}
function toTypeString(ae) {
  return Object.prototype.toString.call(ae).slice(8, -1);
}
var lib$8 = (ae) => ({
  contextRandomize(ie) {
    switch (assert$2(
      ie === null || ie instanceof Uint8Array,
      "Expected seed to be an Uint8Array or null"
    ), ie !== null && isUint8Array("seed", ie, 32), ae.contextRandomize(ie)) {
      case 1:
        throw new Error(errors$2.CONTEXT_RANDOMIZE_UNKNOW);
    }
  },
  privateKeyVerify(ie) {
    return isUint8Array("private key", ie, 32), ae.privateKeyVerify(ie) === 0;
  },
  privateKeyNegate(ie) {
    switch (isUint8Array("private key", ie, 32), ae.privateKeyNegate(ie)) {
      case 0:
        return ie;
      case 1:
        throw new Error(errors$2.IMPOSSIBLE_CASE);
    }
  },
  privateKeyTweakAdd(ie, se) {
    switch (isUint8Array("private key", ie, 32), isUint8Array("tweak", se, 32), ae.privateKeyTweakAdd(ie, se)) {
      case 0:
        return ie;
      case 1:
        throw new Error(errors$2.TWEAK_ADD);
    }
  },
  privateKeyTweakMul(ie, se) {
    switch (isUint8Array("private key", ie, 32), isUint8Array("tweak", se, 32), ae.privateKeyTweakMul(ie, se)) {
      case 0:
        return ie;
      case 1:
        throw new Error(errors$2.TWEAK_MUL);
    }
  },
  publicKeyVerify(ie) {
    return isUint8Array("public key", ie, [33, 65]), ae.publicKeyVerify(ie) === 0;
  },
  publicKeyCreate(ie, se = !0, fe) {
    switch (isUint8Array("private key", ie, 32), isCompressed(se), fe = getAssertedOutput(fe, se ? 33 : 65), ae.publicKeyCreate(fe, ie)) {
      case 0:
        return fe;
      case 1:
        throw new Error(errors$2.SECKEY_INVALID);
      case 2:
        throw new Error(errors$2.PUBKEY_SERIALIZE);
    }
  },
  publicKeyConvert(ie, se = !0, fe) {
    switch (isUint8Array("public key", ie, [33, 65]), isCompressed(se), fe = getAssertedOutput(fe, se ? 33 : 65), ae.publicKeyConvert(fe, ie)) {
      case 0:
        return fe;
      case 1:
        throw new Error(errors$2.PUBKEY_PARSE);
      case 2:
        throw new Error(errors$2.PUBKEY_SERIALIZE);
    }
  },
  publicKeyNegate(ie, se = !0, fe) {
    switch (isUint8Array("public key", ie, [33, 65]), isCompressed(se), fe = getAssertedOutput(fe, se ? 33 : 65), ae.publicKeyNegate(fe, ie)) {
      case 0:
        return fe;
      case 1:
        throw new Error(errors$2.PUBKEY_PARSE);
      case 2:
        throw new Error(errors$2.IMPOSSIBLE_CASE);
      case 3:
        throw new Error(errors$2.PUBKEY_SERIALIZE);
    }
  },
  publicKeyCombine(ie, se = !0, fe) {
    assert$2(Array.isArray(ie), "Expected public keys to be an Array"), assert$2(ie.length > 0, "Expected public keys array will have more than zero items");
    for (const ue of ie)
      isUint8Array("public key", ue, [33, 65]);
    switch (isCompressed(se), fe = getAssertedOutput(fe, se ? 33 : 65), ae.publicKeyCombine(fe, ie)) {
      case 0:
        return fe;
      case 1:
        throw new Error(errors$2.PUBKEY_PARSE);
      case 2:
        throw new Error(errors$2.PUBKEY_COMBINE);
      case 3:
        throw new Error(errors$2.PUBKEY_SERIALIZE);
    }
  },
  publicKeyTweakAdd(ie, se, fe = !0, ue) {
    switch (isUint8Array("public key", ie, [33, 65]), isUint8Array("tweak", se, 32), isCompressed(fe), ue = getAssertedOutput(ue, fe ? 33 : 65), ae.publicKeyTweakAdd(ue, ie, se)) {
      case 0:
        return ue;
      case 1:
        throw new Error(errors$2.PUBKEY_PARSE);
      case 2:
        throw new Error(errors$2.TWEAK_ADD);
    }
  },
  publicKeyTweakMul(ie, se, fe = !0, ue) {
    switch (isUint8Array("public key", ie, [33, 65]), isUint8Array("tweak", se, 32), isCompressed(fe), ue = getAssertedOutput(ue, fe ? 33 : 65), ae.publicKeyTweakMul(ue, ie, se)) {
      case 0:
        return ue;
      case 1:
        throw new Error(errors$2.PUBKEY_PARSE);
      case 2:
        throw new Error(errors$2.TWEAK_MUL);
    }
  },
  signatureNormalize(ie) {
    switch (isUint8Array("signature", ie, 64), ae.signatureNormalize(ie)) {
      case 0:
        return ie;
      case 1:
        throw new Error(errors$2.SIG_PARSE);
    }
  },
  signatureExport(ie, se) {
    isUint8Array("signature", ie, 64), se = getAssertedOutput(se, 72);
    const fe = { output: se, outputlen: 72 };
    switch (ae.signatureExport(fe, ie)) {
      case 0:
        return se.slice(0, fe.outputlen);
      case 1:
        throw new Error(errors$2.SIG_PARSE);
      case 2:
        throw new Error(errors$2.IMPOSSIBLE_CASE);
    }
  },
  signatureImport(ie, se) {
    switch (isUint8Array("signature", ie), se = getAssertedOutput(se, 64), ae.signatureImport(se, ie)) {
      case 0:
        return se;
      case 1:
        throw new Error(errors$2.SIG_PARSE);
      case 2:
        throw new Error(errors$2.IMPOSSIBLE_CASE);
    }
  },
  ecdsaSign(ie, se, fe = {}, ue) {
    isUint8Array("message", ie, 32), isUint8Array("private key", se, 32), assert$2(toTypeString(fe) === "Object", "Expected options to be an Object"), fe.data !== void 0 && isUint8Array("options.data", fe.data), fe.noncefn !== void 0 && assert$2(toTypeString(fe.noncefn) === "Function", "Expected options.noncefn to be a Function"), ue = getAssertedOutput(ue, 64);
    const ce = { signature: ue, recid: null };
    switch (ae.ecdsaSign(ce, ie, se, fe.data, fe.noncefn)) {
      case 0:
        return ce;
      case 1:
        throw new Error(errors$2.SIGN);
      case 2:
        throw new Error(errors$2.IMPOSSIBLE_CASE);
    }
  },
  ecdsaVerify(ie, se, fe) {
    switch (isUint8Array("signature", ie, 64), isUint8Array("message", se, 32), isUint8Array("public key", fe, [33, 65]), ae.ecdsaVerify(ie, se, fe)) {
      case 0:
        return !0;
      case 3:
        return !1;
      case 1:
        throw new Error(errors$2.SIG_PARSE);
      case 2:
        throw new Error(errors$2.PUBKEY_PARSE);
    }
  },
  ecdsaRecover(ie, se, fe, ue = !0, ce) {
    switch (isUint8Array("signature", ie, 64), assert$2(
      toTypeString(se) === "Number" && se >= 0 && se <= 3,
      "Expected recovery id to be a Number within interval [0, 3]"
    ), isUint8Array("message", fe, 32), isCompressed(ue), ce = getAssertedOutput(ce, ue ? 33 : 65), ae.ecdsaRecover(ce, ie, se, fe)) {
      case 0:
        return ce;
      case 1:
        throw new Error(errors$2.SIG_PARSE);
      case 2:
        throw new Error(errors$2.RECOVER);
      case 3:
        throw new Error(errors$2.IMPOSSIBLE_CASE);
    }
  },
  ecdh(ie, se, fe = {}, ue) {
    switch (isUint8Array("public key", ie, [33, 65]), isUint8Array("private key", se, 32), assert$2(toTypeString(fe) === "Object", "Expected options to be an Object"), fe.data !== void 0 && isUint8Array("options.data", fe.data), fe.hashfn !== void 0 ? (assert$2(toTypeString(fe.hashfn) === "Function", "Expected options.hashfn to be a Function"), fe.xbuf !== void 0 && isUint8Array("options.xbuf", fe.xbuf, 32), fe.ybuf !== void 0 && isUint8Array("options.ybuf", fe.ybuf, 32), isUint8Array("output", ue)) : ue = getAssertedOutput(ue, 32), ae.ecdh(ue, ie, se, fe.data, fe.hashfn, fe.xbuf, fe.ybuf)) {
      case 0:
        return ue;
      case 1:
        throw new Error(errors$2.PUBKEY_PARSE);
      case 2:
        throw new Error(errors$2.ECDH);
    }
  }
});
const EC = requireElliptic().ec, ec = new EC("secp256k1"), ecparams = ec.curve, BN = ecparams.n.constructor;
function loadCompressedPublicKey(ae, ie) {
  let se = new BN(ie);
  if (se.cmp(ecparams.p) >= 0)
    return null;
  se = se.toRed(ecparams.red);
  let fe = se.redSqr().redIMul(se).redIAdd(ecparams.b).redSqrt();
  return ae === 3 !== fe.isOdd() && (fe = fe.redNeg()), ec.keyPair({ pub: { x: se, y: fe } });
}
function loadUncompressedPublicKey(ae, ie, se) {
  let fe = new BN(ie), ue = new BN(se);
  if (fe.cmp(ecparams.p) >= 0 || ue.cmp(ecparams.p) >= 0 || (fe = fe.toRed(ecparams.red), ue = ue.toRed(ecparams.red), (ae === 6 || ae === 7) && ue.isOdd() !== (ae === 7)))
    return null;
  const ce = fe.redSqr().redIMul(fe);
  return ue.redSqr().redISub(ce.redIAdd(ecparams.b)).isZero() ? ec.keyPair({ pub: { x: fe, y: ue } }) : null;
}
function loadPublicKey(ae) {
  const ie = ae[0];
  switch (ie) {
    case 2:
    case 3:
      return ae.length !== 33 ? null : loadCompressedPublicKey(ie, ae.subarray(1, 33));
    case 4:
    case 6:
    case 7:
      return ae.length !== 65 ? null : loadUncompressedPublicKey(ie, ae.subarray(1, 33), ae.subarray(33, 65));
    default:
      return null;
  }
}
function savePublicKey(ae, ie) {
  const se = ie.encode(null, ae.length === 33);
  for (let fe = 0; fe < ae.length; ++fe)
    ae[fe] = se[fe];
}
var elliptic$1 = {
  contextRandomize() {
    return 0;
  },
  privateKeyVerify(ae) {
    const ie = new BN(ae);
    return ie.cmp(ecparams.n) < 0 && !ie.isZero() ? 0 : 1;
  },
  privateKeyNegate(ae) {
    const ie = new BN(ae), se = ecparams.n.sub(ie).umod(ecparams.n).toArrayLike(Uint8Array, "be", 32);
    return ae.set(se), 0;
  },
  privateKeyTweakAdd(ae, ie) {
    const se = new BN(ie);
    if (se.cmp(ecparams.n) >= 0 || (se.iadd(new BN(ae)), se.cmp(ecparams.n) >= 0 && se.isub(ecparams.n), se.isZero()))
      return 1;
    const fe = se.toArrayLike(Uint8Array, "be", 32);
    return ae.set(fe), 0;
  },
  privateKeyTweakMul(ae, ie) {
    let se = new BN(ie);
    if (se.cmp(ecparams.n) >= 0 || se.isZero())
      return 1;
    se.imul(new BN(ae)), se.cmp(ecparams.n) >= 0 && (se = se.umod(ecparams.n));
    const fe = se.toArrayLike(Uint8Array, "be", 32);
    return ae.set(fe), 0;
  },
  publicKeyVerify(ae) {
    return loadPublicKey(ae) === null ? 1 : 0;
  },
  publicKeyCreate(ae, ie) {
    const se = new BN(ie);
    if (se.cmp(ecparams.n) >= 0 || se.isZero())
      return 1;
    const fe = ec.keyFromPrivate(ie).getPublic();
    return savePublicKey(ae, fe), 0;
  },
  publicKeyConvert(ae, ie) {
    const se = loadPublicKey(ie);
    if (se === null)
      return 1;
    const fe = se.getPublic();
    return savePublicKey(ae, fe), 0;
  },
  publicKeyNegate(ae, ie) {
    const se = loadPublicKey(ie);
    if (se === null)
      return 1;
    const fe = se.getPublic();
    return fe.y = fe.y.redNeg(), savePublicKey(ae, fe), 0;
  },
  publicKeyCombine(ae, ie) {
    const se = new Array(ie.length);
    for (let ue = 0; ue < ie.length; ++ue)
      if (se[ue] = loadPublicKey(ie[ue]), se[ue] === null)
        return 1;
    let fe = se[0].getPublic();
    for (let ue = 1; ue < se.length; ++ue)
      fe = fe.add(se[ue].pub);
    return fe.isInfinity() ? 2 : (savePublicKey(ae, fe), 0);
  },
  publicKeyTweakAdd(ae, ie, se) {
    const fe = loadPublicKey(ie);
    if (fe === null)
      return 1;
    if (se = new BN(se), se.cmp(ecparams.n) >= 0)
      return 2;
    const ue = fe.getPublic().add(ecparams.g.mul(se));
    return ue.isInfinity() ? 2 : (savePublicKey(ae, ue), 0);
  },
  publicKeyTweakMul(ae, ie, se) {
    const fe = loadPublicKey(ie);
    if (fe === null)
      return 1;
    if (se = new BN(se), se.cmp(ecparams.n) >= 0 || se.isZero())
      return 2;
    const ue = fe.getPublic().mul(se);
    return savePublicKey(ae, ue), 0;
  },
  signatureNormalize(ae) {
    const ie = new BN(ae.subarray(0, 32)), se = new BN(ae.subarray(32, 64));
    return ie.cmp(ecparams.n) >= 0 || se.cmp(ecparams.n) >= 0 ? 1 : (se.cmp(ec.nh) === 1 && ae.set(ecparams.n.sub(se).toArrayLike(Uint8Array, "be", 32), 32), 0);
  },
  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
  // Adapted for Uint8Array instead Buffer
  signatureExport(ae, ie) {
    const se = ie.subarray(0, 32), fe = ie.subarray(32, 64);
    if (new BN(se).cmp(ecparams.n) >= 0 || new BN(fe).cmp(ecparams.n) >= 0)
      return 1;
    const { output: ue } = ae;
    let ce = ue.subarray(4, 37);
    ce[0] = 0, ce.set(se, 1);
    let de = 33, me = 0;
    for (; de > 1 && ce[me] === 0 && !(ce[me + 1] & 128); --de, ++me)
      ;
    if (ce = ce.subarray(me), ce[0] & 128 || de > 1 && ce[0] === 0 && !(ce[1] & 128))
      return 1;
    let we = ue.subarray(39, 72);
    we[0] = 0, we.set(fe, 1);
    let Ee = 33, Se = 0;
    for (; Ee > 1 && we[Se] === 0 && !(we[Se + 1] & 128); --Ee, ++Se)
      ;
    return we = we.subarray(Se), we[0] & 128 || Ee > 1 && we[0] === 0 && !(we[1] & 128) ? 1 : (ae.outputlen = 6 + de + Ee, ue[0] = 48, ue[1] = ae.outputlen - 2, ue[2] = 2, ue[3] = ce.length, ue.set(ce, 4), ue[4 + de] = 2, ue[5 + de] = we.length, ue.set(we, 6 + de), 0);
  },
  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
  // Adapted for Uint8Array instead Buffer
  signatureImport(ae, ie) {
    if (ie.length < 8 || ie.length > 72 || ie[0] !== 48 || ie[1] !== ie.length - 2 || ie[2] !== 2)
      return 1;
    const se = ie[3];
    if (se === 0 || 5 + se >= ie.length || ie[4 + se] !== 2)
      return 1;
    const fe = ie[5 + se];
    if (fe === 0 || 6 + se + fe !== ie.length || ie[4] & 128 || se > 1 && ie[4] === 0 && !(ie[5] & 128) || ie[se + 6] & 128 || fe > 1 && ie[se + 6] === 0 && !(ie[se + 7] & 128))
      return 1;
    let ue = ie.subarray(4, 4 + se);
    if (ue.length === 33 && ue[0] === 0 && (ue = ue.subarray(1)), ue.length > 32)
      return 1;
    let ce = ie.subarray(6 + se);
    if (ce.length === 33 && ce[0] === 0 && (ce = ce.slice(1)), ce.length > 32)
      throw new Error("S length is too long");
    let de = new BN(ue);
    de.cmp(ecparams.n) >= 0 && (de = new BN(0));
    let me = new BN(ie.subarray(6 + se));
    return me.cmp(ecparams.n) >= 0 && (me = new BN(0)), ae.set(de.toArrayLike(Uint8Array, "be", 32), 0), ae.set(me.toArrayLike(Uint8Array, "be", 32), 32), 0;
  },
  ecdsaSign(ae, ie, se, fe, ue) {
    if (ue) {
      const me = ue;
      ue = (we) => {
        const Ee = me(ie, se, null, fe, we);
        if (!(Ee instanceof Uint8Array && Ee.length === 32))
          throw new Error("This is the way");
        return new BN(Ee);
      };
    }
    const ce = new BN(se);
    if (ce.cmp(ecparams.n) >= 0 || ce.isZero())
      return 1;
    let de;
    try {
      de = ec.sign(ie, se, { canonical: !0, k: ue, pers: fe });
    } catch {
      return 1;
    }
    return ae.signature.set(de.r.toArrayLike(Uint8Array, "be", 32), 0), ae.signature.set(de.s.toArrayLike(Uint8Array, "be", 32), 32), ae.recid = de.recoveryParam, 0;
  },
  ecdsaVerify(ae, ie, se) {
    const fe = { r: ae.subarray(0, 32), s: ae.subarray(32, 64) }, ue = new BN(fe.r), ce = new BN(fe.s);
    if (ue.cmp(ecparams.n) >= 0 || ce.cmp(ecparams.n) >= 0)
      return 1;
    if (ce.cmp(ec.nh) === 1 || ue.isZero() || ce.isZero())
      return 3;
    const de = loadPublicKey(se);
    if (de === null)
      return 2;
    const me = de.getPublic();
    return ec.verify(ie, fe, me) ? 0 : 3;
  },
  ecdsaRecover(ae, ie, se, fe) {
    const ue = { r: ie.slice(0, 32), s: ie.slice(32, 64) }, ce = new BN(ue.r), de = new BN(ue.s);
    if (ce.cmp(ecparams.n) >= 0 || de.cmp(ecparams.n) >= 0)
      return 1;
    if (ce.isZero() || de.isZero())
      return 2;
    let me;
    try {
      me = ec.recoverPubKey(fe, ue, se);
    } catch {
      return 2;
    }
    return savePublicKey(ae, me), 0;
  },
  ecdh(ae, ie, se, fe, ue, ce, de) {
    const me = loadPublicKey(ie);
    if (me === null)
      return 1;
    const we = new BN(se);
    if (we.cmp(ecparams.n) >= 0 || we.isZero())
      return 2;
    const Ee = me.getPublic().mul(we);
    if (ue === void 0) {
      const Se = Ee.encode(null, !0), Be = ec.hash().update(Se).digest();
      for (let Ce = 0; Ce < 32; ++Ce)
        ae[Ce] = Be[Ce];
    } else {
      ce || (ce = new Uint8Array(32));
      const Se = Ee.getX().toArray("be", 32);
      for (let Pe = 0; Pe < 32; ++Pe)
        ce[Pe] = Se[Pe];
      de || (de = new Uint8Array(32));
      const Be = Ee.getY().toArray("be", 32);
      for (let Pe = 0; Pe < 32; ++Pe)
        de[Pe] = Be[Pe];
      const Ce = ue(ce, de, fe);
      if (!(Ce instanceof Uint8Array && Ce.length === ae.length))
        return 2;
      ae.set(Ce);
    }
    return 0;
  }
}, elliptic = lib$8(elliptic$1);
const secp256k1$1 = /* @__PURE__ */ getDefaultExportFromCjs$2(elliptic), { Transform: Transform$1 } = readableBrowserExports;
var keccak$1 = (ae) => class ti extends Transform$1 {
  constructor(se, fe, ue, ce, de) {
    super(de), this._rate = se, this._capacity = fe, this._delimitedSuffix = ue, this._hashBitLength = ce, this._options = de, this._state = new ae(), this._state.initialize(se, fe), this._finalized = !1;
  }
  _transform(se, fe, ue) {
    let ce = null;
    try {
      this.update(se, fe);
    } catch (de) {
      ce = de;
    }
    ue(ce);
  }
  _flush(se) {
    let fe = null;
    try {
      this.push(this.digest());
    } catch (ue) {
      fe = ue;
    }
    se(fe);
  }
  update(se, fe) {
    if (!Buffer$F.isBuffer(se) && typeof se != "string")
      throw new TypeError("Data must be a string or a buffer");
    if (this._finalized)
      throw new Error("Digest already called");
    return Buffer$F.isBuffer(se) || (se = Buffer$F.from(se, fe)), this._state.absorb(se), this;
  }
  digest(se) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = !0, this._delimitedSuffix && this._state.absorbLastFewBits(this._delimitedSuffix);
    let fe = this._state.squeeze(this._hashBitLength / 8);
    return se !== void 0 && (fe = fe.toString(se)), this._resetState(), fe;
  }
  // remove result from memory
  _resetState() {
    return this._state.initialize(this._rate, this._capacity), this;
  }
  // because sometimes we need hash right now and little later
  _clone() {
    const se = new ti(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
    return this._state.copy(se._state), se._finalized = this._finalized, se;
  }
};
const { Transform } = readableBrowserExports;
var shake = (ae) => class ri extends Transform {
  constructor(se, fe, ue, ce) {
    super(ce), this._rate = se, this._capacity = fe, this._delimitedSuffix = ue, this._options = ce, this._state = new ae(), this._state.initialize(se, fe), this._finalized = !1;
  }
  _transform(se, fe, ue) {
    let ce = null;
    try {
      this.update(se, fe);
    } catch (de) {
      ce = de;
    }
    ue(ce);
  }
  _flush() {
  }
  _read(se) {
    this.push(this.squeeze(se));
  }
  update(se, fe) {
    if (!Buffer$F.isBuffer(se) && typeof se != "string")
      throw new TypeError("Data must be a string or a buffer");
    if (this._finalized)
      throw new Error("Squeeze already called");
    return Buffer$F.isBuffer(se) || (se = Buffer$F.from(se, fe)), this._state.absorb(se), this;
  }
  squeeze(se, fe) {
    this._finalized || (this._finalized = !0, this._state.absorbLastFewBits(this._delimitedSuffix));
    let ue = this._state.squeeze(se);
    return fe !== void 0 && (ue = ue.toString(fe)), ue;
  }
  _resetState() {
    return this._state.initialize(this._rate, this._capacity), this;
  }
  _clone() {
    const se = new ri(this._rate, this._capacity, this._delimitedSuffix, this._options);
    return this._state.copy(se._state), se._finalized = this._finalized, se;
  }
};
const createKeccak = keccak$1, createShake = shake;
var api = function(ae) {
  const ie = createKeccak(ae), se = createShake(ae);
  return function(fe, ue) {
    switch (typeof fe == "string" ? fe.toLowerCase() : fe) {
      case "keccak224":
        return new ie(1152, 448, null, 224, ue);
      case "keccak256":
        return new ie(1088, 512, null, 256, ue);
      case "keccak384":
        return new ie(832, 768, null, 384, ue);
      case "keccak512":
        return new ie(576, 1024, null, 512, ue);
      case "sha3-224":
        return new ie(1152, 448, 6, 224, ue);
      case "sha3-256":
        return new ie(1088, 512, 6, 256, ue);
      case "sha3-384":
        return new ie(832, 768, 6, 384, ue);
      case "sha3-512":
        return new ie(576, 1024, 6, 512, ue);
      case "shake128":
        return new se(1344, 256, 31, ue);
      case "shake256":
        return new se(1088, 512, 31, ue);
      default:
        throw new Error("Invald algorithm: " + fe);
    }
  };
}, keccakStateUnroll = {};
const P1600_ROUND_CONSTANTS = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
keccakStateUnroll.p1600 = function(ae) {
  for (let ie = 0; ie < 24; ++ie) {
    const se = ae[0] ^ ae[10] ^ ae[20] ^ ae[30] ^ ae[40], fe = ae[1] ^ ae[11] ^ ae[21] ^ ae[31] ^ ae[41], ue = ae[2] ^ ae[12] ^ ae[22] ^ ae[32] ^ ae[42], ce = ae[3] ^ ae[13] ^ ae[23] ^ ae[33] ^ ae[43], de = ae[4] ^ ae[14] ^ ae[24] ^ ae[34] ^ ae[44], me = ae[5] ^ ae[15] ^ ae[25] ^ ae[35] ^ ae[45], we = ae[6] ^ ae[16] ^ ae[26] ^ ae[36] ^ ae[46], Ee = ae[7] ^ ae[17] ^ ae[27] ^ ae[37] ^ ae[47], Se = ae[8] ^ ae[18] ^ ae[28] ^ ae[38] ^ ae[48], Be = ae[9] ^ ae[19] ^ ae[29] ^ ae[39] ^ ae[49];
    let Ce = Se ^ (ue << 1 | ce >>> 31), Ie = Be ^ (ce << 1 | ue >>> 31);
    const Pe = ae[0] ^ Ce, Ne = ae[1] ^ Ie, ke = ae[10] ^ Ce, He = ae[11] ^ Ie, De = ae[20] ^ Ce, Ge = ae[21] ^ Ie, Ye = ae[30] ^ Ce, st = ae[31] ^ Ie, at = ae[40] ^ Ce, mt = ae[41] ^ Ie;
    Ce = se ^ (de << 1 | me >>> 31), Ie = fe ^ (me << 1 | de >>> 31);
    const qe = ae[2] ^ Ce, ze = ae[3] ^ Ie, ot = ae[12] ^ Ce, $e = ae[13] ^ Ie, le = ae[22] ^ Ce, pe = ae[23] ^ Ie, ge = ae[32] ^ Ce, ye = ae[33] ^ Ie, xe = ae[42] ^ Ce, _e = ae[43] ^ Ie;
    Ce = ue ^ (we << 1 | Ee >>> 31), Ie = ce ^ (Ee << 1 | we >>> 31);
    const Ae = ae[4] ^ Ce, ve = ae[5] ^ Ie, he = ae[14] ^ Ce, be = ae[15] ^ Ie, Me = ae[24] ^ Ce, Re = ae[25] ^ Ie, Oe = ae[34] ^ Ce, Te = ae[35] ^ Ie, Fe = ae[44] ^ Ce, je = ae[45] ^ Ie;
    Ce = de ^ (Se << 1 | Be >>> 31), Ie = me ^ (Be << 1 | Se >>> 31);
    const ct = ae[6] ^ Ce, nt = ae[7] ^ Ie, dt = ae[16] ^ Ce, it = ae[17] ^ Ie, Je = ae[26] ^ Ce, gt = ae[27] ^ Ie, Ht = ae[36] ^ Ce, $t = ae[37] ^ Ie, Lt = ae[46] ^ Ce, Tr = ae[47] ^ Ie;
    Ce = we ^ (se << 1 | fe >>> 31), Ie = Ee ^ (fe << 1 | se >>> 31);
    const Zt = ae[8] ^ Ce, wt = ae[9] ^ Ie, Hr = ae[18] ^ Ce, tr = ae[19] ^ Ie, cr = ae[28] ^ Ce, qr = ae[29] ^ Ie, Wt = ae[38] ^ Ce, ar = ae[39] ^ Ie, Dr = ae[48] ^ Ce, Jt = ae[49] ^ Ie, ir = Pe, Gr = Ne, We = He << 4 | ke >>> 28, Le = ke << 4 | He >>> 28, Ke = De << 3 | Ge >>> 29, rt = Ge << 3 | De >>> 29, lt = st << 9 | Ye >>> 23, It = Ye << 9 | st >>> 23, yt = at << 18 | mt >>> 14, jt = mt << 18 | at >>> 14, Lr = qe << 1 | ze >>> 31, zt = ze << 1 | qe >>> 31, rr = $e << 12 | ot >>> 20, Cr = ot << 12 | $e >>> 20, fr = le << 10 | pe >>> 22, pr = pe << 10 | le >>> 22, jr = ye << 13 | ge >>> 19, nr = ge << 13 | ye >>> 19, ur = xe << 2 | _e >>> 30, Wr = _e << 2 | xe >>> 30, or = ve << 30 | Ae >>> 2, lr = Ae << 30 | ve >>> 2, Zr = he << 6 | be >>> 26, Xt = be << 6 | he >>> 26, dr = Re << 11 | Me >>> 21, Ve = Me << 11 | Re >>> 21, Ze = Oe << 15 | Te >>> 17, Xe = Te << 15 | Oe >>> 17, Ue = je << 29 | Fe >>> 3, Qe = Fe << 29 | je >>> 3, pt = ct << 28 | nt >>> 4, Ct = nt << 28 | ct >>> 4, bt = it << 23 | dt >>> 9, Tt = dt << 23 | it >>> 9, br = Je << 25 | gt >>> 7, gr = gt << 25 | Je >>> 7, Fr = Ht << 21 | $t >>> 11, wr = $t << 21 | Ht >>> 11, Rr = Tr << 24 | Lt >>> 8, kr = Lt << 24 | Tr >>> 8, Pr = Zt << 27 | wt >>> 5, Ur = wt << 27 | Zt >>> 5, Ir = Hr << 20 | tr >>> 12, Or = tr << 20 | Hr >>> 12, Nr = qr << 7 | cr >>> 25, Er = cr << 7 | qr >>> 25, Br = Wt << 8 | ar >>> 24, _r = ar << 8 | Wt >>> 24, Sr = Dr << 14 | Jt >>> 18, Mr = Jt << 14 | Dr >>> 18;
    ae[0] = ir ^ ~rr & dr, ae[1] = Gr ^ ~Cr & Ve, ae[10] = pt ^ ~Ir & Ke, ae[11] = Ct ^ ~Or & rt, ae[20] = Lr ^ ~Zr & br, ae[21] = zt ^ ~Xt & gr, ae[30] = Pr ^ ~We & fr, ae[31] = Ur ^ ~Le & pr, ae[40] = or ^ ~bt & Nr, ae[41] = lr ^ ~Tt & Er, ae[2] = rr ^ ~dr & Fr, ae[3] = Cr ^ ~Ve & wr, ae[12] = Ir ^ ~Ke & jr, ae[13] = Or ^ ~rt & nr, ae[22] = Zr ^ ~br & Br, ae[23] = Xt ^ ~gr & _r, ae[32] = We ^ ~fr & Ze, ae[33] = Le ^ ~pr & Xe, ae[42] = bt ^ ~Nr & lt, ae[43] = Tt ^ ~Er & It, ae[4] = dr ^ ~Fr & Sr, ae[5] = Ve ^ ~wr & Mr, ae[14] = Ke ^ ~jr & Ue, ae[15] = rt ^ ~nr & Qe, ae[24] = br ^ ~Br & yt, ae[25] = gr ^ ~_r & jt, ae[34] = fr ^ ~Ze & Rr, ae[35] = pr ^ ~Xe & kr, ae[44] = Nr ^ ~lt & ur, ae[45] = Er ^ ~It & Wr, ae[6] = Fr ^ ~Sr & ir, ae[7] = wr ^ ~Mr & Gr, ae[16] = jr ^ ~Ue & pt, ae[17] = nr ^ ~Qe & Ct, ae[26] = Br ^ ~yt & Lr, ae[27] = _r ^ ~jt & zt, ae[36] = Ze ^ ~Rr & Pr, ae[37] = Xe ^ ~kr & Ur, ae[46] = lt ^ ~ur & or, ae[47] = It ^ ~Wr & lr, ae[8] = Sr ^ ~ir & rr, ae[9] = Mr ^ ~Gr & Cr, ae[18] = Ue ^ ~pt & Ir, ae[19] = Qe ^ ~Ct & Or, ae[28] = yt ^ ~Lr & Zr, ae[29] = jt ^ ~zt & Xt, ae[38] = Rr ^ ~Pr & We, ae[39] = kr ^ ~Ur & Le, ae[48] = ur ^ ~or & bt, ae[49] = Wr ^ ~lr & Tt, ae[0] ^= P1600_ROUND_CONSTANTS[ie * 2], ae[1] ^= P1600_ROUND_CONSTANTS[ie * 2 + 1];
  }
};
const keccakState = keccakStateUnroll;
function Keccak$1() {
  this.state = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ], this.blockSize = null, this.count = 0, this.squeezing = !1;
}
Keccak$1.prototype.initialize = function(ae, ie) {
  for (let se = 0; se < 50; ++se)
    this.state[se] = 0;
  this.blockSize = ae / 8, this.count = 0, this.squeezing = !1;
};
Keccak$1.prototype.absorb = function(ae) {
  for (let ie = 0; ie < ae.length; ++ie)
    this.state[~~(this.count / 4)] ^= ae[ie] << 8 * (this.count % 4), this.count += 1, this.count === this.blockSize && (keccakState.p1600(this.state), this.count = 0);
};
Keccak$1.prototype.absorbLastFewBits = function(ae) {
  this.state[~~(this.count / 4)] ^= ae << 8 * (this.count % 4), ae & 128 && this.count === this.blockSize - 1 && keccakState.p1600(this.state), this.state[~~((this.blockSize - 1) / 4)] ^= 128 << 8 * ((this.blockSize - 1) % 4), keccakState.p1600(this.state), this.count = 0, this.squeezing = !0;
};
Keccak$1.prototype.squeeze = function(ae) {
  this.squeezing || this.absorbLastFewBits(1);
  const ie = Buffer$F.alloc(ae);
  for (let se = 0; se < ae; ++se)
    ie[se] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 255, this.count += 1, this.count === this.blockSize && (keccakState.p1600(this.state), this.count = 0);
  return ie;
};
Keccak$1.prototype.copy = function(ae) {
  for (let ie = 0; ie < 50; ++ie)
    ae.state[ie] = this.state[ie];
  ae.blockSize = this.blockSize, ae.count = this.count, ae.squeezing = this.squeezing;
};
var keccak = Keccak$1, js = api(keccak);
const createKeccakHash = /* @__PURE__ */ getDefaultExportFromCjs$2(js);
function keccak256(ae) {
  return ae = toBuffer$1(ae), createKeccakHash("keccak256").update(ae).digest();
}
function toBuffer$1(ae) {
  if (!Buffer$1$1.isBuffer(ae))
    if (Array.isArray(ae))
      ae = Buffer$1$1.from(ae);
    else if (typeof ae == "string")
      isHexString(ae) ? ae = Buffer$1$1.from(padToEven(stripHexPrefix(ae)), "hex") : ae = Buffer$1$1.from(ae);
    else if (typeof ae == "number")
      ae = intToBuffer(ae);
    else if (ae == null)
      ae = Buffer$1$1.allocUnsafe(0);
    else if (BN$d.isBN(ae))
      ae = ae.toArrayLike(Buffer$1$1);
    else if (ae.toArray)
      ae = Buffer$1$1.from(ae.toArray());
    else
      throw new Error("invalid type");
  return ae;
}
function isHexString(ae, ie) {
  return !(typeof ae != "string" || !ae.match(/^0x[0-9A-Fa-f]*$/) || ie && ae.length !== 2 + 2 * ie);
}
function padToEven(ae) {
  if (typeof ae != "string")
    throw new Error(`while padding to even, value must be string, is currently ${typeof ae}, while padToEven.`);
  return ae.length % 2 && (ae = `0${ae}`), ae;
}
function stripHexPrefix(ae) {
  return typeof ae != "string" ? ae : isHexPrefixed(ae) ? ae.slice(2) : ae;
}
function isHexPrefixed(ae) {
  if (typeof ae != "string")
    throw new Error("value must be type 'string', is currently type " + typeof ae + ", while checking isHexPrefixed.");
  return ae.startsWith("0x");
}
function intToBuffer(ae) {
  const ie = intToHex(ae);
  return Buffer$1$1.from(padToEven(ie.slice(2)), "hex");
}
function intToHex(ae) {
  return `0x${ae.toString(16)}`;
}
typeof window < "u" && (window.keccak256 = keccak256);
const exportForTesting = {
  intToBuffer,
  intToHex,
  isHexPrefixed,
  stripHexPrefix,
  padToEven,
  isHexString,
  toBuffer: toBuffer$1
};
class Secp256k1 {
  _key;
  ownerLength = SIG_CONFIG[SignatureConfig.ETHEREUM].pubLength;
  signatureLength = SIG_CONFIG[SignatureConfig.ETHEREUM].sigLength;
  signatureType = SignatureConfig.ETHEREUM;
  pk;
  constructor(ie, se) {
    this._key = ie, this.pk = se.toString("hex");
  }
  get publicKey() {
    throw new Error("You must implement `publicKey`");
  }
  get key() {
    return Buffer$F.from(this._key, "hex");
  }
  static async verify(ie, se, fe) {
    let ue = ie;
    typeof ie == "string" && (ue = base64url.toBuffer(ie));
    let ce = !1;
    try {
      ce = secp256k1$1.ecdsaVerify(fe, keccak256(Buffer$F.from(se)), ue);
    } catch {
    }
    return ce;
  }
  async sign(ie) {
    return secp256k1$1.ecdsaSign(keccak256(Buffer$F.from(ie)), Buffer$F.from(this.key)).signature;
  }
}
class EthereumSigner extends Secp256k1 {
  get publicKey() {
    return Buffer$F.from(this.pk, "hex");
  }
  constructor(ie) {
    ie.startsWith("0x") && (ie = ie.slice(2));
    const se = Buffer$F.from(ie, "hex"), fe = secp256k1$1.publicKeyCreate(se, !1);
    super(ie, Buffer$F.from(fe));
  }
  async sign(ie) {
    return new Wallet$1(this._key).signMessage(ie).then((fe) => Buffer$F.from(fe.slice(2), "hex"));
  }
  static async verify(ie, se, fe) {
    return secp256k1$1.ecdsaVerify(fe.length === 65 ? fe.slice(0, -1) : fe, arrayify(hashMessage(se)), typeof ie == "string" ? base64url.toBuffer(ie) : ie);
  }
}
class PolygonSigner extends EthereumSigner {
}
class NearSigner extends SolanaSigner {
  constructor(ie) {
    super(ie.replace("ed25519:", ""));
  }
}
class AlgorandSigner extends Curve25519 {
  get publicKey() {
    return Buffer$F.from(this.pk);
  }
  get key() {
    return Buffer$F.from(this._key);
  }
  constructor(ie, se) {
    super(ie.subarray(0, 32), se);
  }
}
let HexSolanaSigner$1 = class extends InjectedSolanaSigner {
  signatureType = 4;
  // for solana sig type
  constructor(ie) {
    super(ie);
  }
  async sign(ie) {
    return super.sign(Buffer$F.from(Buffer$F.from(ie).toString("hex")));
  }
  static async verify(ie, se, fe) {
    return super.verify(ie, Buffer$F.from(Buffer$F.from(se).toString("hex")), fe);
  }
};
class HexSolanaSigner extends SolanaSigner {
  signatureType = 4;
  // for solana sig type
  constructor(ie) {
    super(ie);
  }
  async sign(ie) {
    return super.sign(Buffer$F.from(Buffer$F.from(ie).toString("hex")));
  }
  static async verify(ie, se, fe) {
    return super.verify(ie, Buffer$F.from(Buffer$F.from(se).toString("hex")), fe);
  }
}
class AptosSigner extends Curve25519 {
  constructor(ie, se) {
    super(ie, se);
  }
  get publicKey() {
    return Buffer$F.from(this.pk.slice(2), "hex");
  }
  get key() {
    return Buffer$F.from(this._key.slice(2), "hex");
  }
}
class InjectedAptosSigner {
  _publicKey;
  ownerLength = SIG_CONFIG[SignatureConfig.INJECTEDAPTOS].pubLength;
  signatureLength = SIG_CONFIG[SignatureConfig.INJECTEDAPTOS].sigLength;
  signatureType = SignatureConfig.INJECTEDAPTOS;
  pem;
  provider;
  constructor(ie, se) {
    this.provider = ie, this._publicKey = se;
  }
  get publicKey() {
    return this._publicKey;
  }
  /**
   * signMessage constructs a message and then signs it.
   * the format is "APTOS(\n)
   * message: <hexString>(\n)
   * nonce: bundlr"
   */
  async sign(ie) {
    if (!this.provider.signMessage)
      throw new Error("Selected Wallet does not support message signing");
    const se = await this.provider.signMessage({
      message: Buffer$F.from(ie).toString("hex"),
      nonce: "bundlr"
    });
    return Buffer$F.from(se.signature, "hex");
  }
  static async verify(ie, se, fe) {
    const ue = ie;
    return verify$1(
      Buffer$F.from(fe),
      Buffer$F.from(`APTOS
message: ${Buffer$F.from(se).toString("hex")}
nonce: bundlr`),
      // see comment above sign
      Buffer$F.from(ue)
    );
  }
}
class MultiSignatureAptosSigner {
  _publicKey;
  ownerLength = SIG_CONFIG[SignatureConfig.MULTIAPTOS].pubLength;
  signatureLength = SIG_CONFIG[SignatureConfig.MULTIAPTOS].sigLength;
  signatureType = SignatureConfig.MULTIAPTOS;
  collectSignatures;
  provider;
  constructor(ie, se) {
    this._publicKey = ie, this.collectSignatures = se;
  }
  get publicKey() {
    return this._publicKey;
  }
  async sign(ie) {
    const { signatures: se, bitmap: fe } = await this.collectSignatures(ie), ue = 128, ce = new Uint8Array([0, 0, 0, 0]), de = /* @__PURE__ */ new Set();
    fe.forEach((Ee) => {
      if (Ee >= 32)
        throw new Error(`Invalid bit value ${Ee}.`);
      if (de.has(Ee))
        throw new Error("Duplicated bits detected.");
      de.add(Ee);
      const Se = Math.floor(Ee / 8);
      let Be = ce[Se];
      Be |= ue >> Ee % 8, ce[Se] = Be;
    });
    const me = Buffer$F.alloc(this.signatureLength);
    let we = 0;
    for (let Ee = 0; Ee < 32; Ee++)
      fe.includes(Ee) && me.set(se[we++], Ee * 64);
    return me.set(ce, this.signatureLength - 4), me;
  }
  static async verify(ie, se, fe) {
    const ce = SIG_CONFIG[SignatureConfig.MULTIAPTOS].sigLength - 4, de = fe.slice(0, ce), me = fe.slice(ce);
    let we = !1;
    for (let Ee = 0; Ee < 32; Ee++) {
      const Se = Math.floor(Ee / 8), Be = Ee - Se * 8;
      if ((me[Se] & 128 >> Be) !== 0) {
        const Ie = de.slice(Ee * 64, (Ee + 1) * 64), Pe = ie.slice(Ee * 32, (Ee + 1) * 32);
        await verify$1(Buffer$F.from(Ie), Buffer$F.from(se), Buffer$F.from(Pe)) || (we = !0);
      }
    }
    return !we;
  }
}
class TypedEthereumSigner extends EthereumSigner {
  ownerLength = SIG_CONFIG[SignatureConfig.TYPEDETHEREUM].pubLength;
  signatureLength = SIG_CONFIG[SignatureConfig.TYPEDETHEREUM].sigLength;
  signatureType = SignatureConfig.TYPEDETHEREUM;
  address;
  signer;
  constructor(ie) {
    super(ie), this.address = "0x" + keccak256(super.publicKey.slice(1)).slice(-20).toString("hex"), this.signer = new Wallet$1(ie);
  }
  get publicKey() {
    return Buffer$F.from(this.address);
  }
  async sign(ie) {
    const se = await this.signer._signTypedData(domain, types, {
      address: this.address,
      "Transaction hash": ie
    });
    return Buffer$F.from(se.slice(2), "hex");
  }
  static async verify(ie, se, fe) {
    const ue = ie.toString(), ce = verifyTypedData(domain, types, { address: ue, "Transaction hash": se }, fe);
    return ue.toLowerCase() === ce.toLowerCase();
  }
}
const domain = {
  name: "Bundlr",
  version: "1"
}, types = {
  Bundlr: [
    { name: "Transaction hash", type: "bytes" },
    { name: "address", type: "address" }
  ]
};
class InjectedTypedEthereumSigner {
  ownerLength = SIG_CONFIG[SignatureConfig.TYPEDETHEREUM].pubLength;
  signatureLength = SIG_CONFIG[SignatureConfig.TYPEDETHEREUM].sigLength;
  signatureType = SignatureConfig.TYPEDETHEREUM;
  address;
  signer;
  publicKey;
  constructor(ie) {
    this.signer = ie.getSigner();
  }
  async ready() {
    this.address = (await this.signer.getAddress()).toString().toLowerCase(), this.publicKey = Buffer$F.from(this.address);
  }
  async sign(ie) {
    const se = await this.signer._signTypedData(domain, types, {
      address: this.address,
      "Transaction hash": ie
    });
    return Buffer$F.from(se.slice(2), "hex");
  }
  static verify(ie, se, fe) {
    const ue = ie.toString(), ce = verifyTypedData(domain, types, { address: ue, "Transaction hash": se }, fe);
    return ue.toLowerCase() === ce.toLowerCase();
  }
}
class InjectedArweaveSigner {
  signer;
  publicKey;
  ownerLength = SIG_CONFIG[SignatureConfig.ARWEAVE].pubLength;
  signatureLength = SIG_CONFIG[SignatureConfig.ARWEAVE].sigLength;
  signatureType = SignatureConfig.ARWEAVE;
  arweave;
  constructor(ie, se) {
    this.signer = ie, this.arweave = se;
  }
  async setPublicKey() {
    const ie = await this.signer.getActivePublicKey();
    this.publicKey = base64url.toBuffer(ie);
  }
  async sign(ie) {
    this.publicKey || await this.setPublicKey();
    const se = {
      name: "RSA-PSS",
      saltLength: 32
    }, fe = await this.signer.signature(ie, se);
    return new Uint8Array(Object.values(fe).map((ce) => +ce));
  }
  static async verify(ie, se, fe) {
    return await getCryptoDriver().verify(ie, se, fe);
  }
}
const indexToType = {
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-expect-error
  1: ArweaveSigner,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-expect-error
  2: Curve25519,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-expect-error
  3: EthereumSigner,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-expect-error
  4: HexSolanaSigner$1,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-expect-error
  5: InjectedAptosSigner,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-expect-error
  6: MultiSignatureAptosSigner,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-expect-error
  7: TypedEthereumSigner
};
async function getSignatureData(ae) {
  return deepHash([
    stringToBuffer("dataitem"),
    stringToBuffer("1"),
    stringToBuffer(ae.signatureType.toString()),
    ae.rawOwner,
    ae.rawTarget,
    ae.rawAnchor,
    ae.rawTags,
    ae.rawData
  ]);
}
function longToNByteArray(ae, ie) {
  const se = new Uint8Array(ae);
  if (ie < 0)
    throw new Error("Array is unsigned, cannot represent -ve numbers");
  if (ie > 2 ** (ae * 8) - 1)
    throw new Error(`Number ${ie} is too large for an array of ${ae} bytes`);
  for (let fe = 0; fe < se.length; fe++) {
    const ue = ie & 255;
    se[fe] = ue, ie = (ie - ue) / 256;
  }
  return se;
}
function longTo8ByteArray(ae) {
  return longToNByteArray(8, ae);
}
function shortTo2ByteArray(ae) {
  return longToNByteArray(2, ae);
}
function longTo16ByteArray(ae) {
  return longToNByteArray(16, ae);
}
function longTo32ByteArray(ae) {
  return longToNByteArray(32, ae);
}
function byteArrayToLong(ae) {
  let ie = 0;
  for (let se = ae.length - 1; se >= 0; se--)
    ie = ie * 256 + ae[se];
  return ie;
}
class AVSCTap {
  buf;
  pos;
  constructor(ie = Buffer$F.alloc(MAX_TAG_BYTES), se = 0) {
    this.buf = ie, this.pos = se;
  }
  writeTags(ie) {
    if (!Array.isArray(ie))
      throw new Error("input must be array");
    const se = ie.length;
    let fe;
    if (se)
      for (this.writeLong(se), fe = 0; fe < se; fe++) {
        const ue = ie[fe];
        if (typeof ue?.name != "string" || typeof ue?.value != "string")
          throw new Error(`Invalid tag format for ${ue}, expected {name:string, value: string}`);
        this.writeString(ue.name), this.writeString(ue.value);
      }
    this.writeLong(0);
  }
  toBuffer() {
    const ie = Buffer$F.alloc(this.pos);
    if (this.pos > this.buf.length)
      throw new Error(`Too many tag bytes (${this.pos} > ${this.buf.length})`);
    return this.buf.copy(ie, 0, 0, this.pos), ie;
  }
  writeLong(ie) {
    const se = this.buf;
    let fe, ue;
    if (ie >= -1073741824 && ie < 1073741824) {
      ue = ie >= 0 ? ie << 1 : ~ie << 1 | 1;
      do
        se[this.pos] = ue & 127, ue >>= 7;
      while (ue && (se[this.pos++] |= 128));
    } else {
      fe = ie >= 0 ? ie * 2 : -ie * 2 - 1;
      do
        se[this.pos] = fe & 127, fe /= 128;
      while (fe >= 1 && (se[this.pos++] |= 128));
    }
    this.pos++, this.buf = se;
  }
  // for some reason using setters/getters with ++ doesn't work right.
  // set pos(newPos: number) {
  //   const d = newPos + 1 - this.buf.length;
  //   if (d > 0) this.buf = Buffer.concat([this.buf, Buffer.alloc(d)]);
  //   this._pos = newPos;
  // }
  // get pos(): number {
  //   return this._pos;
  // }
  // protected safeRead(position): number {
  //   return position > this.buf.length ? 0 : this.buf[position];
  // }
  // protected safeWrite(position, value): Buffer {
  //   if (position > this.buf.length) this.buf = Buffer.concat([this.buf, Buffer.alloc(1)]);
  //   this.buf[position] = value;
  //   return this.buf;
  // }
  writeString(ie) {
    const se = Buffer$F.byteLength(ie), fe = this.buf;
    this.writeLong(se);
    let ue = this.pos;
    if (this.pos += se, !(this.pos > fe.length)) {
      if (se > 64)
        this.buf.write(ie, this.pos - se, se, "utf8");
      else {
        let ce, de, me, we;
        for (ce = 0, de = se; ce < de; ce++)
          me = ie.charCodeAt(ce), me < 128 ? fe[ue++] = me : me < 2048 ? (fe[ue++] = me >> 6 | 192, fe[ue++] = me & 63 | 128) : (me & 64512) === 55296 && ((we = ie.charCodeAt(ce + 1)) & 64512) === 56320 ? (me = 65536 + ((me & 1023) << 10) + (we & 1023), ce++, fe[ue++] = me >> 18 | 240, fe[ue++] = me >> 12 & 63 | 128, fe[ue++] = me >> 6 & 63 | 128, fe[ue++] = me & 63 | 128) : (fe[ue++] = me >> 12 | 224, fe[ue++] = me >> 6 & 63 | 128, fe[ue++] = me & 63 | 128);
      }
      this.buf = fe;
    }
  }
  readLong() {
    let ie = 0, se = 0;
    const fe = this.buf;
    let ue, ce, de, me;
    do
      ue = fe[this.pos++], ce = ue & 128, ie |= (ue & 127) << se, se += 7;
    while (ce && se < 28);
    if (ce) {
      de = ie, me = 268435456;
      do
        ue = fe[this.pos++], de += (ue & 127) * me, me *= 128;
      while (ue & 128);
      return (de % 2 ? -(de + 1) : de) / 2;
    }
    return ie >> 1 ^ -(ie & 1);
  }
  skipLong() {
    const ie = this.buf;
    for (; ie[this.pos++] & 128; )
      ;
  }
  readTags() {
    const ie = [];
    let se;
    for (; se = this.readLong(); )
      for (se < 0 && (se = -se, this.skipLong()); se--; ) {
        const fe = this.readString(), ue = this.readString();
        ie.push(
          /* items._read(tap) */
          { name: fe, value: ue }
        );
      }
    return ie;
  }
  readString() {
    const ie = this.readLong(), se = this.pos, fe = this.buf;
    if (this.pos += ie, this.pos > fe.length)
      throw new Error("TAP Position out of range");
    return this.buf.slice(se, se + ie).toString();
  }
}
function serializeTags(ae) {
  if (ae?.length === 0)
    return Buffer$F.allocUnsafe(0);
  const ie = new AVSCTap();
  return ie.writeTags(ae), ie.toBuffer();
}
function deserializeTags(ae) {
  return new AVSCTap(ae).readTags();
}
const MIN_BINARY_SIZE = 80, MAX_TAG_BYTES = 4096;
class DataItem {
  binary;
  _id;
  constructor(ie) {
    this.binary = ie;
  }
  static isDataItem(ie) {
    return ie.binary !== void 0;
  }
  get signatureType() {
    const ie = byteArrayToLong(this.binary.subarray(0, 2));
    if (SignatureConfig?.[ie] !== void 0)
      return ie;
    throw new Error("Unknown signature type: " + ie);
  }
  async isValid() {
    return DataItem.verify(this.binary);
  }
  get id() {
    return base64url.encode(this.rawId);
  }
  set id(ie) {
    this._id = base64url.toBuffer(ie);
  }
  get rawId() {
    return cryptoBrowserifyExports.createHash("sha256").update(this.rawSignature).digest();
  }
  set rawId(ie) {
    this._id = ie;
  }
  get rawSignature() {
    return this.binary.subarray(2, 2 + this.signatureLength);
  }
  get signature() {
    return base64url.encode(this.rawSignature);
  }
  set rawOwner(ie) {
    if (ie.byteLength != this.ownerLength)
      throw new Error(`Expected raw owner (pubkey) to be ${this.ownerLength} bytes, got ${ie.byteLength} bytes.`);
    this.binary.set(ie, 2 + this.signatureLength);
  }
  get rawOwner() {
    return this.binary.subarray(2 + this.signatureLength, 2 + this.signatureLength + this.ownerLength);
  }
  get signatureLength() {
    return SIG_CONFIG[this.signatureType].sigLength;
  }
  get owner() {
    return base64url.encode(this.rawOwner);
  }
  get ownerLength() {
    return SIG_CONFIG[this.signatureType].pubLength;
  }
  get rawTarget() {
    const ie = this.getTargetStart();
    return this.binary[ie] == 1 ? this.binary.subarray(ie + 1, ie + 33) : Buffer$1$1.alloc(0);
  }
  get target() {
    return base64url.encode(this.rawTarget);
  }
  get rawAnchor() {
    const ie = this.getAnchorStart();
    return this.binary[ie] == 1 ? this.binary.subarray(ie + 1, ie + 33) : Buffer$1$1.alloc(0);
  }
  get anchor() {
    return this.rawAnchor.toString();
  }
  get rawTags() {
    const ie = this.getTagsStart(), se = byteArrayToLong(this.binary.subarray(ie + 8, ie + 16));
    return this.binary.subarray(ie + 16, ie + 16 + se);
  }
  get tags() {
    const ie = this.getTagsStart();
    if (byteArrayToLong(this.binary.subarray(ie, ie + 8)) == 0)
      return [];
    const fe = byteArrayToLong(this.binary.subarray(ie + 8, ie + 16));
    return deserializeTags(Buffer$1$1.from(this.binary.subarray(ie + 16, ie + 16 + fe)));
  }
  get tagsB64Url() {
    return this.tags.map((se) => ({
      name: base64url.encode(se.name),
      value: base64url.encode(se.value)
    }));
  }
  getStartOfData() {
    const ie = this.getTagsStart(), se = this.binary.subarray(ie + 8, ie + 16), fe = byteArrayToLong(se);
    return ie + 16 + fe;
  }
  get rawData() {
    const ie = this.getTagsStart(), se = this.binary.subarray(ie + 8, ie + 16), fe = byteArrayToLong(se), ue = ie + 16 + fe;
    return this.binary.subarray(ue, this.binary.length);
  }
  get data() {
    return base64url.encode(this.rawData);
  }
  /**
   * UNSAFE!!
   * DO NOT MUTATE THE BINARY ARRAY. THIS WILL CAUSE UNDEFINED BEHAVIOUR.
   */
  getRaw() {
    return this.binary;
  }
  async sign(ie) {
    return this._id = await sign$2(this, ie), this.rawId;
  }
  async setSignature(ie) {
    this.binary.set(ie, 2), this._id = Buffer$1$1.from(await getCryptoDriver().hash(ie));
  }
  isSigned() {
    return (this._id?.length ?? 0) > 0;
  }
  /**
   * Returns a JSON representation of a DataItem
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  toJSON() {
    return {
      signature: this.signature,
      owner: this.owner,
      target: this.target,
      tags: this.tags.map((ie) => ({
        name: base64url.encode(ie.name),
        value: base64url.encode(ie.value)
      })),
      data: this.data
    };
  }
  /**
   * Verifies a `Buffer` and checks it fits the format of a DataItem
   *
   * A binary is valid iff:
   * - the tags are encoded correctly
   */
  static async verify(ie) {
    if (ie.byteLength < MIN_BINARY_SIZE)
      return !1;
    const se = new DataItem(ie), fe = se.signatureType, ue = se.getTagsStart(), ce = byteArrayToLong(ie.subarray(ue, ue + 8)), de = ie.subarray(ue + 8, ue + 16), me = byteArrayToLong(de);
    if (me > MAX_TAG_BYTES)
      return !1;
    if (ce > 0)
      try {
        if (deserializeTags(Buffer$1$1.from(ie.subarray(ue + 16, ue + 16 + me))).length !== ce)
          return !1;
      } catch {
        return !1;
      }
    const we = indexToType[fe], Ee = await getSignatureData(se);
    return await we.verify(se.rawOwner, Ee, se.rawSignature);
  }
  async getSignatureData() {
    return getSignatureData(this);
  }
  /**
   * Returns the start byte of the tags section (number of tags)
   *
   * @private
   */
  getTagsStart() {
    const ie = this.getTargetStart(), se = this.binary[ie] == 1;
    let fe = ie + (se ? 33 : 1);
    const ue = this.binary[fe] == 1;
    return fe += ue ? 33 : 1, fe;
  }
  /**
   * Returns the start byte of the tags section (number of tags)
   *
   * @private
   */
  getTargetStart() {
    return 2 + this.signatureLength + this.ownerLength;
  }
  /**
   * Returns the start byte of the tags section (number of tags)
   *
   * @private
   */
  getAnchorStart() {
    let ie = this.getTargetStart() + 1;
    const se = this.binary[this.getTargetStart()] == 1;
    return ie += se ? 32 : 0, ie;
  }
}
const HEADER_START = 32;
class Bundle {
  length;
  items;
  binary;
  constructor(ie) {
    this.binary = ie, this.length = this.getDataItemCount(), this.items = this.getItems();
  }
  getRaw() {
    return this.binary;
  }
  /**
   * Get a DataItem by index (`number`) or by txId (`string`)
   * @param index
   */
  get(ie) {
    if (typeof ie == "number") {
      if (ie >= this.length)
        throw new RangeError("Index out of range");
      return this.getByIndex(ie);
    } else
      return this.getById(ie);
  }
  getSizes() {
    const ie = [];
    for (let se = HEADER_START; se < HEADER_START + 64 * this.length; se += 64)
      ie.push(byteArrayToLong(this.binary.subarray(se, se + 32)));
    return ie;
  }
  getIds() {
    const ie = [];
    for (let se = HEADER_START; se < HEADER_START + 64 * this.length; se += 64) {
      const fe = this.binary.subarray(se + 32, se + 64);
      if (fe.length === 0)
        throw new Error("Invalid bundle, id specified in headers doesn't exist");
      ie.push(base64url.encode(fe));
    }
    return ie;
  }
  getIdBy(ie) {
    if (ie > this.length - 1)
      throw new RangeError("Index of bundle out of range");
    const se = 64 + 64 * ie;
    return base64url.encode(this.binary.subarray(se, se + 32));
  }
  async toTransaction(ie, se, fe) {
    const ue = await se.createTransaction({ data: this.binary, ...ie }, fe);
    return ue.addTag("Bundle-Format", "binary"), ue.addTag("Bundle-Version", "2.0.0"), ue;
  }
  async verify() {
    for (const ie of this.items) {
      const se = await ie.isValid(), fe = base64url(cryptoBrowserifyExports.createHash("sha256").update(ie.rawSignature).digest());
      if (!(se && ie.id === fe))
        return !1;
    }
    return !0;
  }
  getOffset(ie) {
    let se = 0;
    for (let fe = HEADER_START; fe < HEADER_START + 64 * this.length; fe += 64) {
      const ue = byteArrayToLong(this.binary.subarray(fe, fe + 32));
      se += ue;
      const ce = this.binary.subarray(fe + 32, fe + 64);
      if (Buffer$F.compare(ce, ie) === 0)
        return { startOffset: se, size: ue };
    }
    return { startOffset: -1, size: -1 };
  }
  // TODO: Test this
  /**
   * UNSAFE! Assumes index < length
   * @param index
   * @private
   */
  getByIndex(ie) {
    let se = 0;
    const fe = this.getBundleStart();
    let ue = 0, ce, de;
    for (let Se = HEADER_START; Se < HEADER_START + 64 * this.length; Se += 64) {
      if (ce = byteArrayToLong(this.binary.subarray(Se, Se + 32)), ue++ === ie) {
        de = this.binary.subarray(Se + 32, Se + 64);
        break;
      }
      se += ce;
    }
    const me = fe + se, we = this.binary.subarray(me, me + ce), Ee = new DataItem(we);
    return Ee.rawId = de, Ee;
  }
  getById(ie) {
    const se = base64url.toBuffer(ie), fe = this.getOffset(se);
    if (fe.startOffset === -1)
      throw new Error("Transaction not found");
    const ce = this.getBundleStart() + fe.startOffset;
    return new DataItem(this.binary.subarray(ce, ce + fe.size));
  }
  getDataItemCount() {
    return byteArrayToLong(this.binary.subarray(0, 32));
  }
  getBundleStart() {
    return 32 + 64 * this.length;
  }
  getItems() {
    const ie = new Array(this.length);
    let se = 0;
    const fe = this.getBundleStart();
    let ue = 0;
    for (let ce = HEADER_START; ce < HEADER_START + 64 * this.length; ce += 64) {
      const de = byteArrayToLong(this.binary.subarray(ce, ce + 32)), me = this.binary.subarray(ce + 32, ce + 64);
      if (me.length === 0)
        throw new Error("Invalid bundle, id specified in headers doesn't exist");
      const we = fe + se, Ee = this.binary.subarray(we, we + de);
      se += de;
      const Se = new DataItem(Ee);
      Se.rawId = me, ie[ue] = Se, ue++;
    }
    return ie;
  }
}
function unbundleData(ae) {
  return new Bundle(ae);
}
async function bundleAndSignData(ae, ie) {
  const se = new Uint8Array(64 * ae.length), fe = await Promise.all(ae.map(async (ce, de) => {
    const me = ce.isSigned() ? ce.rawId : await sign$2(ce, ie), we = new Uint8Array(64);
    return we.set(longTo32ByteArray(ce.getRaw().byteLength), 0), we.set(me, 32), se.set(we, 64 * de), ce.getRaw();
  })).then((ce) => Buffer$F.concat(ce)), ue = Buffer$F.concat([Buffer$F.from(longTo32ByteArray(ae.length)), Buffer$F.from(se), fe]);
  return new Bundle(ue);
}
async function getSignatureAndId(ae, ie) {
  const se = await getSignatureData(ae), fe = await ie.sign(se), ue = await getCryptoDriver().hash(fe);
  return { signature: Buffer$F.from(fe), id: Buffer$F.from(ue) };
}
async function sign$2(ae, ie) {
  const { signature: se, id: fe } = await getSignatureAndId(ae, ie);
  return ae.getRaw().set(se, 2), fe;
}
function createData(ae, ie, se) {
  const fe = ie.publicKey, ue = se?.target ? base64url.toBuffer(se.target) : null, ce = 1 + (ue?.byteLength ?? 0), de = se?.anchor ? Buffer$F.from(se.anchor) : null, me = 1 + (de?.byteLength ?? 0), we = (se?.tags?.length ?? 0) > 0 ? serializeTags(se?.tags) : null, Ee = 16 + (we ? we.byteLength : 0), Se = Buffer$F.from(ae), Be = Se.byteLength, Ce = 2 + ie.signatureLength + ie.ownerLength + ce + me + Ee + Be, Ie = Buffer$F.alloc(Ce);
  if (Ie.set(shortTo2ByteArray(ie.signatureType), 0), Ie.set(new Uint8Array(ie.signatureLength).fill(0), 2), fe.byteLength !== ie.ownerLength)
    throw new Error(`Owner must be ${ie.ownerLength} bytes, but was incorrectly ${fe.byteLength}`);
  Ie.set(fe, 2 + ie.signatureLength);
  const Pe = 2 + ie.signatureLength + ie.ownerLength;
  if (Ie[Pe] = ue ? 1 : 0, ue) {
    if (ue.byteLength !== 32)
      throw new Error(`Target must be 32 bytes but was incorrectly ${ue.byteLength}`);
    Ie.set(ue, Pe + 1);
  }
  const Ne = Pe + ce;
  let ke = Ne + 1;
  if (Ie[Ne] = de ? 1 : 0, de) {
    if (ke += de.byteLength, de.byteLength !== 32)
      throw new Error("Anchor must be 32 bytes");
    Ie.set(de, Ne + 1);
  }
  Ie.set(longTo8ByteArray(se?.tags?.length ?? 0), ke);
  const He = longTo8ByteArray(we?.byteLength ?? 0);
  Ie.set(He, ke + 8), we && Ie.set(we, ke + 16);
  const De = ke + Ee;
  return Ie.set(Se, De), new DataItem(Ie);
}
class BundleItem {
  signatureType;
  rawSignature;
  signature;
  signatureLength;
  rawOwner;
  owner;
  ownerLength;
  rawTarget;
  target;
  rawAnchor;
  anchor;
  rawTags;
  tags;
  rawData;
  data;
  static async verify(...ie) {
    throw new Error("You must implement `verify`");
  }
}
const arbundlesSrc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AVSCTap,
  AlgorandSigner,
  AptosSigner,
  ArconnectSigner: InjectedArweaveSigner,
  Arweave,
  ArweaveSigner,
  Bundle,
  BundleItem,
  CryptoDriver,
  Curve25519,
  DataItem,
  EthereumSigner,
  HexInjectedSolanaSigner: HexSolanaSigner$1,
  HexSolanaSigner,
  InjectedAptosSigner,
  InjectedEthereumSigner,
  InjectedSolanaSigner,
  InjectedTypedEthereumSigner,
  MAX_TAG_BYTES,
  MIN_BINARY_SIZE,
  MultiSignatureAptosSigner,
  NearSigner,
  PolygonSigner,
  Rsa4096: Rsa4096Pss,
  SIG_CONFIG,
  get SignatureConfig() {
    return SignatureConfig;
  },
  Signer: Signer$1,
  SolanaSigner,
  TypedEthereumSigner,
  bundleAndSignData,
  byteArrayToLong,
  concatBuffers,
  createData,
  deepHash,
  deserializeTags,
  exportForTesting,
  getCryptoDriver,
  getSignatureAndId,
  indexToType,
  keccak256,
  longTo16ByteArray,
  longTo32ByteArray,
  longTo8ByteArray,
  longToNByteArray,
  secp256k1: Secp256k1,
  serializeTags,
  shortTo2ByteArray,
  sign: sign$2,
  stringToBuffer,
  unbundleData
}, Symbol.toStringTag, { value: "Module" }));
async function processStream(ae) {
  const ie = getReader(ae);
  let se = (await ie.next()).value;
  se = await readBytes(ie, se, 32);
  const fe = byteArrayToLong(se.subarray(0, 32));
  se = se.subarray(32);
  const ue = 64 * fe;
  se = await readBytes(ie, se, ue);
  const ce = new Array(fe);
  for (let we = 0; we < ue; we += 64)
    ce[we / 64] = [byteArrayToLong(se.subarray(we, we + 32)), base64url(Buffer$F.from(se.subarray(we + 32, we + 64)))];
  se = se.subarray(ue);
  let de = 32 + ue;
  const me = [];
  for (const [we, Ee] of ce) {
    se = await readBytes(ie, se, MIN_BINARY_SIZE), se = await readBytes(ie, se, 2);
    const Se = byteArrayToLong(se.subarray(0, 2));
    se = se.subarray(2);
    const { sigLength: Be, pubLength: Ce, sigName: Ie } = SIG_CONFIG[Se];
    se = await readBytes(ie, se, Be);
    const Pe = se.subarray(0, Be);
    se = se.subarray(Be), se = await readBytes(ie, se, Ce);
    const Ne = se.subarray(0, Ce);
    se = se.subarray(Ce), se = await readBytes(ie, se, 1);
    const ke = se[0] === 1;
    ke && (se = await readBytes(ie, se, 33));
    const He = ke ? se.subarray(1, 33) : Buffer$F.allocUnsafe(0);
    se = se.subarray(ke ? 33 : 1), se = await readBytes(ie, se, 1);
    const De = se[0] === 1;
    De && (se = await readBytes(ie, se, 33));
    const Ge = De ? se.subarray(1, 33) : Buffer$F.allocUnsafe(0);
    se = se.subarray(De ? 33 : 1), se = await readBytes(ie, se, 8);
    const Ye = byteArrayToLong(se.subarray(0, 8));
    se = se.subarray(8), se = await readBytes(ie, se, 8);
    const st = byteArrayToLong(se.subarray(0, 8));
    se = se.subarray(8), se = await readBytes(ie, se, st);
    const at = se.subarray(0, st), mt = Ye !== 0 && st !== 0 ? deserializeTags(Buffer$F.from(at)) : [];
    if (mt.length !== Ye)
      throw new Error("Tags lengths don't match");
    se = se.subarray(st);
    const qe = new streamBrowserify.Transform();
    qe._transform = function(pe, ge, ye) {
      this.push(pe), ye();
    };
    const ze = deepHash([
      stringToBuffer("dataitem"),
      stringToBuffer("1"),
      stringToBuffer(Se.toString()),
      Ne,
      He,
      Ge,
      at,
      qe
    ]), ot = 2 + Be + Ce + (ke ? 33 : 1) + (De ? 33 : 1) + 16 + st, $e = we - ot;
    if (se.byteLength > $e)
      qe.write(se.subarray(0, $e)), se = se.subarray($e);
    else {
      let pe = se.byteLength;
      for (qe.write(se); $e > pe; ) {
        if (se = (await ie.next()).value, !se)
          throw new Error(`Not enough data bytes  expected: ${$e} received: ${pe}`);
        pe += se.byteLength, pe > $e ? qe.write(se.subarray(0, se.byteLength - (pe - $e))) : qe.write(se);
      }
      se = se.subarray(se.byteLength - (pe - $e));
    }
    if (qe.end(), Ee !== base64url(cryptoBrowserifyExports.createHash("sha256").update(Pe).digest()))
      throw new Error("ID doesn't match signature");
    if (!await indexToType[Se].verify(Ne, await ze, Pe))
      throw new Error("Invalid signature");
    me.push({
      id: Ee,
      sigName: Ie,
      signature: base64url(Buffer$F.from(Pe)),
      target: base64url(Buffer$F.from(He)),
      anchor: base64url(Buffer$F.from(Ge)),
      owner: base64url(Buffer$F.from(Ne)),
      tags: mt,
      dataOffset: de + ot,
      dataSize: $e
    }), de += ot + $e;
  }
  return me;
}
async function streamSigner(ae, ie, se, fe) {
  const ue = createData("", se, fe), ce = new streamBrowserify.PassThrough(), de = [
    stringToBuffer("dataitem"),
    stringToBuffer("1"),
    stringToBuffer(ue.signatureType.toString()),
    ue.rawOwner,
    ue.rawTarget,
    ue.rawAnchor,
    ue.rawTags,
    ae
  ], me = await deepHash(de), we = Buffer$F.from(await se.sign(me));
  return ue.setSignature(we), ce.write(ue.getRaw()), ie.pipe(ce);
}
async function readBytes(ae, ie, se) {
  if (ie.byteLength >= se)
    return ie;
  const { done: fe, value: ue } = await ae.next();
  if (fe && !ue)
    throw new Error("Invalid buffer");
  return readBytes(ae, Buffer$F.concat([Buffer$F.from(ie), Buffer$F.from(ue)]), se);
}
async function* getReader(ae) {
  for await (const ie of ae)
    yield ie;
}
const streamExportForTesting = {
  readBytes,
  getReader
}, stream = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: processStream,
  processStream,
  streamExportForTesting,
  streamSigner
}, Symbol.toStringTag, { value: "Module" })), expObj = { ...arbundlesSrc, stream };
globalThis.arbundles ??= expObj;
const arbundles = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Arweave,
  DataItem,
  bundleAndSignData,
  createData,
  deepHash,
  getCryptoDriver,
  stringToBuffer
}, Symbol.toStringTag, { value: "Module" }));
var dist = {}, promisePool = {}, promisePoolExecutor = {}, promisePoolError = {};
Object.defineProperty(promisePoolError, "__esModule", { value: !0 });
promisePoolError.PromisePoolError = void 0;
class PromisePoolError extends Error {
  /**
   * Create a new instance for the given `message` and `item`.
   *
   * @param error  The original error
   * @param item   The item causing the error
   */
  constructor(ie, se) {
    super(), this.raw = ie, this.item = se, this.name = this.constructor.name, this.message = this.messageFrom(ie), Error.captureStackTrace && typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, this.constructor);
  }
  /**
   * Returns a new promise pool error instance wrapping the `error` and `item`.
   *
   * @param {*} error
   * @param {*} item
   *
   * @returns {PromisePoolError}
   */
  static createFrom(ie, se) {
    return new this(ie, se);
  }
  /**
   * Returns the error message from the given `error`.
   *
   * @param {*} error
   *
   * @returns {String}
   */
  messageFrom(ie) {
    return ie instanceof Error || typeof ie == "object" ? ie.message : typeof ie == "string" || typeof ie == "number" ? ie.toString() : "";
  }
}
promisePoolError.PromisePoolError = PromisePoolError;
var stopThePromisePoolError = {};
Object.defineProperty(stopThePromisePoolError, "__esModule", { value: !0 });
stopThePromisePoolError.StopThePromisePoolError = void 0;
class StopThePromisePoolError extends Error {
}
stopThePromisePoolError.StopThePromisePoolError = StopThePromisePoolError;
var validationError = {};
Object.defineProperty(validationError, "__esModule", { value: !0 });
validationError.ValidationError = void 0;
class ValidationError extends Error {
  /**
   * Create a new instance for the given `message`.
   *
   * @param message  The error message
   */
  constructor(ie) {
    super(ie), Error.captureStackTrace && typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, this.constructor);
  }
  /**
   * Returns a validation error with the given `message`.
   */
  static createFrom(ie) {
    return new this(ie);
  }
}
validationError.ValidationError = ValidationError;
var hasRequiredPromisePoolExecutor;
function requirePromisePoolExecutor() {
  if (hasRequiredPromisePoolExecutor)
    return promisePoolExecutor;
  hasRequiredPromisePoolExecutor = 1, Object.defineProperty(promisePoolExecutor, "__esModule", { value: !0 }), promisePoolExecutor.PromisePoolExecutor = void 0;
  const ae = requirePromisePool(), ie = promisePoolError, se = stopThePromisePoolError, fe = validationError;
  class ue {
    /**
     * Creates a new promise pool executer instance with a default concurrency of 10.
     */
    constructor() {
      this.meta = {
        tasks: [],
        items: [],
        errors: [],
        results: [],
        stopped: !1,
        concurrency: 10,
        shouldResultsCorrespond: !1,
        processedItems: [],
        taskTimeout: 0
      }, this.handler = () => {
      }, this.errorHandler = void 0, this.onTaskStartedHandlers = [], this.onTaskFinishedHandlers = [];
    }
    /**
     * Set the number of tasks to process concurrently the promise pool.
     *
     * @param {Integer} concurrency
     *
     * @returns {PromisePoolExecutor}
     */
    useConcurrency(de) {
      if (!this.isValidConcurrency(de))
        throw fe.ValidationError.createFrom(`"concurrency" must be a number, 1 or up. Received "${de}" (${typeof de})`);
      return this.meta.concurrency = de, this;
    }
    /**
     * Determine whether the given `concurrency` value is valid.
     *
     * @param {Number} concurrency
     *
     * @returns {Boolean}
     */
    isValidConcurrency(de) {
      return typeof de == "number" && de >= 1;
    }
    /**
     * Set the timeout in ms for the pool handler
     *
     * @param {Number} timeout
     *
     * @returns {PromisePool}
     */
    withTaskTimeout(de) {
      return this.meta.taskTimeout = de, this;
    }
    /**
     * Returns the number of concurrently processed tasks.
     *
     * @returns {Number}
     */
    concurrency() {
      return this.meta.concurrency;
    }
    /**
     * Assign whether to keep corresponding results between source items and resulting tasks.
     */
    useCorrespondingResults(de) {
      return this.meta.shouldResultsCorrespond = de, this;
    }
    /**
     * Determine whether to keep corresponding results between source items and resulting tasks.
     */
    shouldUseCorrespondingResults() {
      return this.meta.shouldResultsCorrespond;
    }
    /**
     * Returns the task timeout in milliseconds.
     */
    taskTimeout() {
      return this.meta.taskTimeout;
    }
    /**
     * Set the items to be processed in the promise pool.
     *
     * @param {Array} items
     *
     * @returns {PromisePoolExecutor}
     */
    for(de) {
      return this.meta.items = de, this;
    }
    /**
     * Returns the list of items to process.
     *
     * @returns {T[] | Iterable<T> | AsyncIterable<T>}
     */
    items() {
      return this.meta.items;
    }
    /**
     * Returns the number of items to process, or `NaN` if items are not an array.
     *
     * @returns {Number}
     */
    itemsCount() {
      const de = this.items();
      return Array.isArray(de) ? de.length : NaN;
    }
    /**
     * Returns the list of active tasks.
     *
     * @returns {Array}
     */
    tasks() {
      return this.meta.tasks;
    }
    /**
     * Returns the number of currently active tasks.
     *
     * @returns {Number}
     *
     * @deprecated use the `activeTasksCount()` method (plural naming) instead
     */
    activeTaskCount() {
      return this.activeTasksCount();
    }
    /**
     * Returns the number of currently active tasks.
     *
     * @returns {Number}
     */
    activeTasksCount() {
      return this.tasks().length;
    }
    /**
     * Returns the list of processed items.
     *
     * @returns {T[]}
     */
    processedItems() {
      return this.meta.processedItems;
    }
    /**
     * Returns the number of processed items.
     *
     * @returns {Number}
     */
    processedCount() {
      return this.processedItems().length;
    }
    /**
     * Returns the percentage progress of items that have been processed, or `NaN` if items is not an array.
     */
    processedPercentage() {
      return this.processedCount() / this.itemsCount() * 100;
    }
    /**
     * Returns the list of results.
     *
     * @returns {R[]}
     */
    results() {
      return this.meta.results;
    }
    /**
     * Returns the list of errors.
     *
     * @returns {Array<PromisePoolError<T>>}
     */
    errors() {
      return this.meta.errors;
    }
    /**
     * Set the handler that is applied to each item.
     *
     * @param {Function} action
     *
     * @returns {PromisePoolExecutor}
     */
    withHandler(de) {
      return this.handler = de, this;
    }
    /**
     * Determine whether a custom error handle is available.
     *
     * @returns {Boolean}
     */
    hasErrorHandler() {
      return !!this.errorHandler;
    }
    /**
     * Set the error handler function to execute when an error occurs.
     *
     * @param {Function} errorHandler
     *
     * @returns {PromisePoolExecutor}
     */
    handleError(de) {
      return this.errorHandler = de, this;
    }
    /**
     * Set the handler function to execute when started a task.
     *
     * @param {Function} handler
     *
     * @returns {this}
     */
    onTaskStarted(de) {
      return this.onTaskStartedHandlers = de, this;
    }
    /**
      * Assign the given callback `handler` function to run when a task finished.
     *
     * @param {OnProgressCallback<T>} handlers
     *
     * @returns {this}
     */
    onTaskFinished(de) {
      return this.onTaskFinishedHandlers = de, this;
    }
    /**
     * Determines whether the number of active tasks is greater or equal to the concurrency limit.
     *
     * @returns {Boolean}
     */
    hasReachedConcurrencyLimit() {
      return this.activeTasksCount() >= this.concurrency();
    }
    /**
     * Stop a promise pool processing.
     */
    stop() {
      throw this.markAsStopped(), new se.StopThePromisePoolError();
    }
    /**
     * Mark the promise pool as stopped.
     *
     * @returns {PromisePoolExecutor}
     */
    markAsStopped() {
      return this.meta.stopped = !0, this;
    }
    /**
     * Determine whether the pool is stopped.
     *
     * @returns {Boolean}
     */
    isStopped() {
      return this.meta.stopped;
    }
    /**
     * Start processing the promise pool.
     *
     * @returns {ReturnValue}
     */
    async start() {
      return await this.validateInputs().prepareResultsArray().process();
    }
    /**
     * Determine whether the pool should stop.
     *
     * @returns {PromisePoolExecutor}
     *
     * @throws
     */
    validateInputs() {
      if (typeof this.handler != "function")
        throw fe.ValidationError.createFrom("The first parameter for the .process(fn) method must be a function");
      const de = this.taskTimeout();
      if (!(de == null || typeof de == "number" && de >= 0))
        throw fe.ValidationError.createFrom(`"timeout" must be undefined or a number. A number must be 0 or up. Received "${String(de)}" (${typeof de})`);
      if (!this.areItemsValid())
        throw fe.ValidationError.createFrom(`"items" must be an array, an iterable or an async iterable. Received "${typeof this.items()}"`);
      if (this.errorHandler && typeof this.errorHandler != "function")
        throw fe.ValidationError.createFrom(`The error handler must be a function. Received "${typeof this.errorHandler}"`);
      return this.onTaskStartedHandlers.forEach((me) => {
        if (me && typeof me != "function")
          throw fe.ValidationError.createFrom(`The onTaskStarted handler must be a function. Received "${typeof me}"`);
      }), this.onTaskFinishedHandlers.forEach((me) => {
        if (me && typeof me != "function")
          throw fe.ValidationError.createFrom(`The error handler must be a function. Received "${typeof me}"`);
      }), this;
    }
    areItemsValid() {
      const de = this.items();
      return !!(Array.isArray(de) || typeof de[Symbol.iterator] == "function" || typeof de[Symbol.asyncIterator] == "function");
    }
    /**
     * Prefill the results array with `notRun` symbol values if results should correspond.
     */
    prepareResultsArray() {
      const de = this.items();
      return Array.isArray(de) ? this.shouldUseCorrespondingResults() ? (this.meta.results = Array(de.length).fill(ae.PromisePool.notRun), this) : this : this;
    }
    /**
     * Starts processing the promise pool by iterating over the items
     * and running each item through the async `callback` function.
     *
     * @param {Function} callback
     *
     * @returns {Promise}
     */
    async process() {
      let de = 0;
      for await (const me of this.items()) {
        if (this.isStopped())
          break;
        this.shouldUseCorrespondingResults() && (this.results()[de] = ae.PromisePool.notRun), this.startProcessing(me, de), de += 1, await this.waitForProcessingSlot();
      }
      return await this.drained();
    }
    /**
     * Wait for one of the active tasks to finish processing.
     */
    async waitForProcessingSlot() {
      for (; this.hasReachedConcurrencyLimit(); )
        await this.waitForActiveTaskToFinish();
    }
    /**
     * Wait for the next, currently active task to finish processing.
     */
    async waitForActiveTaskToFinish() {
      await Promise.race(this.tasks());
    }
    /**
     * Create a processing function for the given `item`.
     *
     * @param {T} item
     * @param {number} index
     */
    startProcessing(de, me) {
      const we = this.createTaskFor(de, me).then((Ee) => {
        this.save(Ee, me).removeActive(we);
      }).catch(async (Ee) => {
        await this.handleErrorFor(Ee, de, me), this.removeActive(we);
      }).finally(() => {
        this.processedItems().push(de), this.runOnTaskFinishedHandlers(de);
      });
      this.tasks().push(we), this.runOnTaskStartedHandlers(de);
    }
    /**
     * Ensures a returned promise for the processing of the given `item`.
     *
     * @param {T} item
     * @param {number} index
     *
     * @returns {*}
     */
    async createTaskFor(de, me) {
      if (this.taskTimeout() === void 0)
        return this.handler(de, me, this);
      const [we, Ee] = this.createTaskTimeout(de);
      return Promise.race([
        this.handler(de, me, this),
        we()
      ]).finally(Ee);
    }
    /**
     * Returns a tuple of a timer function and a canceller function that
     * times-out after the configured task timeout.
     */
    createTaskTimeout(de) {
      let me;
      return [async () => new Promise((Se, Be) => {
        me = setTimeout(() => {
          Be(new ie.PromisePoolError(`Task in promise pool timed out after ${this.taskTimeout()}ms`, de));
        }, this.taskTimeout());
      }), () => clearTimeout(me)];
    }
    /**
     * Save the given calculation `result`, possibly at the provided `position`.
     *
     * @param {*} result
     * @param {number} position
     *
     * @returns {PromisePoolExecutor}
     */
    save(de, me) {
      return this.shouldUseCorrespondingResults() ? this.results()[me] = de : this.results().push(de), this;
    }
    /**
     * Remove the given `task` from the list of active tasks.
     *
     * @param {Promise} task
     */
    removeActive(de) {
      return this.tasks().splice(this.tasks().indexOf(de), 1), this;
    }
    /**
     * Create and save an error for the the given `item`.
     *
     * @param {Error} error
     * @param {T} item
     * @param {number} index
     */
    async handleErrorFor(de, me, we) {
      if (this.shouldUseCorrespondingResults() && (this.results()[we] = ae.PromisePool.failed), !this.isStoppingThePoolError(de)) {
        if (this.isValidationError(de))
          throw this.markAsStopped(), de;
        this.hasErrorHandler() ? await this.runErrorHandlerFor(de, me) : this.saveErrorFor(de, me);
      }
    }
    /**
     * Determine whether the given `error` is a `StopThePromisePoolError` instance.
     *
     * @param {Error} error
     *
     * @returns {Boolean}
     */
    isStoppingThePoolError(de) {
      return de instanceof se.StopThePromisePoolError;
    }
    /**
     * Determine whether the given `error` is a `ValidationError` instance.
     *
     * @param {Error} error
     *
     * @returns {Boolean}
     */
    isValidationError(de) {
      return de instanceof fe.ValidationError;
    }
    /**
     * Run the users error handler, if available.
     *
     * @param {Error} processingError
     * @param {T} item
     */
    async runErrorHandlerFor(de, me) {
      try {
        await this.errorHandler?.(de, me, this);
      } catch (we) {
        this.rethrowIfNotStoppingThePool(we);
      }
    }
    /**
     * Run the onTaskStarted handlers.
     */
    runOnTaskStartedHandlers(de) {
      this.onTaskStartedHandlers.forEach((me) => {
        me(de, this);
      });
    }
    /**
     * Run the onTaskFinished handlers.
     */
    runOnTaskFinishedHandlers(de) {
      this.onTaskFinishedHandlers.forEach((me) => {
        me(de, this);
      });
    }
    /**
     * Rethrow the given `error` if its not an instance of `StopThePromisePoolError`.
     *
     * @param {Error} error
     */
    rethrowIfNotStoppingThePool(de) {
      if (!this.isStoppingThePoolError(de))
        throw de;
    }
    /**
     * Create and save an error for the the given `item`.
     *
     * @param {T} item
     */
    saveErrorFor(de, me) {
      this.errors().push(ie.PromisePoolError.createFrom(de, me));
    }
    /**
     * Wait for all active tasks to finish. Once all the tasks finished
     * processing, returns an object containing the results and errors.
     *
     * @returns {Object}
     */
    async drained() {
      return await this.drainActiveTasks(), {
        errors: this.errors(),
        results: this.results()
      };
    }
    /**
     * Wait for all of the active tasks to finish processing.
     */
    async drainActiveTasks() {
      await Promise.all(this.tasks());
    }
  }
  return promisePoolExecutor.PromisePoolExecutor = ue, promisePoolExecutor;
}
var hasRequiredPromisePool;
function requirePromisePool() {
  if (hasRequiredPromisePool)
    return promisePool;
  hasRequiredPromisePool = 1, Object.defineProperty(promisePool, "__esModule", { value: !0 }), promisePool.PromisePool = void 0;
  const ae = requirePromisePoolExecutor();
  class ie {
    /**
     * Instantiates a new promise pool with a default `concurrency: 10` and `items: []`.
     *
     * @param {Object} options
     */
    constructor(fe) {
      this.timeout = void 0, this.concurrency = 10, this.items = fe ?? [], this.errorHandler = void 0, this.onTaskStartedHandlers = [], this.onTaskFinishedHandlers = [], this.shouldResultsCorrespond = !1;
    }
    /**
     * Set the number of tasks to process concurrently in the promise pool.
     *
     * @param {Integer} concurrency
     *
     * @returns {PromisePool}
     */
    withConcurrency(fe) {
      return this.concurrency = fe, this;
    }
    /**
     * Set the number of tasks to process concurrently in the promise pool.
     *
     * @param {Number} concurrency
     *
     * @returns {PromisePool}
     */
    static withConcurrency(fe) {
      return new this().withConcurrency(fe);
    }
    /**
     * Set the timeout in milliseconds for the pool handler.
     *
     * @param {Number} timeout
     *
     * @returns {PromisePool}
     */
    withTaskTimeout(fe) {
      return this.timeout = fe, this;
    }
    /**
     * Set the timeout in milliseconds for the pool handler.
     *
     * @param {Number} timeout
     *
     * @returns {PromisePool}
     */
    static withTaskTimeout(fe) {
      return new this().withTaskTimeout(fe);
    }
    /**
     * Set the items to be processed in the promise pool.
     *
     * @param {SomeIterable<ItemType>} items
     *
     * @returns {PromisePool}
     */
    for(fe) {
      const ue = new ie(fe).withConcurrency(this.concurrency);
      return typeof this.errorHandler == "function" && ue.handleError(this.errorHandler), typeof this.timeout == "number" ? ue.withTaskTimeout(this.timeout) : ue;
    }
    /**
     * Set the items to be processed in the promise pool.
     *
     * @param {T[] | Iterable<T> | AsyncIterable<T>} items
     *
     * @returns {PromisePool}
     */
    static for(fe) {
      return new this().for(fe);
    }
    /**
     * Set the error handler function to execute when an error occurs.
     *
     * @param {ErrorHandler<T>} handler
     *
     * @returns {PromisePool}
     */
    handleError(fe) {
      return this.errorHandler = fe, this;
    }
    /**
     * Assign the given callback `handler` function to run when a task starts.
     *
     * @param {OnProgressCallback<T>} handler
     *
     * @returns {PromisePool}
     */
    onTaskStarted(fe) {
      return this.onTaskStartedHandlers.push(fe), this;
    }
    /**
     * Assign the given callback `handler` function to run when a task finished.
     *
     * @param {OnProgressCallback<T>} handler
     *
     * @returns {PromisePool}
     */
    onTaskFinished(fe) {
      return this.onTaskFinishedHandlers.push(fe), this;
    }
    /**
     * Assign whether to keep corresponding results between source items and resulting tasks.
     */
    useCorrespondingResults() {
      return this.shouldResultsCorrespond = !0, this;
    }
    /**
     * Starts processing the promise pool by iterating over the items
     * and running each item through the async `callback` function.
     *
     * @param {ProcessHandler} The async processing function receiving each item from the `items` array.
     *
     * @returns Promise<{ results, errors }>
     */
    async process(fe) {
      return new ae.PromisePoolExecutor().useConcurrency(this.concurrency).useCorrespondingResults(this.shouldResultsCorrespond).withTaskTimeout(this.timeout).withHandler(fe).handleError(this.errorHandler).onTaskStarted(this.onTaskStartedHandlers).onTaskFinished(this.onTaskFinishedHandlers).for(this.items).start();
    }
  }
  return promisePool.PromisePool = ie, ie.notRun = Symbol("notRun"), ie.failed = Symbol("failed"), promisePool;
}
var contracts = {};
Object.defineProperty(contracts, "__esModule", { value: !0 });
var returnValue = {};
Object.defineProperty(returnValue, "__esModule", { value: !0 });
(function(ae) {
  var ie = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(ue, ce, de, me) {
    me === void 0 && (me = de);
    var we = Object.getOwnPropertyDescriptor(ce, de);
    (!we || ("get" in we ? !ce.__esModule : we.writable || we.configurable)) && (we = { enumerable: !0, get: function() {
      return ce[de];
    } }), Object.defineProperty(ue, me, we);
  } : function(ue, ce, de, me) {
    me === void 0 && (me = de), ue[me] = ce[de];
  }), se = commonjsGlobal && commonjsGlobal.__exportStar || function(ue, ce) {
    for (var de in ue)
      de !== "default" && !Object.prototype.hasOwnProperty.call(ce, de) && ie(ce, ue, de);
  };
  Object.defineProperty(ae, "__esModule", { value: !0 });
  const fe = requirePromisePool();
  ae.default = fe.PromisePool, se(contracts, ae), se(requirePromisePool(), ae), se(promisePoolError, ae), se(returnValue, ae), se(stopThePromisePoolError, ae), se(validationError, ae);
})(dist);
var UploadHeaders;
(function(ae) {
  ae.PAID_BY = "x-irys-paid-by";
})(UploadHeaders || (UploadHeaders = {}));
const NOT_READABLE = Symbol("not readable"), READABLE = Symbol("readable"), ENDED = Symbol("ended"), ERRORED = Symbol("errored"), STATES = {
  notReadable: NOT_READABLE,
  readable: READABLE,
  ended: ENDED,
  errored: ERRORED
};
class StreamToAsyncIterator {
  /** The underlying readable stream */
  _stream;
  /** Contains stream's error when stream has error'ed out */
  _error;
  /** The current state of the iterator (not readable, readable, ended, errored) */
  _state = STATES.notReadable;
  _size;
  /** The rejections of promises to call when stream errors out */
  _rejections = /* @__PURE__ */ new Set();
  get closed() {
    return this._state === STATES.ended;
  }
  constructor(ie, { size: se } = {}) {
    this._stream = ie, this._size = se;
    const fe = ["_handleStreamEnd", "_handleStreamError"];
    for (const ue of fe)
      Object.defineProperty(this, ue, {
        configurable: !0,
        writable: !0,
        value: this[ue].bind(this)
      });
    ie.once("error", this._handleStreamError), ie.once("end", this._handleStreamEnd), ie.on("readable", () => {
      this._state = STATES.readable;
    });
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  /**
   * Returns the next iteration of data. Rejects if the stream errored out.
   */
  async next() {
    switch (this._state) {
      case STATES.notReadable: {
        let ie, se;
        try {
          ie = this._untilReadable(), se = this._untilEnd(), await Promise.race([ie.promise, se.promise]);
        } finally {
          ie?.close(), se?.close();
        }
        return this.next();
      }
      case STATES.ended:
        return this.close(), { done: !0, value: void 0 };
      case STATES.errored:
        throw this.close(), this._error;
      case STATES.readable: {
        const ie = this._size ? this._stream.read(this._size) : this._stream.read();
        return ie !== null ? { done: !1, value: ie } : (this._state = STATES.notReadable, await new Promise((se) => setTimeout((fe) => fe(!0), 0, se)), this.next());
      }
    }
  }
  /**
   * Waits until the stream is readable. Rejects if the stream errored out.
   * @returns Promise when stream is readable
   */
  _untilReadable() {
    let ie;
    const se = new Promise((ue, ce) => {
      ie = () => {
        this._state = STATES.readable, this._rejections.delete(ce), ue();
      }, this._state, STATES.readable, this._stream.once("readable", ie), this._rejections.add(ce);
    });
    return { close: () => {
      ie != null && this._stream.removeListener("readable", ie);
    }, promise: se };
  }
  /**
   * Waits until the stream is ended. Rejects if the stream errored out.
   * @returns Promise when stream is finished
   */
  _untilEnd() {
    let ie;
    const se = new Promise((ue, ce) => {
      ie = () => {
        this._state = STATES.ended, this._rejections.delete(ce), ue();
      }, this._stream.once("end", ie), this._rejections.add(ce);
    });
    return { close: () => {
      ie != null && this._stream.removeListener("end", ie);
    }, promise: se };
  }
  return() {
    return this._state = STATES.ended, this.next();
  }
  throw(ie) {
    return this._error = ie, this._state = STATES.errored, this.next();
  }
  /**
   * Destroy the stream
   * @param err An optional error to pass to the stream for an error event
   */
  close(ie) {
    this._stream.removeListener("end", this._handleStreamEnd), this._stream.removeListener("error", this._handleStreamError), this._state = STATES.ended, this._stream.destroy(ie);
  }
  _handleStreamError(ie) {
    this._error = ie, this._state = STATES.errored;
    for (const se of this._rejections)
      se(ie);
  }
  _handleStreamEnd() {
    this._state = STATES.ended;
  }
  get state() {
    return this._state;
  }
}
class ChunkingUploader extends eventsExports.EventEmitter {
  tokenConfig;
  api;
  uploadID;
  token;
  chunkSize;
  batchSize;
  paused = !1;
  isResume = !1;
  uploadOptions;
  arbundles;
  constructor(ie, se) {
    super({ captureRejections: !0 }), this.tokenConfig = ie, this.arbundles = this.tokenConfig.irys.arbundles, this.api = se, this.token = this.tokenConfig.name, this.chunkSize = 25e6, this.batchSize = 5, this.uploadID = "";
  }
  setResumeData(ie) {
    return ie && (this.uploadID = ie, this.isResume = !0), this;
  }
  /**
   * Note: Will return undefined unless an upload has been started.
   * @returns
   */
  getResumeData() {
    return this.uploadID;
  }
  setChunkSize(ie) {
    if (ie < 1)
      throw new Error("Invalid chunk size (must be >=1)");
    return this.chunkSize = ie, this;
  }
  setBatchSize(ie) {
    if (ie < 1)
      throw new Error("Invalid batch size (must be >=1)");
    return this.batchSize = ie, this;
  }
  pause() {
    this.emit("pause"), this.paused = !0;
  }
  resume() {
    this.paused = !1, this.emit("resume");
  }
  async uploadTransaction(ie, se) {
    return this.uploadOptions = se, this.arbundles.DataItem.isDataItem(ie) ? this.runUpload(ie.getRaw()) : this.runUpload(ie);
  }
  async uploadData(ie, se) {
    return this.uploadOptions = se?.upload, this.runUpload(ie, { ...se });
  }
  async runUpload(ie, se) {
    let fe = this.uploadID;
    const ue = se === void 0, ce = { "x-chunking-version": "2" };
    let de;
    if (!fe)
      de = await this.api.get(`/chunks/${this.token}/-1/-1`, { headers: ce }), Utils.checkAndThrow(de, "Getting upload token"), this.uploadID = fe = de.data.id;
    else {
      if (de = await this.api.get(`/chunks/${this.token}/${fe}/-1`, { headers: ce }), de.status === 404)
        throw new Error("Upload ID not found - your upload has probably expired.");
      if (Utils.checkAndThrow(de, "Getting upload info"), this.chunkSize != +de.data.size)
        throw new Error(`Chunk size not equal to that of a previous upload (${+de.data.size}).`);
    }
    const { max: me, min: we } = de.data;
    if (this.chunkSize < +we || this.chunkSize > +me)
      throw new Error(`Chunk size out of allowed range: ${we} - ${me}`);
    let Ee = 0;
    const Se = (le, pe, ge) => new Promise((ye) => {
      retry$1(async (xe) => {
        await this.api.post(`/chunks/${this.token}/${fe}/${pe}`, le, {
          headers: { "Content-Type": "application/octet-stream", ...ce },
          maxBodyLength: 1 / 0,
          maxContentLength: 1 / 0
        }).then((_e) => {
          if (_e?.status >= 300) {
            const Ae = { res: _e, id: ge, offset: pe, size: le.length };
            throw this.emit("chunkError", Ae), _e?.status === 402 && xe(new Error("Not enough funds to send data")), Ae;
          }
          this.emit("chunkUpload", { id: ge, offset: pe, size: le.length, totalUploaded: Ee += le.length }), ye({ o: pe, d: _e });
        });
      });
    }), Be = de.data.chunks ?? [], Ce = new streamBrowserify.PassThrough();
    let Ie = Buffer$F.alloc(0), Pe = !1, Ne = !0;
    Ce.on("end", () => Pe = !0), Ce.on("error", (le) => {
      throw new Error(`Error processing readable: ${le}`);
    });
    const ke = async (le) => {
      for (; !Pe; ) {
        if (Ie.length >= le)
          return pe = Buffer$F.from(Ie.slice(0, le)), Ie = Ie.slice(le), pe;
        var pe = Ce.read(le);
        if (pe === null) {
          await new Promise((ge) => setTimeout((ye) => ye(!0), 0, ge));
          continue;
        }
        if (pe.length === le)
          return pe;
        Ie = Buffer$F.concat([Ie, pe]);
      }
      for (; Ie.length >= le; )
        return pe = Buffer$F.from(Ie.slice(0, le)), Ie = Ie.slice(le), pe;
      return Ne = !1, Ie;
    };
    let He, De;
    if (!ue) {
      He = this.arbundles.createData("", this.tokenConfig.getSigner(), {
        ...se,
        anchor: se?.anchor ?? crypto$4.randomBytes(32).toString("base64").slice(0, 32)
      });
      const le = He.getRaw();
      De = le.length, Ce.write(le), Ee -= le.length;
    }
    if (Buffer$F.isBuffer(ie))
      Ce.write(ie), Ce.end();
    else if ("pipe" in ie)
      ie.pipe(Ce);
    else
      throw new Error("Input data is not a buffer or a compatible stream (no .pipe method)");
    let Ge = 0;
    const Ye = /* @__PURE__ */ new Set();
    let st = 0, at, mt, qe;
    if (!ue) {
      mt = new streamBrowserify.PassThrough();
      const le = He.getRaw().length;
      if (this.chunkSize < De)
        throw new Error(`Configured chunk size is too small for transaction header! (${this.chunkSize} < ${De})`);
      at = await ke(this.chunkSize), st++, Ge += at.length, mt.write(at.slice(le));
      const pe = [
        this.arbundles.stringToBuffer("dataitem"),
        this.arbundles.stringToBuffer("1"),
        this.arbundles.stringToBuffer(He.signatureType.toString()),
        He.rawOwner,
        He.rawTarget,
        He.rawAnchor,
        He.rawTags,
        new StreamToAsyncIterator(mt)
      ];
      qe = this.arbundles.deepHash(pe);
    }
    let ze = Be.pop();
    for (; Ne; ) {
      if (this.paused && await new Promise((ge) => this.on("resume", () => ge(void 0))), ze && +ze[0] - Ge <= this.chunkSize) {
        const ye = ze[1], xe = await ke(ye);
        ue || mt.write(xe), Ge += ye, ze = Be.pop(), st++, Ee += ye;
        continue;
      }
      const le = await ke(this.chunkSize);
      for (ue || mt.write(le); Ye.size >= this.batchSize; ) {
        const [ge] = await Promise.race(Ye);
        Ye.delete(ge);
      }
      const pe = (async () => await Se(le, Ge, ++st))().then((ge) => [pe, ge]);
      Ye.add(pe), Ge += le.length;
    }
    if (mt && mt.end(), await Promise.all(Ye), !ue) {
      const le = await qe, pe = Buffer$F.from(await this.tokenConfig.getSigner().sign(le));
      at.set(pe, 2), await Se(at, 0, 0);
    }
    const ot = { "Content-Type": "application/octet-stream", ...ce };
    se?.upload?.paidBy && (ot[UploadHeaders.PAID_BY] = se.upload.paidBy);
    const $e = await this.api.post(`/chunks/${this.token}/${fe}/-1`, null, {
      headers: ot,
      timeout: this.api.config?.timeout ?? 4e4 * 10
      // server side reconstruction can take a while
    });
    if ($e.status === 402) {
      const le = $e?.headers?.["retry-after"], pe = $e.data + (le ? ` - retry after ${le}s` : "");
      throw new Error(pe);
    }
    if (Utils.checkAndThrow($e, "Finalising upload", [201]), $e.status === 201)
      throw new Error($e.data);
    return $e.data.verify = Utils.verifyReceipt.bind({}, this.arbundles, $e.data.data), this.emit("done", $e), $e;
  }
  get completionPromise() {
    return new Promise((ie) => this.on("done", ie));
  }
}
const CHUNKING_THRESHOLD = 5e7;
class Uploader {
  api;
  token;
  tokenConfig;
  utils;
  contentTypeOverride;
  forceUseChunking;
  arbundles;
  irysTransaction;
  constructor(ie, se, fe, ue, ce) {
    this.api = ie, this.token = fe, this.tokenConfig = ue, this.arbundles = this.tokenConfig.irys.arbundles, this.utils = se, this.irysTransaction = ce;
  }
  async uploadTransaction(ie, se) {
    let fe;
    const ue = this.arbundles.DataItem.isDataItem(ie);
    if (this.forceUseChunking || ue && ie.getRaw().length >= CHUNKING_THRESHOLD || !ue)
      fe = await this.chunkedUploader.uploadTransaction(ue ? ie.getRaw() : ie, se);
    else {
      const { url: ce, timeout: de, headers: me } = this.api.getConfig(), we = { "Content-Type": "application/octet-stream", ...me };
      if (se?.paidBy && (we[UploadHeaders.PAID_BY] = se.paidBy), fe = await this.api.post(new URL(`/tx/${this.token}`, ce).toString(), ie.getRaw(), {
        headers: we,
        timeout: de,
        maxBodyLength: 1 / 0
      }), fe.status === 201)
        throw new Error(fe.data);
    }
    switch (fe.status) {
      case 402:
        const ce = fe?.headers?.["retry-after"], de = fe.data + (ce ? ` - retry after ${ce}s` : "");
        throw new Error(de);
      default:
        if (fe.status >= 400)
          throw new Error(`whilst uploading Irys transaction: ${fe.status} ${fe.statusText}`);
    }
    return fe.data.verify = async () => this.utils.verifyReceipt(fe.data), fe;
  }
  async uploadData(ie, se) {
    if (typeof ie == "string" && (ie = Buffer$F.from(ie)), Buffer$F.isBuffer(ie) && ie.length <= CHUNKING_THRESHOLD) {
      const fe = this.arbundles.createData(ie, this.tokenConfig.getSigner(), {
        ...se,
        anchor: se?.anchor ?? cryptoBrowserifyExports.randomBytes(32).toString("base64").slice(0, 32)
      });
      return await fe.sign(this.tokenConfig.getSigner()), (await this.uploadTransaction(fe, { ...se?.upload })).data;
    }
    return (await this.chunkedUploader.uploadData(ie, se)).data;
  }
  // concurrently uploads transactions
  async concurrentUploader(ie, se) {
    const fe = [], ue = se?.logFunction ? se?.logFunction : async (me) => {
    }, ce = se?.concurrency ?? 5, de = await dist.PromisePool.for(ie).withConcurrency(ce >= 1 ? ce : 5).handleError(async (me, we) => {
      if (fe.push(me), me.message === "Not enough funds to send data")
        throw me;
    }).process(async (me, we, Ee) => {
      await retry$1(async (Se) => {
        try {
          const Be = await this.processItem(me, se?.itemOptions);
          return we % ce == 0 && await ue(`Processed ${we} Items`), se?.resultProcessor ? await se.resultProcessor({ item: me, res: Be, i: we }) : { item: me, res: Be, i: we };
        } catch (Be) {
          throw Be?.message === "Not enough funds to send data" && Se(Be), Be;
        }
      }, { retries: 3, minTimeout: 1e3, maxTimeout: 1e4 });
    });
    return { errors: fe, results: de.results };
  }
  async processItem(ie, se) {
    return this.arbundles.DataItem.isDataItem(ie) ? this.uploadTransaction(ie, { ...se?.upload }) : this.uploadData(ie, se);
  }
  /**
   * geneates a manifest JSON object
   * @param config.items mapping of logical paths to item IDs
   * @param config.indexFile optional logical path of the index file for the manifest
   * @returns
   */
  async generateManifest(ie) {
    const { items: se, indexFile: fe } = ie, ue = {
      manifest: "arweave/paths",
      version: "0.1.0",
      paths: {}
    };
    if (fe) {
      if (!se.has(fe))
        throw new Error(`Unable to access item: ${fe}`);
      ue.index = { path: fe };
    }
    for (const [ce, de] of se.entries())
      ue.paths[ce] = { id: de };
    return ue;
  }
  get chunkedUploader() {
    return new ChunkingUploader(this.tokenConfig, this.api);
  }
  set useChunking(ie) {
    typeof ie == "boolean" && (this.forceUseChunking = ie);
  }
  set contentType(ie) {
    this.contentTypeOverride = ie;
  }
  async uploadBundle(ie, se) {
    const fe = se?.throwawayKey ?? await this.arbundles.getCryptoDriver().generateJWK(), ue = new ArweaveSigner(fe), ce = ie.map((Se) => this.arbundles.DataItem.isDataItem(Se) ? Se : this.arbundles.createData(Se, ue)), de = await this.arbundles.bundleAndSignData(ce, ue), me = this.arbundles.createData(de.getRaw(), this.tokenConfig.getSigner(), {
      tags: [
        { name: "Bundle-Format", value: "binary" },
        { name: "Bundle-Version", value: "2.0.0" }
      ]
    });
    await me.sign(this.tokenConfig.getSigner());
    const we = await this.uploadTransaction(me, se), Ee = base64url(Buffer$F.from(await this.arbundles.getCryptoDriver().hash(base64url.toBuffer(base64url(ue.publicKey)))));
    return { ...we, txs: ce, throwawayKey: fe, throwawayKeyAddress: Ee };
  }
}
class WebUploader extends Uploader {
  irys;
  constructor(ie) {
    super(ie.api, ie.utils, ie.token, ie.tokenConfig, ie.IrysTransaction), this.irys = ie;
  }
  /**
   * Uploads a tagged file object, automatically adding the content-type tag if it's not present
   * @param file - File object to upload
   * @param opts - optional options for the upload / data item creation
   * @returns
   */
  async uploadFile(ie, se) {
    const ue = (se?.tags ? se.tags.some(({ name: ce }) => ce.toLowerCase() === "content-type") : !1) ? se?.tags : [...se?.tags ?? [], { name: "Content-Type", value: ie.type }];
    return this.uploadData(Buffer$F.from(await ie.arrayBuffer()), { tags: ue, ...se });
  }
  /**
   * Uploads a list of `File` objects & a generated folder manifest as a nested bundle using a temporary signing key.
   *
   * @param files list of `File` objects to upload - note: this code determines the paths via the File's `webkitRelativePath` property - if it's undefined, it falls back to file.name
   * @param {string} [opts.indexFileRelPath] Relative path for the index file, i.e `folder/index.html`
   * @param {Tag[]} [opts.manifestTags] List of tags to add onto the manifest transaction
   * @param {JWKInterface} [opts.throwawayKey] Provide your own throwaway JWK to use for signing the items in the bundle
   * @param {boolean} [opts.seperateManifestTx=false] Whether upload the manifest as a seperate tx (not in the nested bundle) - note: transactions in a nested bundle are not indexed by bundlr GQL - if you have tags you want to use to find the manifest, set this option to true
   *
   * @returns Standard upload response from the bundler node, plus the throwaway key & address, manifest, manifest TxId and the list of generated transactions
   */
  async uploadFolder(ie, se) {
    const fe = [], ue = /* @__PURE__ */ new Map(), ce = se?.throwawayKey ?? await this.irys.arbundles.getCryptoDriver().generateJWK(), de = new ArweaveSigner(ce);
    for (const Se of ie) {
      const Be = Se.webkitRelativePath ? Se.webkitRelativePath : Se.name, Ie = (Se.tags ? Se.tags.some(({ name: Ne }) => Ne.toLowerCase() === "content-type") : !1) ? Se.tags : [...Se.tags ?? [], { name: "Content-Type", value: Se.type }], Pe = this.irys.arbundles.createData(Buffer$F.from(await Se.arrayBuffer()), de, {
        tags: Ie
      });
      await Pe.sign(de), fe.push(Pe), ue.set(Be, Pe.id);
    }
    const me = await this.generateManifest({ items: ue, indexFile: se?.indexFileRelPath }), we = this.irys.arbundles.createData(JSON.stringify(me), se?.seperateManifestTx ? this.irys.tokenConfig.getSigner() : de, {
      tags: [
        { name: "Type", value: "manifest" },
        { name: "Content-Type", value: "application/x.arweave-manifest+json" },
        ...se?.manifestTags ?? []
      ]
    });
    se?.seperateManifestTx === !0 ? (await we.sign(this.irys.tokenConfig.getSigner()), await this.uploadTransaction(we, { ...se })) : (await we.sign(de), fe.push(we));
    const Ee = await this.uploadBundle(fe, { ...se });
    return {
      ...Ee.data,
      manifestId: we.id,
      manifest: me,
      throwawayKey: Ee.throwawayKey,
      throwawayKeyAddress: Ee.throwawayKeyAddress,
      txs: Ee.txs
    };
  }
}
class Approval {
  irys;
  constructor(ie) {
    this.irys = ie;
  }
  async getApprovedBalance({ payingAddress: ie = this.irys.address, token: se = this.irys.token, approvedAddress: fe }) {
    const ue = await this.irys.api.get("/account/approval", { params: { payingAddress: ie, token: se, approvedAddress: fe } });
    return ue.status === 404 ? { amount: "0" } : (Utils.checkAndThrow(ue), ue.data);
  }
  async createApproval({ approvedAddress: ie, amount: se, expiresInSeconds: fe }) {
    const ue = [
      { name: UploadApprovalTags.APPROVE_PAYMENT, value: ie },
      { name: UploadApprovalMetaTags.AMOUNT, value: se.toString() }
    ];
    return fe && ue.push({ name: UploadApprovalMetaTags.EXPIRE_SECONDS, value: fe.toString() }), await this.irys.upload("", { tags: ue });
  }
  async revokeApproval({ approvedAddress: ie }) {
    const se = [{ name: UploadApprovalTags.DELETE_APPROVAL, value: ie }];
    return await this.irys.upload("", { tags: se });
  }
}
var UploadApprovalTags;
(function(ae) {
  ae.APPROVE_PAYMENT = "x-irys-approve-payment", ae.DELETE_APPROVAL = "x-irys-delete-payment-approval";
})(UploadApprovalTags || (UploadApprovalTags = {}));
var UploadApprovalMetaTags;
(function(ae) {
  ae.AMOUNT = "x-amount", ae.EXPIRE_SECONDS = "x-expire-seconds";
})(UploadApprovalMetaTags || (UploadApprovalMetaTags = {}));
class BaseWebIrys extends Irys {
  tokenConfig;
  uploader;
  uploadFolder;
  uploadFile;
  constructor({ url: ie, wallet: se, config: fe, getTokenConfig: ue }) {
    switch (ie) {
      case void 0:
      case "node1":
        ie = "https://node1.irys.xyz";
        break;
      case "node2":
        ie = "https://node2.irys.xyz";
        break;
      case "devnet":
        ie = "https://devnet.irys.xyz";
        break;
    }
    const ce = new URL(ie);
    if (super({ url: ce, arbundles }), this.api = new Api$1({
      url: ce,
      timeout: fe?.timeout ?? 1e5,
      headers: fe?.headers
    }), this.tokenConfig = ue(this), this.token = this.tokenConfig.name, ce.host === "devnet.irys.network" && !(fe?.providerUrl ?? (se?.rpcUrl || this.tokenConfig.inheritsRPC)))
      throw new Error(`Using ${ce.host} requires a dev/testnet RPC to be configured! see https://docs.irys.network/sdk/using-devnet`);
    this.utils = new Utils(this.api, this.token, this.tokenConfig), this.uploader = new WebUploader(this), this.funder = new Fund(this.utils), this.uploader = new WebUploader(this), this.provenance = new Provenance(this), this.transactions = new Transaction$2(this), this.approval = new Approval(this), this.address = "Please run `await Irys.ready()`", this.uploadFolder = this.uploader.uploadFolder.bind(this.uploader), this.uploadFile = this.uploader.uploadFile.bind(this.uploader);
  }
}
class BaseWebToken {
  base;
  wallet;
  _address;
  providerUrl;
  providerInstance;
  ticker;
  name;
  irys;
  config;
  opts;
  minConfirm = 5;
  isSlow = !1;
  needsFee = !0;
  inheritsRPC = !1;
  constructor(ie) {
    Object.assign(this, ie), this.config = ie;
  }
  // common methods
  get address() {
    return this._address;
  }
  async ready() {
    this._address = this.wallet ? this.ownerToAddress(await this.getPublicKey()) : void 0;
  }
  async getId(ie) {
    return base64url.encode(Buffer$F.from(await getCryptoDriver().hash(await ie.rawSignature())));
  }
  async price() {
    return getRedstonePrice(this.ticker);
  }
}
async function getRedstonePrice(ae) {
  const ie = await axios$1.get(`https://api.redstone.finance/prices?symbol=${ae}&provider=redstone&limit=1`);
  return await Utils.checkAndThrow(ie, "Getting price data"), ie.data[0].value;
}
const ethereumSigner = InjectedTypedEthereumSigner;
class EthereumConfig extends BaseWebToken {
  signer;
  w3signer;
  inheritsRPC = !0;
  constructor(ie) {
    super(ie), this.base = ["wei", 1e18];
  }
  async getTx(ie) {
    const fe = await this.providerInstance.getTransaction(ie);
    if (!fe)
      throw new Error("Tx doesn't exist");
    if (!fe.to)
      throw new Error(`Unable to resolve transactions ${ie} receiver`);
    return {
      from: fe.from,
      to: fe.to,
      blockHeight: fe.blockNumber ? new BigNumber$1(fe.blockNumber) : void 0,
      amount: new BigNumber$1(fe.value.toHexString(), 16),
      pending: !fe.blockNumber,
      confirmed: fe.confirmations >= this.minConfirm
    };
  }
  ownerToAddress(ie) {
    return ie.toString().toLowerCase();
  }
  async sign(ie) {
    return (await this.getSigner()).sign(ie);
  }
  getSigner() {
    return this.signer || (this.signer = new InjectedTypedEthereumSigner(this.wallet)), this.signer;
  }
  async verify(ie, se, fe) {
    return ethereumSigner.verify(ie, se, fe);
  }
  async getCurrentHeight() {
    const se = await this.providerInstance.send("eth_blockNumber", []);
    return new BigNumber$1(se, 16);
  }
  async getFee(ie, se) {
    const fe = this.providerInstance, ue = {
      to: se,
      from: this.address,
      value: "0x" + new BigNumber$1(ie).toString(16)
    }, ce = await fe.estimateGas(ue), de = await fe.getGasPrice();
    return new BigNumber$1(ce.mul(de).toString());
  }
  async sendTx(ie) {
    const fe = await this.w3signer.sendTransaction(ie);
    return fe ? fe.hash : void 0;
  }
  async createTx(ie, se, fe) {
    const ue = BigNumber.from(new BigNumber$1(ie).toFixed()), ce = this.w3signer, de = await ce.estimateGas({ to: se, from: this.address, value: ue.toHexString() });
    let me = await ce.getGasPrice();
    return this.name === "matic" && (me = BigNumber.from(new BigNumber$1(me.toString()).multipliedBy(10).decimalPlaces(0).toString())), { txId: void 0, tx: await ce.populateTransaction({ to: se, from: this.address, value: ue.toHexString(), gasPrice: me, gasLimit: de }) };
  }
  async getPublicKey() {
    return this.address;
  }
  async ready() {
    this.w3signer = await this.wallet.getSigner(), this._address = (await this.w3signer.getAddress()).toString().toLowerCase(), await this.getSigner().ready(), this.providerInstance = this.wallet, await this.providerInstance?._ready?.();
  }
}
var lib$7 = {}, constants$1 = {};
(function(ae) {
  Object.defineProperty(ae, "__esModule", { value: !0 }), ae.KeyType = void 0, function(ie) {
    ie[ie.ED25519 = 0] = "ED25519";
  }(ae.KeyType || (ae.KeyType = {}));
})(constants$1);
var key_pair$1 = {}, key_pair_base$1 = {};
Object.defineProperty(key_pair_base$1, "__esModule", { value: !0 });
key_pair_base$1.KeyPairBase = void 0;
let KeyPairBase$1 = class {
};
key_pair_base$1.KeyPairBase = KeyPairBase$1;
var key_pair_ed25519$1 = {}, lib$6 = {}, _Buffer$1 = safeBufferExports.Buffer;
function base$2(ae) {
  if (ae.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var ie = new Uint8Array(256), se = 0; se < ie.length; se++)
    ie[se] = 255;
  for (var fe = 0; fe < ae.length; fe++) {
    var ue = ae.charAt(fe), ce = ue.charCodeAt(0);
    if (ie[ce] !== 255)
      throw new TypeError(ue + " is ambiguous");
    ie[ce] = fe;
  }
  var de = ae.length, me = ae.charAt(0), we = Math.log(de) / Math.log(256), Ee = Math.log(256) / Math.log(de);
  function Se(Ie) {
    if ((Array.isArray(Ie) || Ie instanceof Uint8Array) && (Ie = _Buffer$1.from(Ie)), !_Buffer$1.isBuffer(Ie))
      throw new TypeError("Expected Buffer");
    if (Ie.length === 0)
      return "";
    for (var Pe = 0, Ne = 0, ke = 0, He = Ie.length; ke !== He && Ie[ke] === 0; )
      ke++, Pe++;
    for (var De = (He - ke) * Ee + 1 >>> 0, Ge = new Uint8Array(De); ke !== He; ) {
      for (var Ye = Ie[ke], st = 0, at = De - 1; (Ye !== 0 || st < Ne) && at !== -1; at--, st++)
        Ye += 256 * Ge[at] >>> 0, Ge[at] = Ye % de >>> 0, Ye = Ye / de >>> 0;
      if (Ye !== 0)
        throw new Error("Non-zero carry");
      Ne = st, ke++;
    }
    for (var mt = De - Ne; mt !== De && Ge[mt] === 0; )
      mt++;
    for (var qe = me.repeat(Pe); mt < De; ++mt)
      qe += ae.charAt(Ge[mt]);
    return qe;
  }
  function Be(Ie) {
    if (typeof Ie != "string")
      throw new TypeError("Expected String");
    if (Ie.length === 0)
      return _Buffer$1.alloc(0);
    for (var Pe = 0, Ne = 0, ke = 0; Ie[Pe] === me; )
      Ne++, Pe++;
    for (var He = (Ie.length - Pe) * we + 1 >>> 0, De = new Uint8Array(He); Ie[Pe]; ) {
      var Ge = ie[Ie.charCodeAt(Pe)];
      if (Ge === 255)
        return;
      for (var Ye = 0, st = He - 1; (Ge !== 0 || Ye < ke) && st !== -1; st--, Ye++)
        Ge += de * De[st] >>> 0, De[st] = Ge % 256 >>> 0, Ge = Ge / 256 >>> 0;
      if (Ge !== 0)
        throw new Error("Non-zero carry");
      ke = Ye, Pe++;
    }
    for (var at = He - ke; at !== He && De[at] === 0; )
      at++;
    var mt = _Buffer$1.allocUnsafe(Ne + (He - at));
    mt.fill(0, 0, Ne);
    for (var qe = Ne; at !== He; )
      mt[qe++] = De[at++];
    return mt;
  }
  function Ce(Ie) {
    var Pe = Be(Ie);
    if (Pe)
      return Pe;
    throw new Error("Non-base" + de + " character");
  }
  return {
    encode: Se,
    decodeUnsafe: Be,
    decode: Ce
  };
}
var src$2 = base$2, basex$2 = src$2, ALPHABET$3 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", bs58$4 = basex$2(ALPHABET$3);
function inRange(ae, ie, se) {
  return ie <= ae && ae <= se;
}
function ToDictionary(ae) {
  if (ae === void 0)
    return {};
  if (ae === Object(ae))
    return ae;
  throw TypeError("Could not convert argument to dictionary");
}
function stringToCodePoints(ae) {
  for (var ie = String(ae), se = ie.length, fe = 0, ue = []; fe < se; ) {
    var ce = ie.charCodeAt(fe);
    if (ce < 55296 || ce > 57343)
      ue.push(ce);
    else if (56320 <= ce && ce <= 57343)
      ue.push(65533);
    else if (55296 <= ce && ce <= 56319)
      if (fe === se - 1)
        ue.push(65533);
      else {
        var de = ae.charCodeAt(fe + 1);
        if (56320 <= de && de <= 57343) {
          var me = ce & 1023, we = de & 1023;
          ue.push(65536 + (me << 10) + we), fe += 1;
        } else
          ue.push(65533);
      }
    fe += 1;
  }
  return ue;
}
function codePointsToString(ae) {
  for (var ie = "", se = 0; se < ae.length; ++se) {
    var fe = ae[se];
    fe <= 65535 ? ie += String.fromCharCode(fe) : (fe -= 65536, ie += String.fromCharCode(
      (fe >> 10) + 55296,
      (fe & 1023) + 56320
    ));
  }
  return ie;
}
var end_of_stream = -1;
function Stream(ae) {
  this.tokens = [].slice.call(ae);
}
Stream.prototype = {
  /**
   * @return {boolean} True if end-of-stream has been hit.
   */
  endOfStream: function() {
    return !this.tokens.length;
  },
  /**
   * When a token is read from a stream, the first token in the
   * stream must be returned and subsequently removed, and
   * end-of-stream must be returned otherwise.
   *
   * @return {number} Get the next token from the stream, or
   * end_of_stream.
   */
  read: function() {
    return this.tokens.length ? this.tokens.shift() : end_of_stream;
  },
  /**
   * When one or more tokens are prepended to a stream, those tokens
   * must be inserted, in given order, before the first token in the
   * stream.
   *
   * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.
   */
  prepend: function(ae) {
    if (Array.isArray(ae))
      for (var ie = (
        /**@type {!Array.<number>}*/
        ae
      ); ie.length; )
        this.tokens.unshift(ie.pop());
    else
      this.tokens.unshift(ae);
  },
  /**
   * When one or more tokens are pushed to a stream, those tokens
   * must be inserted, in given order, after the last token in the
   * stream.
   *
   * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.
   */
  push: function(ae) {
    if (Array.isArray(ae))
      for (var ie = (
        /**@type {!Array.<number>}*/
        ae
      ); ie.length; )
        this.tokens.push(ie.shift());
    else
      this.tokens.push(ae);
  }
};
var finished = -1;
function decoderError(ae, ie) {
  if (ae)
    throw TypeError("Decoder error");
  return ie || 65533;
}
var DEFAULT_ENCODING = "utf-8";
function TextDecoder$1(ae, ie) {
  if (!(this instanceof TextDecoder$1))
    return new TextDecoder$1(ae, ie);
  if (ae = ae !== void 0 ? String(ae).toLowerCase() : DEFAULT_ENCODING, ae !== DEFAULT_ENCODING)
    throw new Error("Encoding not supported. Only utf-8 is supported");
  ie = ToDictionary(ie), this._streaming = !1, this._BOMseen = !1, this._decoder = null, this._fatal = !!ie.fatal, this._ignoreBOM = !!ie.ignoreBOM, Object.defineProperty(this, "encoding", { value: "utf-8" }), Object.defineProperty(this, "fatal", { value: this._fatal }), Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
}
TextDecoder$1.prototype = {
  /**
   * @param {ArrayBufferView=} input The buffer of bytes to decode.
   * @param {Object=} options
   * @return {string} The decoded string.
   */
  decode: function(ie, se) {
    var fe;
    typeof ie == "object" && ie instanceof ArrayBuffer ? fe = new Uint8Array(ie) : typeof ie == "object" && "buffer" in ie && ie.buffer instanceof ArrayBuffer ? fe = new Uint8Array(
      ie.buffer,
      ie.byteOffset,
      ie.byteLength
    ) : fe = new Uint8Array(0), se = ToDictionary(se), this._streaming || (this._decoder = new UTF8Decoder({ fatal: this._fatal }), this._BOMseen = !1), this._streaming = !!se.stream;
    for (var ue = new Stream(fe), ce = [], de; !ue.endOfStream() && (de = this._decoder.handler(ue, ue.read()), de !== finished); )
      de !== null && (Array.isArray(de) ? ce.push.apply(
        ce,
        /**@type {!Array.<number>}*/
        de
      ) : ce.push(de));
    if (!this._streaming) {
      do {
        if (de = this._decoder.handler(ue, ue.read()), de === finished)
          break;
        de !== null && (Array.isArray(de) ? ce.push.apply(
          ce,
          /**@type {!Array.<number>}*/
          de
        ) : ce.push(de));
      } while (!ue.endOfStream());
      this._decoder = null;
    }
    return ce.length && ["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen && (ce[0] === 65279 ? (this._BOMseen = !0, ce.shift()) : this._BOMseen = !0), codePointsToString(ce);
  }
};
function TextEncoder$1(ae, ie) {
  if (!(this instanceof TextEncoder$1))
    return new TextEncoder$1(ae, ie);
  if (ae = ae !== void 0 ? String(ae).toLowerCase() : DEFAULT_ENCODING, ae !== DEFAULT_ENCODING)
    throw new Error("Encoding not supported. Only utf-8 is supported");
  ie = ToDictionary(ie), this._streaming = !1, this._encoder = null, this._options = { fatal: !!ie.fatal }, Object.defineProperty(this, "encoding", { value: "utf-8" });
}
TextEncoder$1.prototype = {
  /**
   * @param {string=} opt_string The string to encode.
   * @param {Object=} options
   * @return {Uint8Array} Encoded bytes, as a Uint8Array.
   */
  encode: function(ie, se) {
    ie = ie ? String(ie) : "", se = ToDictionary(se), this._streaming || (this._encoder = new UTF8Encoder(this._options)), this._streaming = !!se.stream;
    for (var fe = [], ue = new Stream(stringToCodePoints(ie)), ce; !ue.endOfStream() && (ce = this._encoder.handler(ue, ue.read()), ce !== finished); )
      Array.isArray(ce) ? fe.push.apply(
        fe,
        /**@type {!Array.<number>}*/
        ce
      ) : fe.push(ce);
    if (!this._streaming) {
      for (; ce = this._encoder.handler(ue, ue.read()), ce !== finished; )
        Array.isArray(ce) ? fe.push.apply(
          fe,
          /**@type {!Array.<number>}*/
          ce
        ) : fe.push(ce);
      this._encoder = null;
    }
    return new Uint8Array(fe);
  }
};
function UTF8Decoder(ae) {
  var ie = ae.fatal, se = 0, fe = 0, ue = 0, ce = 128, de = 191;
  this.handler = function(me, we) {
    if (we === end_of_stream && ue !== 0)
      return ue = 0, decoderError(ie);
    if (we === end_of_stream)
      return finished;
    if (ue === 0) {
      if (inRange(we, 0, 127))
        return we;
      if (inRange(we, 194, 223))
        ue = 1, se = we - 192;
      else if (inRange(we, 224, 239))
        we === 224 && (ce = 160), we === 237 && (de = 159), ue = 2, se = we - 224;
      else if (inRange(we, 240, 244))
        we === 240 && (ce = 144), we === 244 && (de = 143), ue = 3, se = we - 240;
      else
        return decoderError(ie);
      return se = se << 6 * ue, null;
    }
    if (!inRange(we, ce, de))
      return se = ue = fe = 0, ce = 128, de = 191, me.prepend(we), decoderError(ie);
    if (ce = 128, de = 191, fe += 1, se += we - 128 << 6 * (ue - fe), fe !== ue)
      return null;
    var Ee = se;
    return se = ue = fe = 0, Ee;
  };
}
function UTF8Encoder(ae) {
  ae.fatal, this.handler = function(ie, se) {
    if (se === end_of_stream)
      return finished;
    if (inRange(se, 0, 127))
      return se;
    var fe, ue;
    inRange(se, 128, 2047) ? (fe = 1, ue = 192) : inRange(se, 2048, 65535) ? (fe = 2, ue = 224) : inRange(se, 65536, 1114111) && (fe = 3, ue = 240);
    for (var ce = [(se >> 6 * fe) + ue]; fe > 0; ) {
      var de = se >> 6 * (fe - 1);
      ce.push(128 | de & 63), fe -= 1;
    }
    return ce;
  };
}
const encoding$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TextDecoder: TextDecoder$1,
  TextEncoder: TextEncoder$1
}, Symbol.toStringTag, { value: "Module" })), require$$2 = /* @__PURE__ */ getAugmentedNamespace(encoding$1);
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(ae, ie, se, fe) {
  fe === void 0 && (fe = se), Object.defineProperty(ae, fe, { enumerable: !0, get: function() {
    return ie[se];
  } });
} : function(ae, ie, se, fe) {
  fe === void 0 && (fe = se), ae[fe] = ie[se];
}), __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(ae, ie) {
  Object.defineProperty(ae, "default", { enumerable: !0, value: ie });
} : function(ae, ie) {
  ae.default = ie;
}), __decorate = commonjsGlobal && commonjsGlobal.__decorate || function(ae, ie, se, fe) {
  var ue = arguments.length, ce = ue < 3 ? ie : fe === null ? fe = Object.getOwnPropertyDescriptor(ie, se) : fe, de;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    ce = Reflect.decorate(ae, ie, se, fe);
  else
    for (var me = ae.length - 1; me >= 0; me--)
      (de = ae[me]) && (ce = (ue < 3 ? de(ce) : ue > 3 ? de(ie, se, ce) : de(ie, se)) || ce);
  return ue > 3 && ce && Object.defineProperty(ie, se, ce), ce;
}, __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(ae) {
  if (ae && ae.__esModule)
    return ae;
  var ie = {};
  if (ae != null)
    for (var se in ae)
      se !== "default" && Object.hasOwnProperty.call(ae, se) && __createBinding(ie, ae, se);
  return __setModuleDefault(ie, ae), ie;
}, __importDefault$5 = commonjsGlobal && commonjsGlobal.__importDefault || function(ae) {
  return ae && ae.__esModule ? ae : { default: ae };
};
Object.defineProperty(lib$6, "__esModule", { value: !0 });
var deserializeUnchecked_1 = lib$6.deserializeUnchecked = deserialize_1 = lib$6.deserialize = serialize_1 = lib$6.serialize = lib$6.BinaryReader = lib$6.BinaryWriter = lib$6.BorshError = lib$6.baseDecode = lib$6.baseEncode = void 0;
const bn_js_1 = __importDefault$5(bnExports$4), bs58_1 = __importDefault$5(bs58$4), encoding = __importStar(require$$2), ResolvedTextDecoder = typeof TextDecoder != "function" ? encoding.TextDecoder : TextDecoder, textDecoder = new ResolvedTextDecoder("utf-8", { fatal: !0 });
function baseEncode(ae) {
  return typeof ae == "string" && (ae = Buffer$F.from(ae, "utf8")), bs58_1.default.encode(Buffer$F.from(ae));
}
lib$6.baseEncode = baseEncode;
function baseDecode(ae) {
  return Buffer$F.from(bs58_1.default.decode(ae));
}
lib$6.baseDecode = baseDecode;
const INITIAL_LENGTH = 1024;
class BorshError extends Error {
  constructor(ie) {
    super(ie), this.fieldPath = [], this.originalMessage = ie;
  }
  addToFieldPath(ie) {
    this.fieldPath.splice(0, 0, ie), this.message = this.originalMessage + ": " + this.fieldPath.join(".");
  }
}
lib$6.BorshError = BorshError;
class BinaryWriter {
  constructor() {
    this.buf = Buffer$F.alloc(INITIAL_LENGTH), this.length = 0;
  }
  maybeResize() {
    this.buf.length < 16 + this.length && (this.buf = Buffer$F.concat([this.buf, Buffer$F.alloc(INITIAL_LENGTH)]));
  }
  writeU8(ie) {
    this.maybeResize(), this.buf.writeUInt8(ie, this.length), this.length += 1;
  }
  writeU16(ie) {
    this.maybeResize(), this.buf.writeUInt16LE(ie, this.length), this.length += 2;
  }
  writeU32(ie) {
    this.maybeResize(), this.buf.writeUInt32LE(ie, this.length), this.length += 4;
  }
  writeU64(ie) {
    this.maybeResize(), this.writeBuffer(Buffer$F.from(new bn_js_1.default(ie).toArray("le", 8)));
  }
  writeU128(ie) {
    this.maybeResize(), this.writeBuffer(Buffer$F.from(new bn_js_1.default(ie).toArray("le", 16)));
  }
  writeU256(ie) {
    this.maybeResize(), this.writeBuffer(Buffer$F.from(new bn_js_1.default(ie).toArray("le", 32)));
  }
  writeU512(ie) {
    this.maybeResize(), this.writeBuffer(Buffer$F.from(new bn_js_1.default(ie).toArray("le", 64)));
  }
  writeBuffer(ie) {
    this.buf = Buffer$F.concat([
      Buffer$F.from(this.buf.subarray(0, this.length)),
      ie,
      Buffer$F.alloc(INITIAL_LENGTH)
    ]), this.length += ie.length;
  }
  writeString(ie) {
    this.maybeResize();
    const se = Buffer$F.from(ie, "utf8");
    this.writeU32(se.length), this.writeBuffer(se);
  }
  writeFixedArray(ie) {
    this.writeBuffer(Buffer$F.from(ie));
  }
  writeArray(ie, se) {
    this.maybeResize(), this.writeU32(ie.length);
    for (const fe of ie)
      this.maybeResize(), se(fe);
  }
  toArray() {
    return this.buf.subarray(0, this.length);
  }
}
lib$6.BinaryWriter = BinaryWriter;
function handlingRangeError(ae, ie, se) {
  const fe = se.value;
  se.value = function(...ue) {
    try {
      return fe.apply(this, ue);
    } catch (ce) {
      if (ce instanceof RangeError) {
        const de = ce.code;
        if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(de) >= 0)
          throw new BorshError("Reached the end of buffer when deserializing");
      }
      throw ce;
    }
  };
}
class BinaryReader {
  constructor(ie) {
    this.buf = ie, this.offset = 0;
  }
  readU8() {
    const ie = this.buf.readUInt8(this.offset);
    return this.offset += 1, ie;
  }
  readU16() {
    const ie = this.buf.readUInt16LE(this.offset);
    return this.offset += 2, ie;
  }
  readU32() {
    const ie = this.buf.readUInt32LE(this.offset);
    return this.offset += 4, ie;
  }
  readU64() {
    const ie = this.readBuffer(8);
    return new bn_js_1.default(ie, "le");
  }
  readU128() {
    const ie = this.readBuffer(16);
    return new bn_js_1.default(ie, "le");
  }
  readU256() {
    const ie = this.readBuffer(32);
    return new bn_js_1.default(ie, "le");
  }
  readU512() {
    const ie = this.readBuffer(64);
    return new bn_js_1.default(ie, "le");
  }
  readBuffer(ie) {
    if (this.offset + ie > this.buf.length)
      throw new BorshError(`Expected buffer length ${ie} isn't within bounds`);
    const se = this.buf.slice(this.offset, this.offset + ie);
    return this.offset += ie, se;
  }
  readString() {
    const ie = this.readU32(), se = this.readBuffer(ie);
    try {
      return textDecoder.decode(se);
    } catch (fe) {
      throw new BorshError(`Error decoding UTF-8 string: ${fe}`);
    }
  }
  readFixedArray(ie) {
    return new Uint8Array(this.readBuffer(ie));
  }
  readArray(ie) {
    const se = this.readU32(), fe = Array();
    for (let ue = 0; ue < se; ++ue)
      fe.push(ie());
    return fe;
  }
}
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU8", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU16", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU32", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU64", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU128", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU256", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU512", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readString", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readFixedArray", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readArray", null);
lib$6.BinaryReader = BinaryReader;
function capitalizeFirstLetter(ae) {
  return ae.charAt(0).toUpperCase() + ae.slice(1);
}
function serializeField(ae, ie, se, fe, ue) {
  try {
    if (typeof fe == "string")
      ue[`write${capitalizeFirstLetter(fe)}`](se);
    else if (fe instanceof Array)
      if (typeof fe[0] == "number") {
        if (se.length !== fe[0])
          throw new BorshError(`Expecting byte array of length ${fe[0]}, but got ${se.length} bytes`);
        ue.writeFixedArray(se);
      } else if (fe.length === 2 && typeof fe[1] == "number") {
        if (se.length !== fe[1])
          throw new BorshError(`Expecting byte array of length ${fe[1]}, but got ${se.length} bytes`);
        for (let ce = 0; ce < fe[1]; ce++)
          serializeField(ae, null, se[ce], fe[0], ue);
      } else
        ue.writeArray(se, (ce) => {
          serializeField(ae, ie, ce, fe[0], ue);
        });
    else if (fe.kind !== void 0)
      switch (fe.kind) {
        case "option": {
          se == null ? ue.writeU8(0) : (ue.writeU8(1), serializeField(ae, ie, se, fe.type, ue));
          break;
        }
        case "map": {
          ue.writeU32(se.size), se.forEach((ce, de) => {
            serializeField(ae, ie, de, fe.key, ue), serializeField(ae, ie, ce, fe.value, ue);
          });
          break;
        }
        default:
          throw new BorshError(`FieldType ${fe} unrecognized`);
      }
    else
      serializeStruct(ae, se, ue);
  } catch (ce) {
    throw ce instanceof BorshError && ce.addToFieldPath(ie), ce;
  }
}
function serializeStruct(ae, ie, se) {
  if (typeof ie.borshSerialize == "function") {
    ie.borshSerialize(se);
    return;
  }
  const fe = ae.get(ie.constructor);
  if (!fe)
    throw new BorshError(`Class ${ie.constructor.name} is missing in schema`);
  if (fe.kind === "struct")
    fe.fields.map(([ue, ce]) => {
      serializeField(ae, ue, ie[ue], ce, se);
    });
  else if (fe.kind === "enum") {
    const ue = ie[fe.field];
    for (let ce = 0; ce < fe.values.length; ++ce) {
      const [de, me] = fe.values[ce];
      if (de === ue) {
        se.writeU8(ce), serializeField(ae, de, ie[de], me, se);
        break;
      }
    }
  } else
    throw new BorshError(`Unexpected schema kind: ${fe.kind} for ${ie.constructor.name}`);
}
function serialize(ae, ie, se = BinaryWriter) {
  const fe = new se();
  return serializeStruct(ae, ie, fe), fe.toArray();
}
var serialize_1 = lib$6.serialize = serialize;
function deserializeField(ae, ie, se, fe) {
  try {
    if (typeof se == "string")
      return fe[`read${capitalizeFirstLetter(se)}`]();
    if (se instanceof Array) {
      if (typeof se[0] == "number")
        return fe.readFixedArray(se[0]);
      if (typeof se[1] == "number") {
        const ue = [];
        for (let ce = 0; ce < se[1]; ce++)
          ue.push(deserializeField(ae, null, se[0], fe));
        return ue;
      } else
        return fe.readArray(() => deserializeField(ae, ie, se[0], fe));
    }
    if (se.kind === "option")
      return fe.readU8() ? deserializeField(ae, ie, se.type, fe) : void 0;
    if (se.kind === "map") {
      let ue = /* @__PURE__ */ new Map();
      const ce = fe.readU32();
      for (let de = 0; de < ce; de++) {
        const me = deserializeField(ae, ie, se.key, fe), we = deserializeField(ae, ie, se.value, fe);
        ue.set(me, we);
      }
      return ue;
    }
    return deserializeStruct(ae, se, fe);
  } catch (ue) {
    throw ue instanceof BorshError && ue.addToFieldPath(ie), ue;
  }
}
function deserializeStruct(ae, ie, se) {
  if (typeof ie.borshDeserialize == "function")
    return ie.borshDeserialize(se);
  const fe = ae.get(ie);
  if (!fe)
    throw new BorshError(`Class ${ie.name} is missing in schema`);
  if (fe.kind === "struct") {
    const ue = {};
    for (const [ce, de] of ae.get(ie).fields)
      ue[ce] = deserializeField(ae, ce, de, se);
    return new ie(ue);
  }
  if (fe.kind === "enum") {
    const ue = se.readU8();
    if (ue >= fe.values.length)
      throw new BorshError(`Enum index: ${ue} is out of range`);
    const [ce, de] = fe.values[ue], me = deserializeField(ae, ce, de, se);
    return new ie({ [ce]: me });
  }
  throw new BorshError(`Unexpected schema kind: ${fe.kind} for ${ie.constructor.name}`);
}
function deserialize(ae, ie, se, fe = BinaryReader) {
  const ue = new fe(se), ce = deserializeStruct(ae, ie, ue);
  if (ue.offset < se.length)
    throw new BorshError(`Unexpected ${se.length - ue.offset} bytes after deserialized data`);
  return ce;
}
var deserialize_1 = lib$6.deserialize = deserialize;
function deserializeUnchecked(ae, ie, se, fe = BinaryReader) {
  const ue = new fe(se);
  return deserializeStruct(ae, ie, ue);
}
deserializeUnchecked_1 = lib$6.deserializeUnchecked = deserializeUnchecked;
function commonjsRequire(ae) {
  throw new Error('Could not dynamically require "' + ae + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var naclFast = { exports: {} };
(function(ae) {
  (function(ie) {
    var se = function(Ve) {
      var Ze, Xe = new Float64Array(16);
      if (Ve)
        for (Ze = 0; Ze < Ve.length; Ze++)
          Xe[Ze] = Ve[Ze];
      return Xe;
    }, fe = function() {
      throw new Error("no PRNG");
    }, ue = new Uint8Array(16), ce = new Uint8Array(32);
    ce[0] = 9;
    var de = se(), me = se([1]), we = se([56129, 1]), Ee = se([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), Se = se([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), Be = se([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Ce = se([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), Ie = se([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function Pe(Ve, Ze, Xe, Ue) {
      Ve[Ze] = Xe >> 24 & 255, Ve[Ze + 1] = Xe >> 16 & 255, Ve[Ze + 2] = Xe >> 8 & 255, Ve[Ze + 3] = Xe & 255, Ve[Ze + 4] = Ue >> 24 & 255, Ve[Ze + 5] = Ue >> 16 & 255, Ve[Ze + 6] = Ue >> 8 & 255, Ve[Ze + 7] = Ue & 255;
    }
    function Ne(Ve, Ze, Xe, Ue, Qe) {
      var pt, Ct = 0;
      for (pt = 0; pt < Qe; pt++)
        Ct |= Ve[Ze + pt] ^ Xe[Ue + pt];
      return (1 & Ct - 1 >>> 8) - 1;
    }
    function ke(Ve, Ze, Xe, Ue) {
      return Ne(Ve, Ze, Xe, Ue, 16);
    }
    function He(Ve, Ze, Xe, Ue) {
      return Ne(Ve, Ze, Xe, Ue, 32);
    }
    function De(Ve, Ze, Xe, Ue) {
      for (var Qe = Ue[0] & 255 | (Ue[1] & 255) << 8 | (Ue[2] & 255) << 16 | (Ue[3] & 255) << 24, pt = Xe[0] & 255 | (Xe[1] & 255) << 8 | (Xe[2] & 255) << 16 | (Xe[3] & 255) << 24, Ct = Xe[4] & 255 | (Xe[5] & 255) << 8 | (Xe[6] & 255) << 16 | (Xe[7] & 255) << 24, bt = Xe[8] & 255 | (Xe[9] & 255) << 8 | (Xe[10] & 255) << 16 | (Xe[11] & 255) << 24, Tt = Xe[12] & 255 | (Xe[13] & 255) << 8 | (Xe[14] & 255) << 16 | (Xe[15] & 255) << 24, br = Ue[4] & 255 | (Ue[5] & 255) << 8 | (Ue[6] & 255) << 16 | (Ue[7] & 255) << 24, gr = Ze[0] & 255 | (Ze[1] & 255) << 8 | (Ze[2] & 255) << 16 | (Ze[3] & 255) << 24, Fr = Ze[4] & 255 | (Ze[5] & 255) << 8 | (Ze[6] & 255) << 16 | (Ze[7] & 255) << 24, wr = Ze[8] & 255 | (Ze[9] & 255) << 8 | (Ze[10] & 255) << 16 | (Ze[11] & 255) << 24, Rr = Ze[12] & 255 | (Ze[13] & 255) << 8 | (Ze[14] & 255) << 16 | (Ze[15] & 255) << 24, kr = Ue[8] & 255 | (Ue[9] & 255) << 8 | (Ue[10] & 255) << 16 | (Ue[11] & 255) << 24, Pr = Xe[16] & 255 | (Xe[17] & 255) << 8 | (Xe[18] & 255) << 16 | (Xe[19] & 255) << 24, Ur = Xe[20] & 255 | (Xe[21] & 255) << 8 | (Xe[22] & 255) << 16 | (Xe[23] & 255) << 24, Ir = Xe[24] & 255 | (Xe[25] & 255) << 8 | (Xe[26] & 255) << 16 | (Xe[27] & 255) << 24, Or = Xe[28] & 255 | (Xe[29] & 255) << 8 | (Xe[30] & 255) << 16 | (Xe[31] & 255) << 24, Nr = Ue[12] & 255 | (Ue[13] & 255) << 8 | (Ue[14] & 255) << 16 | (Ue[15] & 255) << 24, Er = Qe, Br = pt, _r = Ct, Sr = bt, Mr = Tt, $r = br, Yt = gr, er = Fr, xr = wr, yr = Rr, vr = kr, Ar = Pr, Vr = Ur, Jr = Ir, Yr = Or, Xr = Nr, At, en = 0; en < 20; en += 2)
        At = Er + Vr | 0, Mr ^= At << 7 | At >>> 25, At = Mr + Er | 0, xr ^= At << 9 | At >>> 23, At = xr + Mr | 0, Vr ^= At << 13 | At >>> 19, At = Vr + xr | 0, Er ^= At << 18 | At >>> 14, At = $r + Br | 0, yr ^= At << 7 | At >>> 25, At = yr + $r | 0, Jr ^= At << 9 | At >>> 23, At = Jr + yr | 0, Br ^= At << 13 | At >>> 19, At = Br + Jr | 0, $r ^= At << 18 | At >>> 14, At = vr + Yt | 0, Yr ^= At << 7 | At >>> 25, At = Yr + vr | 0, _r ^= At << 9 | At >>> 23, At = _r + Yr | 0, Yt ^= At << 13 | At >>> 19, At = Yt + _r | 0, vr ^= At << 18 | At >>> 14, At = Xr + Ar | 0, Sr ^= At << 7 | At >>> 25, At = Sr + Xr | 0, er ^= At << 9 | At >>> 23, At = er + Sr | 0, Ar ^= At << 13 | At >>> 19, At = Ar + er | 0, Xr ^= At << 18 | At >>> 14, At = Er + Sr | 0, Br ^= At << 7 | At >>> 25, At = Br + Er | 0, _r ^= At << 9 | At >>> 23, At = _r + Br | 0, Sr ^= At << 13 | At >>> 19, At = Sr + _r | 0, Er ^= At << 18 | At >>> 14, At = $r + Mr | 0, Yt ^= At << 7 | At >>> 25, At = Yt + $r | 0, er ^= At << 9 | At >>> 23, At = er + Yt | 0, Mr ^= At << 13 | At >>> 19, At = Mr + er | 0, $r ^= At << 18 | At >>> 14, At = vr + yr | 0, Ar ^= At << 7 | At >>> 25, At = Ar + vr | 0, xr ^= At << 9 | At >>> 23, At = xr + Ar | 0, yr ^= At << 13 | At >>> 19, At = yr + xr | 0, vr ^= At << 18 | At >>> 14, At = Xr + Yr | 0, Vr ^= At << 7 | At >>> 25, At = Vr + Xr | 0, Jr ^= At << 9 | At >>> 23, At = Jr + Vr | 0, Yr ^= At << 13 | At >>> 19, At = Yr + Jr | 0, Xr ^= At << 18 | At >>> 14;
      Er = Er + Qe | 0, Br = Br + pt | 0, _r = _r + Ct | 0, Sr = Sr + bt | 0, Mr = Mr + Tt | 0, $r = $r + br | 0, Yt = Yt + gr | 0, er = er + Fr | 0, xr = xr + wr | 0, yr = yr + Rr | 0, vr = vr + kr | 0, Ar = Ar + Pr | 0, Vr = Vr + Ur | 0, Jr = Jr + Ir | 0, Yr = Yr + Or | 0, Xr = Xr + Nr | 0, Ve[0] = Er >>> 0 & 255, Ve[1] = Er >>> 8 & 255, Ve[2] = Er >>> 16 & 255, Ve[3] = Er >>> 24 & 255, Ve[4] = Br >>> 0 & 255, Ve[5] = Br >>> 8 & 255, Ve[6] = Br >>> 16 & 255, Ve[7] = Br >>> 24 & 255, Ve[8] = _r >>> 0 & 255, Ve[9] = _r >>> 8 & 255, Ve[10] = _r >>> 16 & 255, Ve[11] = _r >>> 24 & 255, Ve[12] = Sr >>> 0 & 255, Ve[13] = Sr >>> 8 & 255, Ve[14] = Sr >>> 16 & 255, Ve[15] = Sr >>> 24 & 255, Ve[16] = Mr >>> 0 & 255, Ve[17] = Mr >>> 8 & 255, Ve[18] = Mr >>> 16 & 255, Ve[19] = Mr >>> 24 & 255, Ve[20] = $r >>> 0 & 255, Ve[21] = $r >>> 8 & 255, Ve[22] = $r >>> 16 & 255, Ve[23] = $r >>> 24 & 255, Ve[24] = Yt >>> 0 & 255, Ve[25] = Yt >>> 8 & 255, Ve[26] = Yt >>> 16 & 255, Ve[27] = Yt >>> 24 & 255, Ve[28] = er >>> 0 & 255, Ve[29] = er >>> 8 & 255, Ve[30] = er >>> 16 & 255, Ve[31] = er >>> 24 & 255, Ve[32] = xr >>> 0 & 255, Ve[33] = xr >>> 8 & 255, Ve[34] = xr >>> 16 & 255, Ve[35] = xr >>> 24 & 255, Ve[36] = yr >>> 0 & 255, Ve[37] = yr >>> 8 & 255, Ve[38] = yr >>> 16 & 255, Ve[39] = yr >>> 24 & 255, Ve[40] = vr >>> 0 & 255, Ve[41] = vr >>> 8 & 255, Ve[42] = vr >>> 16 & 255, Ve[43] = vr >>> 24 & 255, Ve[44] = Ar >>> 0 & 255, Ve[45] = Ar >>> 8 & 255, Ve[46] = Ar >>> 16 & 255, Ve[47] = Ar >>> 24 & 255, Ve[48] = Vr >>> 0 & 255, Ve[49] = Vr >>> 8 & 255, Ve[50] = Vr >>> 16 & 255, Ve[51] = Vr >>> 24 & 255, Ve[52] = Jr >>> 0 & 255, Ve[53] = Jr >>> 8 & 255, Ve[54] = Jr >>> 16 & 255, Ve[55] = Jr >>> 24 & 255, Ve[56] = Yr >>> 0 & 255, Ve[57] = Yr >>> 8 & 255, Ve[58] = Yr >>> 16 & 255, Ve[59] = Yr >>> 24 & 255, Ve[60] = Xr >>> 0 & 255, Ve[61] = Xr >>> 8 & 255, Ve[62] = Xr >>> 16 & 255, Ve[63] = Xr >>> 24 & 255;
    }
    function Ge(Ve, Ze, Xe, Ue) {
      for (var Qe = Ue[0] & 255 | (Ue[1] & 255) << 8 | (Ue[2] & 255) << 16 | (Ue[3] & 255) << 24, pt = Xe[0] & 255 | (Xe[1] & 255) << 8 | (Xe[2] & 255) << 16 | (Xe[3] & 255) << 24, Ct = Xe[4] & 255 | (Xe[5] & 255) << 8 | (Xe[6] & 255) << 16 | (Xe[7] & 255) << 24, bt = Xe[8] & 255 | (Xe[9] & 255) << 8 | (Xe[10] & 255) << 16 | (Xe[11] & 255) << 24, Tt = Xe[12] & 255 | (Xe[13] & 255) << 8 | (Xe[14] & 255) << 16 | (Xe[15] & 255) << 24, br = Ue[4] & 255 | (Ue[5] & 255) << 8 | (Ue[6] & 255) << 16 | (Ue[7] & 255) << 24, gr = Ze[0] & 255 | (Ze[1] & 255) << 8 | (Ze[2] & 255) << 16 | (Ze[3] & 255) << 24, Fr = Ze[4] & 255 | (Ze[5] & 255) << 8 | (Ze[6] & 255) << 16 | (Ze[7] & 255) << 24, wr = Ze[8] & 255 | (Ze[9] & 255) << 8 | (Ze[10] & 255) << 16 | (Ze[11] & 255) << 24, Rr = Ze[12] & 255 | (Ze[13] & 255) << 8 | (Ze[14] & 255) << 16 | (Ze[15] & 255) << 24, kr = Ue[8] & 255 | (Ue[9] & 255) << 8 | (Ue[10] & 255) << 16 | (Ue[11] & 255) << 24, Pr = Xe[16] & 255 | (Xe[17] & 255) << 8 | (Xe[18] & 255) << 16 | (Xe[19] & 255) << 24, Ur = Xe[20] & 255 | (Xe[21] & 255) << 8 | (Xe[22] & 255) << 16 | (Xe[23] & 255) << 24, Ir = Xe[24] & 255 | (Xe[25] & 255) << 8 | (Xe[26] & 255) << 16 | (Xe[27] & 255) << 24, Or = Xe[28] & 255 | (Xe[29] & 255) << 8 | (Xe[30] & 255) << 16 | (Xe[31] & 255) << 24, Nr = Ue[12] & 255 | (Ue[13] & 255) << 8 | (Ue[14] & 255) << 16 | (Ue[15] & 255) << 24, Er = Qe, Br = pt, _r = Ct, Sr = bt, Mr = Tt, $r = br, Yt = gr, er = Fr, xr = wr, yr = Rr, vr = kr, Ar = Pr, Vr = Ur, Jr = Ir, Yr = Or, Xr = Nr, At, en = 0; en < 20; en += 2)
        At = Er + Vr | 0, Mr ^= At << 7 | At >>> 25, At = Mr + Er | 0, xr ^= At << 9 | At >>> 23, At = xr + Mr | 0, Vr ^= At << 13 | At >>> 19, At = Vr + xr | 0, Er ^= At << 18 | At >>> 14, At = $r + Br | 0, yr ^= At << 7 | At >>> 25, At = yr + $r | 0, Jr ^= At << 9 | At >>> 23, At = Jr + yr | 0, Br ^= At << 13 | At >>> 19, At = Br + Jr | 0, $r ^= At << 18 | At >>> 14, At = vr + Yt | 0, Yr ^= At << 7 | At >>> 25, At = Yr + vr | 0, _r ^= At << 9 | At >>> 23, At = _r + Yr | 0, Yt ^= At << 13 | At >>> 19, At = Yt + _r | 0, vr ^= At << 18 | At >>> 14, At = Xr + Ar | 0, Sr ^= At << 7 | At >>> 25, At = Sr + Xr | 0, er ^= At << 9 | At >>> 23, At = er + Sr | 0, Ar ^= At << 13 | At >>> 19, At = Ar + er | 0, Xr ^= At << 18 | At >>> 14, At = Er + Sr | 0, Br ^= At << 7 | At >>> 25, At = Br + Er | 0, _r ^= At << 9 | At >>> 23, At = _r + Br | 0, Sr ^= At << 13 | At >>> 19, At = Sr + _r | 0, Er ^= At << 18 | At >>> 14, At = $r + Mr | 0, Yt ^= At << 7 | At >>> 25, At = Yt + $r | 0, er ^= At << 9 | At >>> 23, At = er + Yt | 0, Mr ^= At << 13 | At >>> 19, At = Mr + er | 0, $r ^= At << 18 | At >>> 14, At = vr + yr | 0, Ar ^= At << 7 | At >>> 25, At = Ar + vr | 0, xr ^= At << 9 | At >>> 23, At = xr + Ar | 0, yr ^= At << 13 | At >>> 19, At = yr + xr | 0, vr ^= At << 18 | At >>> 14, At = Xr + Yr | 0, Vr ^= At << 7 | At >>> 25, At = Vr + Xr | 0, Jr ^= At << 9 | At >>> 23, At = Jr + Vr | 0, Yr ^= At << 13 | At >>> 19, At = Yr + Jr | 0, Xr ^= At << 18 | At >>> 14;
      Ve[0] = Er >>> 0 & 255, Ve[1] = Er >>> 8 & 255, Ve[2] = Er >>> 16 & 255, Ve[3] = Er >>> 24 & 255, Ve[4] = $r >>> 0 & 255, Ve[5] = $r >>> 8 & 255, Ve[6] = $r >>> 16 & 255, Ve[7] = $r >>> 24 & 255, Ve[8] = vr >>> 0 & 255, Ve[9] = vr >>> 8 & 255, Ve[10] = vr >>> 16 & 255, Ve[11] = vr >>> 24 & 255, Ve[12] = Xr >>> 0 & 255, Ve[13] = Xr >>> 8 & 255, Ve[14] = Xr >>> 16 & 255, Ve[15] = Xr >>> 24 & 255, Ve[16] = Yt >>> 0 & 255, Ve[17] = Yt >>> 8 & 255, Ve[18] = Yt >>> 16 & 255, Ve[19] = Yt >>> 24 & 255, Ve[20] = er >>> 0 & 255, Ve[21] = er >>> 8 & 255, Ve[22] = er >>> 16 & 255, Ve[23] = er >>> 24 & 255, Ve[24] = xr >>> 0 & 255, Ve[25] = xr >>> 8 & 255, Ve[26] = xr >>> 16 & 255, Ve[27] = xr >>> 24 & 255, Ve[28] = yr >>> 0 & 255, Ve[29] = yr >>> 8 & 255, Ve[30] = yr >>> 16 & 255, Ve[31] = yr >>> 24 & 255;
    }
    function Ye(Ve, Ze, Xe, Ue) {
      De(Ve, Ze, Xe, Ue);
    }
    function st(Ve, Ze, Xe, Ue) {
      Ge(Ve, Ze, Xe, Ue);
    }
    var at = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function mt(Ve, Ze, Xe, Ue, Qe, pt, Ct) {
      var bt = new Uint8Array(16), Tt = new Uint8Array(64), br, gr;
      for (gr = 0; gr < 16; gr++)
        bt[gr] = 0;
      for (gr = 0; gr < 8; gr++)
        bt[gr] = pt[gr];
      for (; Qe >= 64; ) {
        for (Ye(Tt, bt, Ct, at), gr = 0; gr < 64; gr++)
          Ve[Ze + gr] = Xe[Ue + gr] ^ Tt[gr];
        for (br = 1, gr = 8; gr < 16; gr++)
          br = br + (bt[gr] & 255) | 0, bt[gr] = br & 255, br >>>= 8;
        Qe -= 64, Ze += 64, Ue += 64;
      }
      if (Qe > 0)
        for (Ye(Tt, bt, Ct, at), gr = 0; gr < Qe; gr++)
          Ve[Ze + gr] = Xe[Ue + gr] ^ Tt[gr];
      return 0;
    }
    function qe(Ve, Ze, Xe, Ue, Qe) {
      var pt = new Uint8Array(16), Ct = new Uint8Array(64), bt, Tt;
      for (Tt = 0; Tt < 16; Tt++)
        pt[Tt] = 0;
      for (Tt = 0; Tt < 8; Tt++)
        pt[Tt] = Ue[Tt];
      for (; Xe >= 64; ) {
        for (Ye(Ct, pt, Qe, at), Tt = 0; Tt < 64; Tt++)
          Ve[Ze + Tt] = Ct[Tt];
        for (bt = 1, Tt = 8; Tt < 16; Tt++)
          bt = bt + (pt[Tt] & 255) | 0, pt[Tt] = bt & 255, bt >>>= 8;
        Xe -= 64, Ze += 64;
      }
      if (Xe > 0)
        for (Ye(Ct, pt, Qe, at), Tt = 0; Tt < Xe; Tt++)
          Ve[Ze + Tt] = Ct[Tt];
      return 0;
    }
    function ze(Ve, Ze, Xe, Ue, Qe) {
      var pt = new Uint8Array(32);
      st(pt, Ue, Qe, at);
      for (var Ct = new Uint8Array(8), bt = 0; bt < 8; bt++)
        Ct[bt] = Ue[bt + 16];
      return qe(Ve, Ze, Xe, Ct, pt);
    }
    function ot(Ve, Ze, Xe, Ue, Qe, pt, Ct) {
      var bt = new Uint8Array(32);
      st(bt, pt, Ct, at);
      for (var Tt = new Uint8Array(8), br = 0; br < 8; br++)
        Tt[br] = pt[br + 16];
      return mt(Ve, Ze, Xe, Ue, Qe, Tt, bt);
    }
    var $e = function(Ve) {
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
      var Ze, Xe, Ue, Qe, pt, Ct, bt, Tt;
      Ze = Ve[0] & 255 | (Ve[1] & 255) << 8, this.r[0] = Ze & 8191, Xe = Ve[2] & 255 | (Ve[3] & 255) << 8, this.r[1] = (Ze >>> 13 | Xe << 3) & 8191, Ue = Ve[4] & 255 | (Ve[5] & 255) << 8, this.r[2] = (Xe >>> 10 | Ue << 6) & 7939, Qe = Ve[6] & 255 | (Ve[7] & 255) << 8, this.r[3] = (Ue >>> 7 | Qe << 9) & 8191, pt = Ve[8] & 255 | (Ve[9] & 255) << 8, this.r[4] = (Qe >>> 4 | pt << 12) & 255, this.r[5] = pt >>> 1 & 8190, Ct = Ve[10] & 255 | (Ve[11] & 255) << 8, this.r[6] = (pt >>> 14 | Ct << 2) & 8191, bt = Ve[12] & 255 | (Ve[13] & 255) << 8, this.r[7] = (Ct >>> 11 | bt << 5) & 8065, Tt = Ve[14] & 255 | (Ve[15] & 255) << 8, this.r[8] = (bt >>> 8 | Tt << 8) & 8191, this.r[9] = Tt >>> 5 & 127, this.pad[0] = Ve[16] & 255 | (Ve[17] & 255) << 8, this.pad[1] = Ve[18] & 255 | (Ve[19] & 255) << 8, this.pad[2] = Ve[20] & 255 | (Ve[21] & 255) << 8, this.pad[3] = Ve[22] & 255 | (Ve[23] & 255) << 8, this.pad[4] = Ve[24] & 255 | (Ve[25] & 255) << 8, this.pad[5] = Ve[26] & 255 | (Ve[27] & 255) << 8, this.pad[6] = Ve[28] & 255 | (Ve[29] & 255) << 8, this.pad[7] = Ve[30] & 255 | (Ve[31] & 255) << 8;
    };
    $e.prototype.blocks = function(Ve, Ze, Xe) {
      for (var Ue = this.fin ? 0 : 2048, Qe, pt, Ct, bt, Tt, br, gr, Fr, wr, Rr, kr, Pr, Ur, Ir, Or, Nr, Er, Br, _r, Sr = this.h[0], Mr = this.h[1], $r = this.h[2], Yt = this.h[3], er = this.h[4], xr = this.h[5], yr = this.h[6], vr = this.h[7], Ar = this.h[8], Vr = this.h[9], Jr = this.r[0], Yr = this.r[1], Xr = this.r[2], At = this.r[3], en = this.r[4], an = this.r[5], fn = this.r[6], Qr = this.r[7], rn = this.r[8], on = this.r[9]; Xe >= 16; )
        Qe = Ve[Ze + 0] & 255 | (Ve[Ze + 1] & 255) << 8, Sr += Qe & 8191, pt = Ve[Ze + 2] & 255 | (Ve[Ze + 3] & 255) << 8, Mr += (Qe >>> 13 | pt << 3) & 8191, Ct = Ve[Ze + 4] & 255 | (Ve[Ze + 5] & 255) << 8, $r += (pt >>> 10 | Ct << 6) & 8191, bt = Ve[Ze + 6] & 255 | (Ve[Ze + 7] & 255) << 8, Yt += (Ct >>> 7 | bt << 9) & 8191, Tt = Ve[Ze + 8] & 255 | (Ve[Ze + 9] & 255) << 8, er += (bt >>> 4 | Tt << 12) & 8191, xr += Tt >>> 1 & 8191, br = Ve[Ze + 10] & 255 | (Ve[Ze + 11] & 255) << 8, yr += (Tt >>> 14 | br << 2) & 8191, gr = Ve[Ze + 12] & 255 | (Ve[Ze + 13] & 255) << 8, vr += (br >>> 11 | gr << 5) & 8191, Fr = Ve[Ze + 14] & 255 | (Ve[Ze + 15] & 255) << 8, Ar += (gr >>> 8 | Fr << 8) & 8191, Vr += Fr >>> 5 | Ue, wr = 0, Rr = wr, Rr += Sr * Jr, Rr += Mr * (5 * on), Rr += $r * (5 * rn), Rr += Yt * (5 * Qr), Rr += er * (5 * fn), wr = Rr >>> 13, Rr &= 8191, Rr += xr * (5 * an), Rr += yr * (5 * en), Rr += vr * (5 * At), Rr += Ar * (5 * Xr), Rr += Vr * (5 * Yr), wr += Rr >>> 13, Rr &= 8191, kr = wr, kr += Sr * Yr, kr += Mr * Jr, kr += $r * (5 * on), kr += Yt * (5 * rn), kr += er * (5 * Qr), wr = kr >>> 13, kr &= 8191, kr += xr * (5 * fn), kr += yr * (5 * an), kr += vr * (5 * en), kr += Ar * (5 * At), kr += Vr * (5 * Xr), wr += kr >>> 13, kr &= 8191, Pr = wr, Pr += Sr * Xr, Pr += Mr * Yr, Pr += $r * Jr, Pr += Yt * (5 * on), Pr += er * (5 * rn), wr = Pr >>> 13, Pr &= 8191, Pr += xr * (5 * Qr), Pr += yr * (5 * fn), Pr += vr * (5 * an), Pr += Ar * (5 * en), Pr += Vr * (5 * At), wr += Pr >>> 13, Pr &= 8191, Ur = wr, Ur += Sr * At, Ur += Mr * Xr, Ur += $r * Yr, Ur += Yt * Jr, Ur += er * (5 * on), wr = Ur >>> 13, Ur &= 8191, Ur += xr * (5 * rn), Ur += yr * (5 * Qr), Ur += vr * (5 * fn), Ur += Ar * (5 * an), Ur += Vr * (5 * en), wr += Ur >>> 13, Ur &= 8191, Ir = wr, Ir += Sr * en, Ir += Mr * At, Ir += $r * Xr, Ir += Yt * Yr, Ir += er * Jr, wr = Ir >>> 13, Ir &= 8191, Ir += xr * (5 * on), Ir += yr * (5 * rn), Ir += vr * (5 * Qr), Ir += Ar * (5 * fn), Ir += Vr * (5 * an), wr += Ir >>> 13, Ir &= 8191, Or = wr, Or += Sr * an, Or += Mr * en, Or += $r * At, Or += Yt * Xr, Or += er * Yr, wr = Or >>> 13, Or &= 8191, Or += xr * Jr, Or += yr * (5 * on), Or += vr * (5 * rn), Or += Ar * (5 * Qr), Or += Vr * (5 * fn), wr += Or >>> 13, Or &= 8191, Nr = wr, Nr += Sr * fn, Nr += Mr * an, Nr += $r * en, Nr += Yt * At, Nr += er * Xr, wr = Nr >>> 13, Nr &= 8191, Nr += xr * Yr, Nr += yr * Jr, Nr += vr * (5 * on), Nr += Ar * (5 * rn), Nr += Vr * (5 * Qr), wr += Nr >>> 13, Nr &= 8191, Er = wr, Er += Sr * Qr, Er += Mr * fn, Er += $r * an, Er += Yt * en, Er += er * At, wr = Er >>> 13, Er &= 8191, Er += xr * Xr, Er += yr * Yr, Er += vr * Jr, Er += Ar * (5 * on), Er += Vr * (5 * rn), wr += Er >>> 13, Er &= 8191, Br = wr, Br += Sr * rn, Br += Mr * Qr, Br += $r * fn, Br += Yt * an, Br += er * en, wr = Br >>> 13, Br &= 8191, Br += xr * At, Br += yr * Xr, Br += vr * Yr, Br += Ar * Jr, Br += Vr * (5 * on), wr += Br >>> 13, Br &= 8191, _r = wr, _r += Sr * on, _r += Mr * rn, _r += $r * Qr, _r += Yt * fn, _r += er * an, wr = _r >>> 13, _r &= 8191, _r += xr * en, _r += yr * At, _r += vr * Xr, _r += Ar * Yr, _r += Vr * Jr, wr += _r >>> 13, _r &= 8191, wr = (wr << 2) + wr | 0, wr = wr + Rr | 0, Rr = wr & 8191, wr = wr >>> 13, kr += wr, Sr = Rr, Mr = kr, $r = Pr, Yt = Ur, er = Ir, xr = Or, yr = Nr, vr = Er, Ar = Br, Vr = _r, Ze += 16, Xe -= 16;
      this.h[0] = Sr, this.h[1] = Mr, this.h[2] = $r, this.h[3] = Yt, this.h[4] = er, this.h[5] = xr, this.h[6] = yr, this.h[7] = vr, this.h[8] = Ar, this.h[9] = Vr;
    }, $e.prototype.finish = function(Ve, Ze) {
      var Xe = new Uint16Array(10), Ue, Qe, pt, Ct;
      if (this.leftover) {
        for (Ct = this.leftover, this.buffer[Ct++] = 1; Ct < 16; Ct++)
          this.buffer[Ct] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (Ue = this.h[1] >>> 13, this.h[1] &= 8191, Ct = 2; Ct < 10; Ct++)
        this.h[Ct] += Ue, Ue = this.h[Ct] >>> 13, this.h[Ct] &= 8191;
      for (this.h[0] += Ue * 5, Ue = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += Ue, Ue = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += Ue, Xe[0] = this.h[0] + 5, Ue = Xe[0] >>> 13, Xe[0] &= 8191, Ct = 1; Ct < 10; Ct++)
        Xe[Ct] = this.h[Ct] + Ue, Ue = Xe[Ct] >>> 13, Xe[Ct] &= 8191;
      for (Xe[9] -= 8192, Qe = (Ue ^ 1) - 1, Ct = 0; Ct < 10; Ct++)
        Xe[Ct] &= Qe;
      for (Qe = ~Qe, Ct = 0; Ct < 10; Ct++)
        this.h[Ct] = this.h[Ct] & Qe | Xe[Ct];
      for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, pt = this.h[0] + this.pad[0], this.h[0] = pt & 65535, Ct = 1; Ct < 8; Ct++)
        pt = (this.h[Ct] + this.pad[Ct] | 0) + (pt >>> 16) | 0, this.h[Ct] = pt & 65535;
      Ve[Ze + 0] = this.h[0] >>> 0 & 255, Ve[Ze + 1] = this.h[0] >>> 8 & 255, Ve[Ze + 2] = this.h[1] >>> 0 & 255, Ve[Ze + 3] = this.h[1] >>> 8 & 255, Ve[Ze + 4] = this.h[2] >>> 0 & 255, Ve[Ze + 5] = this.h[2] >>> 8 & 255, Ve[Ze + 6] = this.h[3] >>> 0 & 255, Ve[Ze + 7] = this.h[3] >>> 8 & 255, Ve[Ze + 8] = this.h[4] >>> 0 & 255, Ve[Ze + 9] = this.h[4] >>> 8 & 255, Ve[Ze + 10] = this.h[5] >>> 0 & 255, Ve[Ze + 11] = this.h[5] >>> 8 & 255, Ve[Ze + 12] = this.h[6] >>> 0 & 255, Ve[Ze + 13] = this.h[6] >>> 8 & 255, Ve[Ze + 14] = this.h[7] >>> 0 & 255, Ve[Ze + 15] = this.h[7] >>> 8 & 255;
    }, $e.prototype.update = function(Ve, Ze, Xe) {
      var Ue, Qe;
      if (this.leftover) {
        for (Qe = 16 - this.leftover, Qe > Xe && (Qe = Xe), Ue = 0; Ue < Qe; Ue++)
          this.buffer[this.leftover + Ue] = Ve[Ze + Ue];
        if (Xe -= Qe, Ze += Qe, this.leftover += Qe, this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (Xe >= 16 && (Qe = Xe - Xe % 16, this.blocks(Ve, Ze, Qe), Ze += Qe, Xe -= Qe), Xe) {
        for (Ue = 0; Ue < Xe; Ue++)
          this.buffer[this.leftover + Ue] = Ve[Ze + Ue];
        this.leftover += Xe;
      }
    };
    function le(Ve, Ze, Xe, Ue, Qe, pt) {
      var Ct = new $e(pt);
      return Ct.update(Xe, Ue, Qe), Ct.finish(Ve, Ze), 0;
    }
    function pe(Ve, Ze, Xe, Ue, Qe, pt) {
      var Ct = new Uint8Array(16);
      return le(Ct, 0, Xe, Ue, Qe, pt), ke(Ve, Ze, Ct, 0);
    }
    function ge(Ve, Ze, Xe, Ue, Qe) {
      var pt;
      if (Xe < 32)
        return -1;
      for (ot(Ve, 0, Ze, 0, Xe, Ue, Qe), le(Ve, 16, Ve, 32, Xe - 32, Ve), pt = 0; pt < 16; pt++)
        Ve[pt] = 0;
      return 0;
    }
    function ye(Ve, Ze, Xe, Ue, Qe) {
      var pt, Ct = new Uint8Array(32);
      if (Xe < 32 || (ze(Ct, 0, 32, Ue, Qe), pe(Ze, 16, Ze, 32, Xe - 32, Ct) !== 0))
        return -1;
      for (ot(Ve, 0, Ze, 0, Xe, Ue, Qe), pt = 0; pt < 32; pt++)
        Ve[pt] = 0;
      return 0;
    }
    function xe(Ve, Ze) {
      var Xe;
      for (Xe = 0; Xe < 16; Xe++)
        Ve[Xe] = Ze[Xe] | 0;
    }
    function _e(Ve) {
      var Ze, Xe, Ue = 1;
      for (Ze = 0; Ze < 16; Ze++)
        Xe = Ve[Ze] + Ue + 65535, Ue = Math.floor(Xe / 65536), Ve[Ze] = Xe - Ue * 65536;
      Ve[0] += Ue - 1 + 37 * (Ue - 1);
    }
    function Ae(Ve, Ze, Xe) {
      for (var Ue, Qe = ~(Xe - 1), pt = 0; pt < 16; pt++)
        Ue = Qe & (Ve[pt] ^ Ze[pt]), Ve[pt] ^= Ue, Ze[pt] ^= Ue;
    }
    function ve(Ve, Ze) {
      var Xe, Ue, Qe, pt = se(), Ct = se();
      for (Xe = 0; Xe < 16; Xe++)
        Ct[Xe] = Ze[Xe];
      for (_e(Ct), _e(Ct), _e(Ct), Ue = 0; Ue < 2; Ue++) {
        for (pt[0] = Ct[0] - 65517, Xe = 1; Xe < 15; Xe++)
          pt[Xe] = Ct[Xe] - 65535 - (pt[Xe - 1] >> 16 & 1), pt[Xe - 1] &= 65535;
        pt[15] = Ct[15] - 32767 - (pt[14] >> 16 & 1), Qe = pt[15] >> 16 & 1, pt[14] &= 65535, Ae(Ct, pt, 1 - Qe);
      }
      for (Xe = 0; Xe < 16; Xe++)
        Ve[2 * Xe] = Ct[Xe] & 255, Ve[2 * Xe + 1] = Ct[Xe] >> 8;
    }
    function he(Ve, Ze) {
      var Xe = new Uint8Array(32), Ue = new Uint8Array(32);
      return ve(Xe, Ve), ve(Ue, Ze), He(Xe, 0, Ue, 0);
    }
    function be(Ve) {
      var Ze = new Uint8Array(32);
      return ve(Ze, Ve), Ze[0] & 1;
    }
    function Me(Ve, Ze) {
      var Xe;
      for (Xe = 0; Xe < 16; Xe++)
        Ve[Xe] = Ze[2 * Xe] + (Ze[2 * Xe + 1] << 8);
      Ve[15] &= 32767;
    }
    function Re(Ve, Ze, Xe) {
      for (var Ue = 0; Ue < 16; Ue++)
        Ve[Ue] = Ze[Ue] + Xe[Ue];
    }
    function Oe(Ve, Ze, Xe) {
      for (var Ue = 0; Ue < 16; Ue++)
        Ve[Ue] = Ze[Ue] - Xe[Ue];
    }
    function Te(Ve, Ze, Xe) {
      var Ue, Qe, pt = 0, Ct = 0, bt = 0, Tt = 0, br = 0, gr = 0, Fr = 0, wr = 0, Rr = 0, kr = 0, Pr = 0, Ur = 0, Ir = 0, Or = 0, Nr = 0, Er = 0, Br = 0, _r = 0, Sr = 0, Mr = 0, $r = 0, Yt = 0, er = 0, xr = 0, yr = 0, vr = 0, Ar = 0, Vr = 0, Jr = 0, Yr = 0, Xr = 0, At = Xe[0], en = Xe[1], an = Xe[2], fn = Xe[3], Qr = Xe[4], rn = Xe[5], on = Xe[6], yn = Xe[7], ln = Xe[8], hn = Xe[9], pn = Xe[10], gn = Xe[11], mn = Xe[12], vn = Xe[13], xn = Xe[14], wn = Xe[15];
      Ue = Ze[0], pt += Ue * At, Ct += Ue * en, bt += Ue * an, Tt += Ue * fn, br += Ue * Qr, gr += Ue * rn, Fr += Ue * on, wr += Ue * yn, Rr += Ue * ln, kr += Ue * hn, Pr += Ue * pn, Ur += Ue * gn, Ir += Ue * mn, Or += Ue * vn, Nr += Ue * xn, Er += Ue * wn, Ue = Ze[1], Ct += Ue * At, bt += Ue * en, Tt += Ue * an, br += Ue * fn, gr += Ue * Qr, Fr += Ue * rn, wr += Ue * on, Rr += Ue * yn, kr += Ue * ln, Pr += Ue * hn, Ur += Ue * pn, Ir += Ue * gn, Or += Ue * mn, Nr += Ue * vn, Er += Ue * xn, Br += Ue * wn, Ue = Ze[2], bt += Ue * At, Tt += Ue * en, br += Ue * an, gr += Ue * fn, Fr += Ue * Qr, wr += Ue * rn, Rr += Ue * on, kr += Ue * yn, Pr += Ue * ln, Ur += Ue * hn, Ir += Ue * pn, Or += Ue * gn, Nr += Ue * mn, Er += Ue * vn, Br += Ue * xn, _r += Ue * wn, Ue = Ze[3], Tt += Ue * At, br += Ue * en, gr += Ue * an, Fr += Ue * fn, wr += Ue * Qr, Rr += Ue * rn, kr += Ue * on, Pr += Ue * yn, Ur += Ue * ln, Ir += Ue * hn, Or += Ue * pn, Nr += Ue * gn, Er += Ue * mn, Br += Ue * vn, _r += Ue * xn, Sr += Ue * wn, Ue = Ze[4], br += Ue * At, gr += Ue * en, Fr += Ue * an, wr += Ue * fn, Rr += Ue * Qr, kr += Ue * rn, Pr += Ue * on, Ur += Ue * yn, Ir += Ue * ln, Or += Ue * hn, Nr += Ue * pn, Er += Ue * gn, Br += Ue * mn, _r += Ue * vn, Sr += Ue * xn, Mr += Ue * wn, Ue = Ze[5], gr += Ue * At, Fr += Ue * en, wr += Ue * an, Rr += Ue * fn, kr += Ue * Qr, Pr += Ue * rn, Ur += Ue * on, Ir += Ue * yn, Or += Ue * ln, Nr += Ue * hn, Er += Ue * pn, Br += Ue * gn, _r += Ue * mn, Sr += Ue * vn, Mr += Ue * xn, $r += Ue * wn, Ue = Ze[6], Fr += Ue * At, wr += Ue * en, Rr += Ue * an, kr += Ue * fn, Pr += Ue * Qr, Ur += Ue * rn, Ir += Ue * on, Or += Ue * yn, Nr += Ue * ln, Er += Ue * hn, Br += Ue * pn, _r += Ue * gn, Sr += Ue * mn, Mr += Ue * vn, $r += Ue * xn, Yt += Ue * wn, Ue = Ze[7], wr += Ue * At, Rr += Ue * en, kr += Ue * an, Pr += Ue * fn, Ur += Ue * Qr, Ir += Ue * rn, Or += Ue * on, Nr += Ue * yn, Er += Ue * ln, Br += Ue * hn, _r += Ue * pn, Sr += Ue * gn, Mr += Ue * mn, $r += Ue * vn, Yt += Ue * xn, er += Ue * wn, Ue = Ze[8], Rr += Ue * At, kr += Ue * en, Pr += Ue * an, Ur += Ue * fn, Ir += Ue * Qr, Or += Ue * rn, Nr += Ue * on, Er += Ue * yn, Br += Ue * ln, _r += Ue * hn, Sr += Ue * pn, Mr += Ue * gn, $r += Ue * mn, Yt += Ue * vn, er += Ue * xn, xr += Ue * wn, Ue = Ze[9], kr += Ue * At, Pr += Ue * en, Ur += Ue * an, Ir += Ue * fn, Or += Ue * Qr, Nr += Ue * rn, Er += Ue * on, Br += Ue * yn, _r += Ue * ln, Sr += Ue * hn, Mr += Ue * pn, $r += Ue * gn, Yt += Ue * mn, er += Ue * vn, xr += Ue * xn, yr += Ue * wn, Ue = Ze[10], Pr += Ue * At, Ur += Ue * en, Ir += Ue * an, Or += Ue * fn, Nr += Ue * Qr, Er += Ue * rn, Br += Ue * on, _r += Ue * yn, Sr += Ue * ln, Mr += Ue * hn, $r += Ue * pn, Yt += Ue * gn, er += Ue * mn, xr += Ue * vn, yr += Ue * xn, vr += Ue * wn, Ue = Ze[11], Ur += Ue * At, Ir += Ue * en, Or += Ue * an, Nr += Ue * fn, Er += Ue * Qr, Br += Ue * rn, _r += Ue * on, Sr += Ue * yn, Mr += Ue * ln, $r += Ue * hn, Yt += Ue * pn, er += Ue * gn, xr += Ue * mn, yr += Ue * vn, vr += Ue * xn, Ar += Ue * wn, Ue = Ze[12], Ir += Ue * At, Or += Ue * en, Nr += Ue * an, Er += Ue * fn, Br += Ue * Qr, _r += Ue * rn, Sr += Ue * on, Mr += Ue * yn, $r += Ue * ln, Yt += Ue * hn, er += Ue * pn, xr += Ue * gn, yr += Ue * mn, vr += Ue * vn, Ar += Ue * xn, Vr += Ue * wn, Ue = Ze[13], Or += Ue * At, Nr += Ue * en, Er += Ue * an, Br += Ue * fn, _r += Ue * Qr, Sr += Ue * rn, Mr += Ue * on, $r += Ue * yn, Yt += Ue * ln, er += Ue * hn, xr += Ue * pn, yr += Ue * gn, vr += Ue * mn, Ar += Ue * vn, Vr += Ue * xn, Jr += Ue * wn, Ue = Ze[14], Nr += Ue * At, Er += Ue * en, Br += Ue * an, _r += Ue * fn, Sr += Ue * Qr, Mr += Ue * rn, $r += Ue * on, Yt += Ue * yn, er += Ue * ln, xr += Ue * hn, yr += Ue * pn, vr += Ue * gn, Ar += Ue * mn, Vr += Ue * vn, Jr += Ue * xn, Yr += Ue * wn, Ue = Ze[15], Er += Ue * At, Br += Ue * en, _r += Ue * an, Sr += Ue * fn, Mr += Ue * Qr, $r += Ue * rn, Yt += Ue * on, er += Ue * yn, xr += Ue * ln, yr += Ue * hn, vr += Ue * pn, Ar += Ue * gn, Vr += Ue * mn, Jr += Ue * vn, Yr += Ue * xn, Xr += Ue * wn, pt += 38 * Br, Ct += 38 * _r, bt += 38 * Sr, Tt += 38 * Mr, br += 38 * $r, gr += 38 * Yt, Fr += 38 * er, wr += 38 * xr, Rr += 38 * yr, kr += 38 * vr, Pr += 38 * Ar, Ur += 38 * Vr, Ir += 38 * Jr, Or += 38 * Yr, Nr += 38 * Xr, Qe = 1, Ue = pt + Qe + 65535, Qe = Math.floor(Ue / 65536), pt = Ue - Qe * 65536, Ue = Ct + Qe + 65535, Qe = Math.floor(Ue / 65536), Ct = Ue - Qe * 65536, Ue = bt + Qe + 65535, Qe = Math.floor(Ue / 65536), bt = Ue - Qe * 65536, Ue = Tt + Qe + 65535, Qe = Math.floor(Ue / 65536), Tt = Ue - Qe * 65536, Ue = br + Qe + 65535, Qe = Math.floor(Ue / 65536), br = Ue - Qe * 65536, Ue = gr + Qe + 65535, Qe = Math.floor(Ue / 65536), gr = Ue - Qe * 65536, Ue = Fr + Qe + 65535, Qe = Math.floor(Ue / 65536), Fr = Ue - Qe * 65536, Ue = wr + Qe + 65535, Qe = Math.floor(Ue / 65536), wr = Ue - Qe * 65536, Ue = Rr + Qe + 65535, Qe = Math.floor(Ue / 65536), Rr = Ue - Qe * 65536, Ue = kr + Qe + 65535, Qe = Math.floor(Ue / 65536), kr = Ue - Qe * 65536, Ue = Pr + Qe + 65535, Qe = Math.floor(Ue / 65536), Pr = Ue - Qe * 65536, Ue = Ur + Qe + 65535, Qe = Math.floor(Ue / 65536), Ur = Ue - Qe * 65536, Ue = Ir + Qe + 65535, Qe = Math.floor(Ue / 65536), Ir = Ue - Qe * 65536, Ue = Or + Qe + 65535, Qe = Math.floor(Ue / 65536), Or = Ue - Qe * 65536, Ue = Nr + Qe + 65535, Qe = Math.floor(Ue / 65536), Nr = Ue - Qe * 65536, Ue = Er + Qe + 65535, Qe = Math.floor(Ue / 65536), Er = Ue - Qe * 65536, pt += Qe - 1 + 37 * (Qe - 1), Qe = 1, Ue = pt + Qe + 65535, Qe = Math.floor(Ue / 65536), pt = Ue - Qe * 65536, Ue = Ct + Qe + 65535, Qe = Math.floor(Ue / 65536), Ct = Ue - Qe * 65536, Ue = bt + Qe + 65535, Qe = Math.floor(Ue / 65536), bt = Ue - Qe * 65536, Ue = Tt + Qe + 65535, Qe = Math.floor(Ue / 65536), Tt = Ue - Qe * 65536, Ue = br + Qe + 65535, Qe = Math.floor(Ue / 65536), br = Ue - Qe * 65536, Ue = gr + Qe + 65535, Qe = Math.floor(Ue / 65536), gr = Ue - Qe * 65536, Ue = Fr + Qe + 65535, Qe = Math.floor(Ue / 65536), Fr = Ue - Qe * 65536, Ue = wr + Qe + 65535, Qe = Math.floor(Ue / 65536), wr = Ue - Qe * 65536, Ue = Rr + Qe + 65535, Qe = Math.floor(Ue / 65536), Rr = Ue - Qe * 65536, Ue = kr + Qe + 65535, Qe = Math.floor(Ue / 65536), kr = Ue - Qe * 65536, Ue = Pr + Qe + 65535, Qe = Math.floor(Ue / 65536), Pr = Ue - Qe * 65536, Ue = Ur + Qe + 65535, Qe = Math.floor(Ue / 65536), Ur = Ue - Qe * 65536, Ue = Ir + Qe + 65535, Qe = Math.floor(Ue / 65536), Ir = Ue - Qe * 65536, Ue = Or + Qe + 65535, Qe = Math.floor(Ue / 65536), Or = Ue - Qe * 65536, Ue = Nr + Qe + 65535, Qe = Math.floor(Ue / 65536), Nr = Ue - Qe * 65536, Ue = Er + Qe + 65535, Qe = Math.floor(Ue / 65536), Er = Ue - Qe * 65536, pt += Qe - 1 + 37 * (Qe - 1), Ve[0] = pt, Ve[1] = Ct, Ve[2] = bt, Ve[3] = Tt, Ve[4] = br, Ve[5] = gr, Ve[6] = Fr, Ve[7] = wr, Ve[8] = Rr, Ve[9] = kr, Ve[10] = Pr, Ve[11] = Ur, Ve[12] = Ir, Ve[13] = Or, Ve[14] = Nr, Ve[15] = Er;
    }
    function Fe(Ve, Ze) {
      Te(Ve, Ze, Ze);
    }
    function je(Ve, Ze) {
      var Xe = se(), Ue;
      for (Ue = 0; Ue < 16; Ue++)
        Xe[Ue] = Ze[Ue];
      for (Ue = 253; Ue >= 0; Ue--)
        Fe(Xe, Xe), Ue !== 2 && Ue !== 4 && Te(Xe, Xe, Ze);
      for (Ue = 0; Ue < 16; Ue++)
        Ve[Ue] = Xe[Ue];
    }
    function ct(Ve, Ze) {
      var Xe = se(), Ue;
      for (Ue = 0; Ue < 16; Ue++)
        Xe[Ue] = Ze[Ue];
      for (Ue = 250; Ue >= 0; Ue--)
        Fe(Xe, Xe), Ue !== 1 && Te(Xe, Xe, Ze);
      for (Ue = 0; Ue < 16; Ue++)
        Ve[Ue] = Xe[Ue];
    }
    function nt(Ve, Ze, Xe) {
      var Ue = new Uint8Array(32), Qe = new Float64Array(80), pt, Ct, bt = se(), Tt = se(), br = se(), gr = se(), Fr = se(), wr = se();
      for (Ct = 0; Ct < 31; Ct++)
        Ue[Ct] = Ze[Ct];
      for (Ue[31] = Ze[31] & 127 | 64, Ue[0] &= 248, Me(Qe, Xe), Ct = 0; Ct < 16; Ct++)
        Tt[Ct] = Qe[Ct], gr[Ct] = bt[Ct] = br[Ct] = 0;
      for (bt[0] = gr[0] = 1, Ct = 254; Ct >= 0; --Ct)
        pt = Ue[Ct >>> 3] >>> (Ct & 7) & 1, Ae(bt, Tt, pt), Ae(br, gr, pt), Re(Fr, bt, br), Oe(bt, bt, br), Re(br, Tt, gr), Oe(Tt, Tt, gr), Fe(gr, Fr), Fe(wr, bt), Te(bt, br, bt), Te(br, Tt, Fr), Re(Fr, bt, br), Oe(bt, bt, br), Fe(Tt, bt), Oe(br, gr, wr), Te(bt, br, we), Re(bt, bt, gr), Te(br, br, bt), Te(bt, gr, wr), Te(gr, Tt, Qe), Fe(Tt, Fr), Ae(bt, Tt, pt), Ae(br, gr, pt);
      for (Ct = 0; Ct < 16; Ct++)
        Qe[Ct + 16] = bt[Ct], Qe[Ct + 32] = br[Ct], Qe[Ct + 48] = Tt[Ct], Qe[Ct + 64] = gr[Ct];
      var Rr = Qe.subarray(32), kr = Qe.subarray(16);
      return je(Rr, Rr), Te(kr, kr, Rr), ve(Ve, kr), 0;
    }
    function dt(Ve, Ze) {
      return nt(Ve, Ze, ce);
    }
    function it(Ve, Ze) {
      return fe(Ze, 32), dt(Ve, Ze);
    }
    function Je(Ve, Ze, Xe) {
      var Ue = new Uint8Array(32);
      return nt(Ue, Xe, Ze), st(Ve, ue, Ue, at);
    }
    var gt = ge, Ht = ye;
    function $t(Ve, Ze, Xe, Ue, Qe, pt) {
      var Ct = new Uint8Array(32);
      return Je(Ct, Qe, pt), gt(Ve, Ze, Xe, Ue, Ct);
    }
    function Lt(Ve, Ze, Xe, Ue, Qe, pt) {
      var Ct = new Uint8Array(32);
      return Je(Ct, Qe, pt), Ht(Ve, Ze, Xe, Ue, Ct);
    }
    var Tr = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function Zt(Ve, Ze, Xe, Ue) {
      for (var Qe = new Int32Array(16), pt = new Int32Array(16), Ct, bt, Tt, br, gr, Fr, wr, Rr, kr, Pr, Ur, Ir, Or, Nr, Er, Br, _r, Sr, Mr, $r, Yt, er, xr, yr, vr, Ar, Vr = Ve[0], Jr = Ve[1], Yr = Ve[2], Xr = Ve[3], At = Ve[4], en = Ve[5], an = Ve[6], fn = Ve[7], Qr = Ze[0], rn = Ze[1], on = Ze[2], yn = Ze[3], ln = Ze[4], hn = Ze[5], pn = Ze[6], gn = Ze[7], mn = 0; Ue >= 128; ) {
        for (Mr = 0; Mr < 16; Mr++)
          $r = 8 * Mr + mn, Qe[Mr] = Xe[$r + 0] << 24 | Xe[$r + 1] << 16 | Xe[$r + 2] << 8 | Xe[$r + 3], pt[Mr] = Xe[$r + 4] << 24 | Xe[$r + 5] << 16 | Xe[$r + 6] << 8 | Xe[$r + 7];
        for (Mr = 0; Mr < 80; Mr++)
          if (Ct = Vr, bt = Jr, Tt = Yr, br = Xr, gr = At, Fr = en, wr = an, Rr = fn, kr = Qr, Pr = rn, Ur = on, Ir = yn, Or = ln, Nr = hn, Er = pn, Br = gn, Yt = fn, er = gn, xr = er & 65535, yr = er >>> 16, vr = Yt & 65535, Ar = Yt >>> 16, Yt = (At >>> 14 | ln << 18) ^ (At >>> 18 | ln << 14) ^ (ln >>> 9 | At << 23), er = (ln >>> 14 | At << 18) ^ (ln >>> 18 | At << 14) ^ (At >>> 9 | ln << 23), xr += er & 65535, yr += er >>> 16, vr += Yt & 65535, Ar += Yt >>> 16, Yt = At & en ^ ~At & an, er = ln & hn ^ ~ln & pn, xr += er & 65535, yr += er >>> 16, vr += Yt & 65535, Ar += Yt >>> 16, Yt = Tr[Mr * 2], er = Tr[Mr * 2 + 1], xr += er & 65535, yr += er >>> 16, vr += Yt & 65535, Ar += Yt >>> 16, Yt = Qe[Mr % 16], er = pt[Mr % 16], xr += er & 65535, yr += er >>> 16, vr += Yt & 65535, Ar += Yt >>> 16, yr += xr >>> 16, vr += yr >>> 16, Ar += vr >>> 16, _r = vr & 65535 | Ar << 16, Sr = xr & 65535 | yr << 16, Yt = _r, er = Sr, xr = er & 65535, yr = er >>> 16, vr = Yt & 65535, Ar = Yt >>> 16, Yt = (Vr >>> 28 | Qr << 4) ^ (Qr >>> 2 | Vr << 30) ^ (Qr >>> 7 | Vr << 25), er = (Qr >>> 28 | Vr << 4) ^ (Vr >>> 2 | Qr << 30) ^ (Vr >>> 7 | Qr << 25), xr += er & 65535, yr += er >>> 16, vr += Yt & 65535, Ar += Yt >>> 16, Yt = Vr & Jr ^ Vr & Yr ^ Jr & Yr, er = Qr & rn ^ Qr & on ^ rn & on, xr += er & 65535, yr += er >>> 16, vr += Yt & 65535, Ar += Yt >>> 16, yr += xr >>> 16, vr += yr >>> 16, Ar += vr >>> 16, Rr = vr & 65535 | Ar << 16, Br = xr & 65535 | yr << 16, Yt = br, er = Ir, xr = er & 65535, yr = er >>> 16, vr = Yt & 65535, Ar = Yt >>> 16, Yt = _r, er = Sr, xr += er & 65535, yr += er >>> 16, vr += Yt & 65535, Ar += Yt >>> 16, yr += xr >>> 16, vr += yr >>> 16, Ar += vr >>> 16, br = vr & 65535 | Ar << 16, Ir = xr & 65535 | yr << 16, Jr = Ct, Yr = bt, Xr = Tt, At = br, en = gr, an = Fr, fn = wr, Vr = Rr, rn = kr, on = Pr, yn = Ur, ln = Ir, hn = Or, pn = Nr, gn = Er, Qr = Br, Mr % 16 === 15)
            for ($r = 0; $r < 16; $r++)
              Yt = Qe[$r], er = pt[$r], xr = er & 65535, yr = er >>> 16, vr = Yt & 65535, Ar = Yt >>> 16, Yt = Qe[($r + 9) % 16], er = pt[($r + 9) % 16], xr += er & 65535, yr += er >>> 16, vr += Yt & 65535, Ar += Yt >>> 16, _r = Qe[($r + 1) % 16], Sr = pt[($r + 1) % 16], Yt = (_r >>> 1 | Sr << 31) ^ (_r >>> 8 | Sr << 24) ^ _r >>> 7, er = (Sr >>> 1 | _r << 31) ^ (Sr >>> 8 | _r << 24) ^ (Sr >>> 7 | _r << 25), xr += er & 65535, yr += er >>> 16, vr += Yt & 65535, Ar += Yt >>> 16, _r = Qe[($r + 14) % 16], Sr = pt[($r + 14) % 16], Yt = (_r >>> 19 | Sr << 13) ^ (Sr >>> 29 | _r << 3) ^ _r >>> 6, er = (Sr >>> 19 | _r << 13) ^ (_r >>> 29 | Sr << 3) ^ (Sr >>> 6 | _r << 26), xr += er & 65535, yr += er >>> 16, vr += Yt & 65535, Ar += Yt >>> 16, yr += xr >>> 16, vr += yr >>> 16, Ar += vr >>> 16, Qe[$r] = vr & 65535 | Ar << 16, pt[$r] = xr & 65535 | yr << 16;
        Yt = Vr, er = Qr, xr = er & 65535, yr = er >>> 16, vr = Yt & 65535, Ar = Yt >>> 16, Yt = Ve[0], er = Ze[0], xr += er & 65535, yr += er >>> 16, vr += Yt & 65535, Ar += Yt >>> 16, yr += xr >>> 16, vr += yr >>> 16, Ar += vr >>> 16, Ve[0] = Vr = vr & 65535 | Ar << 16, Ze[0] = Qr = xr & 65535 | yr << 16, Yt = Jr, er = rn, xr = er & 65535, yr = er >>> 16, vr = Yt & 65535, Ar = Yt >>> 16, Yt = Ve[1], er = Ze[1], xr += er & 65535, yr += er >>> 16, vr += Yt & 65535, Ar += Yt >>> 16, yr += xr >>> 16, vr += yr >>> 16, Ar += vr >>> 16, Ve[1] = Jr = vr & 65535 | Ar << 16, Ze[1] = rn = xr & 65535 | yr << 16, Yt = Yr, er = on, xr = er & 65535, yr = er >>> 16, vr = Yt & 65535, Ar = Yt >>> 16, Yt = Ve[2], er = Ze[2], xr += er & 65535, yr += er >>> 16, vr += Yt & 65535, Ar += Yt >>> 16, yr += xr >>> 16, vr += yr >>> 16, Ar += vr >>> 16, Ve[2] = Yr = vr & 65535 | Ar << 16, Ze[2] = on = xr & 65535 | yr << 16, Yt = Xr, er = yn, xr = er & 65535, yr = er >>> 16, vr = Yt & 65535, Ar = Yt >>> 16, Yt = Ve[3], er = Ze[3], xr += er & 65535, yr += er >>> 16, vr += Yt & 65535, Ar += Yt >>> 16, yr += xr >>> 16, vr += yr >>> 16, Ar += vr >>> 16, Ve[3] = Xr = vr & 65535 | Ar << 16, Ze[3] = yn = xr & 65535 | yr << 16, Yt = At, er = ln, xr = er & 65535, yr = er >>> 16, vr = Yt & 65535, Ar = Yt >>> 16, Yt = Ve[4], er = Ze[4], xr += er & 65535, yr += er >>> 16, vr += Yt & 65535, Ar += Yt >>> 16, yr += xr >>> 16, vr += yr >>> 16, Ar += vr >>> 16, Ve[4] = At = vr & 65535 | Ar << 16, Ze[4] = ln = xr & 65535 | yr << 16, Yt = en, er = hn, xr = er & 65535, yr = er >>> 16, vr = Yt & 65535, Ar = Yt >>> 16, Yt = Ve[5], er = Ze[5], xr += er & 65535, yr += er >>> 16, vr += Yt & 65535, Ar += Yt >>> 16, yr += xr >>> 16, vr += yr >>> 16, Ar += vr >>> 16, Ve[5] = en = vr & 65535 | Ar << 16, Ze[5] = hn = xr & 65535 | yr << 16, Yt = an, er = pn, xr = er & 65535, yr = er >>> 16, vr = Yt & 65535, Ar = Yt >>> 16, Yt = Ve[6], er = Ze[6], xr += er & 65535, yr += er >>> 16, vr += Yt & 65535, Ar += Yt >>> 16, yr += xr >>> 16, vr += yr >>> 16, Ar += vr >>> 16, Ve[6] = an = vr & 65535 | Ar << 16, Ze[6] = pn = xr & 65535 | yr << 16, Yt = fn, er = gn, xr = er & 65535, yr = er >>> 16, vr = Yt & 65535, Ar = Yt >>> 16, Yt = Ve[7], er = Ze[7], xr += er & 65535, yr += er >>> 16, vr += Yt & 65535, Ar += Yt >>> 16, yr += xr >>> 16, vr += yr >>> 16, Ar += vr >>> 16, Ve[7] = fn = vr & 65535 | Ar << 16, Ze[7] = gn = xr & 65535 | yr << 16, mn += 128, Ue -= 128;
      }
      return Ue;
    }
    function wt(Ve, Ze, Xe) {
      var Ue = new Int32Array(8), Qe = new Int32Array(8), pt = new Uint8Array(256), Ct, bt = Xe;
      for (Ue[0] = 1779033703, Ue[1] = 3144134277, Ue[2] = 1013904242, Ue[3] = 2773480762, Ue[4] = 1359893119, Ue[5] = 2600822924, Ue[6] = 528734635, Ue[7] = 1541459225, Qe[0] = 4089235720, Qe[1] = 2227873595, Qe[2] = 4271175723, Qe[3] = 1595750129, Qe[4] = 2917565137, Qe[5] = 725511199, Qe[6] = 4215389547, Qe[7] = 327033209, Zt(Ue, Qe, Ze, Xe), Xe %= 128, Ct = 0; Ct < Xe; Ct++)
        pt[Ct] = Ze[bt - Xe + Ct];
      for (pt[Xe] = 128, Xe = 256 - 128 * (Xe < 112 ? 1 : 0), pt[Xe - 9] = 0, Pe(pt, Xe - 8, bt / 536870912 | 0, bt << 3), Zt(Ue, Qe, pt, Xe), Ct = 0; Ct < 8; Ct++)
        Pe(Ve, 8 * Ct, Ue[Ct], Qe[Ct]);
      return 0;
    }
    function Hr(Ve, Ze) {
      var Xe = se(), Ue = se(), Qe = se(), pt = se(), Ct = se(), bt = se(), Tt = se(), br = se(), gr = se();
      Oe(Xe, Ve[1], Ve[0]), Oe(gr, Ze[1], Ze[0]), Te(Xe, Xe, gr), Re(Ue, Ve[0], Ve[1]), Re(gr, Ze[0], Ze[1]), Te(Ue, Ue, gr), Te(Qe, Ve[3], Ze[3]), Te(Qe, Qe, Se), Te(pt, Ve[2], Ze[2]), Re(pt, pt, pt), Oe(Ct, Ue, Xe), Oe(bt, pt, Qe), Re(Tt, pt, Qe), Re(br, Ue, Xe), Te(Ve[0], Ct, bt), Te(Ve[1], br, Tt), Te(Ve[2], Tt, bt), Te(Ve[3], Ct, br);
    }
    function tr(Ve, Ze, Xe) {
      var Ue;
      for (Ue = 0; Ue < 4; Ue++)
        Ae(Ve[Ue], Ze[Ue], Xe);
    }
    function cr(Ve, Ze) {
      var Xe = se(), Ue = se(), Qe = se();
      je(Qe, Ze[2]), Te(Xe, Ze[0], Qe), Te(Ue, Ze[1], Qe), ve(Ve, Ue), Ve[31] ^= be(Xe) << 7;
    }
    function qr(Ve, Ze, Xe) {
      var Ue, Qe;
      for (xe(Ve[0], de), xe(Ve[1], me), xe(Ve[2], me), xe(Ve[3], de), Qe = 255; Qe >= 0; --Qe)
        Ue = Xe[Qe / 8 | 0] >> (Qe & 7) & 1, tr(Ve, Ze, Ue), Hr(Ze, Ve), Hr(Ve, Ve), tr(Ve, Ze, Ue);
    }
    function Wt(Ve, Ze) {
      var Xe = [se(), se(), se(), se()];
      xe(Xe[0], Be), xe(Xe[1], Ce), xe(Xe[2], me), Te(Xe[3], Be, Ce), qr(Ve, Xe, Ze);
    }
    function ar(Ve, Ze, Xe) {
      var Ue = new Uint8Array(64), Qe = [se(), se(), se(), se()], pt;
      for (Xe || fe(Ze, 32), wt(Ue, Ze, 32), Ue[0] &= 248, Ue[31] &= 127, Ue[31] |= 64, Wt(Qe, Ue), cr(Ve, Qe), pt = 0; pt < 32; pt++)
        Ze[pt + 32] = Ve[pt];
      return 0;
    }
    var Dr = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function Jt(Ve, Ze) {
      var Xe, Ue, Qe, pt;
      for (Ue = 63; Ue >= 32; --Ue) {
        for (Xe = 0, Qe = Ue - 32, pt = Ue - 12; Qe < pt; ++Qe)
          Ze[Qe] += Xe - 16 * Ze[Ue] * Dr[Qe - (Ue - 32)], Xe = Math.floor((Ze[Qe] + 128) / 256), Ze[Qe] -= Xe * 256;
        Ze[Qe] += Xe, Ze[Ue] = 0;
      }
      for (Xe = 0, Qe = 0; Qe < 32; Qe++)
        Ze[Qe] += Xe - (Ze[31] >> 4) * Dr[Qe], Xe = Ze[Qe] >> 8, Ze[Qe] &= 255;
      for (Qe = 0; Qe < 32; Qe++)
        Ze[Qe] -= Xe * Dr[Qe];
      for (Ue = 0; Ue < 32; Ue++)
        Ze[Ue + 1] += Ze[Ue] >> 8, Ve[Ue] = Ze[Ue] & 255;
    }
    function ir(Ve) {
      var Ze = new Float64Array(64), Xe;
      for (Xe = 0; Xe < 64; Xe++)
        Ze[Xe] = Ve[Xe];
      for (Xe = 0; Xe < 64; Xe++)
        Ve[Xe] = 0;
      Jt(Ve, Ze);
    }
    function Gr(Ve, Ze, Xe, Ue) {
      var Qe = new Uint8Array(64), pt = new Uint8Array(64), Ct = new Uint8Array(64), bt, Tt, br = new Float64Array(64), gr = [se(), se(), se(), se()];
      wt(Qe, Ue, 32), Qe[0] &= 248, Qe[31] &= 127, Qe[31] |= 64;
      var Fr = Xe + 64;
      for (bt = 0; bt < Xe; bt++)
        Ve[64 + bt] = Ze[bt];
      for (bt = 0; bt < 32; bt++)
        Ve[32 + bt] = Qe[32 + bt];
      for (wt(Ct, Ve.subarray(32), Xe + 32), ir(Ct), Wt(gr, Ct), cr(Ve, gr), bt = 32; bt < 64; bt++)
        Ve[bt] = Ue[bt];
      for (wt(pt, Ve, Xe + 64), ir(pt), bt = 0; bt < 64; bt++)
        br[bt] = 0;
      for (bt = 0; bt < 32; bt++)
        br[bt] = Ct[bt];
      for (bt = 0; bt < 32; bt++)
        for (Tt = 0; Tt < 32; Tt++)
          br[bt + Tt] += pt[bt] * Qe[Tt];
      return Jt(Ve.subarray(32), br), Fr;
    }
    function We(Ve, Ze) {
      var Xe = se(), Ue = se(), Qe = se(), pt = se(), Ct = se(), bt = se(), Tt = se();
      return xe(Ve[2], me), Me(Ve[1], Ze), Fe(Qe, Ve[1]), Te(pt, Qe, Ee), Oe(Qe, Qe, Ve[2]), Re(pt, Ve[2], pt), Fe(Ct, pt), Fe(bt, Ct), Te(Tt, bt, Ct), Te(Xe, Tt, Qe), Te(Xe, Xe, pt), ct(Xe, Xe), Te(Xe, Xe, Qe), Te(Xe, Xe, pt), Te(Xe, Xe, pt), Te(Ve[0], Xe, pt), Fe(Ue, Ve[0]), Te(Ue, Ue, pt), he(Ue, Qe) && Te(Ve[0], Ve[0], Ie), Fe(Ue, Ve[0]), Te(Ue, Ue, pt), he(Ue, Qe) ? -1 : (be(Ve[0]) === Ze[31] >> 7 && Oe(Ve[0], de, Ve[0]), Te(Ve[3], Ve[0], Ve[1]), 0);
    }
    function Le(Ve, Ze, Xe, Ue) {
      var Qe, pt = new Uint8Array(32), Ct = new Uint8Array(64), bt = [se(), se(), se(), se()], Tt = [se(), se(), se(), se()];
      if (Xe < 64 || We(Tt, Ue))
        return -1;
      for (Qe = 0; Qe < Xe; Qe++)
        Ve[Qe] = Ze[Qe];
      for (Qe = 0; Qe < 32; Qe++)
        Ve[Qe + 32] = Ue[Qe];
      if (wt(Ct, Ve, Xe), ir(Ct), qr(bt, Tt, Ct), Wt(Tt, Ze.subarray(32)), Hr(bt, Tt), cr(pt, bt), Xe -= 64, He(Ze, 0, pt, 0)) {
        for (Qe = 0; Qe < Xe; Qe++)
          Ve[Qe] = 0;
        return -1;
      }
      for (Qe = 0; Qe < Xe; Qe++)
        Ve[Qe] = Ze[Qe + 64];
      return Xe;
    }
    var Ke = 32, rt = 24, lt = 32, It = 16, yt = 32, jt = 32, Lr = 32, zt = 32, rr = 32, Cr = rt, fr = lt, pr = It, jr = 64, nr = 32, ur = 64, Wr = 32, or = 64;
    ie.lowlevel = {
      crypto_core_hsalsa20: st,
      crypto_stream_xor: ot,
      crypto_stream: ze,
      crypto_stream_salsa20_xor: mt,
      crypto_stream_salsa20: qe,
      crypto_onetimeauth: le,
      crypto_onetimeauth_verify: pe,
      crypto_verify_16: ke,
      crypto_verify_32: He,
      crypto_secretbox: ge,
      crypto_secretbox_open: ye,
      crypto_scalarmult: nt,
      crypto_scalarmult_base: dt,
      crypto_box_beforenm: Je,
      crypto_box_afternm: gt,
      crypto_box: $t,
      crypto_box_open: Lt,
      crypto_box_keypair: it,
      crypto_hash: wt,
      crypto_sign: Gr,
      crypto_sign_keypair: ar,
      crypto_sign_open: Le,
      crypto_secretbox_KEYBYTES: Ke,
      crypto_secretbox_NONCEBYTES: rt,
      crypto_secretbox_ZEROBYTES: lt,
      crypto_secretbox_BOXZEROBYTES: It,
      crypto_scalarmult_BYTES: yt,
      crypto_scalarmult_SCALARBYTES: jt,
      crypto_box_PUBLICKEYBYTES: Lr,
      crypto_box_SECRETKEYBYTES: zt,
      crypto_box_BEFORENMBYTES: rr,
      crypto_box_NONCEBYTES: Cr,
      crypto_box_ZEROBYTES: fr,
      crypto_box_BOXZEROBYTES: pr,
      crypto_sign_BYTES: jr,
      crypto_sign_PUBLICKEYBYTES: nr,
      crypto_sign_SECRETKEYBYTES: ur,
      crypto_sign_SEEDBYTES: Wr,
      crypto_hash_BYTES: or,
      gf: se,
      D: Ee,
      L: Dr,
      pack25519: ve,
      unpack25519: Me,
      M: Te,
      A: Re,
      S: Fe,
      Z: Oe,
      pow2523: ct,
      add: Hr,
      set25519: xe,
      modL: Jt,
      scalarmult: qr,
      scalarbase: Wt
    };
    function lr(Ve, Ze) {
      if (Ve.length !== Ke)
        throw new Error("bad key size");
      if (Ze.length !== rt)
        throw new Error("bad nonce size");
    }
    function Zr(Ve, Ze) {
      if (Ve.length !== Lr)
        throw new Error("bad public key size");
      if (Ze.length !== zt)
        throw new Error("bad secret key size");
    }
    function Xt() {
      for (var Ve = 0; Ve < arguments.length; Ve++)
        if (!(arguments[Ve] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
    }
    function dr(Ve) {
      for (var Ze = 0; Ze < Ve.length; Ze++)
        Ve[Ze] = 0;
    }
    ie.randomBytes = function(Ve) {
      var Ze = new Uint8Array(Ve);
      return fe(Ze, Ve), Ze;
    }, ie.secretbox = function(Ve, Ze, Xe) {
      Xt(Ve, Ze, Xe), lr(Xe, Ze);
      for (var Ue = new Uint8Array(lt + Ve.length), Qe = new Uint8Array(Ue.length), pt = 0; pt < Ve.length; pt++)
        Ue[pt + lt] = Ve[pt];
      return ge(Qe, Ue, Ue.length, Ze, Xe), Qe.subarray(It);
    }, ie.secretbox.open = function(Ve, Ze, Xe) {
      Xt(Ve, Ze, Xe), lr(Xe, Ze);
      for (var Ue = new Uint8Array(It + Ve.length), Qe = new Uint8Array(Ue.length), pt = 0; pt < Ve.length; pt++)
        Ue[pt + It] = Ve[pt];
      return Ue.length < 32 || ye(Qe, Ue, Ue.length, Ze, Xe) !== 0 ? null : Qe.subarray(lt);
    }, ie.secretbox.keyLength = Ke, ie.secretbox.nonceLength = rt, ie.secretbox.overheadLength = It, ie.scalarMult = function(Ve, Ze) {
      if (Xt(Ve, Ze), Ve.length !== jt)
        throw new Error("bad n size");
      if (Ze.length !== yt)
        throw new Error("bad p size");
      var Xe = new Uint8Array(yt);
      return nt(Xe, Ve, Ze), Xe;
    }, ie.scalarMult.base = function(Ve) {
      if (Xt(Ve), Ve.length !== jt)
        throw new Error("bad n size");
      var Ze = new Uint8Array(yt);
      return dt(Ze, Ve), Ze;
    }, ie.scalarMult.scalarLength = jt, ie.scalarMult.groupElementLength = yt, ie.box = function(Ve, Ze, Xe, Ue) {
      var Qe = ie.box.before(Xe, Ue);
      return ie.secretbox(Ve, Ze, Qe);
    }, ie.box.before = function(Ve, Ze) {
      Xt(Ve, Ze), Zr(Ve, Ze);
      var Xe = new Uint8Array(rr);
      return Je(Xe, Ve, Ze), Xe;
    }, ie.box.after = ie.secretbox, ie.box.open = function(Ve, Ze, Xe, Ue) {
      var Qe = ie.box.before(Xe, Ue);
      return ie.secretbox.open(Ve, Ze, Qe);
    }, ie.box.open.after = ie.secretbox.open, ie.box.keyPair = function() {
      var Ve = new Uint8Array(Lr), Ze = new Uint8Array(zt);
      return it(Ve, Ze), { publicKey: Ve, secretKey: Ze };
    }, ie.box.keyPair.fromSecretKey = function(Ve) {
      if (Xt(Ve), Ve.length !== zt)
        throw new Error("bad secret key size");
      var Ze = new Uint8Array(Lr);
      return dt(Ze, Ve), { publicKey: Ze, secretKey: new Uint8Array(Ve) };
    }, ie.box.publicKeyLength = Lr, ie.box.secretKeyLength = zt, ie.box.sharedKeyLength = rr, ie.box.nonceLength = Cr, ie.box.overheadLength = ie.secretbox.overheadLength, ie.sign = function(Ve, Ze) {
      if (Xt(Ve, Ze), Ze.length !== ur)
        throw new Error("bad secret key size");
      var Xe = new Uint8Array(jr + Ve.length);
      return Gr(Xe, Ve, Ve.length, Ze), Xe;
    }, ie.sign.open = function(Ve, Ze) {
      if (Xt(Ve, Ze), Ze.length !== nr)
        throw new Error("bad public key size");
      var Xe = new Uint8Array(Ve.length), Ue = Le(Xe, Ve, Ve.length, Ze);
      if (Ue < 0)
        return null;
      for (var Qe = new Uint8Array(Ue), pt = 0; pt < Qe.length; pt++)
        Qe[pt] = Xe[pt];
      return Qe;
    }, ie.sign.detached = function(Ve, Ze) {
      for (var Xe = ie.sign(Ve, Ze), Ue = new Uint8Array(jr), Qe = 0; Qe < Ue.length; Qe++)
        Ue[Qe] = Xe[Qe];
      return Ue;
    }, ie.sign.detached.verify = function(Ve, Ze, Xe) {
      if (Xt(Ve, Ze, Xe), Ze.length !== jr)
        throw new Error("bad signature size");
      if (Xe.length !== nr)
        throw new Error("bad public key size");
      var Ue = new Uint8Array(jr + Ve.length), Qe = new Uint8Array(jr + Ve.length), pt;
      for (pt = 0; pt < jr; pt++)
        Ue[pt] = Ze[pt];
      for (pt = 0; pt < Ve.length; pt++)
        Ue[pt + jr] = Ve[pt];
      return Le(Qe, Ue, Ue.length, Xe) >= 0;
    }, ie.sign.keyPair = function() {
      var Ve = new Uint8Array(nr), Ze = new Uint8Array(ur);
      return ar(Ve, Ze), { publicKey: Ve, secretKey: Ze };
    }, ie.sign.keyPair.fromSecretKey = function(Ve) {
      if (Xt(Ve), Ve.length !== ur)
        throw new Error("bad secret key size");
      for (var Ze = new Uint8Array(nr), Xe = 0; Xe < Ze.length; Xe++)
        Ze[Xe] = Ve[32 + Xe];
      return { publicKey: Ze, secretKey: new Uint8Array(Ve) };
    }, ie.sign.keyPair.fromSeed = function(Ve) {
      if (Xt(Ve), Ve.length !== Wr)
        throw new Error("bad seed size");
      for (var Ze = new Uint8Array(nr), Xe = new Uint8Array(ur), Ue = 0; Ue < 32; Ue++)
        Xe[Ue] = Ve[Ue];
      return ar(Ze, Xe, !0), { publicKey: Ze, secretKey: Xe };
    }, ie.sign.publicKeyLength = nr, ie.sign.secretKeyLength = ur, ie.sign.seedLength = Wr, ie.sign.signatureLength = jr, ie.hash = function(Ve) {
      Xt(Ve);
      var Ze = new Uint8Array(or);
      return wt(Ze, Ve, Ve.length), Ze;
    }, ie.hash.hashLength = or, ie.verify = function(Ve, Ze) {
      return Xt(Ve, Ze), Ve.length === 0 || Ze.length === 0 || Ve.length !== Ze.length ? !1 : Ne(Ve, 0, Ze, 0, Ve.length) === 0;
    }, ie.setPRNG = function(Ve) {
      fe = Ve;
    }, function() {
      var Ve = typeof self < "u" ? self.crypto || self.msCrypto : null;
      if (Ve && Ve.getRandomValues) {
        var Ze = 65536;
        ie.setPRNG(function(Xe, Ue) {
          var Qe, pt = new Uint8Array(Ue);
          for (Qe = 0; Qe < Ue; Qe += Ze)
            Ve.getRandomValues(pt.subarray(Qe, Qe + Math.min(Ue - Qe, Ze)));
          for (Qe = 0; Qe < Ue; Qe++)
            Xe[Qe] = pt[Qe];
          dr(pt);
        });
      } else
        typeof commonjsRequire < "u" && (Ve = requireCryptoBrowserify(), Ve && Ve.randomBytes && ie.setPRNG(function(Xe, Ue) {
          var Qe, pt = Ve.randomBytes(Ue);
          for (Qe = 0; Qe < Ue; Qe++)
            Xe[Qe] = pt[Qe];
          dr(pt);
        }));
    }();
  })(ae.exports ? ae.exports : self.nacl = self.nacl || {});
})(naclFast);
var naclFastExports = naclFast.exports;
const o$e = /* @__PURE__ */ getDefaultExportFromCjs$2(naclFastExports);
var public_key$1 = {}, lib$5 = {}, assignable$1 = {};
Object.defineProperty(assignable$1, "__esModule", { value: !0 });
assignable$1.Assignable = void 0;
let Assignable$1 = class {
  constructor(ie) {
    Object.keys(ie).map((se) => {
      this[se] = ie[se];
    });
  }
};
assignable$1.Assignable = Assignable$1;
var errors$1 = {};
Object.defineProperty(errors$1, "__esModule", { value: !0 });
errors$1.ErrorContext = errors$1.TypedError = errors$1.ArgumentTypeError = errors$1.PositionalArgsError = void 0;
let PositionalArgsError$1 = class extends Error {
  constructor() {
    super("Contract method calls expect named arguments wrapped in object, e.g. { argName1: argValue1, argName2: argValue2 }");
  }
};
errors$1.PositionalArgsError = PositionalArgsError$1;
let ArgumentTypeError$1 = class extends Error {
  constructor(ie, se, fe) {
    super(`Expected ${se} for '${ie}' argument, but got '${JSON.stringify(fe)}'`);
  }
};
errors$1.ArgumentTypeError = ArgumentTypeError$1;
let TypedError$1 = class extends Error {
  constructor(ie, se, fe) {
    super(ie), this.type = se || "UntypedError", this.context = fe;
  }
};
errors$1.TypedError = TypedError$1;
let ErrorContext$1 = class {
  constructor(ie) {
    this.transactionHash = ie;
  }
};
errors$1.ErrorContext = ErrorContext$1;
var provider$1 = {}, light_client$1 = {};
(function(ae) {
  Object.defineProperty(ae, "__esModule", { value: !0 }), ae.IdType = void 0, function(ie) {
    ie.Transaction = "transaction", ie.Receipt = "receipt";
  }(ae.IdType || (ae.IdType = {}));
})(light_client$1);
var response$1 = {};
(function(ae) {
  Object.defineProperty(ae, "__esModule", { value: !0 }), ae.FinalExecutionStatusBasic = ae.ExecutionStatusBasic = void 0, function(ie) {
    ie.Unknown = "Unknown", ie.Pending = "Pending", ie.Failure = "Failure";
  }(ae.ExecutionStatusBasic || (ae.ExecutionStatusBasic = {})), function(ie) {
    ie.NotStarted = "NotStarted", ie.Started = "Started", ie.Failure = "Failure";
  }(ae.FinalExecutionStatusBasic || (ae.FinalExecutionStatusBasic = {}));
})(response$1);
(function(ae) {
  Object.defineProperty(ae, "__esModule", { value: !0 }), ae.FinalExecutionStatusBasic = ae.ExecutionStatusBasic = ae.IdType = void 0;
  var ie = light_client$1;
  Object.defineProperty(ae, "IdType", { enumerable: !0, get: function() {
    return ie.IdType;
  } });
  var se = response$1;
  Object.defineProperty(ae, "ExecutionStatusBasic", { enumerable: !0, get: function() {
    return se.ExecutionStatusBasic;
  } }), Object.defineProperty(ae, "FinalExecutionStatusBasic", { enumerable: !0, get: function() {
    return se.FinalExecutionStatusBasic;
  } });
})(provider$1);
(function(ae) {
  var ie = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(fe, ue, ce, de) {
    de === void 0 && (de = ce);
    var me = Object.getOwnPropertyDescriptor(ue, ce);
    (!me || ("get" in me ? !ue.__esModule : me.writable || me.configurable)) && (me = { enumerable: !0, get: function() {
      return ue[ce];
    } }), Object.defineProperty(fe, de, me);
  } : function(fe, ue, ce, de) {
    de === void 0 && (de = ce), fe[de] = ue[ce];
  }), se = commonjsGlobal && commonjsGlobal.__exportStar || function(fe, ue) {
    for (var ce in fe)
      ce !== "default" && !Object.prototype.hasOwnProperty.call(ue, ce) && ie(ue, fe, ce);
  };
  Object.defineProperty(ae, "__esModule", { value: !0 }), se(assignable$1, ae), se(errors$1, ae), se(provider$1, ae);
})(lib$5);
var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function(ae) {
  return ae && ae.__esModule ? ae : { default: ae };
};
Object.defineProperty(public_key$1, "__esModule", { value: !0 });
public_key$1.PublicKey = void 0;
const types_1$5 = lib$5, borsh_1$3 = lib$6, tweetnacl_1$3 = __importDefault$4(naclFastExports), constants_1$3 = constants$1;
function key_type_to_str$1(ae) {
  switch (ae) {
    case constants_1$3.KeyType.ED25519:
      return "ed25519";
    default:
      throw new Error(`Unknown key type ${ae}`);
  }
}
function str_to_key_type$1(ae) {
  switch (ae.toLowerCase()) {
    case "ed25519":
      return constants_1$3.KeyType.ED25519;
    default:
      throw new Error(`Unknown key type ${ae}`);
  }
}
let PublicKey$2 = class Ln extends types_1$5.Assignable {
  static from(ie) {
    return typeof ie == "string" ? Ln.fromString(ie) : ie;
  }
  static fromString(ie) {
    const se = ie.split(":");
    if (se.length === 1)
      return new Ln({ keyType: constants_1$3.KeyType.ED25519, data: (0, borsh_1$3.baseDecode)(se[0]) });
    if (se.length === 2)
      return new Ln({ keyType: str_to_key_type$1(se[0]), data: (0, borsh_1$3.baseDecode)(se[1]) });
    throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
  }
  toString() {
    return `${key_type_to_str$1(this.keyType)}:${(0, borsh_1$3.baseEncode)(this.data)}`;
  }
  verify(ie, se) {
    switch (this.keyType) {
      case constants_1$3.KeyType.ED25519:
        return tweetnacl_1$3.default.sign.detached.verify(ie, se, this.data);
      default:
        throw new Error(`Unknown key type ${this.keyType}`);
    }
  }
};
public_key$1.PublicKey = PublicKey$2;
var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(ae) {
  return ae && ae.__esModule ? ae : { default: ae };
};
Object.defineProperty(key_pair_ed25519$1, "__esModule", { value: !0 });
key_pair_ed25519$1.KeyPairEd25519 = void 0;
const borsh_1$2 = lib$6, tweetnacl_1$2 = __importDefault$3(naclFastExports), constants_1$2 = constants$1, key_pair_base_1$3 = key_pair_base$1, public_key_1$1 = public_key$1;
let KeyPairEd25519$1 = class ni extends key_pair_base_1$3.KeyPairBase {
  /**
   * Construct an instance of key pair given a secret key.
   * It's generally assumed that these are encoded in base58.
   * @param {string} secretKey
   */
  constructor(ie) {
    super();
    const se = tweetnacl_1$2.default.sign.keyPair.fromSecretKey((0, borsh_1$2.baseDecode)(ie));
    this.publicKey = new public_key_1$1.PublicKey({ keyType: constants_1$2.KeyType.ED25519, data: se.publicKey }), this.secretKey = ie;
  }
  /**
   * Generate a new random keypair.
   * @example
   * const keyRandom = KeyPair.fromRandom();
   * keyRandom.publicKey
   * // returns [PUBLIC_KEY]
   *
   * keyRandom.secretKey
   * // returns [SECRET_KEY]
   */
  static fromRandom() {
    const ie = tweetnacl_1$2.default.sign.keyPair();
    return new ni((0, borsh_1$2.baseEncode)(ie.secretKey));
  }
  sign(ie) {
    return { signature: tweetnacl_1$2.default.sign.detached(ie, (0, borsh_1$2.baseDecode)(this.secretKey)), publicKey: this.publicKey };
  }
  verify(ie, se) {
    return this.publicKey.verify(ie, se);
  }
  toString() {
    return `ed25519:${this.secretKey}`;
  }
  getPublicKey() {
    return this.publicKey;
  }
};
key_pair_ed25519$1.KeyPairEd25519 = KeyPairEd25519$1;
Object.defineProperty(key_pair$1, "__esModule", { value: !0 });
key_pair$1.KeyPair = void 0;
const key_pair_base_1$2 = key_pair_base$1, key_pair_ed25519_1$1 = key_pair_ed25519$1;
let KeyPair$1 = class extends key_pair_base_1$2.KeyPairBase {
  /**
   * @param curve Name of elliptical curve, case-insensitive
   * @returns Random KeyPair based on the curve
   */
  static fromRandom(ie) {
    switch (ie.toUpperCase()) {
      case "ED25519":
        return key_pair_ed25519_1$1.KeyPairEd25519.fromRandom();
      default:
        throw new Error(`Unknown curve ${ie}`);
    }
  }
  static fromString(ie) {
    const se = ie.split(":");
    if (se.length === 1)
      return new key_pair_ed25519_1$1.KeyPairEd25519(se[0]);
    if (se.length === 2)
      switch (se[0].toUpperCase()) {
        case "ED25519":
          return new key_pair_ed25519_1$1.KeyPairEd25519(se[1]);
        default:
          throw new Error(`Unknown curve: ${se[0]}`);
      }
    else
      throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
  }
};
key_pair$1.KeyPair = KeyPair$1;
(function(ae) {
  Object.defineProperty(ae, "__esModule", { value: !0 }), ae.PublicKey = ae.KeyPairEd25519 = ae.KeyPair = ae.KeyType = void 0;
  var ie = constants$1;
  Object.defineProperty(ae, "KeyType", { enumerable: !0, get: function() {
    return ie.KeyType;
  } });
  var se = key_pair$1;
  Object.defineProperty(ae, "KeyPair", { enumerable: !0, get: function() {
    return se.KeyPair;
  } });
  var fe = key_pair_ed25519$1;
  Object.defineProperty(ae, "KeyPairEd25519", { enumerable: !0, get: function() {
    return fe.KeyPairEd25519;
  } });
  var ue = public_key$1;
  Object.defineProperty(ae, "PublicKey", { enumerable: !0, get: function() {
    return ue.PublicKey;
  } });
})(lib$7);
var lib$4 = {}, browser_local_storage_key_store = {}, lib$3 = {}, in_memory_key_store = {}, keystore = {};
Object.defineProperty(keystore, "__esModule", { value: !0 });
keystore.KeyStore = void 0;
class KeyStore {
}
keystore.KeyStore = KeyStore;
var __awaiter$8 = commonjsGlobal && commonjsGlobal.__awaiter || function(ae, ie, se, fe) {
  function ue(ce) {
    return ce instanceof se ? ce : new se(function(de) {
      de(ce);
    });
  }
  return new (se || (se = Promise))(function(ce, de) {
    function me(Se) {
      try {
        Ee(fe.next(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function we(Se) {
      try {
        Ee(fe.throw(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function Ee(Se) {
      Se.done ? ce(Se.value) : ue(Se.value).then(me, we);
    }
    Ee((fe = fe.apply(ae, ie || [])).next());
  });
};
Object.defineProperty(in_memory_key_store, "__esModule", { value: !0 });
in_memory_key_store.InMemoryKeyStore = void 0;
const crypto_1$1 = lib$7, keystore_1$1 = keystore;
class InMemoryKeyStore extends keystore_1$1.KeyStore {
  constructor() {
    super(), this.keys = {};
  }
  /**
   * Stores a {@link utils/key_pair!KeyPair} in in-memory storage item
   * @param networkId The targeted network. (ex. default, betanet, etc)
   * @param accountId The NEAR account tied to the key pair
   * @param keyPair The key pair to store in local storage
   */
  setKey(ie, se, fe) {
    return __awaiter$8(this, void 0, void 0, function* () {
      this.keys[`${se}:${ie}`] = fe.toString();
    });
  }
  /**
   * Gets a {@link utils/key_pair!KeyPair} from in-memory storage
   * @param networkId The targeted network. (ex. default, betanet, etc)
   * @param accountId The NEAR account tied to the key pair
   * @returns {Promise<KeyPair>}
   */
  getKey(ie, se) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const fe = this.keys[`${se}:${ie}`];
      return fe ? crypto_1$1.KeyPair.fromString(fe) : null;
    });
  }
  /**
   * Removes a {@link utils/key_pair!KeyPair} from in-memory storage
   * @param networkId The targeted network. (ex. default, betanet, etc)
   * @param accountId The NEAR account tied to the key pair
   */
  removeKey(ie, se) {
    return __awaiter$8(this, void 0, void 0, function* () {
      delete this.keys[`${se}:${ie}`];
    });
  }
  /**
   * Removes all {@link utils/key_pair!KeyPair} from in-memory storage
   */
  clear() {
    return __awaiter$8(this, void 0, void 0, function* () {
      this.keys = {};
    });
  }
  /**
   * Get the network(s) from in-memory storage
   * @returns {Promise<string[]>}
   */
  getNetworks() {
    return __awaiter$8(this, void 0, void 0, function* () {
      const ie = /* @__PURE__ */ new Set();
      return Object.keys(this.keys).forEach((se) => {
        const fe = se.split(":");
        ie.add(fe[1]);
      }), Array.from(ie.values());
    });
  }
  /**
   * Gets the account(s) from in-memory storage
   * @param networkId The targeted network. (ex. default, betanet, etc)
   */
  getAccounts(ie) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const se = new Array();
      return Object.keys(this.keys).forEach((fe) => {
        const ue = fe.split(":");
        ue[ue.length - 1] === ie && se.push(ue.slice(0, ue.length - 1).join(":"));
      }), se;
    });
  }
  /** @hidden */
  toString() {
    return "InMemoryKeyStore";
  }
}
in_memory_key_store.InMemoryKeyStore = InMemoryKeyStore;
var merge_key_store = {}, __awaiter$7 = commonjsGlobal && commonjsGlobal.__awaiter || function(ae, ie, se, fe) {
  function ue(ce) {
    return ce instanceof se ? ce : new se(function(de) {
      de(ce);
    });
  }
  return new (se || (se = Promise))(function(ce, de) {
    function me(Se) {
      try {
        Ee(fe.next(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function we(Se) {
      try {
        Ee(fe.throw(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function Ee(Se) {
      Se.done ? ce(Se.value) : ue(Se.value).then(me, we);
    }
    Ee((fe = fe.apply(ae, ie || [])).next());
  });
};
Object.defineProperty(merge_key_store, "__esModule", { value: !0 });
merge_key_store.MergeKeyStore = void 0;
const keystore_1 = keystore;
class MergeKeyStore extends keystore_1.KeyStore {
  /**
   * @param keyStores read calls are attempted from start to end of array
   * @param options.writeKeyStoreIndex the keystore index that will receive all write calls
   */
  constructor(ie, se = { writeKeyStoreIndex: 0 }) {
    super(), this.options = se, this.keyStores = ie;
  }
  /**
   * Store a {@link utils/key_pair!KeyPair} to the first index of a key store array
   * @param networkId The targeted network. (ex. default, betanet, etc)
   * @param accountId The NEAR account tied to the key pair
   * @param keyPair The key pair to store in local storage
   */
  setKey(ie, se, fe) {
    return __awaiter$7(this, void 0, void 0, function* () {
      yield this.keyStores[this.options.writeKeyStoreIndex].setKey(ie, se, fe);
    });
  }
  /**
   * Gets a {@link utils/key_pair!KeyPair} from the array of key stores
   * @param networkId The targeted network. (ex. default, betanet, etc)
   * @param accountId The NEAR account tied to the key pair
   * @returns {Promise<KeyPair>}
   */
  getKey(ie, se) {
    return __awaiter$7(this, void 0, void 0, function* () {
      for (const fe of this.keyStores) {
        const ue = yield fe.getKey(ie, se);
        if (ue)
          return ue;
      }
      return null;
    });
  }
  /**
   * Removes a {@link utils/key_pair!KeyPair} from the array of key stores
   * @param networkId The targeted network. (ex. default, betanet, etc)
   * @param accountId The NEAR account tied to the key pair
   */
  removeKey(ie, se) {
    return __awaiter$7(this, void 0, void 0, function* () {
      for (const fe of this.keyStores)
        yield fe.removeKey(ie, se);
    });
  }
  /**
   * Removes all items from each key store
   */
  clear() {
    return __awaiter$7(this, void 0, void 0, function* () {
      for (const ie of this.keyStores)
        yield ie.clear();
    });
  }
  /**
   * Get the network(s) from the array of key stores
   * @returns {Promise<string[]>}
   */
  getNetworks() {
    return __awaiter$7(this, void 0, void 0, function* () {
      const ie = /* @__PURE__ */ new Set();
      for (const se of this.keyStores)
        for (const fe of yield se.getNetworks())
          ie.add(fe);
      return Array.from(ie);
    });
  }
  /**
   * Gets the account(s) from the array of key stores
   * @param networkId The targeted network. (ex. default, betanet, etc)
   */
  getAccounts(ie) {
    return __awaiter$7(this, void 0, void 0, function* () {
      const se = /* @__PURE__ */ new Set();
      for (const fe of this.keyStores)
        for (const ue of yield fe.getAccounts(ie))
          se.add(ue);
      return Array.from(se);
    });
  }
  /** @hidden */
  toString() {
    return `MergeKeyStore(${this.keyStores.join(", ")})`;
  }
}
merge_key_store.MergeKeyStore = MergeKeyStore;
(function(ae) {
  Object.defineProperty(ae, "__esModule", { value: !0 }), ae.MergeKeyStore = ae.KeyStore = ae.InMemoryKeyStore = void 0;
  var ie = in_memory_key_store;
  Object.defineProperty(ae, "InMemoryKeyStore", { enumerable: !0, get: function() {
    return ie.InMemoryKeyStore;
  } });
  var se = keystore;
  Object.defineProperty(ae, "KeyStore", { enumerable: !0, get: function() {
    return se.KeyStore;
  } });
  var fe = merge_key_store;
  Object.defineProperty(ae, "MergeKeyStore", { enumerable: !0, get: function() {
    return fe.MergeKeyStore;
  } });
})(lib$3);
var __awaiter$6 = commonjsGlobal && commonjsGlobal.__awaiter || function(ae, ie, se, fe) {
  function ue(ce) {
    return ce instanceof se ? ce : new se(function(de) {
      de(ce);
    });
  }
  return new (se || (se = Promise))(function(ce, de) {
    function me(Se) {
      try {
        Ee(fe.next(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function we(Se) {
      try {
        Ee(fe.throw(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function Ee(Se) {
      Se.done ? ce(Se.value) : ue(Se.value).then(me, we);
    }
    Ee((fe = fe.apply(ae, ie || [])).next());
  });
};
Object.defineProperty(browser_local_storage_key_store, "__esModule", { value: !0 });
browser_local_storage_key_store.BrowserLocalStorageKeyStore = void 0;
const crypto_1 = lib$7, keystores_1 = lib$3, LOCAL_STORAGE_KEY_PREFIX = "near-api-js:keystore:";
class BrowserLocalStorageKeyStore extends keystores_1.KeyStore {
  /**
   * @param localStorage defaults to window.localStorage
   * @param prefix defaults to `near-api-js:keystore:`
   */
  constructor(ie = window.localStorage, se = LOCAL_STORAGE_KEY_PREFIX) {
    super(), this.localStorage = ie, this.prefix = se;
  }
  /**
   * Stores a {@link utils/key_pair!KeyPair} in local storage.
   * @param networkId The targeted network. (ex. default, betanet, etc)
   * @param accountId The NEAR account tied to the key pair
   * @param keyPair The key pair to store in local storage
   */
  setKey(ie, se, fe) {
    return __awaiter$6(this, void 0, void 0, function* () {
      this.localStorage.setItem(this.storageKeyForSecretKey(ie, se), fe.toString());
    });
  }
  /**
   * Gets a {@link utils/key_pair!KeyPair} from local storage
   * @param networkId The targeted network. (ex. default, betanet, etc)
   * @param accountId The NEAR account tied to the key pair
   * @returns {Promise<KeyPair>}
   */
  getKey(ie, se) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const fe = this.localStorage.getItem(this.storageKeyForSecretKey(ie, se));
      return fe ? crypto_1.KeyPair.fromString(fe) : null;
    });
  }
  /**
   * Removes a {@link utils/key_pair!KeyPair} from local storage
   * @param networkId The targeted network. (ex. default, betanet, etc)
   * @param accountId The NEAR account tied to the key pair
   */
  removeKey(ie, se) {
    return __awaiter$6(this, void 0, void 0, function* () {
      this.localStorage.removeItem(this.storageKeyForSecretKey(ie, se));
    });
  }
  /**
   * Removes all items that start with `prefix` from local storage
   */
  clear() {
    return __awaiter$6(this, void 0, void 0, function* () {
      for (const ie of this.storageKeys())
        ie.startsWith(this.prefix) && this.localStorage.removeItem(ie);
    });
  }
  /**
   * Get the network(s) from local storage
   * @returns {Promise<string[]>}
   */
  getNetworks() {
    return __awaiter$6(this, void 0, void 0, function* () {
      const ie = /* @__PURE__ */ new Set();
      for (const se of this.storageKeys())
        if (se.startsWith(this.prefix)) {
          const fe = se.substring(this.prefix.length).split(":");
          ie.add(fe[1]);
        }
      return Array.from(ie.values());
    });
  }
  /**
   * Gets the account(s) from local storage
   * @param networkId The targeted network. (ex. default, betanet, etc)
   */
  getAccounts(ie) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const se = new Array();
      for (const fe of this.storageKeys())
        if (fe.startsWith(this.prefix)) {
          const ue = fe.substring(this.prefix.length).split(":");
          ue[1] === ie && se.push(ue[0]);
        }
      return se;
    });
  }
  /**
   * @hidden
   * Helper function to retrieve a local storage key
   * @param networkId The targeted network. (ex. default, betanet, etc)
   * @param accountId The NEAR account tied to the storage keythat's sought
   * @returns {string} An example might be: `near-api-js:keystore:near-friend:default`
   */
  storageKeyForSecretKey(ie, se) {
    return `${this.prefix}${se}:${ie}`;
  }
  /** @hidden */
  *storageKeys() {
    for (let ie = 0; ie < this.localStorage.length; ie++)
      yield this.localStorage.key(ie);
  }
}
browser_local_storage_key_store.BrowserLocalStorageKeyStore = BrowserLocalStorageKeyStore;
(function(ae) {
  Object.defineProperty(ae, "__esModule", { value: !0 }), ae.BrowserLocalStorageKeyStore = void 0;
  var ie = browser_local_storage_key_store;
  Object.defineProperty(ae, "BrowserLocalStorageKeyStore", { enumerable: !0, get: function() {
    return ie.BrowserLocalStorageKeyStore;
  } });
})(lib$4);
var lib$2 = {}, action_creators = {}, actions = {}, lib$1 = {}, assignable = {};
Object.defineProperty(assignable, "__esModule", { value: !0 });
assignable.Assignable = void 0;
class Assignable {
  constructor(ie) {
    Object.keys(ie).map((se) => {
      this[se] = ie[se];
    });
  }
}
assignable.Assignable = Assignable;
var errors = {};
Object.defineProperty(errors, "__esModule", { value: !0 });
errors.ErrorContext = errors.TypedError = errors.ArgumentTypeError = errors.PositionalArgsError = void 0;
class PositionalArgsError extends Error {
  constructor() {
    super("Contract method calls expect named arguments wrapped in object, e.g. { argName1: argValue1, argName2: argValue2 }");
  }
}
errors.PositionalArgsError = PositionalArgsError;
class ArgumentTypeError extends Error {
  constructor(ie, se, fe) {
    super(`Expected ${se} for '${ie}' argument, but got '${JSON.stringify(fe)}'`);
  }
}
errors.ArgumentTypeError = ArgumentTypeError;
class TypedError extends Error {
  constructor(ie, se, fe) {
    super(ie), this.type = se || "UntypedError", this.context = fe;
  }
}
errors.TypedError = TypedError;
class ErrorContext {
  constructor(ie) {
    this.transactionHash = ie;
  }
}
errors.ErrorContext = ErrorContext;
var provider = {}, light_client = {};
(function(ae) {
  Object.defineProperty(ae, "__esModule", { value: !0 }), ae.IdType = void 0, function(ie) {
    ie.Transaction = "transaction", ie.Receipt = "receipt";
  }(ae.IdType || (ae.IdType = {}));
})(light_client);
var response = {};
(function(ae) {
  Object.defineProperty(ae, "__esModule", { value: !0 }), ae.FinalExecutionStatusBasic = ae.ExecutionStatusBasic = void 0, function(ie) {
    ie.Unknown = "Unknown", ie.Pending = "Pending", ie.Failure = "Failure";
  }(ae.ExecutionStatusBasic || (ae.ExecutionStatusBasic = {})), function(ie) {
    ie.NotStarted = "NotStarted", ie.Started = "Started", ie.Failure = "Failure";
  }(ae.FinalExecutionStatusBasic || (ae.FinalExecutionStatusBasic = {}));
})(response);
(function(ae) {
  Object.defineProperty(ae, "__esModule", { value: !0 }), ae.FinalExecutionStatusBasic = ae.ExecutionStatusBasic = ae.IdType = void 0;
  var ie = light_client;
  Object.defineProperty(ae, "IdType", { enumerable: !0, get: function() {
    return ie.IdType;
  } });
  var se = response;
  Object.defineProperty(ae, "ExecutionStatusBasic", { enumerable: !0, get: function() {
    return se.ExecutionStatusBasic;
  } }), Object.defineProperty(ae, "FinalExecutionStatusBasic", { enumerable: !0, get: function() {
    return se.FinalExecutionStatusBasic;
  } });
})(provider);
(function(ae) {
  var ie = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(fe, ue, ce, de) {
    de === void 0 && (de = ce);
    var me = Object.getOwnPropertyDescriptor(ue, ce);
    (!me || ("get" in me ? !ue.__esModule : me.writable || me.configurable)) && (me = { enumerable: !0, get: function() {
      return ue[ce];
    } }), Object.defineProperty(fe, de, me);
  } : function(fe, ue, ce, de) {
    de === void 0 && (de = ce), fe[de] = ue[ce];
  }), se = commonjsGlobal && commonjsGlobal.__exportStar || function(fe, ue) {
    for (var ce in fe)
      ce !== "default" && !Object.prototype.hasOwnProperty.call(ue, ce) && ie(ue, fe, ce);
  };
  Object.defineProperty(ae, "__esModule", { value: !0 }), se(assignable, ae), se(errors, ae), se(provider, ae);
})(lib$1);
Object.defineProperty(actions, "__esModule", { value: !0 });
actions.Action = actions.SignedDelegate = actions.DeleteAccount = actions.DeleteKey = actions.AddKey = actions.Stake = actions.Transfer = actions.FunctionCall = actions.DeployContract = actions.CreateAccount = actions.IAction = actions.AccessKey = actions.AccessKeyPermission = actions.FullAccessPermission = actions.FunctionCallPermission = void 0;
const types_1$4 = lib$1;
class Enum {
  constructor(ie) {
    if (Object.keys(ie).length !== 1)
      throw new Error("Enum can only take single value");
    Object.keys(ie).map((se) => {
      this[se] = ie[se], this.enum = se;
    });
  }
}
class FunctionCallPermission extends types_1$4.Assignable {
}
actions.FunctionCallPermission = FunctionCallPermission;
class FullAccessPermission extends types_1$4.Assignable {
}
actions.FullAccessPermission = FullAccessPermission;
class AccessKeyPermission extends Enum {
}
actions.AccessKeyPermission = AccessKeyPermission;
class AccessKey extends types_1$4.Assignable {
}
actions.AccessKey = AccessKey;
class IAction extends types_1$4.Assignable {
}
actions.IAction = IAction;
class CreateAccount extends IAction {
}
actions.CreateAccount = CreateAccount;
class DeployContract extends IAction {
}
actions.DeployContract = DeployContract;
class FunctionCall extends IAction {
}
actions.FunctionCall = FunctionCall;
class Transfer extends IAction {
}
actions.Transfer = Transfer;
class Stake extends IAction {
}
actions.Stake = Stake;
class AddKey extends IAction {
}
actions.AddKey = AddKey;
class DeleteKey extends IAction {
}
actions.DeleteKey = DeleteKey;
class DeleteAccount extends IAction {
}
actions.DeleteAccount = DeleteAccount;
class SignedDelegate extends IAction {
}
actions.SignedDelegate = SignedDelegate;
class Action extends Enum {
}
actions.Action = Action;
Object.defineProperty(action_creators, "__esModule", { value: !0 });
action_creators.actionCreators = action_creators.stringifyJsonOrBytes = void 0;
const actions_1$1 = actions;
function fullAccessKey() {
  return new actions_1$1.AccessKey({
    permission: new actions_1$1.AccessKeyPermission({
      fullAccess: new actions_1$1.FullAccessPermission({})
    })
  });
}
function functionCallAccessKey(ae, ie, se) {
  return new actions_1$1.AccessKey({
    permission: new actions_1$1.AccessKeyPermission({
      functionCall: new actions_1$1.FunctionCallPermission({ receiverId: ae, allowance: se, methodNames: ie })
    })
  });
}
function createAccount() {
  return new actions_1$1.Action({ createAccount: new actions_1$1.CreateAccount({}) });
}
function deployContract(ae) {
  return new actions_1$1.Action({ deployContract: new actions_1$1.DeployContract({ code: ae }) });
}
function stringifyJsonOrBytes(ae) {
  return ae.byteLength !== void 0 && ae.byteLength === ae.length ? ae : Buffer$F.from(JSON.stringify(ae));
}
action_creators.stringifyJsonOrBytes = stringifyJsonOrBytes;
function functionCall(ae, ie, se, fe, ue = stringifyJsonOrBytes, ce = !1) {
  return ce ? new actions_1$1.Action({ functionCall: new actions_1$1.FunctionCall({ methodName: ae, args: ie, gas: se, deposit: fe }) }) : new actions_1$1.Action({
    functionCall: new actions_1$1.FunctionCall({
      methodName: ae,
      args: ue(ie),
      gas: se,
      deposit: fe
    })
  });
}
function transfer(ae) {
  return new actions_1$1.Action({ transfer: new actions_1$1.Transfer({ deposit: ae }) });
}
function stake(ae, ie) {
  return new actions_1$1.Action({ stake: new actions_1$1.Stake({ stake: ae, publicKey: ie }) });
}
function addKey(ae, ie) {
  return new actions_1$1.Action({ addKey: new actions_1$1.AddKey({ publicKey: ae, accessKey: ie }) });
}
function deleteKey(ae) {
  return new actions_1$1.Action({ deleteKey: new actions_1$1.DeleteKey({ publicKey: ae }) });
}
function deleteAccount(ae) {
  return new actions_1$1.Action({ deleteAccount: new actions_1$1.DeleteAccount({ beneficiaryId: ae }) });
}
function signedDelegate({ delegateAction: ae, signature: ie }) {
  return new actions_1$1.Action({ signedDelegate: new actions_1$1.SignedDelegate({ delegateAction: ae, signature: ie }) });
}
action_creators.actionCreators = {
  addKey,
  createAccount,
  deleteAccount,
  deleteKey,
  deployContract,
  fullAccessKey,
  functionCall,
  functionCallAccessKey,
  signedDelegate,
  stake,
  transfer
};
var create_transaction = {}, schema = {}, lib = {}, constants = {};
(function(ae) {
  Object.defineProperty(ae, "__esModule", { value: !0 }), ae.KeyType = void 0, function(ie) {
    ie[ie.ED25519 = 0] = "ED25519";
  }(ae.KeyType || (ae.KeyType = {}));
})(constants);
var key_pair = {}, key_pair_base = {};
Object.defineProperty(key_pair_base, "__esModule", { value: !0 });
key_pair_base.KeyPairBase = void 0;
class KeyPairBase {
}
key_pair_base.KeyPairBase = KeyPairBase;
var key_pair_ed25519 = {}, public_key = {}, __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(ae) {
  return ae && ae.__esModule ? ae : { default: ae };
};
Object.defineProperty(public_key, "__esModule", { value: !0 });
public_key.PublicKey = void 0;
const types_1$3 = lib$1, borsh_1$1 = lib$6, tweetnacl_1$1 = __importDefault$2(naclFastExports), constants_1$1 = constants;
function key_type_to_str(ae) {
  switch (ae) {
    case constants_1$1.KeyType.ED25519:
      return "ed25519";
    default:
      throw new Error(`Unknown key type ${ae}`);
  }
}
function str_to_key_type(ae) {
  switch (ae.toLowerCase()) {
    case "ed25519":
      return constants_1$1.KeyType.ED25519;
    default:
      throw new Error(`Unknown key type ${ae}`);
  }
}
let PublicKey$1 = class Dn extends types_1$3.Assignable {
  static from(ie) {
    return typeof ie == "string" ? Dn.fromString(ie) : ie;
  }
  static fromString(ie) {
    const se = ie.split(":");
    if (se.length === 1)
      return new Dn({ keyType: constants_1$1.KeyType.ED25519, data: (0, borsh_1$1.baseDecode)(se[0]) });
    if (se.length === 2)
      return new Dn({ keyType: str_to_key_type(se[0]), data: (0, borsh_1$1.baseDecode)(se[1]) });
    throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
  }
  toString() {
    return `${key_type_to_str(this.keyType)}:${(0, borsh_1$1.baseEncode)(this.data)}`;
  }
  verify(ie, se) {
    switch (this.keyType) {
      case constants_1$1.KeyType.ED25519:
        return tweetnacl_1$1.default.sign.detached.verify(ie, se, this.data);
      default:
        throw new Error(`Unknown key type ${this.keyType}`);
    }
  }
};
public_key.PublicKey = PublicKey$1;
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(ae) {
  return ae && ae.__esModule ? ae : { default: ae };
};
Object.defineProperty(key_pair_ed25519, "__esModule", { value: !0 });
key_pair_ed25519.KeyPairEd25519 = void 0;
const borsh_1 = lib$6, tweetnacl_1 = __importDefault$1(naclFastExports), constants_1 = constants, key_pair_base_1$1 = key_pair_base, public_key_1 = public_key;
class KeyPairEd25519 extends key_pair_base_1$1.KeyPairBase {
  /**
   * Construct an instance of key pair given a secret key.
   * It's generally assumed that these are encoded in base58.
   * @param {string} secretKey
   */
  constructor(ie) {
    super();
    const se = tweetnacl_1.default.sign.keyPair.fromSecretKey((0, borsh_1.baseDecode)(ie));
    this.publicKey = new public_key_1.PublicKey({ keyType: constants_1.KeyType.ED25519, data: se.publicKey }), this.secretKey = ie;
  }
  /**
   * Generate a new random keypair.
   * @example
   * const keyRandom = KeyPair.fromRandom();
   * keyRandom.publicKey
   * // returns [PUBLIC_KEY]
   *
   * keyRandom.secretKey
   * // returns [SECRET_KEY]
   */
  static fromRandom() {
    const ie = tweetnacl_1.default.sign.keyPair();
    return new KeyPairEd25519((0, borsh_1.baseEncode)(ie.secretKey));
  }
  sign(ie) {
    return { signature: tweetnacl_1.default.sign.detached(ie, (0, borsh_1.baseDecode)(this.secretKey)), publicKey: this.publicKey };
  }
  verify(ie, se) {
    return this.publicKey.verify(ie, se);
  }
  toString() {
    return `ed25519:${this.secretKey}`;
  }
  getPublicKey() {
    return this.publicKey;
  }
}
key_pair_ed25519.KeyPairEd25519 = KeyPairEd25519;
Object.defineProperty(key_pair, "__esModule", { value: !0 });
key_pair.KeyPair = void 0;
const key_pair_base_1 = key_pair_base, key_pair_ed25519_1 = key_pair_ed25519;
class KeyPair extends key_pair_base_1.KeyPairBase {
  /**
   * @param curve Name of elliptical curve, case-insensitive
   * @returns Random KeyPair based on the curve
   */
  static fromRandom(ie) {
    switch (ie.toUpperCase()) {
      case "ED25519":
        return key_pair_ed25519_1.KeyPairEd25519.fromRandom();
      default:
        throw new Error(`Unknown curve ${ie}`);
    }
  }
  static fromString(ie) {
    const se = ie.split(":");
    if (se.length === 1)
      return new key_pair_ed25519_1.KeyPairEd25519(se[0]);
    if (se.length === 2)
      switch (se[0].toUpperCase()) {
        case "ED25519":
          return new key_pair_ed25519_1.KeyPairEd25519(se[1]);
        default:
          throw new Error(`Unknown curve: ${se[0]}`);
      }
    else
      throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
  }
}
key_pair.KeyPair = KeyPair;
(function(ae) {
  Object.defineProperty(ae, "__esModule", { value: !0 }), ae.PublicKey = ae.KeyPairEd25519 = ae.KeyPair = ae.KeyType = void 0;
  var ie = constants;
  Object.defineProperty(ae, "KeyType", { enumerable: !0, get: function() {
    return ie.KeyType;
  } });
  var se = key_pair;
  Object.defineProperty(ae, "KeyPair", { enumerable: !0, get: function() {
    return se.KeyPair;
  } });
  var fe = key_pair_ed25519;
  Object.defineProperty(ae, "KeyPairEd25519", { enumerable: !0, get: function() {
    return fe.KeyPairEd25519;
  } });
  var ue = public_key;
  Object.defineProperty(ae, "PublicKey", { enumerable: !0, get: function() {
    return ue.PublicKey;
  } });
})(lib);
var delegate = {};
Object.defineProperty(delegate, "__esModule", { value: !0 });
delegate.buildDelegateAction = delegate.DelegateAction = void 0;
const types_1$2 = lib$1;
class DelegateAction extends types_1$2.Assignable {
}
delegate.DelegateAction = DelegateAction;
function buildDelegateAction({ actions: ae, maxBlockHeight: ie, nonce: se, publicKey: fe, receiverId: ue, senderId: ce }) {
  return new DelegateAction({
    senderId: ce,
    receiverId: ue,
    actions: ae,
    nonce: se,
    maxBlockHeight: ie,
    publicKey: fe
  });
}
delegate.buildDelegateAction = buildDelegateAction;
var prefix = {};
Object.defineProperty(prefix, "__esModule", { value: !0 });
prefix.DelegateActionPrefix = void 0;
const types_1$1 = lib$1, ACTIONABLE_MESSAGE_BASE = Math.pow(2, 30), NEP = {
  MetaTransactions: 366
};
class NEPPrefix extends types_1$1.Assignable {
}
class ActionableMessagePrefix extends NEPPrefix {
  /** Given the NEP number, set the prefix using 2^30 as the offset **/
  constructor(ie) {
    super({ prefix: ACTIONABLE_MESSAGE_BASE + ie });
  }
}
class DelegateActionPrefix extends ActionableMessagePrefix {
  constructor() {
    super(NEP.MetaTransactions);
  }
}
prefix.DelegateActionPrefix = DelegateActionPrefix;
var signature$1 = {};
Object.defineProperty(signature$1, "__esModule", { value: !0 });
signature$1.Signature = void 0;
const types_1 = lib$1;
class Signature extends types_1.Assignable {
}
signature$1.Signature = Signature;
(function(ae) {
  Object.defineProperty(ae, "__esModule", { value: !0 }), ae.SCHEMA = ae.SignedTransaction = ae.Transaction = ae.decodeSignedTransaction = ae.decodeTransaction = ae.encodeTransaction = ae.encodeSignedDelegate = ae.encodeDelegateAction = void 0;
  const ie = lib, se = lib$1, fe = lib$6, ue = actions, ce = delegate, de = prefix, me = signature$1;
  function we(Ne) {
    return new Uint8Array([
      ...(0, fe.serialize)(ae.SCHEMA, new de.DelegateActionPrefix()),
      ...(0, fe.serialize)(ae.SCHEMA, Ne)
    ]);
  }
  ae.encodeDelegateAction = we;
  function Ee(Ne) {
    return (0, fe.serialize)(ae.SCHEMA, Ne);
  }
  ae.encodeSignedDelegate = Ee;
  function Se(Ne) {
    return (0, fe.serialize)(ae.SCHEMA, Ne);
  }
  ae.encodeTransaction = Se;
  function Be(Ne) {
    return (0, fe.deserialize)(ae.SCHEMA, Ie, Ne);
  }
  ae.decodeTransaction = Be;
  function Ce(Ne) {
    return (0, fe.deserialize)(ae.SCHEMA, Pe, Ne);
  }
  ae.decodeSignedTransaction = Ce;
  class Ie extends se.Assignable {
    encode() {
      return Se(this);
    }
    static decode(ke) {
      return Be(ke);
    }
  }
  ae.Transaction = Ie;
  class Pe extends se.Assignable {
    encode() {
      return Se(this);
    }
    static decode(ke) {
      return Ce(ke);
    }
  }
  ae.SignedTransaction = Pe, ae.SCHEMA = /* @__PURE__ */ new Map([
    [me.Signature, { kind: "struct", fields: [
      ["keyType", "u8"],
      ["data", [64]]
    ] }],
    [Pe, { kind: "struct", fields: [
      ["transaction", Ie],
      ["signature", me.Signature]
    ] }],
    [Ie, { kind: "struct", fields: [
      ["signerId", "string"],
      ["publicKey", ie.PublicKey],
      ["nonce", "u64"],
      ["receiverId", "string"],
      ["blockHash", [32]],
      ["actions", [ue.Action]]
    ] }],
    [ie.PublicKey, { kind: "struct", fields: [
      ["keyType", "u8"],
      ["data", [32]]
    ] }],
    [ue.AccessKey, { kind: "struct", fields: [
      ["nonce", "u64"],
      ["permission", ue.AccessKeyPermission]
    ] }],
    [ue.AccessKeyPermission, { kind: "enum", field: "enum", values: [
      ["functionCall", ue.FunctionCallPermission],
      ["fullAccess", ue.FullAccessPermission]
    ] }],
    [ue.FunctionCallPermission, { kind: "struct", fields: [
      ["allowance", { kind: "option", type: "u128" }],
      ["receiverId", "string"],
      ["methodNames", ["string"]]
    ] }],
    [ue.FullAccessPermission, { kind: "struct", fields: [] }],
    [ue.Action, { kind: "enum", field: "enum", values: [
      ["createAccount", ue.CreateAccount],
      ["deployContract", ue.DeployContract],
      ["functionCall", ue.FunctionCall],
      ["transfer", ue.Transfer],
      ["stake", ue.Stake],
      ["addKey", ue.AddKey],
      ["deleteKey", ue.DeleteKey],
      ["deleteAccount", ue.DeleteAccount],
      ["signedDelegate", ue.SignedDelegate]
    ] }],
    [ue.CreateAccount, { kind: "struct", fields: [] }],
    [ue.DeployContract, { kind: "struct", fields: [
      ["code", ["u8"]]
    ] }],
    [ue.FunctionCall, { kind: "struct", fields: [
      ["methodName", "string"],
      ["args", ["u8"]],
      ["gas", "u64"],
      ["deposit", "u128"]
    ] }],
    [ue.Transfer, { kind: "struct", fields: [
      ["deposit", "u128"]
    ] }],
    [ue.Stake, { kind: "struct", fields: [
      ["stake", "u128"],
      ["publicKey", ie.PublicKey]
    ] }],
    [ue.AddKey, { kind: "struct", fields: [
      ["publicKey", ie.PublicKey],
      ["accessKey", ue.AccessKey]
    ] }],
    [ue.DeleteKey, { kind: "struct", fields: [
      ["publicKey", ie.PublicKey]
    ] }],
    [ue.DeleteAccount, { kind: "struct", fields: [
      ["beneficiaryId", "string"]
    ] }],
    [ce.DelegateAction, { kind: "struct", fields: [
      ["senderId", "string"],
      ["receiverId", "string"],
      ["actions", [ue.Action]],
      ["nonce", "u64"],
      ["maxBlockHeight", "u64"],
      ["publicKey", ie.PublicKey]
    ] }],
    [de.DelegateActionPrefix, { kind: "struct", fields: [
      ["prefix", "u32"]
    ] }],
    [ue.SignedDelegate, { kind: "struct", fields: [
      ["delegateAction", ce.DelegateAction],
      ["signature", me.Signature]
    ] }]
  ]);
})(schema);
Object.defineProperty(create_transaction, "__esModule", { value: !0 });
create_transaction.createTransaction = void 0;
const schema_1$1 = schema;
function createTransaction(ae, ie, se, fe, ue, ce) {
  return new schema_1$1.Transaction({ signerId: ae, publicKey: ie, nonce: fe, receiverId: se, actions: ue, blockHash: ce });
}
create_transaction.createTransaction = createTransaction;
var sign$1 = {}, sha256$1 = { exports: {} };
(function(module) {
  (function() {
    var ERROR = "input is invalid type", WINDOW = typeof window == "object", root = WINDOW ? window : {};
    root.JS_SHA256_NO_WINDOW && (WINDOW = !1);
    var WEB_WORKER = !WINDOW && typeof self == "object", NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process$1 == "object" && process$1.versions && process$1.versions.node;
    NODE_JS ? root = commonjsGlobal : WEB_WORKER && (root = self);
    var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && !0 && module.exports, ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", HEX_CHARS = "0123456789abcdef".split(""), EXTRA = [-2147483648, 8388608, 32768, 128], SHIFT = [24, 16, 8, 0], K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ], OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"], blocks = [];
    (root.JS_SHA256_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(ae) {
      return Object.prototype.toString.call(ae) === "[object Array]";
    }), ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(ae) {
      return typeof ae == "object" && ae.buffer && ae.buffer.constructor === ArrayBuffer;
    });
    var createOutputMethod = function(ae, ie) {
      return function(se) {
        return new Sha256(ie, !0).update(se)[ae]();
      };
    }, createMethod = function(ae) {
      var ie = createOutputMethod("hex", ae);
      NODE_JS && (ie = nodeWrap(ie, ae)), ie.create = function() {
        return new Sha256(ae);
      }, ie.update = function(ue) {
        return ie.create().update(ue);
      };
      for (var se = 0; se < OUTPUT_TYPES.length; ++se) {
        var fe = OUTPUT_TYPES[se];
        ie[fe] = createOutputMethod(fe, ae);
      }
      return ie;
    }, nodeWrap = function(method, is224) {
      var crypto = eval("require('crypto')"), Buffer = eval("require('buffer').Buffer"), algorithm = is224 ? "sha224" : "sha256", nodeMethod = function(ae) {
        if (typeof ae == "string")
          return crypto.createHash(algorithm).update(ae, "utf8").digest("hex");
        if (ae == null)
          throw new Error(ERROR);
        return ae.constructor === ArrayBuffer && (ae = new Uint8Array(ae)), Array.isArray(ae) || ArrayBuffer.isView(ae) || ae.constructor === Buffer ? crypto.createHash(algorithm).update(new Buffer(ae)).digest("hex") : method(ae);
      };
      return nodeMethod;
    }, createHmacOutputMethod = function(ae, ie) {
      return function(se, fe) {
        return new HmacSha256(se, ie, !0).update(fe)[ae]();
      };
    }, createHmacMethod = function(ae) {
      var ie = createHmacOutputMethod("hex", ae);
      ie.create = function(ue) {
        return new HmacSha256(ue, ae);
      }, ie.update = function(ue, ce) {
        return ie.create(ue).update(ce);
      };
      for (var se = 0; se < OUTPUT_TYPES.length; ++se) {
        var fe = OUTPUT_TYPES[se];
        ie[fe] = createHmacOutputMethod(fe, ae);
      }
      return ie;
    };
    function Sha256(ae, ie) {
      ie ? (blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0, this.blocks = blocks) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ae ? (this.h0 = 3238371032, this.h1 = 914150663, this.h2 = 812702999, this.h3 = 4144912697, this.h4 = 4290775857, this.h5 = 1750603025, this.h6 = 1694076839, this.h7 = 3204075428) : (this.h0 = 1779033703, this.h1 = 3144134277, this.h2 = 1013904242, this.h3 = 2773480762, this.h4 = 1359893119, this.h5 = 2600822924, this.h6 = 528734635, this.h7 = 1541459225), this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0, this.is224 = ae;
    }
    Sha256.prototype.update = function(ae) {
      if (!this.finalized) {
        var ie, se = typeof ae;
        if (se !== "string") {
          if (se === "object") {
            if (ae === null)
              throw new Error(ERROR);
            if (ARRAY_BUFFER && ae.constructor === ArrayBuffer)
              ae = new Uint8Array(ae);
            else if (!Array.isArray(ae) && (!ARRAY_BUFFER || !ArrayBuffer.isView(ae)))
              throw new Error(ERROR);
          } else
            throw new Error(ERROR);
          ie = !0;
        }
        for (var fe, ue = 0, ce, de = ae.length, me = this.blocks; ue < de; ) {
          if (this.hashed && (this.hashed = !1, me[0] = this.block, me[16] = me[1] = me[2] = me[3] = me[4] = me[5] = me[6] = me[7] = me[8] = me[9] = me[10] = me[11] = me[12] = me[13] = me[14] = me[15] = 0), ie)
            for (ce = this.start; ue < de && ce < 64; ++ue)
              me[ce >> 2] |= ae[ue] << SHIFT[ce++ & 3];
          else
            for (ce = this.start; ue < de && ce < 64; ++ue)
              fe = ae.charCodeAt(ue), fe < 128 ? me[ce >> 2] |= fe << SHIFT[ce++ & 3] : fe < 2048 ? (me[ce >> 2] |= (192 | fe >> 6) << SHIFT[ce++ & 3], me[ce >> 2] |= (128 | fe & 63) << SHIFT[ce++ & 3]) : fe < 55296 || fe >= 57344 ? (me[ce >> 2] |= (224 | fe >> 12) << SHIFT[ce++ & 3], me[ce >> 2] |= (128 | fe >> 6 & 63) << SHIFT[ce++ & 3], me[ce >> 2] |= (128 | fe & 63) << SHIFT[ce++ & 3]) : (fe = 65536 + ((fe & 1023) << 10 | ae.charCodeAt(++ue) & 1023), me[ce >> 2] |= (240 | fe >> 18) << SHIFT[ce++ & 3], me[ce >> 2] |= (128 | fe >> 12 & 63) << SHIFT[ce++ & 3], me[ce >> 2] |= (128 | fe >> 6 & 63) << SHIFT[ce++ & 3], me[ce >> 2] |= (128 | fe & 63) << SHIFT[ce++ & 3]);
          this.lastByteIndex = ce, this.bytes += ce - this.start, ce >= 64 ? (this.block = me[16], this.start = ce - 64, this.hash(), this.hashed = !0) : this.start = ce;
        }
        return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
      }
    }, Sha256.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var ae = this.blocks, ie = this.lastByteIndex;
        ae[16] = this.block, ae[ie >> 2] |= EXTRA[ie & 3], this.block = ae[16], ie >= 56 && (this.hashed || this.hash(), ae[0] = this.block, ae[16] = ae[1] = ae[2] = ae[3] = ae[4] = ae[5] = ae[6] = ae[7] = ae[8] = ae[9] = ae[10] = ae[11] = ae[12] = ae[13] = ae[14] = ae[15] = 0), ae[14] = this.hBytes << 3 | this.bytes >>> 29, ae[15] = this.bytes << 3, this.hash();
      }
    }, Sha256.prototype.hash = function() {
      var ae = this.h0, ie = this.h1, se = this.h2, fe = this.h3, ue = this.h4, ce = this.h5, de = this.h6, me = this.h7, we = this.blocks, Ee, Se, Be, Ce, Ie, Pe, Ne, ke, He, De, Ge;
      for (Ee = 16; Ee < 64; ++Ee)
        Ie = we[Ee - 15], Se = (Ie >>> 7 | Ie << 25) ^ (Ie >>> 18 | Ie << 14) ^ Ie >>> 3, Ie = we[Ee - 2], Be = (Ie >>> 17 | Ie << 15) ^ (Ie >>> 19 | Ie << 13) ^ Ie >>> 10, we[Ee] = we[Ee - 16] + Se + we[Ee - 7] + Be << 0;
      for (Ge = ie & se, Ee = 0; Ee < 64; Ee += 4)
        this.first ? (this.is224 ? (ke = 300032, Ie = we[0] - 1413257819, me = Ie - 150054599 << 0, fe = Ie + 24177077 << 0) : (ke = 704751109, Ie = we[0] - 210244248, me = Ie - 1521486534 << 0, fe = Ie + 143694565 << 0), this.first = !1) : (Se = (ae >>> 2 | ae << 30) ^ (ae >>> 13 | ae << 19) ^ (ae >>> 22 | ae << 10), Be = (ue >>> 6 | ue << 26) ^ (ue >>> 11 | ue << 21) ^ (ue >>> 25 | ue << 7), ke = ae & ie, Ce = ke ^ ae & se ^ Ge, Ne = ue & ce ^ ~ue & de, Ie = me + Be + Ne + K[Ee] + we[Ee], Pe = Se + Ce, me = fe + Ie << 0, fe = Ie + Pe << 0), Se = (fe >>> 2 | fe << 30) ^ (fe >>> 13 | fe << 19) ^ (fe >>> 22 | fe << 10), Be = (me >>> 6 | me << 26) ^ (me >>> 11 | me << 21) ^ (me >>> 25 | me << 7), He = fe & ae, Ce = He ^ fe & ie ^ ke, Ne = me & ue ^ ~me & ce, Ie = de + Be + Ne + K[Ee + 1] + we[Ee + 1], Pe = Se + Ce, de = se + Ie << 0, se = Ie + Pe << 0, Se = (se >>> 2 | se << 30) ^ (se >>> 13 | se << 19) ^ (se >>> 22 | se << 10), Be = (de >>> 6 | de << 26) ^ (de >>> 11 | de << 21) ^ (de >>> 25 | de << 7), De = se & fe, Ce = De ^ se & ae ^ He, Ne = de & me ^ ~de & ue, Ie = ce + Be + Ne + K[Ee + 2] + we[Ee + 2], Pe = Se + Ce, ce = ie + Ie << 0, ie = Ie + Pe << 0, Se = (ie >>> 2 | ie << 30) ^ (ie >>> 13 | ie << 19) ^ (ie >>> 22 | ie << 10), Be = (ce >>> 6 | ce << 26) ^ (ce >>> 11 | ce << 21) ^ (ce >>> 25 | ce << 7), Ge = ie & se, Ce = Ge ^ ie & fe ^ De, Ne = ce & de ^ ~ce & me, Ie = ue + Be + Ne + K[Ee + 3] + we[Ee + 3], Pe = Se + Ce, ue = ae + Ie << 0, ae = Ie + Pe << 0;
      this.h0 = this.h0 + ae << 0, this.h1 = this.h1 + ie << 0, this.h2 = this.h2 + se << 0, this.h3 = this.h3 + fe << 0, this.h4 = this.h4 + ue << 0, this.h5 = this.h5 + ce << 0, this.h6 = this.h6 + de << 0, this.h7 = this.h7 + me << 0;
    }, Sha256.prototype.hex = function() {
      this.finalize();
      var ae = this.h0, ie = this.h1, se = this.h2, fe = this.h3, ue = this.h4, ce = this.h5, de = this.h6, me = this.h7, we = HEX_CHARS[ae >> 28 & 15] + HEX_CHARS[ae >> 24 & 15] + HEX_CHARS[ae >> 20 & 15] + HEX_CHARS[ae >> 16 & 15] + HEX_CHARS[ae >> 12 & 15] + HEX_CHARS[ae >> 8 & 15] + HEX_CHARS[ae >> 4 & 15] + HEX_CHARS[ae & 15] + HEX_CHARS[ie >> 28 & 15] + HEX_CHARS[ie >> 24 & 15] + HEX_CHARS[ie >> 20 & 15] + HEX_CHARS[ie >> 16 & 15] + HEX_CHARS[ie >> 12 & 15] + HEX_CHARS[ie >> 8 & 15] + HEX_CHARS[ie >> 4 & 15] + HEX_CHARS[ie & 15] + HEX_CHARS[se >> 28 & 15] + HEX_CHARS[se >> 24 & 15] + HEX_CHARS[se >> 20 & 15] + HEX_CHARS[se >> 16 & 15] + HEX_CHARS[se >> 12 & 15] + HEX_CHARS[se >> 8 & 15] + HEX_CHARS[se >> 4 & 15] + HEX_CHARS[se & 15] + HEX_CHARS[fe >> 28 & 15] + HEX_CHARS[fe >> 24 & 15] + HEX_CHARS[fe >> 20 & 15] + HEX_CHARS[fe >> 16 & 15] + HEX_CHARS[fe >> 12 & 15] + HEX_CHARS[fe >> 8 & 15] + HEX_CHARS[fe >> 4 & 15] + HEX_CHARS[fe & 15] + HEX_CHARS[ue >> 28 & 15] + HEX_CHARS[ue >> 24 & 15] + HEX_CHARS[ue >> 20 & 15] + HEX_CHARS[ue >> 16 & 15] + HEX_CHARS[ue >> 12 & 15] + HEX_CHARS[ue >> 8 & 15] + HEX_CHARS[ue >> 4 & 15] + HEX_CHARS[ue & 15] + HEX_CHARS[ce >> 28 & 15] + HEX_CHARS[ce >> 24 & 15] + HEX_CHARS[ce >> 20 & 15] + HEX_CHARS[ce >> 16 & 15] + HEX_CHARS[ce >> 12 & 15] + HEX_CHARS[ce >> 8 & 15] + HEX_CHARS[ce >> 4 & 15] + HEX_CHARS[ce & 15] + HEX_CHARS[de >> 28 & 15] + HEX_CHARS[de >> 24 & 15] + HEX_CHARS[de >> 20 & 15] + HEX_CHARS[de >> 16 & 15] + HEX_CHARS[de >> 12 & 15] + HEX_CHARS[de >> 8 & 15] + HEX_CHARS[de >> 4 & 15] + HEX_CHARS[de & 15];
      return this.is224 || (we += HEX_CHARS[me >> 28 & 15] + HEX_CHARS[me >> 24 & 15] + HEX_CHARS[me >> 20 & 15] + HEX_CHARS[me >> 16 & 15] + HEX_CHARS[me >> 12 & 15] + HEX_CHARS[me >> 8 & 15] + HEX_CHARS[me >> 4 & 15] + HEX_CHARS[me & 15]), we;
    }, Sha256.prototype.toString = Sha256.prototype.hex, Sha256.prototype.digest = function() {
      this.finalize();
      var ae = this.h0, ie = this.h1, se = this.h2, fe = this.h3, ue = this.h4, ce = this.h5, de = this.h6, me = this.h7, we = [
        ae >> 24 & 255,
        ae >> 16 & 255,
        ae >> 8 & 255,
        ae & 255,
        ie >> 24 & 255,
        ie >> 16 & 255,
        ie >> 8 & 255,
        ie & 255,
        se >> 24 & 255,
        se >> 16 & 255,
        se >> 8 & 255,
        se & 255,
        fe >> 24 & 255,
        fe >> 16 & 255,
        fe >> 8 & 255,
        fe & 255,
        ue >> 24 & 255,
        ue >> 16 & 255,
        ue >> 8 & 255,
        ue & 255,
        ce >> 24 & 255,
        ce >> 16 & 255,
        ce >> 8 & 255,
        ce & 255,
        de >> 24 & 255,
        de >> 16 & 255,
        de >> 8 & 255,
        de & 255
      ];
      return this.is224 || we.push(me >> 24 & 255, me >> 16 & 255, me >> 8 & 255, me & 255), we;
    }, Sha256.prototype.array = Sha256.prototype.digest, Sha256.prototype.arrayBuffer = function() {
      this.finalize();
      var ae = new ArrayBuffer(this.is224 ? 28 : 32), ie = new DataView(ae);
      return ie.setUint32(0, this.h0), ie.setUint32(4, this.h1), ie.setUint32(8, this.h2), ie.setUint32(12, this.h3), ie.setUint32(16, this.h4), ie.setUint32(20, this.h5), ie.setUint32(24, this.h6), this.is224 || ie.setUint32(28, this.h7), ae;
    };
    function HmacSha256(ae, ie, se) {
      var fe, ue = typeof ae;
      if (ue === "string") {
        var ce = [], de = ae.length, me = 0, we;
        for (fe = 0; fe < de; ++fe)
          we = ae.charCodeAt(fe), we < 128 ? ce[me++] = we : we < 2048 ? (ce[me++] = 192 | we >> 6, ce[me++] = 128 | we & 63) : we < 55296 || we >= 57344 ? (ce[me++] = 224 | we >> 12, ce[me++] = 128 | we >> 6 & 63, ce[me++] = 128 | we & 63) : (we = 65536 + ((we & 1023) << 10 | ae.charCodeAt(++fe) & 1023), ce[me++] = 240 | we >> 18, ce[me++] = 128 | we >> 12 & 63, ce[me++] = 128 | we >> 6 & 63, ce[me++] = 128 | we & 63);
        ae = ce;
      } else if (ue === "object") {
        if (ae === null)
          throw new Error(ERROR);
        if (ARRAY_BUFFER && ae.constructor === ArrayBuffer)
          ae = new Uint8Array(ae);
        else if (!Array.isArray(ae) && (!ARRAY_BUFFER || !ArrayBuffer.isView(ae)))
          throw new Error(ERROR);
      } else
        throw new Error(ERROR);
      ae.length > 64 && (ae = new Sha256(ie, !0).update(ae).array());
      var Ee = [], Se = [];
      for (fe = 0; fe < 64; ++fe) {
        var Be = ae[fe] || 0;
        Ee[fe] = 92 ^ Be, Se[fe] = 54 ^ Be;
      }
      Sha256.call(this, ie, se), this.update(Se), this.oKeyPad = Ee, this.inner = !0, this.sharedMemory = se;
    }
    HmacSha256.prototype = new Sha256(), HmacSha256.prototype.finalize = function() {
      if (Sha256.prototype.finalize.call(this), this.inner) {
        this.inner = !1;
        var ae = this.array();
        Sha256.call(this, this.is224, this.sharedMemory), this.update(this.oKeyPad), this.update(ae), Sha256.prototype.finalize.call(this);
      }
    };
    var exports = createMethod();
    exports.sha256 = exports, exports.sha224 = createMethod(!0), exports.sha256.hmac = createHmacMethod(), exports.sha224.hmac = createHmacMethod(!0), COMMON_JS ? module.exports = exports : (root.sha256 = exports.sha256, root.sha224 = exports.sha224);
  })();
})(sha256$1);
var sha256Exports = sha256$1.exports, __awaiter$5 = commonjsGlobal && commonjsGlobal.__awaiter || function(ae, ie, se, fe) {
  function ue(ce) {
    return ce instanceof se ? ce : new se(function(de) {
      de(ce);
    });
  }
  return new (se || (se = Promise))(function(ce, de) {
    function me(Se) {
      try {
        Ee(fe.next(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function we(Se) {
      try {
        Ee(fe.throw(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function Ee(Se) {
      Se.done ? ce(Se.value) : ue(Se.value).then(me, we);
    }
    Ee((fe = fe.apply(ae, ie || [])).next());
  });
}, __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(ae) {
  return ae && ae.__esModule ? ae : { default: ae };
};
Object.defineProperty(sign$1, "__esModule", { value: !0 });
sign$1.signDelegateAction = sign$1.signTransaction = void 0;
const js_sha256_1 = __importDefault(sha256Exports), actions_1 = actions, create_transaction_1 = create_transaction, schema_1 = schema, signature_1 = signature$1;
function signTransactionObject(ae, ie, se, fe) {
  return __awaiter$5(this, void 0, void 0, function* () {
    const ue = (0, schema_1.encodeTransaction)(ae), ce = new Uint8Array(js_sha256_1.default.sha256.array(ue)), de = yield ie.signMessage(ue, se, fe), me = new schema_1.SignedTransaction({
      transaction: ae,
      signature: new signature_1.Signature({ keyType: ae.publicKey.keyType, data: de.signature })
    });
    return [ce, me];
  });
}
function signTransaction(...ae) {
  return __awaiter$5(this, void 0, void 0, function* () {
    if (ae[0].constructor === schema_1.Transaction) {
      const [ie, se, fe, ue] = ae;
      return signTransactionObject(ie, se, fe, ue);
    } else {
      const [ie, se, fe, ue, ce, de, me] = ae, we = yield ce.getPublicKey(de, me), Ee = (0, create_transaction_1.createTransaction)(de, we, ie, se, fe, ue);
      return signTransactionObject(Ee, ce, de, me);
    }
  });
}
sign$1.signTransaction = signTransaction;
function signDelegateAction({ delegateAction: ae, signer: ie }) {
  return __awaiter$5(this, void 0, void 0, function* () {
    const se = (0, schema_1.encodeDelegateAction)(ae), fe = yield ie.sign(se), ue = new actions_1.SignedDelegate({
      delegateAction: ae,
      signature: new signature_1.Signature({
        keyType: ae.publicKey.keyType,
        data: fe
      })
    });
    return {
      hash: new Uint8Array(js_sha256_1.default.sha256.array(se)),
      signedDelegateAction: ue
    };
  });
}
sign$1.signDelegateAction = signDelegateAction;
(function(ae) {
  var ie = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(fe, ue, ce, de) {
    de === void 0 && (de = ce);
    var me = Object.getOwnPropertyDescriptor(ue, ce);
    (!me || ("get" in me ? !ue.__esModule : me.writable || me.configurable)) && (me = { enumerable: !0, get: function() {
      return ue[ce];
    } }), Object.defineProperty(fe, de, me);
  } : function(fe, ue, ce, de) {
    de === void 0 && (de = ce), fe[de] = ue[ce];
  }), se = commonjsGlobal && commonjsGlobal.__exportStar || function(fe, ue) {
    for (var ce in fe)
      ce !== "default" && !Object.prototype.hasOwnProperty.call(ue, ce) && ie(ue, fe, ce);
  };
  Object.defineProperty(ae, "__esModule", { value: !0 }), se(action_creators, ae), se(actions, ae), se(create_transaction, ae), se(delegate, ae), se(schema, ae), se(sign$1, ae), se(signature$1, ae);
})(lib$2);
function base$1(ae) {
  if (ae.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var ie = new Uint8Array(256), se = 0; se < ie.length; se++)
    ie[se] = 255;
  for (var fe = 0; fe < ae.length; fe++) {
    var ue = ae.charAt(fe), ce = ue.charCodeAt(0);
    if (ie[ce] !== 255)
      throw new TypeError(ue + " is ambiguous");
    ie[ce] = fe;
  }
  var de = ae.length, me = ae.charAt(0), we = Math.log(de) / Math.log(256), Ee = Math.log(256) / Math.log(de);
  function Se(Ie) {
    if (Ie instanceof Uint8Array || (ArrayBuffer.isView(Ie) ? Ie = new Uint8Array(Ie.buffer, Ie.byteOffset, Ie.byteLength) : Array.isArray(Ie) && (Ie = Uint8Array.from(Ie))), !(Ie instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (Ie.length === 0)
      return "";
    for (var Pe = 0, Ne = 0, ke = 0, He = Ie.length; ke !== He && Ie[ke] === 0; )
      ke++, Pe++;
    for (var De = (He - ke) * Ee + 1 >>> 0, Ge = new Uint8Array(De); ke !== He; ) {
      for (var Ye = Ie[ke], st = 0, at = De - 1; (Ye !== 0 || st < Ne) && at !== -1; at--, st++)
        Ye += 256 * Ge[at] >>> 0, Ge[at] = Ye % de >>> 0, Ye = Ye / de >>> 0;
      if (Ye !== 0)
        throw new Error("Non-zero carry");
      Ne = st, ke++;
    }
    for (var mt = De - Ne; mt !== De && Ge[mt] === 0; )
      mt++;
    for (var qe = me.repeat(Pe); mt < De; ++mt)
      qe += ae.charAt(Ge[mt]);
    return qe;
  }
  function Be(Ie) {
    if (typeof Ie != "string")
      throw new TypeError("Expected String");
    if (Ie.length === 0)
      return new Uint8Array();
    for (var Pe = 0, Ne = 0, ke = 0; Ie[Pe] === me; )
      Ne++, Pe++;
    for (var He = (Ie.length - Pe) * we + 1 >>> 0, De = new Uint8Array(He); Ie[Pe]; ) {
      var Ge = ie[Ie.charCodeAt(Pe)];
      if (Ge === 255)
        return;
      for (var Ye = 0, st = He - 1; (Ge !== 0 || Ye < ke) && st !== -1; st--, Ye++)
        Ge += de * De[st] >>> 0, De[st] = Ge % 256 >>> 0, Ge = Ge / 256 >>> 0;
      if (Ge !== 0)
        throw new Error("Non-zero carry");
      ke = Ye, Pe++;
    }
    for (var at = He - ke; at !== He && De[at] === 0; )
      at++;
    for (var mt = new Uint8Array(Ne + (He - at)), qe = Ne; at !== He; )
      mt[qe++] = De[at++];
    return mt;
  }
  function Ce(Ie) {
    var Pe = Be(Ie);
    if (Pe)
      return Pe;
    throw new Error("Non-base" + de + " character");
  }
  return {
    encode: Se,
    decodeUnsafe: Be,
    decode: Ce
  };
}
var src$1 = base$1;
const basex$1 = src$1, ALPHABET$2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58$2 = basex$1(ALPHABET$2);
const bs58$3 = /* @__PURE__ */ getDefaultExportFromCjs$2(bs58$2);
class NearConfig extends BaseWebToken {
  // protected keyStore: KeyPair
  keyPair;
  near;
  constructor(ie) {
    super(ie), this.near = this.wallet._near, this.base = ["yoctoNEAR", 1e25];
  }
  async ready() {
    if (!this.wallet.isSignedIn())
      throw new Error("Wallet has not been signed in!");
    const ie = new lib$4.BrowserLocalStorageKeyStore(), se = this.wallet.account();
    if (this.keyPair = await ie.getKey(this.wallet._networkId, se.accountId), !this.keyPair) {
      this.keyPair = lib$7.KeyPair.fromRandom("ed25519");
      const fe = this.keyPair.getPublicKey().toString();
      await ie.setKey(this.wallet._networkId, se.accountId, this.keyPair), await se.addKey(fe);
    }
    this._address = await this.wallet.getAccountId(), this.providerInstance = this.wallet._near.connection.provider;
  }
  /**
   * NEAR wants both the sender ID and tx Hash, so we have to concatenate to keep with the interface.
   * @param txId assumes format senderID:txHash
   */
  async getTx(ie) {
    const se = await this.providerInstance, [fe, ue] = ie.split(":"), ce = await se.txStatusReceipts(bs58$3.decode(ue), fe), de = await se.block(ce.transaction_outcome.block_hash), me = (await se.block({ finality: "final" })).header.height;
    if (ce.receipts_outcome[0].outcome.status.SuccessValue !== "")
      throw new Error("Transaction failed!");
    const we = ce.receipts[0].receipt.Action.actions[0].Transfer.deposit ?? 0;
    return {
      from: fe,
      to: ce.transaction.receiver_id,
      amount: new BigNumber$1(we),
      blockHeight: new BigNumber$1(de.header.height),
      pending: !1,
      confirmed: me - de.header.height >= this.minConfirm
    };
  }
  /**
   * address = accountID
   * @param owner // assumed to be the "ed25519:" header + b58 encoded key
   */
  ownerToAddress(ie) {
    const se = typeof ie == "string" ? ie : bs58$3.encode(ie);
    return Buffer$F.from(bs58$3.decode(se.replace("ed25519:", ""))).toString("hex");
  }
  async sign(ie) {
    return this.getSigner().sign(ie);
  }
  getSigner() {
    return new NearSigner(this.keyPair.secretKey);
  }
  async verify(ie, se, fe) {
    return NearSigner.verify(ie, se, fe);
  }
  async getCurrentHeight() {
    const ie = await this.providerInstance.status();
    return new BigNumber$1(ie.sync_info.latest_block_height);
  }
  async getFee(ie, se) {
    const fe = (await this.providerInstance.block({ finality: "final" })).header.height, ue = await this.providerInstance.gasPrice(fe);
    return new BigNumber$1(ue.gas_price).multipliedBy(45e10);
  }
  async sendTx(ie) {
    const se = await this.providerInstance.sendTransaction(ie);
    return `${this.address}:${se.transaction.hash}`;
  }
  async createTx(ie, se, fe) {
    if (!this.address)
      throw new Error("Address is undefined - you might be missing a wallet, or have not run Irys.ready()");
    const ue = await this.providerInstance.query({
      request_type: "view_access_key",
      finality: "final",
      account_id: this.address,
      public_key: this.keyPair.getPublicKey().toString()
    }), ce = ++ue.nonce, de = Buffer$F.from(bs58$3.decode(ue.block_hash)), me = [lib$2.actionCreators.transfer(new BN$d(new BigNumber$1(ie).toString()))], we = lib$2.createTransaction(this.address, this.keyPair.getPublicKey(), se, ce, me, de), Ee = serialize_1(lib$2.SCHEMA, we), Se = new Uint8Array(sha256Exports.sha256.array(Ee)), Be = this.keyPair.sign(Se);
    return { tx: new lib$2.SignedTransaction({
      transaction: we,
      signature: new lib$2.Signature({
        keyType: we.publicKey.keyType,
        data: Be.signature
      })
    }), txId: void 0 };
  }
  async getPublicKey() {
    return Buffer$F.from(this.keyPair.getPublicKey().data);
  }
}
function number$1(ae) {
  if (!Number.isSafeInteger(ae) || ae < 0)
    throw new Error(`Wrong positive integer: ${ae}`);
}
function isBytes$3(ae) {
  return ae instanceof Uint8Array || ae != null && typeof ae == "object" && ae.constructor.name === "Uint8Array";
}
function bytes(ae, ...ie) {
  if (!isBytes$3(ae))
    throw new Error("Expected Uint8Array");
  if (ie.length > 0 && !ie.includes(ae.length))
    throw new Error(`Expected Uint8Array of length ${ie}, not of length=${ae.length}`);
}
function hash(ae) {
  if (typeof ae != "function" || typeof ae.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$1(ae.outputLen), number$1(ae.blockLen);
}
function exists(ae, ie = !0) {
  if (ae.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (ie && ae.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(ae, ie) {
  bytes(ae);
  const se = ie.outputLen;
  if (ae.length < se)
    throw new Error(`digestInto() expects output buffer of length at least ${se}`);
}
const crypto$1 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u32$1 = (ae) => new Uint32Array(ae.buffer, ae.byteOffset, Math.floor(ae.byteLength / 4));
function isBytes$2(ae) {
  return ae instanceof Uint8Array || ae != null && typeof ae == "object" && ae.constructor.name === "Uint8Array";
}
const createView = (ae) => new DataView(ae.buffer, ae.byteOffset, ae.byteLength), rotr = (ae, ie) => ae << 32 - ie | ae >>> ie, isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
const hexes$1 = /* @__PURE__ */ Array.from({ length: 256 }, (ae, ie) => ie.toString(16).padStart(2, "0"));
function bytesToHex$1(ae) {
  if (!isBytes$2(ae))
    throw new Error("Uint8Array expected");
  let ie = "";
  for (let se = 0; se < ae.length; se++)
    ie += hexes$1[ae[se]];
  return ie;
}
const asciis$1 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16$1(ae) {
  if (ae >= asciis$1._0 && ae <= asciis$1._9)
    return ae - asciis$1._0;
  if (ae >= asciis$1._A && ae <= asciis$1._F)
    return ae - (asciis$1._A - 10);
  if (ae >= asciis$1._a && ae <= asciis$1._f)
    return ae - (asciis$1._a - 10);
}
function hexToBytes$1(ae) {
  if (typeof ae != "string")
    throw new Error("hex string expected, got " + typeof ae);
  const ie = ae.length, se = ie / 2;
  if (ie % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + ie);
  const fe = new Uint8Array(se);
  for (let ue = 0, ce = 0; ue < se; ue++, ce += 2) {
    const de = asciiToBase16$1(ae.charCodeAt(ce)), me = asciiToBase16$1(ae.charCodeAt(ce + 1));
    if (de === void 0 || me === void 0) {
      const we = ae[ce] + ae[ce + 1];
      throw new Error('hex string expected, got non-hex character "' + we + '" at index ' + ce);
    }
    fe[ue] = de * 16 + me;
  }
  return fe;
}
function utf8ToBytes$1(ae) {
  if (typeof ae != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof ae}`);
  return new Uint8Array(new TextEncoder().encode(ae));
}
function toBytes(ae) {
  if (typeof ae == "string" && (ae = utf8ToBytes$1(ae)), !isBytes$2(ae))
    throw new Error(`expected Uint8Array, got ${typeof ae}`);
  return ae;
}
function concatBytes$1(...ae) {
  let ie = 0;
  for (let fe = 0; fe < ae.length; fe++) {
    const ue = ae[fe];
    if (!isBytes$2(ue))
      throw new Error("Uint8Array expected");
    ie += ue.length;
  }
  const se = new Uint8Array(ie);
  for (let fe = 0, ue = 0; fe < ae.length; fe++) {
    const ce = ae[fe];
    se.set(ce, ue), ue += ce.length;
  }
  return se;
}
class Hash {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
const toStr = {}.toString;
function checkOpts(ae, ie) {
  if (ie !== void 0 && toStr.call(ie) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  return Object.assign(ae, ie);
}
function wrapConstructor(ae) {
  const ie = (fe) => ae().update(toBytes(fe)).digest(), se = ae();
  return ie.outputLen = se.outputLen, ie.blockLen = se.blockLen, ie.create = () => ae(), ie;
}
function randomBytes(ae = 32) {
  if (crypto$1 && typeof crypto$1.getRandomValues == "function")
    return crypto$1.getRandomValues(new Uint8Array(ae));
  throw new Error("crypto.getRandomValues must be defined");
}
function setBigUint64(ae, ie, se, fe) {
  if (typeof ae.setBigUint64 == "function")
    return ae.setBigUint64(ie, se, fe);
  const ue = BigInt(32), ce = BigInt(4294967295), de = Number(se >> ue & ce), me = Number(se & ce), we = fe ? 4 : 0, Ee = fe ? 0 : 4;
  ae.setUint32(ie + we, de, fe), ae.setUint32(ie + Ee, me, fe);
}
class SHA2 extends Hash {
  constructor(ie, se, fe, ue) {
    super(), this.blockLen = ie, this.outputLen = se, this.padOffset = fe, this.isLE = ue, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(ie), this.view = createView(this.buffer);
  }
  update(ie) {
    exists(this);
    const { view: se, buffer: fe, blockLen: ue } = this;
    ie = toBytes(ie);
    const ce = ie.length;
    for (let de = 0; de < ce; ) {
      const me = Math.min(ue - this.pos, ce - de);
      if (me === ue) {
        const we = createView(ie);
        for (; ue <= ce - de; de += ue)
          this.process(we, de);
        continue;
      }
      fe.set(ie.subarray(de, de + me), this.pos), this.pos += me, de += me, this.pos === ue && (this.process(se, 0), this.pos = 0);
    }
    return this.length += ie.length, this.roundClean(), this;
  }
  digestInto(ie) {
    exists(this), output(ie, this), this.finished = !0;
    const { buffer: se, view: fe, blockLen: ue, isLE: ce } = this;
    let { pos: de } = this;
    se[de++] = 128, this.buffer.subarray(de).fill(0), this.padOffset > ue - de && (this.process(fe, 0), de = 0);
    for (let Be = de; Be < ue; Be++)
      se[Be] = 0;
    setBigUint64(fe, ue - 8, BigInt(this.length * 8), ce), this.process(fe, 0);
    const me = createView(ie), we = this.outputLen;
    if (we % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const Ee = we / 4, Se = this.get();
    if (Ee > Se.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let Be = 0; Be < Ee; Be++)
      me.setUint32(4 * Be, Se[Be], ce);
  }
  digest() {
    const { buffer: ie, outputLen: se } = this;
    this.digestInto(ie);
    const fe = ie.slice(0, se);
    return this.destroy(), fe;
  }
  _cloneInto(ie) {
    ie || (ie = new this.constructor()), ie.set(...this.get());
    const { blockLen: se, buffer: fe, length: ue, finished: ce, destroyed: de, pos: me } = this;
    return ie.length = ue, ie.pos = me, ie.finished = ce, ie.destroyed = de, ue % se && ie.buffer.set(fe), ie;
  }
}
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1), _32n = /* @__PURE__ */ BigInt(32);
function fromBig(ae, ie = !1) {
  return ie ? { h: Number(ae & U32_MASK64), l: Number(ae >> _32n & U32_MASK64) } : { h: Number(ae >> _32n & U32_MASK64) | 0, l: Number(ae & U32_MASK64) | 0 };
}
function split(ae, ie = !1) {
  let se = new Uint32Array(ae.length), fe = new Uint32Array(ae.length);
  for (let ue = 0; ue < ae.length; ue++) {
    const { h: ce, l: de } = fromBig(ae[ue], ie);
    [se[ue], fe[ue]] = [ce, de];
  }
  return [se, fe];
}
const toBig = (ae, ie) => BigInt(ae >>> 0) << _32n | BigInt(ie >>> 0), shrSH = (ae, ie, se) => ae >>> se, shrSL = (ae, ie, se) => ae << 32 - se | ie >>> se, rotrSH = (ae, ie, se) => ae >>> se | ie << 32 - se, rotrSL = (ae, ie, se) => ae << 32 - se | ie >>> se, rotrBH = (ae, ie, se) => ae << 64 - se | ie >>> se - 32, rotrBL = (ae, ie, se) => ae >>> se - 32 | ie << 64 - se, rotr32H = (ae, ie) => ie, rotr32L = (ae, ie) => ae, rotlSH = (ae, ie, se) => ae << se | ie >>> 32 - se, rotlSL = (ae, ie, se) => ie << se | ae >>> 32 - se, rotlBH = (ae, ie, se) => ie << se - 32 | ae >>> 64 - se, rotlBL = (ae, ie, se) => ae << se - 32 | ie >>> 64 - se;
function add(ae, ie, se, fe) {
  const ue = (ie >>> 0) + (fe >>> 0);
  return { h: ae + se + (ue / 2 ** 32 | 0) | 0, l: ue | 0 };
}
const add3L = (ae, ie, se) => (ae >>> 0) + (ie >>> 0) + (se >>> 0), add3H = (ae, ie, se, fe) => ie + se + fe + (ae / 2 ** 32 | 0) | 0, add4L = (ae, ie, se, fe) => (ae >>> 0) + (ie >>> 0) + (se >>> 0) + (fe >>> 0), add4H = (ae, ie, se, fe, ue) => ie + se + fe + ue + (ae / 2 ** 32 | 0) | 0, add5L = (ae, ie, se, fe, ue) => (ae >>> 0) + (ie >>> 0) + (se >>> 0) + (fe >>> 0) + (ue >>> 0), add5H = (ae, ie, se, fe, ue, ce) => ie + se + fe + ue + ce + (ae / 2 ** 32 | 0) | 0, u64$1 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
}, [SHA512_Kh, SHA512_Kl] = u64$1.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((ae) => BigInt(ae))), SHA512_W_H = /* @__PURE__ */ new Uint32Array(80), SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends SHA2 {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: ie, Al: se, Bh: fe, Bl: ue, Ch: ce, Cl: de, Dh: me, Dl: we, Eh: Ee, El: Se, Fh: Be, Fl: Ce, Gh: Ie, Gl: Pe, Hh: Ne, Hl: ke } = this;
    return [ie, se, fe, ue, ce, de, me, we, Ee, Se, Be, Ce, Ie, Pe, Ne, ke];
  }
  // prettier-ignore
  set(ie, se, fe, ue, ce, de, me, we, Ee, Se, Be, Ce, Ie, Pe, Ne, ke) {
    this.Ah = ie | 0, this.Al = se | 0, this.Bh = fe | 0, this.Bl = ue | 0, this.Ch = ce | 0, this.Cl = de | 0, this.Dh = me | 0, this.Dl = we | 0, this.Eh = Ee | 0, this.El = Se | 0, this.Fh = Be | 0, this.Fl = Ce | 0, this.Gh = Ie | 0, this.Gl = Pe | 0, this.Hh = Ne | 0, this.Hl = ke | 0;
  }
  process(ie, se) {
    for (let Ge = 0; Ge < 16; Ge++, se += 4)
      SHA512_W_H[Ge] = ie.getUint32(se), SHA512_W_L[Ge] = ie.getUint32(se += 4);
    for (let Ge = 16; Ge < 80; Ge++) {
      const Ye = SHA512_W_H[Ge - 15] | 0, st = SHA512_W_L[Ge - 15] | 0, at = u64$1.rotrSH(Ye, st, 1) ^ u64$1.rotrSH(Ye, st, 8) ^ u64$1.shrSH(Ye, st, 7), mt = u64$1.rotrSL(Ye, st, 1) ^ u64$1.rotrSL(Ye, st, 8) ^ u64$1.shrSL(Ye, st, 7), qe = SHA512_W_H[Ge - 2] | 0, ze = SHA512_W_L[Ge - 2] | 0, ot = u64$1.rotrSH(qe, ze, 19) ^ u64$1.rotrBH(qe, ze, 61) ^ u64$1.shrSH(qe, ze, 6), $e = u64$1.rotrSL(qe, ze, 19) ^ u64$1.rotrBL(qe, ze, 61) ^ u64$1.shrSL(qe, ze, 6), le = u64$1.add4L(mt, $e, SHA512_W_L[Ge - 7], SHA512_W_L[Ge - 16]), pe = u64$1.add4H(le, at, ot, SHA512_W_H[Ge - 7], SHA512_W_H[Ge - 16]);
      SHA512_W_H[Ge] = pe | 0, SHA512_W_L[Ge] = le | 0;
    }
    let { Ah: fe, Al: ue, Bh: ce, Bl: de, Ch: me, Cl: we, Dh: Ee, Dl: Se, Eh: Be, El: Ce, Fh: Ie, Fl: Pe, Gh: Ne, Gl: ke, Hh: He, Hl: De } = this;
    for (let Ge = 0; Ge < 80; Ge++) {
      const Ye = u64$1.rotrSH(Be, Ce, 14) ^ u64$1.rotrSH(Be, Ce, 18) ^ u64$1.rotrBH(Be, Ce, 41), st = u64$1.rotrSL(Be, Ce, 14) ^ u64$1.rotrSL(Be, Ce, 18) ^ u64$1.rotrBL(Be, Ce, 41), at = Be & Ie ^ ~Be & Ne, mt = Ce & Pe ^ ~Ce & ke, qe = u64$1.add5L(De, st, mt, SHA512_Kl[Ge], SHA512_W_L[Ge]), ze = u64$1.add5H(qe, He, Ye, at, SHA512_Kh[Ge], SHA512_W_H[Ge]), ot = qe | 0, $e = u64$1.rotrSH(fe, ue, 28) ^ u64$1.rotrBH(fe, ue, 34) ^ u64$1.rotrBH(fe, ue, 39), le = u64$1.rotrSL(fe, ue, 28) ^ u64$1.rotrBL(fe, ue, 34) ^ u64$1.rotrBL(fe, ue, 39), pe = fe & ce ^ fe & me ^ ce & me, ge = ue & de ^ ue & we ^ de & we;
      He = Ne | 0, De = ke | 0, Ne = Ie | 0, ke = Pe | 0, Ie = Be | 0, Pe = Ce | 0, { h: Be, l: Ce } = u64$1.add(Ee | 0, Se | 0, ze | 0, ot | 0), Ee = me | 0, Se = we | 0, me = ce | 0, we = de | 0, ce = fe | 0, de = ue | 0;
      const ye = u64$1.add3L(ot, le, ge);
      fe = u64$1.add3H(ye, ze, $e, pe), ue = ye | 0;
    }
    ({ h: fe, l: ue } = u64$1.add(this.Ah | 0, this.Al | 0, fe | 0, ue | 0)), { h: ce, l: de } = u64$1.add(this.Bh | 0, this.Bl | 0, ce | 0, de | 0), { h: me, l: we } = u64$1.add(this.Ch | 0, this.Cl | 0, me | 0, we | 0), { h: Ee, l: Se } = u64$1.add(this.Dh | 0, this.Dl | 0, Ee | 0, Se | 0), { h: Be, l: Ce } = u64$1.add(this.Eh | 0, this.El | 0, Be | 0, Ce | 0), { h: Ie, l: Pe } = u64$1.add(this.Fh | 0, this.Fl | 0, Ie | 0, Pe | 0), { h: Ne, l: ke } = u64$1.add(this.Gh | 0, this.Gl | 0, Ne | 0, ke | 0), { h: He, l: De } = u64$1.add(this.Hh | 0, this.Hl | 0, He | 0, De | 0), this.set(fe, ue, ce, de, me, we, Ee, Se, Be, Ce, Ie, Pe, Ne, ke, He, De);
  }
  roundClean() {
    SHA512_W_H.fill(0), SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const sha512 = /* @__PURE__ */ wrapConstructor(() => new SHA512());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$5 = BigInt(0), _1n$7 = BigInt(1), _2n$5 = BigInt(2);
function isBytes$1(ae) {
  return ae instanceof Uint8Array || ae != null && typeof ae == "object" && ae.constructor.name === "Uint8Array";
}
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (ae, ie) => ie.toString(16).padStart(2, "0"));
function bytesToHex(ae) {
  if (!isBytes$1(ae))
    throw new Error("Uint8Array expected");
  let ie = "";
  for (let se = 0; se < ae.length; se++)
    ie += hexes[ae[se]];
  return ie;
}
function numberToHexUnpadded(ae) {
  const ie = ae.toString(16);
  return ie.length & 1 ? `0${ie}` : ie;
}
function hexToNumber(ae) {
  if (typeof ae != "string")
    throw new Error("hex string expected, got " + typeof ae);
  return BigInt(ae === "" ? "0" : `0x${ae}`);
}
const asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(ae) {
  if (ae >= asciis._0 && ae <= asciis._9)
    return ae - asciis._0;
  if (ae >= asciis._A && ae <= asciis._F)
    return ae - (asciis._A - 10);
  if (ae >= asciis._a && ae <= asciis._f)
    return ae - (asciis._a - 10);
}
function hexToBytes(ae) {
  if (typeof ae != "string")
    throw new Error("hex string expected, got " + typeof ae);
  const ie = ae.length, se = ie / 2;
  if (ie % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + ie);
  const fe = new Uint8Array(se);
  for (let ue = 0, ce = 0; ue < se; ue++, ce += 2) {
    const de = asciiToBase16(ae.charCodeAt(ce)), me = asciiToBase16(ae.charCodeAt(ce + 1));
    if (de === void 0 || me === void 0) {
      const we = ae[ce] + ae[ce + 1];
      throw new Error('hex string expected, got non-hex character "' + we + '" at index ' + ce);
    }
    fe[ue] = de * 16 + me;
  }
  return fe;
}
function bytesToNumberBE(ae) {
  return hexToNumber(bytesToHex(ae));
}
function bytesToNumberLE(ae) {
  if (!isBytes$1(ae))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex(Uint8Array.from(ae).reverse()));
}
function numberToBytesBE(ae, ie) {
  return hexToBytes(ae.toString(16).padStart(ie * 2, "0"));
}
function numberToBytesLE(ae, ie) {
  return numberToBytesBE(ae, ie).reverse();
}
function numberToVarBytesBE(ae) {
  return hexToBytes(numberToHexUnpadded(ae));
}
function ensureBytes(ae, ie, se) {
  let fe;
  if (typeof ie == "string")
    try {
      fe = hexToBytes(ie);
    } catch (ce) {
      throw new Error(`${ae} must be valid hex string, got "${ie}". Cause: ${ce}`);
    }
  else if (isBytes$1(ie))
    fe = Uint8Array.from(ie);
  else
    throw new Error(`${ae} must be hex string or Uint8Array`);
  const ue = fe.length;
  if (typeof se == "number" && ue !== se)
    throw new Error(`${ae} expected ${se} bytes, got ${ue}`);
  return fe;
}
function concatBytes(...ae) {
  let ie = 0;
  for (let ue = 0; ue < ae.length; ue++) {
    const ce = ae[ue];
    if (!isBytes$1(ce))
      throw new Error("Uint8Array expected");
    ie += ce.length;
  }
  let se = new Uint8Array(ie), fe = 0;
  for (let ue = 0; ue < ae.length; ue++) {
    const ce = ae[ue];
    se.set(ce, fe), fe += ce.length;
  }
  return se;
}
function equalBytes(ae, ie) {
  if (ae.length !== ie.length)
    return !1;
  let se = 0;
  for (let fe = 0; fe < ae.length; fe++)
    se |= ae[fe] ^ ie[fe];
  return se === 0;
}
function utf8ToBytes(ae) {
  if (typeof ae != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof ae}`);
  return new Uint8Array(new TextEncoder().encode(ae));
}
function bitLen(ae) {
  let ie;
  for (ie = 0; ae > _0n$5; ae >>= _1n$7, ie += 1)
    ;
  return ie;
}
function bitGet(ae, ie) {
  return ae >> BigInt(ie) & _1n$7;
}
const bitSet = (ae, ie, se) => ae | (se ? _1n$7 : _0n$5) << BigInt(ie), bitMask = (ae) => (_2n$5 << BigInt(ae - 1)) - _1n$7, u8n = (ae) => new Uint8Array(ae), u8fr = (ae) => Uint8Array.from(ae);
function createHmacDrbg(ae, ie, se) {
  if (typeof ae != "number" || ae < 2)
    throw new Error("hashLen must be a number");
  if (typeof ie != "number" || ie < 2)
    throw new Error("qByteLen must be a number");
  if (typeof se != "function")
    throw new Error("hmacFn must be a function");
  let fe = u8n(ae), ue = u8n(ae), ce = 0;
  const de = () => {
    fe.fill(1), ue.fill(0), ce = 0;
  }, me = (...Be) => se(ue, fe, ...Be), we = (Be = u8n()) => {
    ue = me(u8fr([0]), Be), fe = me(), Be.length !== 0 && (ue = me(u8fr([1]), Be), fe = me());
  }, Ee = () => {
    if (ce++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let Be = 0;
    const Ce = [];
    for (; Be < ie; ) {
      fe = me();
      const Ie = fe.slice();
      Ce.push(Ie), Be += fe.length;
    }
    return concatBytes(...Ce);
  };
  return (Be, Ce) => {
    de(), we(Be);
    let Ie;
    for (; !(Ie = Ce(Ee())); )
      we();
    return de(), Ie;
  };
}
const validatorFns = {
  bigint: (ae) => typeof ae == "bigint",
  function: (ae) => typeof ae == "function",
  boolean: (ae) => typeof ae == "boolean",
  string: (ae) => typeof ae == "string",
  stringOrUint8Array: (ae) => typeof ae == "string" || isBytes$1(ae),
  isSafeInteger: (ae) => Number.isSafeInteger(ae),
  array: (ae) => Array.isArray(ae),
  field: (ae, ie) => ie.Fp.isValid(ae),
  hash: (ae) => typeof ae == "function" && Number.isSafeInteger(ae.outputLen)
};
function validateObject(ae, ie, se = {}) {
  const fe = (ue, ce, de) => {
    const me = validatorFns[ce];
    if (typeof me != "function")
      throw new Error(`Invalid validator "${ce}", expected function`);
    const we = ae[ue];
    if (!(de && we === void 0) && !me(we, ae))
      throw new Error(`Invalid param ${String(ue)}=${we} (${typeof we}), expected ${ce}`);
  };
  for (const [ue, ce] of Object.entries(ie))
    fe(ue, ce, !1);
  for (const [ue, ce] of Object.entries(se))
    fe(ue, ce, !0);
  return ae;
}
const ut = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet,
  bitLen,
  bitMask,
  bitSet,
  bytesToHex,
  bytesToNumberBE,
  bytesToNumberLE,
  concatBytes,
  createHmacDrbg,
  ensureBytes,
  equalBytes,
  hexToBytes,
  hexToNumber,
  isBytes: isBytes$1,
  numberToBytesBE,
  numberToBytesLE,
  numberToHexUnpadded,
  numberToVarBytesBE,
  utf8ToBytes,
  validateObject
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$4 = BigInt(0), _1n$6 = BigInt(1), _2n$4 = BigInt(2), _3n$1 = BigInt(3), _4n = BigInt(4), _5n$1 = BigInt(5), _8n$1 = BigInt(8);
BigInt(9);
BigInt(16);
function mod(ae, ie) {
  const se = ae % ie;
  return se >= _0n$4 ? se : ie + se;
}
function pow(ae, ie, se) {
  if (se <= _0n$4 || ie < _0n$4)
    throw new Error("Expected power/modulo > 0");
  if (se === _1n$6)
    return _0n$4;
  let fe = _1n$6;
  for (; ie > _0n$4; )
    ie & _1n$6 && (fe = fe * ae % se), ae = ae * ae % se, ie >>= _1n$6;
  return fe;
}
function pow2(ae, ie, se) {
  let fe = ae;
  for (; ie-- > _0n$4; )
    fe *= fe, fe %= se;
  return fe;
}
function invert(ae, ie) {
  if (ae === _0n$4 || ie <= _0n$4)
    throw new Error(`invert: expected positive integers, got n=${ae} mod=${ie}`);
  let se = mod(ae, ie), fe = ie, ue = _0n$4, ce = _1n$6;
  for (; se !== _0n$4; ) {
    const me = fe / se, we = fe % se, Ee = ue - ce * me;
    fe = se, se = we, ue = ce, ce = Ee;
  }
  if (fe !== _1n$6)
    throw new Error("invert: does not exist");
  return mod(ue, ie);
}
function tonelliShanks(ae) {
  const ie = (ae - _1n$6) / _2n$4;
  let se, fe, ue;
  for (se = ae - _1n$6, fe = 0; se % _2n$4 === _0n$4; se /= _2n$4, fe++)
    ;
  for (ue = _2n$4; ue < ae && pow(ue, ie, ae) !== ae - _1n$6; ue++)
    ;
  if (fe === 1) {
    const de = (ae + _1n$6) / _4n;
    return function(we, Ee) {
      const Se = we.pow(Ee, de);
      if (!we.eql(we.sqr(Se), Ee))
        throw new Error("Cannot find square root");
      return Se;
    };
  }
  const ce = (se + _1n$6) / _2n$4;
  return function(me, we) {
    if (me.pow(we, ie) === me.neg(me.ONE))
      throw new Error("Cannot find square root");
    let Ee = fe, Se = me.pow(me.mul(me.ONE, ue), se), Be = me.pow(we, ce), Ce = me.pow(we, se);
    for (; !me.eql(Ce, me.ONE); ) {
      if (me.eql(Ce, me.ZERO))
        return me.ZERO;
      let Ie = 1;
      for (let Ne = me.sqr(Ce); Ie < Ee && !me.eql(Ne, me.ONE); Ie++)
        Ne = me.sqr(Ne);
      const Pe = me.pow(Se, _1n$6 << BigInt(Ee - Ie - 1));
      Se = me.sqr(Pe), Be = me.mul(Be, Pe), Ce = me.mul(Ce, Se), Ee = Ie;
    }
    return Be;
  };
}
function FpSqrt(ae) {
  if (ae % _4n === _3n$1) {
    const ie = (ae + _1n$6) / _4n;
    return function(fe, ue) {
      const ce = fe.pow(ue, ie);
      if (!fe.eql(fe.sqr(ce), ue))
        throw new Error("Cannot find square root");
      return ce;
    };
  }
  if (ae % _8n$1 === _5n$1) {
    const ie = (ae - _5n$1) / _8n$1;
    return function(fe, ue) {
      const ce = fe.mul(ue, _2n$4), de = fe.pow(ce, ie), me = fe.mul(ue, de), we = fe.mul(fe.mul(me, _2n$4), de), Ee = fe.mul(me, fe.sub(we, fe.ONE));
      if (!fe.eql(fe.sqr(Ee), ue))
        throw new Error("Cannot find square root");
      return Ee;
    };
  }
  return tonelliShanks(ae);
}
const isNegativeLE = (ae, ie) => (mod(ae, ie) & _1n$6) === _1n$6, FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(ae) {
  const ie = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, se = FIELD_FIELDS.reduce((fe, ue) => (fe[ue] = "function", fe), ie);
  return validateObject(ae, se);
}
function FpPow(ae, ie, se) {
  if (se < _0n$4)
    throw new Error("Expected power > 0");
  if (se === _0n$4)
    return ae.ONE;
  if (se === _1n$6)
    return ie;
  let fe = ae.ONE, ue = ie;
  for (; se > _0n$4; )
    se & _1n$6 && (fe = ae.mul(fe, ue)), ue = ae.sqr(ue), se >>= _1n$6;
  return fe;
}
function FpInvertBatch(ae, ie) {
  const se = new Array(ie.length), fe = ie.reduce((ce, de, me) => ae.is0(de) ? ce : (se[me] = ce, ae.mul(ce, de)), ae.ONE), ue = ae.inv(fe);
  return ie.reduceRight((ce, de, me) => ae.is0(de) ? ce : (se[me] = ae.mul(ce, se[me]), ae.mul(ce, de)), ue), se;
}
function nLength(ae, ie) {
  const se = ie !== void 0 ? ie : ae.toString(2).length, fe = Math.ceil(se / 8);
  return { nBitLength: se, nByteLength: fe };
}
function Field(ae, ie, se = !1, fe = {}) {
  if (ae <= _0n$4)
    throw new Error(`Expected Field ORDER > 0, got ${ae}`);
  const { nBitLength: ue, nByteLength: ce } = nLength(ae, ie);
  if (ce > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const de = FpSqrt(ae), me = Object.freeze({
    ORDER: ae,
    BITS: ue,
    BYTES: ce,
    MASK: bitMask(ue),
    ZERO: _0n$4,
    ONE: _1n$6,
    create: (we) => mod(we, ae),
    isValid: (we) => {
      if (typeof we != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof we}`);
      return _0n$4 <= we && we < ae;
    },
    is0: (we) => we === _0n$4,
    isOdd: (we) => (we & _1n$6) === _1n$6,
    neg: (we) => mod(-we, ae),
    eql: (we, Ee) => we === Ee,
    sqr: (we) => mod(we * we, ae),
    add: (we, Ee) => mod(we + Ee, ae),
    sub: (we, Ee) => mod(we - Ee, ae),
    mul: (we, Ee) => mod(we * Ee, ae),
    pow: (we, Ee) => FpPow(me, we, Ee),
    div: (we, Ee) => mod(we * invert(Ee, ae), ae),
    // Same as above, but doesn't normalize
    sqrN: (we) => we * we,
    addN: (we, Ee) => we + Ee,
    subN: (we, Ee) => we - Ee,
    mulN: (we, Ee) => we * Ee,
    inv: (we) => invert(we, ae),
    sqrt: fe.sqrt || ((we) => de(me, we)),
    invertBatch: (we) => FpInvertBatch(me, we),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (we, Ee, Se) => Se ? Ee : we,
    toBytes: (we) => se ? numberToBytesLE(we, ce) : numberToBytesBE(we, ce),
    fromBytes: (we) => {
      if (we.length !== ce)
        throw new Error(`Fp.fromBytes: expected ${ce}, got ${we.length}`);
      return se ? bytesToNumberLE(we) : bytesToNumberBE(we);
    }
  });
  return Object.freeze(me);
}
function FpSqrtEven(ae, ie) {
  if (!ae.isOdd)
    throw new Error("Field doesn't have isOdd");
  const se = ae.sqrt(ie);
  return ae.isOdd(se) ? ae.neg(se) : se;
}
function getFieldBytesLength(ae) {
  if (typeof ae != "bigint")
    throw new Error("field order must be bigint");
  const ie = ae.toString(2).length;
  return Math.ceil(ie / 8);
}
function getMinHashLength(ae) {
  const ie = getFieldBytesLength(ae);
  return ie + Math.ceil(ie / 2);
}
function mapHashToField(ae, ie, se = !1) {
  const fe = ae.length, ue = getFieldBytesLength(ie), ce = getMinHashLength(ie);
  if (fe < 16 || fe < ce || fe > 1024)
    throw new Error(`expected ${ce}-1024 bytes of input, got ${fe}`);
  const de = se ? bytesToNumberBE(ae) : bytesToNumberLE(ae), me = mod(de, ie - _1n$6) + _1n$6;
  return se ? numberToBytesLE(me, ue) : numberToBytesBE(me, ue);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$3 = BigInt(0), _1n$5 = BigInt(1);
function wNAF(ae, ie) {
  const se = (ue, ce) => {
    const de = ce.negate();
    return ue ? de : ce;
  }, fe = (ue) => {
    const ce = Math.ceil(ie / ue) + 1, de = 2 ** (ue - 1);
    return { windows: ce, windowSize: de };
  };
  return {
    constTimeNegate: se,
    // non-const time multiplication ladder
    unsafeLadder(ue, ce) {
      let de = ae.ZERO, me = ue;
      for (; ce > _0n$3; )
        ce & _1n$5 && (de = de.add(me)), me = me.double(), ce >>= _1n$5;
      return de;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(ue, ce) {
      const { windows: de, windowSize: me } = fe(ce), we = [];
      let Ee = ue, Se = Ee;
      for (let Be = 0; Be < de; Be++) {
        Se = Ee, we.push(Se);
        for (let Ce = 1; Ce < me; Ce++)
          Se = Se.add(Ee), we.push(Se);
        Ee = Se.double();
      }
      return we;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(ue, ce, de) {
      const { windows: me, windowSize: we } = fe(ue);
      let Ee = ae.ZERO, Se = ae.BASE;
      const Be = BigInt(2 ** ue - 1), Ce = 2 ** ue, Ie = BigInt(ue);
      for (let Pe = 0; Pe < me; Pe++) {
        const Ne = Pe * we;
        let ke = Number(de & Be);
        de >>= Ie, ke > we && (ke -= Ce, de += _1n$5);
        const He = Ne, De = Ne + Math.abs(ke) - 1, Ge = Pe % 2 !== 0, Ye = ke < 0;
        ke === 0 ? Se = Se.add(se(Ge, ce[He])) : Ee = Ee.add(se(Ye, ce[De]));
      }
      return { p: Ee, f: Se };
    },
    wNAFCached(ue, ce, de, me) {
      const we = ue._WINDOW_SIZE || 1;
      let Ee = ce.get(ue);
      return Ee || (Ee = this.precomputeWindow(ue, we), we !== 1 && ce.set(ue, me(Ee))), this.wNAF(we, Ee, de);
    }
  };
}
function validateBasic(ae) {
  return validateField(ae.Fp), validateObject(ae, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...nLength(ae.n, ae.nBitLength),
    ...ae,
    p: ae.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$2 = BigInt(0), _1n$4 = BigInt(1), _2n$3 = BigInt(2), _8n = BigInt(8), VERIFY_DEFAULT = { zip215: !0 };
function validateOpts$1(ae) {
  const ie = validateBasic(ae);
  return validateObject(ae, {
    hash: "function",
    a: "bigint",
    d: "bigint",
    randomBytes: "function"
  }, {
    adjustScalarBytes: "function",
    domain: "function",
    uvRatio: "function",
    mapToCurve: "function"
  }), Object.freeze({ ...ie });
}
function twistedEdwards(ae) {
  const ie = validateOpts$1(ae), { Fp: se, n: fe, prehash: ue, hash: ce, randomBytes: de, nByteLength: me, h: we } = ie, Ee = _2n$3 << BigInt(me * 8) - _1n$4, Se = se.create, Be = ie.uvRatio || ((Ae, ve) => {
    try {
      return { isValid: !0, value: se.sqrt(Ae * se.inv(ve)) };
    } catch {
      return { isValid: !1, value: _0n$2 };
    }
  }), Ce = ie.adjustScalarBytes || ((Ae) => Ae), Ie = ie.domain || ((Ae, ve, he) => {
    if (ve.length || he)
      throw new Error("Contexts/pre-hash are not supported");
    return Ae;
  }), Pe = (Ae) => typeof Ae == "bigint" && _0n$2 < Ae, Ne = (Ae, ve) => Pe(Ae) && Pe(ve) && Ae < ve, ke = (Ae) => Ae === _0n$2 || Ne(Ae, Ee);
  function He(Ae, ve) {
    if (Ne(Ae, ve))
      return Ae;
    throw new Error(`Expected valid scalar < ${ve}, got ${typeof Ae} ${Ae}`);
  }
  function De(Ae) {
    return Ae === _0n$2 ? Ae : He(Ae, fe);
  }
  const Ge = /* @__PURE__ */ new Map();
  function Ye(Ae) {
    if (!(Ae instanceof st))
      throw new Error("ExtendedPoint expected");
  }
  class st {
    constructor(ve, he, be, Me) {
      if (this.ex = ve, this.ey = he, this.ez = be, this.et = Me, !ke(ve))
        throw new Error("x required");
      if (!ke(he))
        throw new Error("y required");
      if (!ke(be))
        throw new Error("z required");
      if (!ke(Me))
        throw new Error("t required");
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(ve) {
      if (ve instanceof st)
        throw new Error("extended point not allowed");
      const { x: he, y: be } = ve || {};
      if (!ke(he) || !ke(be))
        throw new Error("invalid affine point");
      return new st(he, be, _1n$4, Se(he * be));
    }
    static normalizeZ(ve) {
      const he = se.invertBatch(ve.map((be) => be.ez));
      return ve.map((be, Me) => be.toAffine(he[Me])).map(st.fromAffine);
    }
    // "Private method", don't use it directly
    _setWindowSize(ve) {
      this._WINDOW_SIZE = ve, Ge.delete(this);
    }
    // Not required for fromHex(), which always creates valid points.
    // Could be useful for fromAffine().
    assertValidity() {
      const { a: ve, d: he } = ie;
      if (this.is0())
        throw new Error("bad point: ZERO");
      const { ex: be, ey: Me, ez: Re, et: Oe } = this, Te = Se(be * be), Fe = Se(Me * Me), je = Se(Re * Re), ct = Se(je * je), nt = Se(Te * ve), dt = Se(je * Se(nt + Fe)), it = Se(ct + Se(he * Se(Te * Fe)));
      if (dt !== it)
        throw new Error("bad point: equation left != right (1)");
      const Je = Se(be * Me), gt = Se(Re * Oe);
      if (Je !== gt)
        throw new Error("bad point: equation left != right (2)");
    }
    // Compare one point to another.
    equals(ve) {
      Ye(ve);
      const { ex: he, ey: be, ez: Me } = this, { ex: Re, ey: Oe, ez: Te } = ve, Fe = Se(he * Te), je = Se(Re * Me), ct = Se(be * Te), nt = Se(Oe * Me);
      return Fe === je && ct === nt;
    }
    is0() {
      return this.equals(st.ZERO);
    }
    negate() {
      return new st(Se(-this.ex), this.ey, this.ez, Se(-this.et));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a: ve } = ie, { ex: he, ey: be, ez: Me } = this, Re = Se(he * he), Oe = Se(be * be), Te = Se(_2n$3 * Se(Me * Me)), Fe = Se(ve * Re), je = he + be, ct = Se(Se(je * je) - Re - Oe), nt = Fe + Oe, dt = nt - Te, it = Fe - Oe, Je = Se(ct * dt), gt = Se(nt * it), Ht = Se(ct * it), $t = Se(dt * nt);
      return new st(Je, gt, $t, Ht);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(ve) {
      Ye(ve);
      const { a: he, d: be } = ie, { ex: Me, ey: Re, ez: Oe, et: Te } = this, { ex: Fe, ey: je, ez: ct, et: nt } = ve;
      if (he === BigInt(-1)) {
        const cr = Se((Re - Me) * (je + Fe)), qr = Se((Re + Me) * (je - Fe)), Wt = Se(qr - cr);
        if (Wt === _0n$2)
          return this.double();
        const ar = Se(Oe * _2n$3 * nt), Dr = Se(Te * _2n$3 * ct), Jt = Dr + ar, ir = qr + cr, Gr = Dr - ar, We = Se(Jt * Wt), Le = Se(ir * Gr), Ke = Se(Jt * Gr), rt = Se(Wt * ir);
        return new st(We, Le, rt, Ke);
      }
      const dt = Se(Me * Fe), it = Se(Re * je), Je = Se(Te * be * nt), gt = Se(Oe * ct), Ht = Se((Me + Re) * (Fe + je) - dt - it), $t = gt - Je, Lt = gt + Je, Tr = Se(it - he * dt), Zt = Se(Ht * $t), wt = Se(Lt * Tr), Hr = Se(Ht * Tr), tr = Se($t * Lt);
      return new st(Zt, wt, tr, Hr);
    }
    subtract(ve) {
      return this.add(ve.negate());
    }
    wNAF(ve) {
      return qe.wNAFCached(this, Ge, ve, st.normalizeZ);
    }
    // Constant-time multiplication.
    multiply(ve) {
      const { p: he, f: be } = this.wNAF(He(ve, fe));
      return st.normalizeZ([he, be])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    multiplyUnsafe(ve) {
      let he = De(ve);
      return he === _0n$2 ? mt : this.equals(mt) || he === _1n$4 ? this : this.equals(at) ? this.wNAF(he).p : qe.unsafeLadder(this, he);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(we).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return qe.unsafeLadder(this, fe).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(ve) {
      const { ex: he, ey: be, ez: Me } = this, Re = this.is0();
      ve == null && (ve = Re ? _8n : se.inv(Me));
      const Oe = Se(he * ve), Te = Se(be * ve), Fe = Se(Me * ve);
      if (Re)
        return { x: _0n$2, y: _1n$4 };
      if (Fe !== _1n$4)
        throw new Error("invZ was invalid");
      return { x: Oe, y: Te };
    }
    clearCofactor() {
      const { h: ve } = ie;
      return ve === _1n$4 ? this : this.multiplyUnsafe(ve);
    }
    // Converts hash string or Uint8Array to Point.
    // Uses algo from RFC8032 5.1.3.
    static fromHex(ve, he = !1) {
      const { d: be, a: Me } = ie, Re = se.BYTES;
      ve = ensureBytes("pointHex", ve, Re);
      const Oe = ve.slice(), Te = ve[Re - 1];
      Oe[Re - 1] = Te & -129;
      const Fe = bytesToNumberLE(Oe);
      Fe === _0n$2 || (he ? He(Fe, Ee) : He(Fe, se.ORDER));
      const je = Se(Fe * Fe), ct = Se(je - _1n$4), nt = Se(be * je - Me);
      let { isValid: dt, value: it } = Be(ct, nt);
      if (!dt)
        throw new Error("Point.fromHex: invalid y coordinate");
      const Je = (it & _1n$4) === _1n$4, gt = (Te & 128) !== 0;
      if (!he && it === _0n$2 && gt)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      return gt !== Je && (it = Se(-it)), st.fromAffine({ x: it, y: Fe });
    }
    static fromPrivateKey(ve) {
      return $e(ve).point;
    }
    toRawBytes() {
      const { x: ve, y: he } = this.toAffine(), be = numberToBytesLE(he, se.BYTES);
      return be[be.length - 1] |= ve & _1n$4 ? 128 : 0, be;
    }
    toHex() {
      return bytesToHex(this.toRawBytes());
    }
  }
  st.BASE = new st(ie.Gx, ie.Gy, _1n$4, Se(ie.Gx * ie.Gy)), st.ZERO = new st(_0n$2, _1n$4, _1n$4, _0n$2);
  const { BASE: at, ZERO: mt } = st, qe = wNAF(st, me * 8);
  function ze(Ae) {
    return mod(Ae, fe);
  }
  function ot(Ae) {
    return ze(bytesToNumberLE(Ae));
  }
  function $e(Ae) {
    const ve = me;
    Ae = ensureBytes("private key", Ae, ve);
    const he = ensureBytes("hashed private key", ce(Ae), 2 * ve), be = Ce(he.slice(0, ve)), Me = he.slice(ve, 2 * ve), Re = ot(be), Oe = at.multiply(Re), Te = Oe.toRawBytes();
    return { head: be, prefix: Me, scalar: Re, point: Oe, pointBytes: Te };
  }
  function le(Ae) {
    return $e(Ae).pointBytes;
  }
  function pe(Ae = new Uint8Array(), ...ve) {
    const he = concatBytes(...ve);
    return ot(ce(Ie(he, ensureBytes("context", Ae), !!ue)));
  }
  function ge(Ae, ve, he = {}) {
    Ae = ensureBytes("message", Ae), ue && (Ae = ue(Ae));
    const { prefix: be, scalar: Me, pointBytes: Re } = $e(ve), Oe = pe(he.context, be, Ae), Te = at.multiply(Oe).toRawBytes(), Fe = pe(he.context, Te, Re, Ae), je = ze(Oe + Fe * Me);
    De(je);
    const ct = concatBytes(Te, numberToBytesLE(je, se.BYTES));
    return ensureBytes("result", ct, me * 2);
  }
  const ye = VERIFY_DEFAULT;
  function xe(Ae, ve, he, be = ye) {
    const { context: Me, zip215: Re } = be, Oe = se.BYTES;
    Ae = ensureBytes("signature", Ae, 2 * Oe), ve = ensureBytes("message", ve), ue && (ve = ue(ve));
    const Te = bytesToNumberLE(Ae.slice(Oe, 2 * Oe));
    let Fe, je, ct;
    try {
      Fe = st.fromHex(he, Re), je = st.fromHex(Ae.slice(0, Oe), Re), ct = at.multiplyUnsafe(Te);
    } catch {
      return !1;
    }
    if (!Re && Fe.isSmallOrder())
      return !1;
    const nt = pe(Me, je.toRawBytes(), Fe.toRawBytes(), ve);
    return je.add(Fe.multiplyUnsafe(nt)).subtract(ct).clearCofactor().equals(st.ZERO);
  }
  return at._setWindowSize(8), {
    CURVE: ie,
    getPublicKey: le,
    sign: ge,
    verify: xe,
    ExtendedPoint: st,
    utils: {
      getExtendedPublicKey: $e,
      // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
      randomPrivateKey: () => de(se.BYTES),
      /**
       * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
       * values. This slows down first getPublicKey() by milliseconds (see Speed section),
       * but allows to speed-up subsequent getPublicKey() calls up to 20x.
       * @param windowSize 2, 4, 8, 16
       */
      precompute(Ae = 8, ve = st.BASE) {
        return ve._setWindowSize(Ae), ve.multiply(BigInt(3)), ve;
      }
    }
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"), ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt(0);
const _1n$3 = BigInt(1), _2n$2 = BigInt(2), _5n = BigInt(5), _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
function ed25519_pow_2_252_3(ae) {
  const ie = ED25519_P, fe = ae * ae % ie * ae % ie, ue = pow2(fe, _2n$2, ie) * fe % ie, ce = pow2(ue, _1n$3, ie) * ae % ie, de = pow2(ce, _5n, ie) * ce % ie, me = pow2(de, _10n, ie) * de % ie, we = pow2(me, _20n, ie) * me % ie, Ee = pow2(we, _40n, ie) * we % ie, Se = pow2(Ee, _80n, ie) * Ee % ie, Be = pow2(Se, _80n, ie) * Ee % ie, Ce = pow2(Be, _10n, ie) * de % ie;
  return { pow_p_5_8: pow2(Ce, _2n$2, ie) * ae % ie, b2: fe };
}
function adjustScalarBytes(ae) {
  return ae[0] &= 248, ae[31] &= 127, ae[31] |= 64, ae;
}
function uvRatio(ae, ie) {
  const se = ED25519_P, fe = mod(ie * ie * ie, se), ue = mod(fe * fe * ie, se), ce = ed25519_pow_2_252_3(ae * ue).pow_p_5_8;
  let de = mod(ae * fe * ce, se);
  const me = mod(ie * de * de, se), we = de, Ee = mod(de * ED25519_SQRT_M1, se), Se = me === ae, Be = me === mod(-ae, se), Ce = me === mod(-ae * ED25519_SQRT_M1, se);
  return Se && (de = we), (Be || Ce) && (de = Ee), isNegativeLE(de, se) && (de = mod(-de, se)), { isValid: Se || Be, value: de };
}
const Fp$1 = Field(ED25519_P, void 0, !0), ed25519Defaults = {
  // Param: a
  a: BigInt(-1),
  // Fp.create(-1) is proper; our way still works and is faster
  // d is equal to -121665/121666 over finite field.
  // Negative number is P - number, and division is invert(number, P)
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  // Finite field p over which we'll do calculations; 2n**255n - 19n
  Fp: Fp$1,
  // Subgroup order: how many points curve has
  // 2n**252n + 27742317777372353535851937790883648493n;
  n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
  // Cofactor
  h: BigInt(8),
  // Base point (x, y) aka generator point
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
  hash: sha512,
  randomBytes,
  adjustScalarBytes,
  // dom2
  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
  // Constant-time, u/v
  uvRatio
}, ed25519 = /* @__PURE__ */ twistedEdwards(ed25519Defaults);
function ed25519_domain(ae, ie, se) {
  if (ie.length > 255)
    throw new Error("Context is too big");
  return concatBytes$1(utf8ToBytes$1("SigEd25519 no Ed25519 collisions"), new Uint8Array([se ? 1 : 0, ie.length]), ie, ae);
}
({
  ...ed25519Defaults
});
({
  ...ed25519Defaults
});
const ELL2_C1 = (Fp$1.ORDER + BigInt(3)) / BigInt(8);
Fp$1.pow(_2n$2, ELL2_C1);
Fp$1.sqrt(Fp$1.neg(Fp$1.ONE));
(Fp$1.ORDER - BigInt(5)) / BigInt(8);
BigInt(486662);
FpSqrtEven(Fp$1, Fp$1.neg(BigInt(486664)));
BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var _Buffer = safeBufferExports.Buffer;
function base(ae) {
  if (ae.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var ie = new Uint8Array(256), se = 0; se < ie.length; se++)
    ie[se] = 255;
  for (var fe = 0; fe < ae.length; fe++) {
    var ue = ae.charAt(fe), ce = ue.charCodeAt(0);
    if (ie[ce] !== 255)
      throw new TypeError(ue + " is ambiguous");
    ie[ce] = fe;
  }
  var de = ae.length, me = ae.charAt(0), we = Math.log(de) / Math.log(256), Ee = Math.log(256) / Math.log(de);
  function Se(Ie) {
    if ((Array.isArray(Ie) || Ie instanceof Uint8Array) && (Ie = _Buffer.from(Ie)), !_Buffer.isBuffer(Ie))
      throw new TypeError("Expected Buffer");
    if (Ie.length === 0)
      return "";
    for (var Pe = 0, Ne = 0, ke = 0, He = Ie.length; ke !== He && Ie[ke] === 0; )
      ke++, Pe++;
    for (var De = (He - ke) * Ee + 1 >>> 0, Ge = new Uint8Array(De); ke !== He; ) {
      for (var Ye = Ie[ke], st = 0, at = De - 1; (Ye !== 0 || st < Ne) && at !== -1; at--, st++)
        Ye += 256 * Ge[at] >>> 0, Ge[at] = Ye % de >>> 0, Ye = Ye / de >>> 0;
      if (Ye !== 0)
        throw new Error("Non-zero carry");
      Ne = st, ke++;
    }
    for (var mt = De - Ne; mt !== De && Ge[mt] === 0; )
      mt++;
    for (var qe = me.repeat(Pe); mt < De; ++mt)
      qe += ae.charAt(Ge[mt]);
    return qe;
  }
  function Be(Ie) {
    if (typeof Ie != "string")
      throw new TypeError("Expected String");
    if (Ie.length === 0)
      return _Buffer.alloc(0);
    for (var Pe = 0, Ne = 0, ke = 0; Ie[Pe] === me; )
      Ne++, Pe++;
    for (var He = (Ie.length - Pe) * we + 1 >>> 0, De = new Uint8Array(He); Ie[Pe]; ) {
      var Ge = ie[Ie.charCodeAt(Pe)];
      if (Ge === 255)
        return;
      for (var Ye = 0, st = He - 1; (Ge !== 0 || Ye < ke) && st !== -1; st--, Ye++)
        Ge += de * De[st] >>> 0, De[st] = Ge % 256 >>> 0, Ge = Ge / 256 >>> 0;
      if (Ge !== 0)
        throw new Error("Non-zero carry");
      ke = Ye, Pe++;
    }
    for (var at = He - ke; at !== He && De[at] === 0; )
      at++;
    var mt = _Buffer.allocUnsafe(Ne + (He - at));
    mt.fill(0, 0, Ne);
    for (var qe = Ne; at !== He; )
      mt[qe++] = De[at++];
    return mt;
  }
  function Ce(Ie) {
    var Pe = Be(Ie);
    if (Pe)
      return Pe;
    throw new Error("Non-base" + de + " character");
  }
  return {
    encode: Se,
    decodeUnsafe: Be,
    decode: Ce
  };
}
var src = base, basex = src, ALPHABET$1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", bs58 = basex(ALPHABET$1);
const bs58$1 = /* @__PURE__ */ getDefaultExportFromCjs$2(bs58), Chi = (ae, ie, se) => ae & ie ^ ~ae & se, Maj = (ae, ie, se) => ae & ie ^ ae & se ^ ie & se, SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends SHA2 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV[0] | 0, this.B = IV[1] | 0, this.C = IV[2] | 0, this.D = IV[3] | 0, this.E = IV[4] | 0, this.F = IV[5] | 0, this.G = IV[6] | 0, this.H = IV[7] | 0;
  }
  get() {
    const { A: ie, B: se, C: fe, D: ue, E: ce, F: de, G: me, H: we } = this;
    return [ie, se, fe, ue, ce, de, me, we];
  }
  // prettier-ignore
  set(ie, se, fe, ue, ce, de, me, we) {
    this.A = ie | 0, this.B = se | 0, this.C = fe | 0, this.D = ue | 0, this.E = ce | 0, this.F = de | 0, this.G = me | 0, this.H = we | 0;
  }
  process(ie, se) {
    for (let Be = 0; Be < 16; Be++, se += 4)
      SHA256_W[Be] = ie.getUint32(se, !1);
    for (let Be = 16; Be < 64; Be++) {
      const Ce = SHA256_W[Be - 15], Ie = SHA256_W[Be - 2], Pe = rotr(Ce, 7) ^ rotr(Ce, 18) ^ Ce >>> 3, Ne = rotr(Ie, 17) ^ rotr(Ie, 19) ^ Ie >>> 10;
      SHA256_W[Be] = Ne + SHA256_W[Be - 7] + Pe + SHA256_W[Be - 16] | 0;
    }
    let { A: fe, B: ue, C: ce, D: de, E: me, F: we, G: Ee, H: Se } = this;
    for (let Be = 0; Be < 64; Be++) {
      const Ce = rotr(me, 6) ^ rotr(me, 11) ^ rotr(me, 25), Ie = Se + Ce + Chi(me, we, Ee) + SHA256_K[Be] + SHA256_W[Be] | 0, Ne = (rotr(fe, 2) ^ rotr(fe, 13) ^ rotr(fe, 22)) + Maj(fe, ue, ce) | 0;
      Se = Ee, Ee = we, we = me, me = de + Ie | 0, de = ce, ce = ue, ue = fe, fe = Ie + Ne | 0;
    }
    fe = fe + this.A | 0, ue = ue + this.B | 0, ce = ce + this.C | 0, de = de + this.D | 0, me = me + this.E | 0, we = we + this.F | 0, Ee = Ee + this.G | 0, Se = Se + this.H | 0, this.set(fe, ue, ce, de, me, we, Ee, Se);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());
var Layout$1 = {};
Object.defineProperty(Layout$1, "__esModule", { value: !0 });
Layout$1.s16 = Layout$1.s8 = Layout$1.nu64be = Layout$1.u48be = Layout$1.u40be = Layout$1.u32be = Layout$1.u24be = Layout$1.u16be = nu64 = Layout$1.nu64 = Layout$1.u48 = Layout$1.u40 = u32 = Layout$1.u32 = Layout$1.u24 = u16 = Layout$1.u16 = u8 = Layout$1.u8 = offset = Layout$1.offset = Layout$1.greedy = Layout$1.Constant = Layout$1.UTF8 = Layout$1.CString = Layout$1.Blob = Layout$1.Boolean = Layout$1.BitField = Layout$1.BitStructure = Layout$1.VariantLayout = Layout$1.Union = Layout$1.UnionLayoutDiscriminator = Layout$1.UnionDiscriminator = Layout$1.Structure = Layout$1.Sequence = Layout$1.DoubleBE = Layout$1.Double = Layout$1.FloatBE = Layout$1.Float = Layout$1.NearInt64BE = Layout$1.NearInt64 = Layout$1.NearUInt64BE = Layout$1.NearUInt64 = Layout$1.IntBE = Layout$1.Int = Layout$1.UIntBE = Layout$1.UInt = Layout$1.OffsetLayout = Layout$1.GreedyCount = Layout$1.ExternalLayout = Layout$1.bindConstructorLayout = Layout$1.nameWithProperty = Layout$1.Layout = Layout$1.uint8ArrayToBuffer = Layout$1.checkUint8Array = void 0;
Layout$1.constant = Layout$1.utf8 = Layout$1.cstr = blob = Layout$1.blob = Layout$1.unionLayoutDiscriminator = Layout$1.union = seq = Layout$1.seq = Layout$1.bits = struct = Layout$1.struct = Layout$1.f64be = Layout$1.f64 = Layout$1.f32be = Layout$1.f32 = Layout$1.ns64be = Layout$1.s48be = Layout$1.s40be = Layout$1.s32be = Layout$1.s24be = Layout$1.s16be = ns64 = Layout$1.ns64 = Layout$1.s48 = Layout$1.s40 = Layout$1.s32 = Layout$1.s24 = void 0;
const buffer_1 = require$$0$2;
function checkUint8Array(ae) {
  if (!(ae instanceof Uint8Array))
    throw new TypeError("b must be a Uint8Array");
}
Layout$1.checkUint8Array = checkUint8Array;
function uint8ArrayToBuffer(ae) {
  return checkUint8Array(ae), buffer_1.Buffer.from(ae.buffer, ae.byteOffset, ae.length);
}
Layout$1.uint8ArrayToBuffer = uint8ArrayToBuffer;
class Layout {
  constructor(ie, se) {
    if (!Number.isInteger(ie))
      throw new TypeError("span must be an integer");
    this.span = ie, this.property = se;
  }
  /** Function to create an Object into which decoded properties will
   * be written.
   *
   * Used only for layouts that {@link Layout#decode|decode} to Object
   * instances, which means:
   * * {@link Structure}
   * * {@link Union}
   * * {@link VariantLayout}
   * * {@link BitStructure}
   *
   * If left undefined the JavaScript representation of these layouts
   * will be Object instances.
   *
   * See {@link bindConstructorLayout}.
   */
  makeDestinationObject() {
    return {};
  }
  /**
   * Calculate the span of a specific instance of a layout.
   *
   * @param {Uint8Array} b - the buffer that contains an encoded instance.
   *
   * @param {Number} [offset] - the offset at which the encoded instance
   * starts.  If absent a zero offset is inferred.
   *
   * @return {Number} - the number of bytes covered by the layout
   * instance.  If this method is not overridden in a subclass the
   * definition-time constant {@link Layout#span|span} will be
   * returned.
   *
   * @throws {RangeError} - if the length of the value cannot be
   * determined.
   */
  getSpan(ie, se) {
    if (0 > this.span)
      throw new RangeError("indeterminate span");
    return this.span;
  }
  /**
   * Replicate the layout using a new property.
   *
   * This function must be used to get a structurally-equivalent layout
   * with a different name since all {@link Layout} instances are
   * immutable.
   *
   * **NOTE** This is a shallow copy.  All fields except {@link
   * Layout#property|property} are strictly equal to the origin layout.
   *
   * @param {String} property - the value for {@link
   * Layout#property|property} in the replica.
   *
   * @returns {Layout} - the copy with {@link Layout#property|property}
   * set to `property`.
   */
  replicate(ie) {
    const se = Object.create(this.constructor.prototype);
    return Object.assign(se, this), se.property = ie, se;
  }
  /**
   * Create an object from layout properties and an array of values.
   *
   * **NOTE** This function returns `undefined` if invoked on a layout
   * that does not return its value as an Object.  Objects are
   * returned for things that are a {@link Structure}, which includes
   * {@link VariantLayout|variant layouts} if they are structures, and
   * excludes {@link Union}s.  If you want this feature for a union
   * you must use {@link Union.getVariant|getVariant} to select the
   * desired layout.
   *
   * @param {Array} values - an array of values that correspond to the
   * default order for properties.  As with {@link Layout#decode|decode}
   * layout elements that have no property name are skipped when
   * iterating over the array values.  Only the top-level properties are
   * assigned; arguments are not assigned to properties of contained
   * layouts.  Any unused values are ignored.
   *
   * @return {(Object|undefined)}
   */
  fromArray(ie) {
  }
}
Layout$1.Layout = Layout;
function nameWithProperty(ae, ie) {
  return ie.property ? ae + "[" + ie.property + "]" : ae;
}
Layout$1.nameWithProperty = nameWithProperty;
function bindConstructorLayout(ae, ie) {
  if (typeof ae != "function")
    throw new TypeError("Class must be constructor");
  if (Object.prototype.hasOwnProperty.call(ae, "layout_"))
    throw new Error("Class is already bound to a layout");
  if (!(ie && ie instanceof Layout))
    throw new TypeError("layout must be a Layout");
  if (Object.prototype.hasOwnProperty.call(ie, "boundConstructor_"))
    throw new Error("layout is already bound to a constructor");
  ae.layout_ = ie, ie.boundConstructor_ = ae, ie.makeDestinationObject = () => new ae(), Object.defineProperty(ae.prototype, "encode", {
    value(se, fe) {
      return ie.encode(this, se, fe);
    },
    writable: !0
  }), Object.defineProperty(ae, "decode", {
    value(se, fe) {
      return ie.decode(se, fe);
    },
    writable: !0
  });
}
Layout$1.bindConstructorLayout = bindConstructorLayout;
class ExternalLayout extends Layout {
  /**
   * Return `true` iff the external layout decodes to an unsigned
   * integer layout.
   *
   * In that case it can be used as the source of {@link
   * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
   * or as {@link UnionLayoutDiscriminator#layout|external union
   * discriminators}.
   *
   * @abstract
   */
  isCount() {
    throw new Error("ExternalLayout is abstract");
  }
}
Layout$1.ExternalLayout = ExternalLayout;
class GreedyCount extends ExternalLayout {
  constructor(ie = 1, se) {
    if (!Number.isInteger(ie) || 0 >= ie)
      throw new TypeError("elementSpan must be a (positive) integer");
    super(-1, se), this.elementSpan = ie;
  }
  /** @override */
  isCount() {
    return !0;
  }
  /** @override */
  decode(ie, se = 0) {
    checkUint8Array(ie);
    const fe = ie.length - se;
    return Math.floor(fe / this.elementSpan);
  }
  /** @override */
  encode(ie, se, fe) {
    return 0;
  }
}
Layout$1.GreedyCount = GreedyCount;
class OffsetLayout extends ExternalLayout {
  constructor(ie, se = 0, fe) {
    if (!(ie instanceof Layout))
      throw new TypeError("layout must be a Layout");
    if (!Number.isInteger(se))
      throw new TypeError("offset must be integer or undefined");
    super(ie.span, fe || ie.property), this.layout = ie, this.offset = se;
  }
  /** @override */
  isCount() {
    return this.layout instanceof UInt || this.layout instanceof UIntBE;
  }
  /** @override */
  decode(ie, se = 0) {
    return this.layout.decode(ie, se + this.offset);
  }
  /** @override */
  encode(ie, se, fe = 0) {
    return this.layout.encode(ie, se, fe + this.offset);
  }
}
Layout$1.OffsetLayout = OffsetLayout;
class UInt extends Layout {
  constructor(ie, se) {
    if (super(ie, se), 6 < this.span)
      throw new RangeError("span must not exceed 6 bytes");
  }
  /** @override */
  decode(ie, se = 0) {
    return uint8ArrayToBuffer(ie).readUIntLE(se, this.span);
  }
  /** @override */
  encode(ie, se, fe = 0) {
    return uint8ArrayToBuffer(se).writeUIntLE(ie, fe, this.span), this.span;
  }
}
Layout$1.UInt = UInt;
class UIntBE extends Layout {
  constructor(ie, se) {
    if (super(ie, se), 6 < this.span)
      throw new RangeError("span must not exceed 6 bytes");
  }
  /** @override */
  decode(ie, se = 0) {
    return uint8ArrayToBuffer(ie).readUIntBE(se, this.span);
  }
  /** @override */
  encode(ie, se, fe = 0) {
    return uint8ArrayToBuffer(se).writeUIntBE(ie, fe, this.span), this.span;
  }
}
Layout$1.UIntBE = UIntBE;
class Int extends Layout {
  constructor(ie, se) {
    if (super(ie, se), 6 < this.span)
      throw new RangeError("span must not exceed 6 bytes");
  }
  /** @override */
  decode(ie, se = 0) {
    return uint8ArrayToBuffer(ie).readIntLE(se, this.span);
  }
  /** @override */
  encode(ie, se, fe = 0) {
    return uint8ArrayToBuffer(se).writeIntLE(ie, fe, this.span), this.span;
  }
}
Layout$1.Int = Int;
class IntBE extends Layout {
  constructor(ie, se) {
    if (super(ie, se), 6 < this.span)
      throw new RangeError("span must not exceed 6 bytes");
  }
  /** @override */
  decode(ie, se = 0) {
    return uint8ArrayToBuffer(ie).readIntBE(se, this.span);
  }
  /** @override */
  encode(ie, se, fe = 0) {
    return uint8ArrayToBuffer(se).writeIntBE(ie, fe, this.span), this.span;
  }
}
Layout$1.IntBE = IntBE;
const V2E32 = Math.pow(2, 32);
function divmodInt64(ae) {
  const ie = Math.floor(ae / V2E32), se = ae - ie * V2E32;
  return { hi32: ie, lo32: se };
}
function roundedInt64(ae, ie) {
  return ae * V2E32 + ie;
}
class NearUInt64 extends Layout {
  constructor(ie) {
    super(8, ie);
  }
  /** @override */
  decode(ie, se = 0) {
    const fe = uint8ArrayToBuffer(ie), ue = fe.readUInt32LE(se), ce = fe.readUInt32LE(se + 4);
    return roundedInt64(ce, ue);
  }
  /** @override */
  encode(ie, se, fe = 0) {
    const ue = divmodInt64(ie), ce = uint8ArrayToBuffer(se);
    return ce.writeUInt32LE(ue.lo32, fe), ce.writeUInt32LE(ue.hi32, fe + 4), 8;
  }
}
Layout$1.NearUInt64 = NearUInt64;
class NearUInt64BE extends Layout {
  constructor(ie) {
    super(8, ie);
  }
  /** @override */
  decode(ie, se = 0) {
    const fe = uint8ArrayToBuffer(ie), ue = fe.readUInt32BE(se), ce = fe.readUInt32BE(se + 4);
    return roundedInt64(ue, ce);
  }
  /** @override */
  encode(ie, se, fe = 0) {
    const ue = divmodInt64(ie), ce = uint8ArrayToBuffer(se);
    return ce.writeUInt32BE(ue.hi32, fe), ce.writeUInt32BE(ue.lo32, fe + 4), 8;
  }
}
Layout$1.NearUInt64BE = NearUInt64BE;
class NearInt64 extends Layout {
  constructor(ie) {
    super(8, ie);
  }
  /** @override */
  decode(ie, se = 0) {
    const fe = uint8ArrayToBuffer(ie), ue = fe.readUInt32LE(se), ce = fe.readInt32LE(se + 4);
    return roundedInt64(ce, ue);
  }
  /** @override */
  encode(ie, se, fe = 0) {
    const ue = divmodInt64(ie), ce = uint8ArrayToBuffer(se);
    return ce.writeUInt32LE(ue.lo32, fe), ce.writeInt32LE(ue.hi32, fe + 4), 8;
  }
}
Layout$1.NearInt64 = NearInt64;
class NearInt64BE extends Layout {
  constructor(ie) {
    super(8, ie);
  }
  /** @override */
  decode(ie, se = 0) {
    const fe = uint8ArrayToBuffer(ie), ue = fe.readInt32BE(se), ce = fe.readUInt32BE(se + 4);
    return roundedInt64(ue, ce);
  }
  /** @override */
  encode(ie, se, fe = 0) {
    const ue = divmodInt64(ie), ce = uint8ArrayToBuffer(se);
    return ce.writeInt32BE(ue.hi32, fe), ce.writeUInt32BE(ue.lo32, fe + 4), 8;
  }
}
Layout$1.NearInt64BE = NearInt64BE;
class Float extends Layout {
  constructor(ie) {
    super(4, ie);
  }
  /** @override */
  decode(ie, se = 0) {
    return uint8ArrayToBuffer(ie).readFloatLE(se);
  }
  /** @override */
  encode(ie, se, fe = 0) {
    return uint8ArrayToBuffer(se).writeFloatLE(ie, fe), 4;
  }
}
Layout$1.Float = Float;
class FloatBE extends Layout {
  constructor(ie) {
    super(4, ie);
  }
  /** @override */
  decode(ie, se = 0) {
    return uint8ArrayToBuffer(ie).readFloatBE(se);
  }
  /** @override */
  encode(ie, se, fe = 0) {
    return uint8ArrayToBuffer(se).writeFloatBE(ie, fe), 4;
  }
}
Layout$1.FloatBE = FloatBE;
class Double extends Layout {
  constructor(ie) {
    super(8, ie);
  }
  /** @override */
  decode(ie, se = 0) {
    return uint8ArrayToBuffer(ie).readDoubleLE(se);
  }
  /** @override */
  encode(ie, se, fe = 0) {
    return uint8ArrayToBuffer(se).writeDoubleLE(ie, fe), 8;
  }
}
Layout$1.Double = Double;
class DoubleBE extends Layout {
  constructor(ie) {
    super(8, ie);
  }
  /** @override */
  decode(ie, se = 0) {
    return uint8ArrayToBuffer(ie).readDoubleBE(se);
  }
  /** @override */
  encode(ie, se, fe = 0) {
    return uint8ArrayToBuffer(se).writeDoubleBE(ie, fe), 8;
  }
}
Layout$1.DoubleBE = DoubleBE;
class Sequence extends Layout {
  constructor(ie, se, fe) {
    if (!(ie instanceof Layout))
      throw new TypeError("elementLayout must be a Layout");
    if (!(se instanceof ExternalLayout && se.isCount() || Number.isInteger(se) && 0 <= se))
      throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
    let ue = -1;
    !(se instanceof ExternalLayout) && 0 < ie.span && (ue = se * ie.span), super(ue, fe), this.elementLayout = ie, this.count = se;
  }
  /** @override */
  getSpan(ie, se = 0) {
    if (0 <= this.span)
      return this.span;
    let fe = 0, ue = this.count;
    if (ue instanceof ExternalLayout && (ue = ue.decode(ie, se)), 0 < this.elementLayout.span)
      fe = ue * this.elementLayout.span;
    else {
      let ce = 0;
      for (; ce < ue; )
        fe += this.elementLayout.getSpan(ie, se + fe), ++ce;
    }
    return fe;
  }
  /** @override */
  decode(ie, se = 0) {
    const fe = [];
    let ue = 0, ce = this.count;
    for (ce instanceof ExternalLayout && (ce = ce.decode(ie, se)); ue < ce; )
      fe.push(this.elementLayout.decode(ie, se)), se += this.elementLayout.getSpan(ie, se), ue += 1;
    return fe;
  }
  /** Implement {@link Layout#encode|encode} for {@link Sequence}.
   *
   * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
   * the unused space in the buffer is left unchanged.  If `src` is
   * longer than {@link Sequence#count|count} the unneeded elements are
   * ignored.
   *
   * **NOTE** If {@link Layout#count|count} is an instance of {@link
   * ExternalLayout} then the length of `src` will be encoded as the
   * count after `src` is encoded. */
  encode(ie, se, fe = 0) {
    const ue = this.elementLayout, ce = ie.reduce((de, me) => de + ue.encode(me, se, fe + de), 0);
    return this.count instanceof ExternalLayout && this.count.encode(ie.length, se, fe), ce;
  }
}
Layout$1.Sequence = Sequence;
class Structure extends Layout {
  constructor(ie, se, fe) {
    if (!(Array.isArray(ie) && ie.reduce((ce, de) => ce && de instanceof Layout, !0)))
      throw new TypeError("fields must be array of Layout instances");
    typeof se == "boolean" && fe === void 0 && (fe = se, se = void 0);
    for (const ce of ie)
      if (0 > ce.span && ce.property === void 0)
        throw new Error("fields cannot contain unnamed variable-length layout");
    let ue = -1;
    try {
      ue = ie.reduce((ce, de) => ce + de.getSpan(), 0);
    } catch {
    }
    super(ue, se), this.fields = ie, this.decodePrefixes = !!fe;
  }
  /** @override */
  getSpan(ie, se = 0) {
    if (0 <= this.span)
      return this.span;
    let fe = 0;
    try {
      fe = this.fields.reduce((ue, ce) => {
        const de = ce.getSpan(ie, se);
        return se += de, ue + de;
      }, 0);
    } catch {
      throw new RangeError("indeterminate span");
    }
    return fe;
  }
  /** @override */
  decode(ie, se = 0) {
    checkUint8Array(ie);
    const fe = this.makeDestinationObject();
    for (const ue of this.fields)
      if (ue.property !== void 0 && (fe[ue.property] = ue.decode(ie, se)), se += ue.getSpan(ie, se), this.decodePrefixes && ie.length === se)
        break;
    return fe;
  }
  /** Implement {@link Layout#encode|encode} for {@link Structure}.
   *
   * If `src` is missing a property for a member with a defined {@link
   * Layout#property|property} the corresponding region of the buffer is
   * left unmodified. */
  encode(ie, se, fe = 0) {
    const ue = fe;
    let ce = 0, de = 0;
    for (const me of this.fields) {
      let we = me.span;
      if (de = 0 < we ? we : 0, me.property !== void 0) {
        const Ee = ie[me.property];
        Ee !== void 0 && (de = me.encode(Ee, se, fe), 0 > we && (we = me.getSpan(se, fe)));
      }
      ce = fe, fe += we;
    }
    return ce + de - ue;
  }
  /** @override */
  fromArray(ie) {
    const se = this.makeDestinationObject();
    for (const fe of this.fields)
      fe.property !== void 0 && 0 < ie.length && (se[fe.property] = ie.shift());
    return se;
  }
  /**
   * Get access to the layout of a given property.
   *
   * @param {String} property - the structure member of interest.
   *
   * @return {Layout} - the layout associated with `property`, or
   * undefined if there is no such property.
   */
  layoutFor(ie) {
    if (typeof ie != "string")
      throw new TypeError("property must be string");
    for (const se of this.fields)
      if (se.property === ie)
        return se;
  }
  /**
   * Get the offset of a structure member.
   *
   * @param {String} property - the structure member of interest.
   *
   * @return {Number} - the offset in bytes to the start of `property`
   * within the structure, or undefined if `property` is not a field
   * within the structure.  If the property is a member but follows a
   * variable-length structure member a negative number will be
   * returned.
   */
  offsetOf(ie) {
    if (typeof ie != "string")
      throw new TypeError("property must be string");
    let se = 0;
    for (const fe of this.fields) {
      if (fe.property === ie)
        return se;
      0 > fe.span ? se = -1 : 0 <= se && (se += fe.span);
    }
  }
}
Layout$1.Structure = Structure;
class UnionDiscriminator {
  constructor(ie) {
    this.property = ie;
  }
  /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
   *
   * The implementation of this method need not reference the buffer if
   * variant information is available through other means. */
  decode(ie, se) {
    throw new Error("UnionDiscriminator is abstract");
  }
  /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
   *
   * The implementation of this method need not store the value if
   * variant information is maintained through other means. */
  encode(ie, se, fe) {
    throw new Error("UnionDiscriminator is abstract");
  }
}
Layout$1.UnionDiscriminator = UnionDiscriminator;
class UnionLayoutDiscriminator extends UnionDiscriminator {
  constructor(ie, se) {
    if (!(ie instanceof ExternalLayout && ie.isCount()))
      throw new TypeError("layout must be an unsigned integer ExternalLayout");
    super(se || ie.property || "variant"), this.layout = ie;
  }
  /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
  decode(ie, se) {
    return this.layout.decode(ie, se);
  }
  /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
  encode(ie, se, fe) {
    return this.layout.encode(ie, se, fe);
  }
}
Layout$1.UnionLayoutDiscriminator = UnionLayoutDiscriminator;
class Union extends Layout {
  constructor(ie, se, fe) {
    let ue;
    if (ie instanceof UInt || ie instanceof UIntBE)
      ue = new UnionLayoutDiscriminator(new OffsetLayout(ie));
    else if (ie instanceof ExternalLayout && ie.isCount())
      ue = new UnionLayoutDiscriminator(ie);
    else if (ie instanceof UnionDiscriminator)
      ue = ie;
    else
      throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
    if (se === void 0 && (se = null), !(se === null || se instanceof Layout))
      throw new TypeError("defaultLayout must be null or a Layout");
    if (se !== null) {
      if (0 > se.span)
        throw new Error("defaultLayout must have constant span");
      se.property === void 0 && (se = se.replicate("content"));
    }
    let ce = -1;
    se && (ce = se.span, 0 <= ce && (ie instanceof UInt || ie instanceof UIntBE) && (ce += ue.layout.span)), super(ce, fe), this.discriminator = ue, this.usesPrefixDiscriminator = ie instanceof UInt || ie instanceof UIntBE, this.defaultLayout = se, this.registry = {};
    let de = this.defaultGetSourceVariant.bind(this);
    this.getSourceVariant = function(me) {
      return de(me);
    }, this.configGetSourceVariant = function(me) {
      de = me.bind(this);
    };
  }
  /** @override */
  getSpan(ie, se = 0) {
    if (0 <= this.span)
      return this.span;
    const fe = this.getVariant(ie, se);
    if (!fe)
      throw new Error("unable to determine span for unrecognized variant");
    return fe.getSpan(ie, se);
  }
  /**
   * Method to infer a registered Union variant compatible with `src`.
   *
   * The first satisfied rule in the following sequence defines the
   * return value:
   * * If `src` has properties matching the Union discriminator and
   *   the default layout, `undefined` is returned regardless of the
   *   value of the discriminator property (this ensures the default
   *   layout will be used);
   * * If `src` has a property matching the Union discriminator, the
   *   value of the discriminator identifies a registered variant, and
   *   either (a) the variant has no layout, or (b) `src` has the
   *   variant's property, then the variant is returned (because the
   *   source satisfies the constraints of the variant it identifies);
   * * If `src` does not have a property matching the Union
   *   discriminator, but does have a property matching a registered
   *   variant, then the variant is returned (because the source
   *   matches a variant without an explicit conflict);
   * * An error is thrown (because we either can't identify a variant,
   *   or we were explicitly told the variant but can't satisfy it).
   *
   * @param {Object} src - an object presumed to be compatible with
   * the content of the Union.
   *
   * @return {(undefined|VariantLayout)} - as described above.
   *
   * @throws {Error} - if `src` cannot be associated with a default or
   * registered variant.
   */
  defaultGetSourceVariant(ie) {
    if (Object.prototype.hasOwnProperty.call(ie, this.discriminator.property)) {
      if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(ie, this.defaultLayout.property))
        return;
      const se = this.registry[ie[this.discriminator.property]];
      if (se && (!se.layout || se.property && Object.prototype.hasOwnProperty.call(ie, se.property)))
        return se;
    } else
      for (const se in this.registry) {
        const fe = this.registry[se];
        if (fe.property && Object.prototype.hasOwnProperty.call(ie, fe.property))
          return fe;
      }
    throw new Error("unable to infer src variant");
  }
  /** Implement {@link Layout#decode|decode} for {@link Union}.
   *
   * If the variant is {@link Union#addVariant|registered} the return
   * value is an instance of that variant, with no explicit
   * discriminator.  Otherwise the {@link Union#defaultLayout|default
   * layout} is used to decode the content. */
  decode(ie, se = 0) {
    let fe;
    const ue = this.discriminator, ce = ue.decode(ie, se), de = this.registry[ce];
    if (de === void 0) {
      const me = this.defaultLayout;
      let we = 0;
      this.usesPrefixDiscriminator && (we = ue.layout.span), fe = this.makeDestinationObject(), fe[ue.property] = ce, fe[me.property] = me.decode(ie, se + we);
    } else
      fe = de.decode(ie, se);
    return fe;
  }
  /** Implement {@link Layout#encode|encode} for {@link Union}.
   *
   * This API assumes the `src` object is consistent with the union's
   * {@link Union#defaultLayout|default layout}.  To encode variants
   * use the appropriate variant-specific {@link VariantLayout#encode}
   * method. */
  encode(ie, se, fe = 0) {
    const ue = this.getSourceVariant(ie);
    if (ue === void 0) {
      const ce = this.discriminator, de = this.defaultLayout;
      let me = 0;
      return this.usesPrefixDiscriminator && (me = ce.layout.span), ce.encode(ie[ce.property], se, fe), me + de.encode(ie[de.property], se, fe + me);
    }
    return ue.encode(ie, se, fe);
  }
  /** Register a new variant structure within a union.  The newly
   * created variant is returned.
   *
   * @param {Number} variant - initializer for {@link
   * VariantLayout#variant|variant}.
   *
   * @param {Layout} layout - initializer for {@link
   * VariantLayout#layout|layout}.
   *
   * @param {String} property - initializer for {@link
   * Layout#property|property}.
   *
   * @return {VariantLayout} */
  addVariant(ie, se, fe) {
    const ue = new VariantLayout(this, ie, se, fe);
    return this.registry[ie] = ue, ue;
  }
  /**
   * Get the layout associated with a registered variant.
   *
   * If `vb` does not produce a registered variant the function returns
   * `undefined`.
   *
   * @param {(Number|Uint8Array)} vb - either the variant number, or a
   * buffer from which the discriminator is to be read.
   *
   * @param {Number} offset - offset into `vb` for the start of the
   * union.  Used only when `vb` is an instance of {Uint8Array}.
   *
   * @return {({VariantLayout}|undefined)}
   */
  getVariant(ie, se = 0) {
    let fe;
    return ie instanceof Uint8Array ? fe = this.discriminator.decode(ie, se) : fe = ie, this.registry[fe];
  }
}
Layout$1.Union = Union;
class VariantLayout extends Layout {
  constructor(ie, se, fe, ue) {
    if (!(ie instanceof Union))
      throw new TypeError("union must be a Union");
    if (!Number.isInteger(se) || 0 > se)
      throw new TypeError("variant must be a (non-negative) integer");
    if (typeof fe == "string" && ue === void 0 && (ue = fe, fe = null), fe) {
      if (!(fe instanceof Layout))
        throw new TypeError("layout must be a Layout");
      if (ie.defaultLayout !== null && 0 <= fe.span && fe.span > ie.defaultLayout.span)
        throw new Error("variant span exceeds span of containing union");
      if (typeof ue != "string")
        throw new TypeError("variant must have a String property");
    }
    let ce = ie.span;
    0 > ie.span && (ce = fe ? fe.span : 0, 0 <= ce && ie.usesPrefixDiscriminator && (ce += ie.discriminator.layout.span)), super(ce, ue), this.union = ie, this.variant = se, this.layout = fe || null;
  }
  /** @override */
  getSpan(ie, se = 0) {
    if (0 <= this.span)
      return this.span;
    let fe = 0;
    this.union.usesPrefixDiscriminator && (fe = this.union.discriminator.layout.span);
    let ue = 0;
    return this.layout && (ue = this.layout.getSpan(ie, se + fe)), fe + ue;
  }
  /** @override */
  decode(ie, se = 0) {
    const fe = this.makeDestinationObject();
    if (this !== this.union.getVariant(ie, se))
      throw new Error("variant mismatch");
    let ue = 0;
    return this.union.usesPrefixDiscriminator && (ue = this.union.discriminator.layout.span), this.layout ? fe[this.property] = this.layout.decode(ie, se + ue) : this.property ? fe[this.property] = !0 : this.union.usesPrefixDiscriminator && (fe[this.union.discriminator.property] = this.variant), fe;
  }
  /** @override */
  encode(ie, se, fe = 0) {
    let ue = 0;
    if (this.union.usesPrefixDiscriminator && (ue = this.union.discriminator.layout.span), this.layout && !Object.prototype.hasOwnProperty.call(ie, this.property))
      throw new TypeError("variant lacks property " + this.property);
    this.union.discriminator.encode(this.variant, se, fe);
    let ce = ue;
    if (this.layout && (this.layout.encode(ie[this.property], se, fe + ue), ce += this.layout.getSpan(se, fe + ue), 0 <= this.union.span && ce > this.union.span))
      throw new Error("encoded variant overruns containing union");
    return ce;
  }
  /** Delegate {@link Layout#fromArray|fromArray} to {@link
   * VariantLayout#layout|layout}. */
  fromArray(ie) {
    if (this.layout)
      return this.layout.fromArray(ie);
  }
}
Layout$1.VariantLayout = VariantLayout;
function fixBitwiseResult(ae) {
  return 0 > ae && (ae += 4294967296), ae;
}
class BitStructure extends Layout {
  constructor(ie, se, fe) {
    if (!(ie instanceof UInt || ie instanceof UIntBE))
      throw new TypeError("word must be a UInt or UIntBE layout");
    if (typeof se == "string" && fe === void 0 && (fe = se, se = !1), 4 < ie.span)
      throw new RangeError("word cannot exceed 32 bits");
    super(ie.span, fe), this.word = ie, this.msb = !!se, this.fields = [];
    let ue = 0;
    this._packedSetValue = function(ce) {
      return ue = fixBitwiseResult(ce), this;
    }, this._packedGetValue = function() {
      return ue;
    };
  }
  /** @override */
  decode(ie, se = 0) {
    const fe = this.makeDestinationObject(), ue = this.word.decode(ie, se);
    this._packedSetValue(ue);
    for (const ce of this.fields)
      ce.property !== void 0 && (fe[ce.property] = ce.decode(ie));
    return fe;
  }
  /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
   *
   * If `src` is missing a property for a member with a defined {@link
   * Layout#property|property} the corresponding region of the packed
   * value is left unmodified.  Unused bits are also left unmodified. */
  encode(ie, se, fe = 0) {
    const ue = this.word.decode(se, fe);
    this._packedSetValue(ue);
    for (const ce of this.fields)
      if (ce.property !== void 0) {
        const de = ie[ce.property];
        de !== void 0 && ce.encode(de);
      }
    return this.word.encode(this._packedGetValue(), se, fe);
  }
  /** Register a new bitfield with a containing bit structure.  The
   * resulting bitfield is returned.
   *
   * @param {Number} bits - initializer for {@link BitField#bits|bits}.
   *
   * @param {string} property - initializer for {@link
   * Layout#property|property}.
   *
   * @return {BitField} */
  addField(ie, se) {
    const fe = new BitField(this, ie, se);
    return this.fields.push(fe), fe;
  }
  /** As with {@link BitStructure#addField|addField} for single-bit
   * fields with `boolean` value representation.
   *
   * @param {string} property - initializer for {@link
   * Layout#property|property}.
   *
   * @return {Boolean} */
  // `Boolean` conflicts with the native primitive type
  // eslint-disable-next-line @typescript-eslint/ban-types
  addBoolean(ie) {
    const se = new Boolean$1(this, ie);
    return this.fields.push(se), se;
  }
  /**
   * Get access to the bit field for a given property.
   *
   * @param {String} property - the bit field of interest.
   *
   * @return {BitField} - the field associated with `property`, or
   * undefined if there is no such property.
   */
  fieldFor(ie) {
    if (typeof ie != "string")
      throw new TypeError("property must be string");
    for (const se of this.fields)
      if (se.property === ie)
        return se;
  }
}
Layout$1.BitStructure = BitStructure;
class BitField {
  constructor(ie, se, fe) {
    if (!(ie instanceof BitStructure))
      throw new TypeError("container must be a BitStructure");
    if (!Number.isInteger(se) || 0 >= se)
      throw new TypeError("bits must be positive integer");
    const ue = 8 * ie.span, ce = ie.fields.reduce((de, me) => de + me.bits, 0);
    if (se + ce > ue)
      throw new Error("bits too long for span remainder (" + (ue - ce) + " of " + ue + " remain)");
    this.container = ie, this.bits = se, this.valueMask = (1 << se) - 1, se === 32 && (this.valueMask = 4294967295), this.start = ce, this.container.msb && (this.start = ue - ce - se), this.wordMask = fixBitwiseResult(this.valueMask << this.start), this.property = fe;
  }
  /** Store a value into the corresponding subsequence of the containing
   * bit field. */
  decode(ie, se) {
    const fe = this.container._packedGetValue();
    return fixBitwiseResult(fe & this.wordMask) >>> this.start;
  }
  /** Store a value into the corresponding subsequence of the containing
   * bit field.
   *
   * **NOTE** This is not a specialization of {@link
   * Layout#encode|Layout.encode} and there is no return value. */
  encode(ie) {
    if (typeof ie != "number" || !Number.isInteger(ie) || ie !== fixBitwiseResult(ie & this.valueMask))
      throw new TypeError(nameWithProperty("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
    const se = this.container._packedGetValue(), fe = fixBitwiseResult(ie << this.start);
    this.container._packedSetValue(fixBitwiseResult(se & ~this.wordMask) | fe);
  }
}
Layout$1.BitField = BitField;
let Boolean$1 = class extends BitField {
  constructor(ie, se) {
    super(ie, 1, se);
  }
  /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
   *
   * @returns {boolean} */
  decode(ie, se) {
    return !!super.decode(ie, se);
  }
  /** @override */
  encode(ie) {
    typeof ie == "boolean" && (ie = +ie), super.encode(ie);
  }
};
Layout$1.Boolean = Boolean$1;
let Blob$2 = class extends Layout {
  constructor(ie, se) {
    if (!(ie instanceof ExternalLayout && ie.isCount() || Number.isInteger(ie) && 0 <= ie))
      throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
    let fe = -1;
    ie instanceof ExternalLayout || (fe = ie), super(fe, se), this.length = ie;
  }
  /** @override */
  getSpan(ie, se) {
    let fe = this.span;
    return 0 > fe && (fe = this.length.decode(ie, se)), fe;
  }
  /** @override */
  decode(ie, se = 0) {
    let fe = this.span;
    return 0 > fe && (fe = this.length.decode(ie, se)), uint8ArrayToBuffer(ie).slice(se, se + fe);
  }
  /** Implement {@link Layout#encode|encode} for {@link Blob}.
   *
   * **NOTE** If {@link Layout#count|count} is an instance of {@link
   * ExternalLayout} then the length of `src` will be encoded as the
   * count after `src` is encoded. */
  encode(ie, se, fe) {
    let ue = this.length;
    if (this.length instanceof ExternalLayout && (ue = ie.length), !(ie instanceof Uint8Array && ue === ie.length))
      throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + ue + ") Uint8Array as src");
    if (fe + ue > se.length)
      throw new RangeError("encoding overruns Uint8Array");
    const ce = uint8ArrayToBuffer(ie);
    return uint8ArrayToBuffer(se).write(ce.toString("hex"), fe, ue, "hex"), this.length instanceof ExternalLayout && this.length.encode(ue, se, fe), ue;
  }
};
Layout$1.Blob = Blob$2;
class CString extends Layout {
  constructor(ie) {
    super(-1, ie);
  }
  /** @override */
  getSpan(ie, se = 0) {
    checkUint8Array(ie);
    let fe = se;
    for (; fe < ie.length && ie[fe] !== 0; )
      fe += 1;
    return 1 + fe - se;
  }
  /** @override */
  decode(ie, se = 0) {
    const fe = this.getSpan(ie, se);
    return uint8ArrayToBuffer(ie).slice(se, se + fe - 1).toString("utf-8");
  }
  /** @override */
  encode(ie, se, fe = 0) {
    typeof ie != "string" && (ie = String(ie));
    const ue = buffer_1.Buffer.from(ie, "utf8"), ce = ue.length;
    if (fe + ce > se.length)
      throw new RangeError("encoding overruns Buffer");
    const de = uint8ArrayToBuffer(se);
    return ue.copy(de, fe), de[fe + ce] = 0, ce + 1;
  }
}
Layout$1.CString = CString;
class UTF8 extends Layout {
  constructor(ie, se) {
    if (typeof ie == "string" && se === void 0 && (se = ie, ie = void 0), ie === void 0)
      ie = -1;
    else if (!Number.isInteger(ie))
      throw new TypeError("maxSpan must be an integer");
    super(-1, se), this.maxSpan = ie;
  }
  /** @override */
  getSpan(ie, se = 0) {
    return checkUint8Array(ie), ie.length - se;
  }
  /** @override */
  decode(ie, se = 0) {
    const fe = this.getSpan(ie, se);
    if (0 <= this.maxSpan && this.maxSpan < fe)
      throw new RangeError("text length exceeds maxSpan");
    return uint8ArrayToBuffer(ie).slice(se, se + fe).toString("utf-8");
  }
  /** @override */
  encode(ie, se, fe = 0) {
    typeof ie != "string" && (ie = String(ie));
    const ue = buffer_1.Buffer.from(ie, "utf8"), ce = ue.length;
    if (0 <= this.maxSpan && this.maxSpan < ce)
      throw new RangeError("text length exceeds maxSpan");
    if (fe + ce > se.length)
      throw new RangeError("encoding overruns Buffer");
    return ue.copy(uint8ArrayToBuffer(se), fe), ce;
  }
}
Layout$1.UTF8 = UTF8;
class Constant extends Layout {
  constructor(ie, se) {
    super(0, se), this.value = ie;
  }
  /** @override */
  decode(ie, se) {
    return this.value;
  }
  /** @override */
  encode(ie, se, fe) {
    return 0;
  }
}
Layout$1.Constant = Constant;
Layout$1.greedy = (ae, ie) => new GreedyCount(ae, ie);
var offset = Layout$1.offset = (ae, ie, se) => new OffsetLayout(ae, ie, se), u8 = Layout$1.u8 = (ae) => new UInt(1, ae), u16 = Layout$1.u16 = (ae) => new UInt(2, ae);
Layout$1.u24 = (ae) => new UInt(3, ae);
var u32 = Layout$1.u32 = (ae) => new UInt(4, ae);
Layout$1.u40 = (ae) => new UInt(5, ae);
Layout$1.u48 = (ae) => new UInt(6, ae);
var nu64 = Layout$1.nu64 = (ae) => new NearUInt64(ae);
Layout$1.u16be = (ae) => new UIntBE(2, ae);
Layout$1.u24be = (ae) => new UIntBE(3, ae);
Layout$1.u32be = (ae) => new UIntBE(4, ae);
Layout$1.u40be = (ae) => new UIntBE(5, ae);
Layout$1.u48be = (ae) => new UIntBE(6, ae);
Layout$1.nu64be = (ae) => new NearUInt64BE(ae);
Layout$1.s8 = (ae) => new Int(1, ae);
Layout$1.s16 = (ae) => new Int(2, ae);
Layout$1.s24 = (ae) => new Int(3, ae);
Layout$1.s32 = (ae) => new Int(4, ae);
Layout$1.s40 = (ae) => new Int(5, ae);
Layout$1.s48 = (ae) => new Int(6, ae);
var ns64 = Layout$1.ns64 = (ae) => new NearInt64(ae);
Layout$1.s16be = (ae) => new IntBE(2, ae);
Layout$1.s24be = (ae) => new IntBE(3, ae);
Layout$1.s32be = (ae) => new IntBE(4, ae);
Layout$1.s40be = (ae) => new IntBE(5, ae);
Layout$1.s48be = (ae) => new IntBE(6, ae);
Layout$1.ns64be = (ae) => new NearInt64BE(ae);
Layout$1.f32 = (ae) => new Float(ae);
Layout$1.f32be = (ae) => new FloatBE(ae);
Layout$1.f64 = (ae) => new Double(ae);
Layout$1.f64be = (ae) => new DoubleBE(ae);
var struct = Layout$1.struct = (ae, ie, se) => new Structure(ae, ie, se);
Layout$1.bits = (ae, ie, se) => new BitStructure(ae, ie, se);
var seq = Layout$1.seq = (ae, ie, se) => new Sequence(ae, ie, se);
Layout$1.union = (ae, ie, se) => new Union(ae, ie, se);
Layout$1.unionLayoutDiscriminator = (ae, ie) => new UnionLayoutDiscriminator(ae, ie);
var blob = Layout$1.blob = (ae, ie) => new Blob$2(ae, ie);
Layout$1.cstr = (ae) => new CString(ae);
Layout$1.utf8 = (ae, ie) => new UTF8(ae, ie);
Layout$1.constant = (ae, ie) => new Constant(ae, ie);
var browser$1 = {};
Object.defineProperty(browser$1, "__esModule", { value: !0 });
function toBigIntLE(ae) {
  {
    const ie = Buffer$F.from(ae);
    ie.reverse();
    const se = ie.toString("hex");
    return se.length === 0 ? BigInt(0) : BigInt(`0x${se}`);
  }
}
var toBigIntLE_1 = browser$1.toBigIntLE = toBigIntLE;
function toBigIntBE(ae) {
  {
    const ie = ae.toString("hex");
    return ie.length === 0 ? BigInt(0) : BigInt(`0x${ie}`);
  }
}
browser$1.toBigIntBE = toBigIntBE;
function toBufferLE(ae, ie) {
  {
    const se = ae.toString(16), fe = Buffer$F.from(se.padStart(ie * 2, "0").slice(0, ie * 2), "hex");
    return fe.reverse(), fe;
  }
}
var toBufferLE_1 = browser$1.toBufferLE = toBufferLE;
function toBufferBE(ae, ie) {
  {
    const se = ae.toString(16);
    return Buffer$F.from(se.padStart(ie * 2, "0").slice(0, ie * 2), "hex");
  }
}
browser$1.toBufferBE = toBufferBE;
class StructError extends TypeError {
  constructor(ie, se) {
    let fe;
    const {
      message: ue,
      ...ce
    } = ie, {
      path: de
    } = ie, me = de.length === 0 ? ue : "At path: " + de.join(".") + " -- " + ue;
    super(me), Object.assign(this, ce), this.name = this.constructor.name, this.failures = () => {
      var we;
      return (we = fe) != null ? we : fe = [ie, ...se()];
    };
  }
}
function isIterable(ae) {
  return isObject$2(ae) && typeof ae[Symbol.iterator] == "function";
}
function isObject$2(ae) {
  return typeof ae == "object" && ae != null;
}
function print(ae) {
  return typeof ae == "string" ? JSON.stringify(ae) : "" + ae;
}
function shiftIterator(ae) {
  const {
    done: ie,
    value: se
  } = ae.next();
  return ie ? void 0 : se;
}
function toFailure(ae, ie, se, fe) {
  if (ae === !0)
    return;
  ae === !1 ? ae = {} : typeof ae == "string" && (ae = {
    message: ae
  });
  const {
    path: ue,
    branch: ce
  } = ie, {
    type: de
  } = se, {
    refinement: me,
    message: we = "Expected a value of type `" + de + "`" + (me ? " with refinement `" + me + "`" : "") + ", but received: `" + print(fe) + "`"
  } = ae;
  return {
    value: fe,
    type: de,
    refinement: me,
    key: ue[ue.length - 1],
    path: ue,
    branch: ce,
    ...ae,
    message: we
  };
}
function* toFailures(ae, ie, se, fe) {
  isIterable(ae) || (ae = [ae]);
  for (const ue of ae) {
    const ce = toFailure(ue, ie, se, fe);
    ce && (yield ce);
  }
}
function* run(ae, ie, se = {}) {
  const {
    path: fe = [],
    branch: ue = [ae],
    coerce: ce = !1,
    mask: de = !1
  } = se, me = {
    path: fe,
    branch: ue
  };
  if (ce && (ae = ie.coercer(ae, me), de && ie.type !== "type" && isObject$2(ie.schema) && isObject$2(ae) && !Array.isArray(ae)))
    for (const Ee in ae)
      ie.schema[Ee] === void 0 && delete ae[Ee];
  let we = !0;
  for (const Ee of ie.validator(ae, me))
    we = !1, yield [Ee, void 0];
  for (let [Ee, Se, Be] of ie.entries(ae, me)) {
    const Ce = run(Se, Be, {
      path: Ee === void 0 ? fe : [...fe, Ee],
      branch: Ee === void 0 ? ue : [...ue, Se],
      coerce: ce,
      mask: de
    });
    for (const Ie of Ce)
      Ie[0] ? (we = !1, yield [Ie[0], void 0]) : ce && (Se = Ie[1], Ee === void 0 ? ae = Se : ae instanceof Map ? ae.set(Ee, Se) : ae instanceof Set ? ae.add(Se) : isObject$2(ae) && (ae[Ee] = Se));
  }
  if (we)
    for (const Ee of ie.refiner(ae, me))
      we = !1, yield [Ee, void 0];
  we && (yield [void 0, ae]);
}
let Struct$1 = class {
  constructor(ie) {
    const {
      type: se,
      schema: fe,
      validator: ue,
      refiner: ce,
      coercer: de = (we) => we,
      entries: me = function* () {
      }
    } = ie;
    this.type = se, this.schema = fe, this.entries = me, this.coercer = de, ue ? this.validator = (we, Ee) => {
      const Se = ue(we, Ee);
      return toFailures(Se, Ee, this, we);
    } : this.validator = () => [], ce ? this.refiner = (we, Ee) => {
      const Se = ce(we, Ee);
      return toFailures(Se, Ee, this, we);
    } : this.refiner = () => [];
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(ie) {
    return assert$1(ie, this);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(ie) {
    return create(ie, this);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(ie) {
    return is(ie, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */
  mask(ie) {
    return mask(ie, this);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */
  validate(ie, se = {}) {
    return validate$1(ie, this, se);
  }
};
function assert$1(ae, ie) {
  const se = validate$1(ae, ie);
  if (se[0])
    throw se[0];
}
function create(ae, ie) {
  const se = validate$1(ae, ie, {
    coerce: !0
  });
  if (se[0])
    throw se[0];
  return se[1];
}
function mask(ae, ie) {
  const se = validate$1(ae, ie, {
    coerce: !0,
    mask: !0
  });
  if (se[0])
    throw se[0];
  return se[1];
}
function is(ae, ie) {
  return !validate$1(ae, ie)[0];
}
function validate$1(ae, ie, se = {}) {
  const fe = run(ae, ie, se), ue = shiftIterator(fe);
  return ue[0] ? [new StructError(ue[0], function* () {
    for (const de of fe)
      de[0] && (yield de[0]);
  }), void 0] : [void 0, ue[1]];
}
function define(ae, ie) {
  return new Struct$1({
    type: ae,
    schema: null,
    validator: ie
  });
}
function any() {
  return define("any", () => !0);
}
function array(ae) {
  return new Struct$1({
    type: "array",
    schema: ae,
    *entries(ie) {
      if (ae && Array.isArray(ie))
        for (const [se, fe] of ie.entries())
          yield [se, fe, ae];
    },
    coercer(ie) {
      return Array.isArray(ie) ? ie.slice() : ie;
    },
    validator(ie) {
      return Array.isArray(ie) || "Expected an array value, but received: " + print(ie);
    }
  });
}
function boolean() {
  return define("boolean", (ae) => typeof ae == "boolean");
}
function instance(ae) {
  return define("instance", (ie) => ie instanceof ae || "Expected a `" + ae.name + "` instance, but received: " + print(ie));
}
function literal(ae) {
  const ie = print(ae), se = typeof ae;
  return new Struct$1({
    type: "literal",
    schema: se === "string" || se === "number" || se === "boolean" ? ae : null,
    validator(fe) {
      return fe === ae || "Expected the literal `" + ie + "`, but received: " + print(fe);
    }
  });
}
function never() {
  return define("never", () => !1);
}
function nullable(ae) {
  return new Struct$1({
    ...ae,
    validator: (ie, se) => ie === null || ae.validator(ie, se),
    refiner: (ie, se) => ie === null || ae.refiner(ie, se)
  });
}
function number() {
  return define("number", (ae) => typeof ae == "number" && !isNaN(ae) || "Expected a number, but received: " + print(ae));
}
function optional(ae) {
  return new Struct$1({
    ...ae,
    validator: (ie, se) => ie === void 0 || ae.validator(ie, se),
    refiner: (ie, se) => ie === void 0 || ae.refiner(ie, se)
  });
}
function record(ae, ie) {
  return new Struct$1({
    type: "record",
    schema: null,
    *entries(se) {
      if (isObject$2(se))
        for (const fe in se) {
          const ue = se[fe];
          yield [fe, fe, ae], yield [fe, ue, ie];
        }
    },
    validator(se) {
      return isObject$2(se) || "Expected an object, but received: " + print(se);
    }
  });
}
function string() {
  return define("string", (ae) => typeof ae == "string" || "Expected a string, but received: " + print(ae));
}
function tuple(ae) {
  const ie = never();
  return new Struct$1({
    type: "tuple",
    schema: null,
    *entries(se) {
      if (Array.isArray(se)) {
        const fe = Math.max(ae.length, se.length);
        for (let ue = 0; ue < fe; ue++)
          yield [ue, se[ue], ae[ue] || ie];
      }
    },
    validator(se) {
      return Array.isArray(se) || "Expected an array, but received: " + print(se);
    }
  });
}
function type(ae) {
  const ie = Object.keys(ae);
  return new Struct$1({
    type: "type",
    schema: ae,
    *entries(se) {
      if (isObject$2(se))
        for (const fe of ie)
          yield [fe, se[fe], ae[fe]];
    },
    validator(se) {
      return isObject$2(se) || "Expected an object, but received: " + print(se);
    }
  });
}
function union(ae) {
  const ie = ae.map((se) => se.type).join(" | ");
  return new Struct$1({
    type: "union",
    schema: null,
    validator(se, fe) {
      const ue = [];
      for (const ce of ae) {
        const [...de] = run(se, ce, fe), [me] = de;
        if (me[0])
          for (const [we] of de)
            we && ue.push(we);
        else
          return [];
      }
      return ["Expected the value to satisfy a union of `" + ie + "`, but received: " + print(se), ...ue];
    }
  });
}
function unknown() {
  return define("unknown", () => !0);
}
function coerce(ae, ie, se) {
  return new Struct$1({
    ...ae,
    coercer: (fe, ue) => is(fe, ie) ? ae.coercer(se(fe, ue), ue) : ae.coercer(fe, ue)
  });
}
var getRandomValues$1, rnds8$1 = new Uint8Array(16);
function rng$1() {
  if (!getRandomValues$1 && (getRandomValues$1 = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !getRandomValues$1))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return getRandomValues$1(rnds8$1);
}
const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(ae) {
  return typeof ae == "string" && REGEX.test(ae);
}
var byteToHex$1 = [];
for (var i$9 = 0; i$9 < 256; ++i$9)
  byteToHex$1.push((i$9 + 256).toString(16).substr(1));
function stringify$1(ae) {
  var ie = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, se = (byteToHex$1[ae[ie + 0]] + byteToHex$1[ae[ie + 1]] + byteToHex$1[ae[ie + 2]] + byteToHex$1[ae[ie + 3]] + "-" + byteToHex$1[ae[ie + 4]] + byteToHex$1[ae[ie + 5]] + "-" + byteToHex$1[ae[ie + 6]] + byteToHex$1[ae[ie + 7]] + "-" + byteToHex$1[ae[ie + 8]] + byteToHex$1[ae[ie + 9]] + "-" + byteToHex$1[ae[ie + 10]] + byteToHex$1[ae[ie + 11]] + byteToHex$1[ae[ie + 12]] + byteToHex$1[ae[ie + 13]] + byteToHex$1[ae[ie + 14]] + byteToHex$1[ae[ie + 15]]).toLowerCase();
  if (!validate(se))
    throw TypeError("Stringified UUID is invalid");
  return se;
}
var _nodeId, _clockseq, _lastMSecs = 0, _lastNSecs = 0;
function v1(ae, ie, se) {
  var fe = ie && se || 0, ue = ie || new Array(16);
  ae = ae || {};
  var ce = ae.node || _nodeId, de = ae.clockseq !== void 0 ? ae.clockseq : _clockseq;
  if (ce == null || de == null) {
    var me = ae.random || (ae.rng || rng$1)();
    ce == null && (ce = _nodeId = [me[0] | 1, me[1], me[2], me[3], me[4], me[5]]), de == null && (de = _clockseq = (me[6] << 8 | me[7]) & 16383);
  }
  var we = ae.msecs !== void 0 ? ae.msecs : Date.now(), Ee = ae.nsecs !== void 0 ? ae.nsecs : _lastNSecs + 1, Se = we - _lastMSecs + (Ee - _lastNSecs) / 1e4;
  if (Se < 0 && ae.clockseq === void 0 && (de = de + 1 & 16383), (Se < 0 || we > _lastMSecs) && ae.nsecs === void 0 && (Ee = 0), Ee >= 1e4)
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  _lastMSecs = we, _lastNSecs = Ee, _clockseq = de, we += 122192928e5;
  var Be = ((we & 268435455) * 1e4 + Ee) % 4294967296;
  ue[fe++] = Be >>> 24 & 255, ue[fe++] = Be >>> 16 & 255, ue[fe++] = Be >>> 8 & 255, ue[fe++] = Be & 255;
  var Ce = we / 4294967296 * 1e4 & 268435455;
  ue[fe++] = Ce >>> 8 & 255, ue[fe++] = Ce & 255, ue[fe++] = Ce >>> 24 & 15 | 16, ue[fe++] = Ce >>> 16 & 255, ue[fe++] = de >>> 8 | 128, ue[fe++] = de & 255;
  for (var Ie = 0; Ie < 6; ++Ie)
    ue[fe + Ie] = ce[Ie];
  return ie || stringify$1(ue);
}
function parse(ae) {
  if (!validate(ae))
    throw TypeError("Invalid UUID");
  var ie, se = new Uint8Array(16);
  return se[0] = (ie = parseInt(ae.slice(0, 8), 16)) >>> 24, se[1] = ie >>> 16 & 255, se[2] = ie >>> 8 & 255, se[3] = ie & 255, se[4] = (ie = parseInt(ae.slice(9, 13), 16)) >>> 8, se[5] = ie & 255, se[6] = (ie = parseInt(ae.slice(14, 18), 16)) >>> 8, se[7] = ie & 255, se[8] = (ie = parseInt(ae.slice(19, 23), 16)) >>> 8, se[9] = ie & 255, se[10] = (ie = parseInt(ae.slice(24, 36), 16)) / 1099511627776 & 255, se[11] = ie / 4294967296 & 255, se[12] = ie >>> 24 & 255, se[13] = ie >>> 16 & 255, se[14] = ie >>> 8 & 255, se[15] = ie & 255, se;
}
function stringToBytes(ae) {
  ae = unescape(encodeURIComponent(ae));
  for (var ie = [], se = 0; se < ae.length; ++se)
    ie.push(ae.charCodeAt(se));
  return ie;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", URL$1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(ae, ie, se) {
  function fe(ue, ce, de, me) {
    if (typeof ue == "string" && (ue = stringToBytes(ue)), typeof ce == "string" && (ce = parse(ce)), ce.length !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    var we = new Uint8Array(16 + ue.length);
    if (we.set(ce), we.set(ue, ce.length), we = se(we), we[6] = we[6] & 15 | ie, we[8] = we[8] & 63 | 128, de) {
      me = me || 0;
      for (var Ee = 0; Ee < 16; ++Ee)
        de[me + Ee] = we[Ee];
      return de;
    }
    return stringify$1(we);
  }
  try {
    fe.name = ae;
  } catch {
  }
  return fe.DNS = DNS, fe.URL = URL$1, fe;
}
function md5(ae) {
  if (typeof ae == "string") {
    var ie = unescape(encodeURIComponent(ae));
    ae = new Uint8Array(ie.length);
    for (var se = 0; se < ie.length; ++se)
      ae[se] = ie.charCodeAt(se);
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(ae), ae.length * 8));
}
function md5ToHexEncodedArray(ae) {
  for (var ie = [], se = ae.length * 32, fe = "0123456789abcdef", ue = 0; ue < se; ue += 8) {
    var ce = ae[ue >> 5] >>> ue % 32 & 255, de = parseInt(fe.charAt(ce >>> 4 & 15) + fe.charAt(ce & 15), 16);
    ie.push(de);
  }
  return ie;
}
function getOutputLength(ae) {
  return (ae + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(ae, ie) {
  ae[ie >> 5] |= 128 << ie % 32, ae[getOutputLength(ie) - 1] = ie;
  for (var se = 1732584193, fe = -271733879, ue = -1732584194, ce = 271733878, de = 0; de < ae.length; de += 16) {
    var me = se, we = fe, Ee = ue, Se = ce;
    se = md5ff(se, fe, ue, ce, ae[de], 7, -680876936), ce = md5ff(ce, se, fe, ue, ae[de + 1], 12, -389564586), ue = md5ff(ue, ce, se, fe, ae[de + 2], 17, 606105819), fe = md5ff(fe, ue, ce, se, ae[de + 3], 22, -1044525330), se = md5ff(se, fe, ue, ce, ae[de + 4], 7, -176418897), ce = md5ff(ce, se, fe, ue, ae[de + 5], 12, 1200080426), ue = md5ff(ue, ce, se, fe, ae[de + 6], 17, -1473231341), fe = md5ff(fe, ue, ce, se, ae[de + 7], 22, -45705983), se = md5ff(se, fe, ue, ce, ae[de + 8], 7, 1770035416), ce = md5ff(ce, se, fe, ue, ae[de + 9], 12, -1958414417), ue = md5ff(ue, ce, se, fe, ae[de + 10], 17, -42063), fe = md5ff(fe, ue, ce, se, ae[de + 11], 22, -1990404162), se = md5ff(se, fe, ue, ce, ae[de + 12], 7, 1804603682), ce = md5ff(ce, se, fe, ue, ae[de + 13], 12, -40341101), ue = md5ff(ue, ce, se, fe, ae[de + 14], 17, -1502002290), fe = md5ff(fe, ue, ce, se, ae[de + 15], 22, 1236535329), se = md5gg(se, fe, ue, ce, ae[de + 1], 5, -165796510), ce = md5gg(ce, se, fe, ue, ae[de + 6], 9, -1069501632), ue = md5gg(ue, ce, se, fe, ae[de + 11], 14, 643717713), fe = md5gg(fe, ue, ce, se, ae[de], 20, -373897302), se = md5gg(se, fe, ue, ce, ae[de + 5], 5, -701558691), ce = md5gg(ce, se, fe, ue, ae[de + 10], 9, 38016083), ue = md5gg(ue, ce, se, fe, ae[de + 15], 14, -660478335), fe = md5gg(fe, ue, ce, se, ae[de + 4], 20, -405537848), se = md5gg(se, fe, ue, ce, ae[de + 9], 5, 568446438), ce = md5gg(ce, se, fe, ue, ae[de + 14], 9, -1019803690), ue = md5gg(ue, ce, se, fe, ae[de + 3], 14, -187363961), fe = md5gg(fe, ue, ce, se, ae[de + 8], 20, 1163531501), se = md5gg(se, fe, ue, ce, ae[de + 13], 5, -1444681467), ce = md5gg(ce, se, fe, ue, ae[de + 2], 9, -51403784), ue = md5gg(ue, ce, se, fe, ae[de + 7], 14, 1735328473), fe = md5gg(fe, ue, ce, se, ae[de + 12], 20, -1926607734), se = md5hh(se, fe, ue, ce, ae[de + 5], 4, -378558), ce = md5hh(ce, se, fe, ue, ae[de + 8], 11, -2022574463), ue = md5hh(ue, ce, se, fe, ae[de + 11], 16, 1839030562), fe = md5hh(fe, ue, ce, se, ae[de + 14], 23, -35309556), se = md5hh(se, fe, ue, ce, ae[de + 1], 4, -1530992060), ce = md5hh(ce, se, fe, ue, ae[de + 4], 11, 1272893353), ue = md5hh(ue, ce, se, fe, ae[de + 7], 16, -155497632), fe = md5hh(fe, ue, ce, se, ae[de + 10], 23, -1094730640), se = md5hh(se, fe, ue, ce, ae[de + 13], 4, 681279174), ce = md5hh(ce, se, fe, ue, ae[de], 11, -358537222), ue = md5hh(ue, ce, se, fe, ae[de + 3], 16, -722521979), fe = md5hh(fe, ue, ce, se, ae[de + 6], 23, 76029189), se = md5hh(se, fe, ue, ce, ae[de + 9], 4, -640364487), ce = md5hh(ce, se, fe, ue, ae[de + 12], 11, -421815835), ue = md5hh(ue, ce, se, fe, ae[de + 15], 16, 530742520), fe = md5hh(fe, ue, ce, se, ae[de + 2], 23, -995338651), se = md5ii(se, fe, ue, ce, ae[de], 6, -198630844), ce = md5ii(ce, se, fe, ue, ae[de + 7], 10, 1126891415), ue = md5ii(ue, ce, se, fe, ae[de + 14], 15, -1416354905), fe = md5ii(fe, ue, ce, se, ae[de + 5], 21, -57434055), se = md5ii(se, fe, ue, ce, ae[de + 12], 6, 1700485571), ce = md5ii(ce, se, fe, ue, ae[de + 3], 10, -1894986606), ue = md5ii(ue, ce, se, fe, ae[de + 10], 15, -1051523), fe = md5ii(fe, ue, ce, se, ae[de + 1], 21, -2054922799), se = md5ii(se, fe, ue, ce, ae[de + 8], 6, 1873313359), ce = md5ii(ce, se, fe, ue, ae[de + 15], 10, -30611744), ue = md5ii(ue, ce, se, fe, ae[de + 6], 15, -1560198380), fe = md5ii(fe, ue, ce, se, ae[de + 13], 21, 1309151649), se = md5ii(se, fe, ue, ce, ae[de + 4], 6, -145523070), ce = md5ii(ce, se, fe, ue, ae[de + 11], 10, -1120210379), ue = md5ii(ue, ce, se, fe, ae[de + 2], 15, 718787259), fe = md5ii(fe, ue, ce, se, ae[de + 9], 21, -343485551), se = safeAdd(se, me), fe = safeAdd(fe, we), ue = safeAdd(ue, Ee), ce = safeAdd(ce, Se);
  }
  return [se, fe, ue, ce];
}
function bytesToWords(ae) {
  if (ae.length === 0)
    return [];
  for (var ie = ae.length * 8, se = new Uint32Array(getOutputLength(ie)), fe = 0; fe < ie; fe += 8)
    se[fe >> 5] |= (ae[fe / 8] & 255) << fe % 32;
  return se;
}
function safeAdd(ae, ie) {
  var se = (ae & 65535) + (ie & 65535), fe = (ae >> 16) + (ie >> 16) + (se >> 16);
  return fe << 16 | se & 65535;
}
function bitRotateLeft(ae, ie) {
  return ae << ie | ae >>> 32 - ie;
}
function md5cmn(ae, ie, se, fe, ue, ce) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(ie, ae), safeAdd(fe, ce)), ue), se);
}
function md5ff(ae, ie, se, fe, ue, ce, de) {
  return md5cmn(ie & se | ~ie & fe, ae, ie, ue, ce, de);
}
function md5gg(ae, ie, se, fe, ue, ce, de) {
  return md5cmn(ie & fe | se & ~fe, ae, ie, ue, ce, de);
}
function md5hh(ae, ie, se, fe, ue, ce, de) {
  return md5cmn(ie ^ se ^ fe, ae, ie, ue, ce, de);
}
function md5ii(ae, ie, se, fe, ue, ce, de) {
  return md5cmn(se ^ (ie | ~fe), ae, ie, ue, ce, de);
}
var v3 = v35("v3", 48, md5);
const v3$1 = v3;
function v4$1(ae, ie, se) {
  ae = ae || {};
  var fe = ae.random || (ae.rng || rng$1)();
  if (fe[6] = fe[6] & 15 | 64, fe[8] = fe[8] & 63 | 128, ie) {
    se = se || 0;
    for (var ue = 0; ue < 16; ++ue)
      ie[se + ue] = fe[ue];
    return ie;
  }
  return stringify$1(fe);
}
function f$c(ae, ie, se, fe) {
  switch (ae) {
    case 0:
      return ie & se ^ ~ie & fe;
    case 1:
      return ie ^ se ^ fe;
    case 2:
      return ie & se ^ ie & fe ^ se & fe;
    case 3:
      return ie ^ se ^ fe;
  }
}
function ROTL(ae, ie) {
  return ae << ie | ae >>> 32 - ie;
}
function sha1(ae) {
  var ie = [1518500249, 1859775393, 2400959708, 3395469782], se = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof ae == "string") {
    var fe = unescape(encodeURIComponent(ae));
    ae = [];
    for (var ue = 0; ue < fe.length; ++ue)
      ae.push(fe.charCodeAt(ue));
  } else
    Array.isArray(ae) || (ae = Array.prototype.slice.call(ae));
  ae.push(128);
  for (var ce = ae.length / 4 + 2, de = Math.ceil(ce / 16), me = new Array(de), we = 0; we < de; ++we) {
    for (var Ee = new Uint32Array(16), Se = 0; Se < 16; ++Se)
      Ee[Se] = ae[we * 64 + Se * 4] << 24 | ae[we * 64 + Se * 4 + 1] << 16 | ae[we * 64 + Se * 4 + 2] << 8 | ae[we * 64 + Se * 4 + 3];
    me[we] = Ee;
  }
  me[de - 1][14] = (ae.length - 1) * 8 / Math.pow(2, 32), me[de - 1][14] = Math.floor(me[de - 1][14]), me[de - 1][15] = (ae.length - 1) * 8 & 4294967295;
  for (var Be = 0; Be < de; ++Be) {
    for (var Ce = new Uint32Array(80), Ie = 0; Ie < 16; ++Ie)
      Ce[Ie] = me[Be][Ie];
    for (var Pe = 16; Pe < 80; ++Pe)
      Ce[Pe] = ROTL(Ce[Pe - 3] ^ Ce[Pe - 8] ^ Ce[Pe - 14] ^ Ce[Pe - 16], 1);
    for (var Ne = se[0], ke = se[1], He = se[2], De = se[3], Ge = se[4], Ye = 0; Ye < 80; ++Ye) {
      var st = Math.floor(Ye / 20), at = ROTL(Ne, 5) + f$c(st, ke, He, De) + Ge + ie[st] + Ce[Ye] >>> 0;
      Ge = De, De = He, He = ROTL(ke, 30) >>> 0, ke = Ne, Ne = at;
    }
    se[0] = se[0] + Ne >>> 0, se[1] = se[1] + ke >>> 0, se[2] = se[2] + He >>> 0, se[3] = se[3] + De >>> 0, se[4] = se[4] + Ge >>> 0;
  }
  return [se[0] >> 24 & 255, se[0] >> 16 & 255, se[0] >> 8 & 255, se[0] & 255, se[1] >> 24 & 255, se[1] >> 16 & 255, se[1] >> 8 & 255, se[1] & 255, se[2] >> 24 & 255, se[2] >> 16 & 255, se[2] >> 8 & 255, se[2] & 255, se[3] >> 24 & 255, se[3] >> 16 & 255, se[3] >> 8 & 255, se[3] & 255, se[4] >> 24 & 255, se[4] >> 16 & 255, se[4] >> 8 & 255, se[4] & 255];
}
var v5 = v35("v5", 80, sha1);
const v5$1 = v5, nil = "00000000-0000-0000-0000-000000000000";
function version$2(ae) {
  if (!validate(ae))
    throw TypeError("Invalid UUID");
  return parseInt(ae.substr(14, 1), 16);
}
const esmBrowser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NIL: nil,
  parse,
  stringify: stringify$1,
  v1,
  v3: v3$1,
  v4: v4$1,
  v5: v5$1,
  validate,
  version: version$2
}, Symbol.toStringTag, { value: "Module" })), require$$0 = /* @__PURE__ */ getAugmentedNamespace(esmBrowser), uuid$1 = require$$0.v4, generateRequest$1 = function(ae, ie, se, fe) {
  if (typeof ae != "string")
    throw new TypeError(ae + " must be a string");
  fe = fe || {};
  const ue = typeof fe.version == "number" ? fe.version : 2;
  if (ue !== 1 && ue !== 2)
    throw new TypeError(ue + " must be 1 or 2");
  const ce = {
    method: ae
  };
  if (ue === 2 && (ce.jsonrpc = "2.0"), ie) {
    if (typeof ie != "object" && !Array.isArray(ie))
      throw new TypeError(ie + " must be an object, array or omitted");
    ce.params = ie;
  }
  if (typeof se > "u") {
    const de = typeof fe.generator == "function" ? fe.generator : function() {
      return uuid$1();
    };
    ce.id = de(ce, fe);
  } else
    ue === 2 && se === null ? fe.notificationIdNull && (ce.id = null) : ce.id = se;
  return ce;
};
var generateRequest_1 = generateRequest$1;
const uuid = require$$0.v4, generateRequest = generateRequest_1, ClientBrowser = function(ae, ie) {
  if (!(this instanceof ClientBrowser))
    return new ClientBrowser(ae, ie);
  ie || (ie = {}), this.options = {
    reviver: typeof ie.reviver < "u" ? ie.reviver : null,
    replacer: typeof ie.replacer < "u" ? ie.replacer : null,
    generator: typeof ie.generator < "u" ? ie.generator : function() {
      return uuid();
    },
    version: typeof ie.version < "u" ? ie.version : 2,
    notificationIdNull: typeof ie.notificationIdNull == "boolean" ? ie.notificationIdNull : !1
  }, this.callServer = ae;
};
var browser = ClientBrowser;
ClientBrowser.prototype.request = function(ae, ie, se, fe) {
  const ue = this;
  let ce = null;
  const de = Array.isArray(ae) && typeof ie == "function";
  if (this.options.version === 1 && de)
    throw new TypeError("JSON-RPC 1.0 does not support batching");
  if (de || !de && ae && typeof ae == "object" && typeof ie == "function")
    fe = ie, ce = ae;
  else {
    typeof se == "function" && (fe = se, se = void 0);
    const Ee = typeof fe == "function";
    try {
      ce = generateRequest(ae, ie, se, {
        generator: this.options.generator,
        version: this.options.version,
        notificationIdNull: this.options.notificationIdNull
      });
    } catch (Se) {
      if (Ee)
        return fe(Se);
      throw Se;
    }
    if (!Ee)
      return ce;
  }
  let we;
  try {
    we = JSON.stringify(ce, this.options.replacer);
  } catch (Ee) {
    return fe(Ee);
  }
  return this.callServer(we, function(Ee, Se) {
    ue._parseResponse(Ee, Se, fe);
  }), ce;
};
ClientBrowser.prototype._parseResponse = function(ae, ie, se) {
  if (ae) {
    se(ae);
    return;
  }
  if (!ie)
    return se();
  let fe;
  try {
    fe = JSON.parse(ie, this.options.reviver);
  } catch (ue) {
    return se(ue);
  }
  if (se.length === 3)
    if (Array.isArray(fe)) {
      const ue = function(de) {
        return typeof de.error < "u";
      }, ce = function(de) {
        return !ue(de);
      };
      return se(null, fe.filter(ue), fe.filter(ce));
    } else
      return se(null, fe.error, fe.result);
  se(null, fe);
};
const RpcClient = /* @__PURE__ */ getDefaultExportFromCjs$2(browser);
var client = {}, interopRequireDefault = { exports: {} };
(function(ae) {
  function ie(se) {
    return se && se.__esModule ? se : {
      default: se
    };
  }
  ae.exports = ie, ae.exports.__esModule = !0, ae.exports.default = ae.exports;
})(interopRequireDefault);
var interopRequireDefaultExports = interopRequireDefault.exports, regeneratorRuntime$1 = { exports: {} }, _typeof = { exports: {} }, hasRequired_typeof;
function require_typeof() {
  return hasRequired_typeof || (hasRequired_typeof = 1, function(ae) {
    function ie(se) {
      "@babel/helpers - typeof";
      return ae.exports = ie = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(fe) {
        return typeof fe;
      } : function(fe) {
        return fe && typeof Symbol == "function" && fe.constructor === Symbol && fe !== Symbol.prototype ? "symbol" : typeof fe;
      }, ae.exports.__esModule = !0, ae.exports.default = ae.exports, ie(se);
    }
    ae.exports = ie, ae.exports.__esModule = !0, ae.exports.default = ae.exports;
  }(_typeof)), _typeof.exports;
}
var hasRequiredRegeneratorRuntime;
function requireRegeneratorRuntime() {
  return hasRequiredRegeneratorRuntime || (hasRequiredRegeneratorRuntime = 1, function(ae) {
    var ie = require_typeof().default;
    function se() {
      ae.exports = se = function() {
        return ue;
      }, ae.exports.__esModule = !0, ae.exports.default = ae.exports;
      var fe, ue = {}, ce = Object.prototype, de = ce.hasOwnProperty, me = Object.defineProperty || function(ve, he, be) {
        ve[he] = be.value;
      }, we = typeof Symbol == "function" ? Symbol : {}, Ee = we.iterator || "@@iterator", Se = we.asyncIterator || "@@asyncIterator", Be = we.toStringTag || "@@toStringTag";
      function Ce(ve, he, be) {
        return Object.defineProperty(ve, he, {
          value: be,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }), ve[he];
      }
      try {
        Ce({}, "");
      } catch {
        Ce = function(be, Me, Re) {
          return be[Me] = Re;
        };
      }
      function Ie(ve, he, be, Me) {
        var Re = he && he.prototype instanceof Ye ? he : Ye, Oe = Object.create(Re.prototype), Te = new _e(Me || []);
        return me(Oe, "_invoke", {
          value: pe(ve, be, Te)
        }), Oe;
      }
      function Pe(ve, he, be) {
        try {
          return {
            type: "normal",
            arg: ve.call(he, be)
          };
        } catch (Me) {
          return {
            type: "throw",
            arg: Me
          };
        }
      }
      ue.wrap = Ie;
      var Ne = "suspendedStart", ke = "suspendedYield", He = "executing", De = "completed", Ge = {};
      function Ye() {
      }
      function st() {
      }
      function at() {
      }
      var mt = {};
      Ce(mt, Ee, function() {
        return this;
      });
      var qe = Object.getPrototypeOf, ze = qe && qe(qe(Ae([])));
      ze && ze !== ce && de.call(ze, Ee) && (mt = ze);
      var ot = at.prototype = Ye.prototype = Object.create(mt);
      function $e(ve) {
        ["next", "throw", "return"].forEach(function(he) {
          Ce(ve, he, function(be) {
            return this._invoke(he, be);
          });
        });
      }
      function le(ve, he) {
        function be(Re, Oe, Te, Fe) {
          var je = Pe(ve[Re], ve, Oe);
          if (je.type !== "throw") {
            var ct = je.arg, nt = ct.value;
            return nt && ie(nt) == "object" && de.call(nt, "__await") ? he.resolve(nt.__await).then(function(dt) {
              be("next", dt, Te, Fe);
            }, function(dt) {
              be("throw", dt, Te, Fe);
            }) : he.resolve(nt).then(function(dt) {
              ct.value = dt, Te(ct);
            }, function(dt) {
              return be("throw", dt, Te, Fe);
            });
          }
          Fe(je.arg);
        }
        var Me;
        me(this, "_invoke", {
          value: function(Oe, Te) {
            function Fe() {
              return new he(function(je, ct) {
                be(Oe, Te, je, ct);
              });
            }
            return Me = Me ? Me.then(Fe, Fe) : Fe();
          }
        });
      }
      function pe(ve, he, be) {
        var Me = Ne;
        return function(Re, Oe) {
          if (Me === He)
            throw new Error("Generator is already running");
          if (Me === De) {
            if (Re === "throw")
              throw Oe;
            return {
              value: fe,
              done: !0
            };
          }
          for (be.method = Re, be.arg = Oe; ; ) {
            var Te = be.delegate;
            if (Te) {
              var Fe = ge(Te, be);
              if (Fe) {
                if (Fe === Ge)
                  continue;
                return Fe;
              }
            }
            if (be.method === "next")
              be.sent = be._sent = be.arg;
            else if (be.method === "throw") {
              if (Me === Ne)
                throw Me = De, be.arg;
              be.dispatchException(be.arg);
            } else
              be.method === "return" && be.abrupt("return", be.arg);
            Me = He;
            var je = Pe(ve, he, be);
            if (je.type === "normal") {
              if (Me = be.done ? De : ke, je.arg === Ge)
                continue;
              return {
                value: je.arg,
                done: be.done
              };
            }
            je.type === "throw" && (Me = De, be.method = "throw", be.arg = je.arg);
          }
        };
      }
      function ge(ve, he) {
        var be = he.method, Me = ve.iterator[be];
        if (Me === fe)
          return he.delegate = null, be === "throw" && ve.iterator.return && (he.method = "return", he.arg = fe, ge(ve, he), he.method === "throw") || be !== "return" && (he.method = "throw", he.arg = new TypeError("The iterator does not provide a '" + be + "' method")), Ge;
        var Re = Pe(Me, ve.iterator, he.arg);
        if (Re.type === "throw")
          return he.method = "throw", he.arg = Re.arg, he.delegate = null, Ge;
        var Oe = Re.arg;
        return Oe ? Oe.done ? (he[ve.resultName] = Oe.value, he.next = ve.nextLoc, he.method !== "return" && (he.method = "next", he.arg = fe), he.delegate = null, Ge) : Oe : (he.method = "throw", he.arg = new TypeError("iterator result is not an object"), he.delegate = null, Ge);
      }
      function ye(ve) {
        var he = {
          tryLoc: ve[0]
        };
        1 in ve && (he.catchLoc = ve[1]), 2 in ve && (he.finallyLoc = ve[2], he.afterLoc = ve[3]), this.tryEntries.push(he);
      }
      function xe(ve) {
        var he = ve.completion || {};
        he.type = "normal", delete he.arg, ve.completion = he;
      }
      function _e(ve) {
        this.tryEntries = [{
          tryLoc: "root"
        }], ve.forEach(ye, this), this.reset(!0);
      }
      function Ae(ve) {
        if (ve || ve === "") {
          var he = ve[Ee];
          if (he)
            return he.call(ve);
          if (typeof ve.next == "function")
            return ve;
          if (!isNaN(ve.length)) {
            var be = -1, Me = function Re() {
              for (; ++be < ve.length; )
                if (de.call(ve, be))
                  return Re.value = ve[be], Re.done = !1, Re;
              return Re.value = fe, Re.done = !0, Re;
            };
            return Me.next = Me;
          }
        }
        throw new TypeError(ie(ve) + " is not iterable");
      }
      return st.prototype = at, me(ot, "constructor", {
        value: at,
        configurable: !0
      }), me(at, "constructor", {
        value: st,
        configurable: !0
      }), st.displayName = Ce(at, Be, "GeneratorFunction"), ue.isGeneratorFunction = function(ve) {
        var he = typeof ve == "function" && ve.constructor;
        return !!he && (he === st || (he.displayName || he.name) === "GeneratorFunction");
      }, ue.mark = function(ve) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(ve, at) : (ve.__proto__ = at, Ce(ve, Be, "GeneratorFunction")), ve.prototype = Object.create(ot), ve;
      }, ue.awrap = function(ve) {
        return {
          __await: ve
        };
      }, $e(le.prototype), Ce(le.prototype, Se, function() {
        return this;
      }), ue.AsyncIterator = le, ue.async = function(ve, he, be, Me, Re) {
        Re === void 0 && (Re = Promise);
        var Oe = new le(Ie(ve, he, be, Me), Re);
        return ue.isGeneratorFunction(he) ? Oe : Oe.next().then(function(Te) {
          return Te.done ? Te.value : Oe.next();
        });
      }, $e(ot), Ce(ot, Be, "Generator"), Ce(ot, Ee, function() {
        return this;
      }), Ce(ot, "toString", function() {
        return "[object Generator]";
      }), ue.keys = function(ve) {
        var he = Object(ve), be = [];
        for (var Me in he)
          be.push(Me);
        return be.reverse(), function Re() {
          for (; be.length; ) {
            var Oe = be.pop();
            if (Oe in he)
              return Re.value = Oe, Re.done = !1, Re;
          }
          return Re.done = !0, Re;
        };
      }, ue.values = Ae, _e.prototype = {
        constructor: _e,
        reset: function(he) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = fe, this.done = !1, this.delegate = null, this.method = "next", this.arg = fe, this.tryEntries.forEach(xe), !he)
            for (var be in this)
              be.charAt(0) === "t" && de.call(this, be) && !isNaN(+be.slice(1)) && (this[be] = fe);
        },
        stop: function() {
          this.done = !0;
          var he = this.tryEntries[0].completion;
          if (he.type === "throw")
            throw he.arg;
          return this.rval;
        },
        dispatchException: function(he) {
          if (this.done)
            throw he;
          var be = this;
          function Me(ct, nt) {
            return Te.type = "throw", Te.arg = he, be.next = ct, nt && (be.method = "next", be.arg = fe), !!nt;
          }
          for (var Re = this.tryEntries.length - 1; Re >= 0; --Re) {
            var Oe = this.tryEntries[Re], Te = Oe.completion;
            if (Oe.tryLoc === "root")
              return Me("end");
            if (Oe.tryLoc <= this.prev) {
              var Fe = de.call(Oe, "catchLoc"), je = de.call(Oe, "finallyLoc");
              if (Fe && je) {
                if (this.prev < Oe.catchLoc)
                  return Me(Oe.catchLoc, !0);
                if (this.prev < Oe.finallyLoc)
                  return Me(Oe.finallyLoc);
              } else if (Fe) {
                if (this.prev < Oe.catchLoc)
                  return Me(Oe.catchLoc, !0);
              } else {
                if (!je)
                  throw new Error("try statement without catch or finally");
                if (this.prev < Oe.finallyLoc)
                  return Me(Oe.finallyLoc);
              }
            }
          }
        },
        abrupt: function(he, be) {
          for (var Me = this.tryEntries.length - 1; Me >= 0; --Me) {
            var Re = this.tryEntries[Me];
            if (Re.tryLoc <= this.prev && de.call(Re, "finallyLoc") && this.prev < Re.finallyLoc) {
              var Oe = Re;
              break;
            }
          }
          Oe && (he === "break" || he === "continue") && Oe.tryLoc <= be && be <= Oe.finallyLoc && (Oe = null);
          var Te = Oe ? Oe.completion : {};
          return Te.type = he, Te.arg = be, Oe ? (this.method = "next", this.next = Oe.finallyLoc, Ge) : this.complete(Te);
        },
        complete: function(he, be) {
          if (he.type === "throw")
            throw he.arg;
          return he.type === "break" || he.type === "continue" ? this.next = he.arg : he.type === "return" ? (this.rval = this.arg = he.arg, this.method = "return", this.next = "end") : he.type === "normal" && be && (this.next = be), Ge;
        },
        finish: function(he) {
          for (var be = this.tryEntries.length - 1; be >= 0; --be) {
            var Me = this.tryEntries[be];
            if (Me.finallyLoc === he)
              return this.complete(Me.completion, Me.afterLoc), xe(Me), Ge;
          }
        },
        catch: function(he) {
          for (var be = this.tryEntries.length - 1; be >= 0; --be) {
            var Me = this.tryEntries[be];
            if (Me.tryLoc === he) {
              var Re = Me.completion;
              if (Re.type === "throw") {
                var Oe = Re.arg;
                xe(Me);
              }
              return Oe;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function(he, be, Me) {
          return this.delegate = {
            iterator: Ae(he),
            resultName: be,
            nextLoc: Me
          }, this.method === "next" && (this.arg = fe), Ge;
        }
      }, ue;
    }
    ae.exports = se, ae.exports.__esModule = !0, ae.exports.default = ae.exports;
  }(regeneratorRuntime$1)), regeneratorRuntime$1.exports;
}
var regenerator, hasRequiredRegenerator;
function requireRegenerator() {
  if (hasRequiredRegenerator)
    return regenerator;
  hasRequiredRegenerator = 1;
  var ae = requireRegeneratorRuntime()();
  regenerator = ae;
  try {
    regeneratorRuntime = ae;
  } catch {
    typeof globalThis == "object" ? globalThis.regeneratorRuntime = ae : Function("r", "regeneratorRuntime = r")(ae);
  }
  return regenerator;
}
var asyncToGenerator = { exports: {} }, hasRequiredAsyncToGenerator;
function requireAsyncToGenerator() {
  return hasRequiredAsyncToGenerator || (hasRequiredAsyncToGenerator = 1, function(ae) {
    function ie(fe, ue, ce, de, me, we, Ee) {
      try {
        var Se = fe[we](Ee), Be = Se.value;
      } catch (Ce) {
        ce(Ce);
        return;
      }
      Se.done ? ue(Be) : Promise.resolve(Be).then(de, me);
    }
    function se(fe) {
      return function() {
        var ue = this, ce = arguments;
        return new Promise(function(de, me) {
          var we = fe.apply(ue, ce);
          function Ee(Be) {
            ie(we, de, me, Ee, Se, "next", Be);
          }
          function Se(Be) {
            ie(we, de, me, Ee, Se, "throw", Be);
          }
          Ee(void 0);
        });
      };
    }
    ae.exports = se, ae.exports.__esModule = !0, ae.exports.default = ae.exports;
  }(asyncToGenerator)), asyncToGenerator.exports;
}
var classCallCheck = { exports: {} }, hasRequiredClassCallCheck;
function requireClassCallCheck() {
  return hasRequiredClassCallCheck || (hasRequiredClassCallCheck = 1, function(ae) {
    function ie(se, fe) {
      if (!(se instanceof fe))
        throw new TypeError("Cannot call a class as a function");
    }
    ae.exports = ie, ae.exports.__esModule = !0, ae.exports.default = ae.exports;
  }(classCallCheck)), classCallCheck.exports;
}
var createClass = { exports: {} }, toPropertyKey = { exports: {} }, toPrimitive = { exports: {} }, hasRequiredToPrimitive;
function requireToPrimitive() {
  return hasRequiredToPrimitive || (hasRequiredToPrimitive = 1, function(ae) {
    var ie = require_typeof().default;
    function se(fe, ue) {
      if (ie(fe) != "object" || !fe)
        return fe;
      var ce = fe[Symbol.toPrimitive];
      if (ce !== void 0) {
        var de = ce.call(fe, ue || "default");
        if (ie(de) != "object")
          return de;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (ue === "string" ? String : Number)(fe);
    }
    ae.exports = se, ae.exports.__esModule = !0, ae.exports.default = ae.exports;
  }(toPrimitive)), toPrimitive.exports;
}
var hasRequiredToPropertyKey;
function requireToPropertyKey() {
  return hasRequiredToPropertyKey || (hasRequiredToPropertyKey = 1, function(ae) {
    var ie = require_typeof().default, se = requireToPrimitive();
    function fe(ue) {
      var ce = se(ue, "string");
      return ie(ce) == "symbol" ? ce : String(ce);
    }
    ae.exports = fe, ae.exports.__esModule = !0, ae.exports.default = ae.exports;
  }(toPropertyKey)), toPropertyKey.exports;
}
var hasRequiredCreateClass;
function requireCreateClass() {
  return hasRequiredCreateClass || (hasRequiredCreateClass = 1, function(ae) {
    var ie = requireToPropertyKey();
    function se(ue, ce) {
      for (var de = 0; de < ce.length; de++) {
        var me = ce[de];
        me.enumerable = me.enumerable || !1, me.configurable = !0, "value" in me && (me.writable = !0), Object.defineProperty(ue, ie(me.key), me);
      }
    }
    function fe(ue, ce, de) {
      return ce && se(ue.prototype, ce), de && se(ue, de), Object.defineProperty(ue, "prototype", {
        writable: !1
      }), ue;
    }
    ae.exports = fe, ae.exports.__esModule = !0, ae.exports.default = ae.exports;
  }(createClass)), createClass.exports;
}
var inherits$1 = { exports: {} }, setPrototypeOf = { exports: {} }, hasRequiredSetPrototypeOf;
function requireSetPrototypeOf() {
  return hasRequiredSetPrototypeOf || (hasRequiredSetPrototypeOf = 1, function(ae) {
    function ie(se, fe) {
      return ae.exports = ie = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(ce, de) {
        return ce.__proto__ = de, ce;
      }, ae.exports.__esModule = !0, ae.exports.default = ae.exports, ie(se, fe);
    }
    ae.exports = ie, ae.exports.__esModule = !0, ae.exports.default = ae.exports;
  }(setPrototypeOf)), setPrototypeOf.exports;
}
var hasRequiredInherits;
function requireInherits() {
  return hasRequiredInherits || (hasRequiredInherits = 1, function(ae) {
    var ie = requireSetPrototypeOf();
    function se(fe, ue) {
      if (typeof ue != "function" && ue !== null)
        throw new TypeError("Super expression must either be null or a function");
      fe.prototype = Object.create(ue && ue.prototype, {
        constructor: {
          value: fe,
          writable: !0,
          configurable: !0
        }
      }), Object.defineProperty(fe, "prototype", {
        writable: !1
      }), ue && ie(fe, ue);
    }
    ae.exports = se, ae.exports.__esModule = !0, ae.exports.default = ae.exports;
  }(inherits$1)), inherits$1.exports;
}
var possibleConstructorReturn = { exports: {} }, assertThisInitialized = { exports: {} }, hasRequiredAssertThisInitialized;
function requireAssertThisInitialized() {
  return hasRequiredAssertThisInitialized || (hasRequiredAssertThisInitialized = 1, function(ae) {
    function ie(se) {
      if (se === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return se;
    }
    ae.exports = ie, ae.exports.__esModule = !0, ae.exports.default = ae.exports;
  }(assertThisInitialized)), assertThisInitialized.exports;
}
var hasRequiredPossibleConstructorReturn;
function requirePossibleConstructorReturn() {
  return hasRequiredPossibleConstructorReturn || (hasRequiredPossibleConstructorReturn = 1, function(ae) {
    var ie = require_typeof().default, se = requireAssertThisInitialized();
    function fe(ue, ce) {
      if (ce && (ie(ce) === "object" || typeof ce == "function"))
        return ce;
      if (ce !== void 0)
        throw new TypeError("Derived constructors may only return object or undefined");
      return se(ue);
    }
    ae.exports = fe, ae.exports.__esModule = !0, ae.exports.default = ae.exports;
  }(possibleConstructorReturn)), possibleConstructorReturn.exports;
}
var getPrototypeOf$1 = { exports: {} }, hasRequiredGetPrototypeOf;
function requireGetPrototypeOf() {
  return hasRequiredGetPrototypeOf || (hasRequiredGetPrototypeOf = 1, function(ae) {
    function ie(se) {
      return ae.exports = ie = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(ue) {
        return ue.__proto__ || Object.getPrototypeOf(ue);
      }, ae.exports.__esModule = !0, ae.exports.default = ae.exports, ie(se);
    }
    ae.exports = ie, ae.exports.__esModule = !0, ae.exports.default = ae.exports;
  }(getPrototypeOf$1)), getPrototypeOf$1.exports;
}
var eventemitter3$2 = { exports: {} }, hasRequiredEventemitter3;
function requireEventemitter3() {
  return hasRequiredEventemitter3 || (hasRequiredEventemitter3 = 1, function(ae) {
    var ie = Object.prototype.hasOwnProperty, se = "~";
    function fe() {
    }
    Object.create && (fe.prototype = /* @__PURE__ */ Object.create(null), new fe().__proto__ || (se = !1));
    function ue(we, Ee, Se) {
      this.fn = we, this.context = Ee, this.once = Se || !1;
    }
    function ce(we, Ee, Se, Be, Ce) {
      if (typeof Se != "function")
        throw new TypeError("The listener must be a function");
      var Ie = new ue(Se, Be || we, Ce), Pe = se ? se + Ee : Ee;
      return we._events[Pe] ? we._events[Pe].fn ? we._events[Pe] = [we._events[Pe], Ie] : we._events[Pe].push(Ie) : (we._events[Pe] = Ie, we._eventsCount++), we;
    }
    function de(we, Ee) {
      --we._eventsCount === 0 ? we._events = new fe() : delete we._events[Ee];
    }
    function me() {
      this._events = new fe(), this._eventsCount = 0;
    }
    me.prototype.eventNames = function() {
      var Ee = [], Se, Be;
      if (this._eventsCount === 0)
        return Ee;
      for (Be in Se = this._events)
        ie.call(Se, Be) && Ee.push(se ? Be.slice(1) : Be);
      return Object.getOwnPropertySymbols ? Ee.concat(Object.getOwnPropertySymbols(Se)) : Ee;
    }, me.prototype.listeners = function(Ee) {
      var Se = se ? se + Ee : Ee, Be = this._events[Se];
      if (!Be)
        return [];
      if (Be.fn)
        return [Be.fn];
      for (var Ce = 0, Ie = Be.length, Pe = new Array(Ie); Ce < Ie; Ce++)
        Pe[Ce] = Be[Ce].fn;
      return Pe;
    }, me.prototype.listenerCount = function(Ee) {
      var Se = se ? se + Ee : Ee, Be = this._events[Se];
      return Be ? Be.fn ? 1 : Be.length : 0;
    }, me.prototype.emit = function(Ee, Se, Be, Ce, Ie, Pe) {
      var Ne = se ? se + Ee : Ee;
      if (!this._events[Ne])
        return !1;
      var ke = this._events[Ne], He = arguments.length, De, Ge;
      if (ke.fn) {
        switch (ke.once && this.removeListener(Ee, ke.fn, void 0, !0), He) {
          case 1:
            return ke.fn.call(ke.context), !0;
          case 2:
            return ke.fn.call(ke.context, Se), !0;
          case 3:
            return ke.fn.call(ke.context, Se, Be), !0;
          case 4:
            return ke.fn.call(ke.context, Se, Be, Ce), !0;
          case 5:
            return ke.fn.call(ke.context, Se, Be, Ce, Ie), !0;
          case 6:
            return ke.fn.call(ke.context, Se, Be, Ce, Ie, Pe), !0;
        }
        for (Ge = 1, De = new Array(He - 1); Ge < He; Ge++)
          De[Ge - 1] = arguments[Ge];
        ke.fn.apply(ke.context, De);
      } else {
        var Ye = ke.length, st;
        for (Ge = 0; Ge < Ye; Ge++)
          switch (ke[Ge].once && this.removeListener(Ee, ke[Ge].fn, void 0, !0), He) {
            case 1:
              ke[Ge].fn.call(ke[Ge].context);
              break;
            case 2:
              ke[Ge].fn.call(ke[Ge].context, Se);
              break;
            case 3:
              ke[Ge].fn.call(ke[Ge].context, Se, Be);
              break;
            case 4:
              ke[Ge].fn.call(ke[Ge].context, Se, Be, Ce);
              break;
            default:
              if (!De)
                for (st = 1, De = new Array(He - 1); st < He; st++)
                  De[st - 1] = arguments[st];
              ke[Ge].fn.apply(ke[Ge].context, De);
          }
      }
      return !0;
    }, me.prototype.on = function(Ee, Se, Be) {
      return ce(this, Ee, Se, Be, !1);
    }, me.prototype.once = function(Ee, Se, Be) {
      return ce(this, Ee, Se, Be, !0);
    }, me.prototype.removeListener = function(Ee, Se, Be, Ce) {
      var Ie = se ? se + Ee : Ee;
      if (!this._events[Ie])
        return this;
      if (!Se)
        return de(this, Ie), this;
      var Pe = this._events[Ie];
      if (Pe.fn)
        Pe.fn === Se && (!Ce || Pe.once) && (!Be || Pe.context === Be) && de(this, Ie);
      else {
        for (var Ne = 0, ke = [], He = Pe.length; Ne < He; Ne++)
          (Pe[Ne].fn !== Se || Ce && !Pe[Ne].once || Be && Pe[Ne].context !== Be) && ke.push(Pe[Ne]);
        ke.length ? this._events[Ie] = ke.length === 1 ? ke[0] : ke : de(this, Ie);
      }
      return this;
    }, me.prototype.removeAllListeners = function(Ee) {
      var Se;
      return Ee ? (Se = se ? se + Ee : Ee, this._events[Se] && de(this, Se)) : (this._events = new fe(), this._eventsCount = 0), this;
    }, me.prototype.off = me.prototype.removeListener, me.prototype.addListener = me.prototype.on, me.prefixed = se, me.EventEmitter = me, ae.exports = me;
  }(eventemitter3$2)), eventemitter3$2.exports;
}
var utils$2 = {}, hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils)
    return utils$2;
  hasRequiredUtils = 1;
  var ae = interopRequireDefaultExports;
  Object.defineProperty(utils$2, "__esModule", {
    value: !0
  }), utils$2.DefaultDataPack = void 0, utils$2.createError = ce;
  var ie = ae(requireClassCallCheck()), se = ae(requireCreateClass()), fe = /* @__PURE__ */ new Map([[-32e3, "Event not provided"], [-32600, "Invalid Request"], [-32601, "Method not found"], [-32602, "Invalid params"], [-32603, "Internal error"], [-32604, "Params not found"], [-32605, "Method forbidden"], [-32606, "Event forbidden"], [-32700, "Parse error"]]), ue = /* @__PURE__ */ function() {
    function de() {
      (0, ie.default)(this, de);
    }
    return (0, se.default)(de, [{
      key: "encode",
      value: function(we) {
        return JSON.stringify(we);
      }
    }, {
      key: "decode",
      value: function(we) {
        return JSON.parse(we);
      }
    }]), de;
  }();
  utils$2.DefaultDataPack = ue;
  function ce(de, me) {
    var we = {
      code: de,
      message: fe.get(de) || "Internal Server Error"
    };
    return me && (we.data = me), we;
  }
  return utils$2;
}
(function(ae) {
  var ie = interopRequireDefaultExports;
  Object.defineProperty(ae, "__esModule", {
    value: !0
  }), ae.default = void 0;
  var se = ie(requireRegenerator()), fe = ie(requireAsyncToGenerator()), ue = ie(require_typeof()), ce = ie(requireClassCallCheck()), de = ie(requireCreateClass()), me = ie(requireInherits()), we = ie(requirePossibleConstructorReturn()), Ee = ie(requireGetPrototypeOf()), Se = requireEventemitter3(), Be = requireUtils();
  function Ce(ke) {
    var He = Ie();
    return function() {
      var Ge = (0, Ee.default)(ke), Ye;
      if (He) {
        var st = (0, Ee.default)(this).constructor;
        Ye = Reflect.construct(Ge, arguments, st);
      } else
        Ye = Ge.apply(this, arguments);
      return (0, we.default)(this, Ye);
    };
  }
  function Ie() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function")
      return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  var Pe = function(ke, He) {
    var De = {};
    for (var Ge in ke)
      Object.prototype.hasOwnProperty.call(ke, Ge) && He.indexOf(Ge) < 0 && (De[Ge] = ke[Ge]);
    if (ke != null && typeof Object.getOwnPropertySymbols == "function")
      for (var Ye = 0, Ge = Object.getOwnPropertySymbols(ke); Ye < Ge.length; Ye++)
        He.indexOf(Ge[Ye]) < 0 && Object.prototype.propertyIsEnumerable.call(ke, Ge[Ye]) && (De[Ge[Ye]] = ke[Ge[Ye]]);
    return De;
  }, Ne = /* @__PURE__ */ function(ke) {
    (0, me.default)(De, ke);
    var He = Ce(De);
    function De(Ge) {
      var Ye, st = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "ws://localhost:8080", at = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, mt = arguments.length > 3 ? arguments[3] : void 0, qe = arguments.length > 4 ? arguments[4] : void 0;
      (0, ce.default)(this, De);
      var ze = at.autoconnect, ot = ze === void 0 ? !0 : ze, $e = at.reconnect, le = $e === void 0 ? !0 : $e, pe = at.reconnect_interval, ge = pe === void 0 ? 1e3 : pe, ye = at.max_reconnects, xe = ye === void 0 ? 5 : ye, _e = Pe(at, ["autoconnect", "reconnect", "reconnect_interval", "max_reconnects"]);
      return Ye = He.call(this), Ye.webSocketFactory = Ge, Ye.queue = {}, Ye.rpc_id = 0, Ye.address = st, Ye.autoconnect = ot, Ye.ready = !1, Ye.reconnect = le, Ye.reconnect_timer_id = void 0, Ye.reconnect_interval = ge, Ye.max_reconnects = xe, Ye.rest_options = _e, Ye.current_reconnects = 0, Ye.generate_request_id = mt || function() {
        return ++Ye.rpc_id;
      }, qe ? Ye.dataPack = qe : Ye.dataPack = new Be.DefaultDataPack(), Ye.autoconnect && Ye._connect(Ye.address, Object.assign({
        autoconnect: Ye.autoconnect,
        reconnect: Ye.reconnect,
        reconnect_interval: Ye.reconnect_interval,
        max_reconnects: Ye.max_reconnects
      }, Ye.rest_options)), Ye;
    }
    return (0, de.default)(De, [{
      key: "connect",
      value: function() {
        this.socket || this._connect(this.address, Object.assign({
          autoconnect: this.autoconnect,
          reconnect: this.reconnect,
          reconnect_interval: this.reconnect_interval,
          max_reconnects: this.max_reconnects
        }, this.rest_options));
      }
      /**
       * Calls a registered RPC method on server.
       * @method
       * @param {String} method - RPC method name
       * @param {Object|Array} params - optional method parameters
       * @param {Number} timeout - RPC reply timeout value
       * @param {Object} ws_opts - options passed to ws
       * @return {Promise}
       */
    }, {
      key: "call",
      value: function(Ye, st, at, mt) {
        var qe = this;
        return !mt && (0, ue.default)(at) === "object" && (mt = at, at = null), new Promise(function(ze, ot) {
          if (!qe.ready)
            return ot(new Error("socket not ready"));
          var $e = qe.generate_request_id(Ye, st), le = {
            jsonrpc: "2.0",
            method: Ye,
            params: st || void 0,
            id: $e
          };
          qe.socket.send(qe.dataPack.encode(le), mt, function(pe) {
            if (pe)
              return ot(pe);
            qe.queue[$e] = {
              promise: [ze, ot]
            }, at && (qe.queue[$e].timeout = setTimeout(function() {
              delete qe.queue[$e], ot(new Error("reply timeout"));
            }, at));
          });
        });
      }
      /**
       * Logins with the other side of the connection.
       * @method
       * @param {Object} params - Login credentials object
       * @return {Promise}
       */
    }, {
      key: "login",
      value: function() {
        var Ge = (0, fe.default)(/* @__PURE__ */ se.default.mark(function st(at) {
          var mt;
          return se.default.wrap(function(ze) {
            for (; ; )
              switch (ze.prev = ze.next) {
                case 0:
                  return ze.next = 2, this.call("rpc.login", at);
                case 2:
                  if (mt = ze.sent, mt) {
                    ze.next = 5;
                    break;
                  }
                  throw new Error("authentication failed");
                case 5:
                  return ze.abrupt("return", mt);
                case 6:
                case "end":
                  return ze.stop();
              }
          }, st, this);
        }));
        function Ye(st) {
          return Ge.apply(this, arguments);
        }
        return Ye;
      }()
      /**
       * Fetches a list of client's methods registered on server.
       * @method
       * @return {Array}
       */
    }, {
      key: "listMethods",
      value: function() {
        var Ge = (0, fe.default)(/* @__PURE__ */ se.default.mark(function st() {
          return se.default.wrap(function(mt) {
            for (; ; )
              switch (mt.prev = mt.next) {
                case 0:
                  return mt.next = 2, this.call("__listMethods");
                case 2:
                  return mt.abrupt("return", mt.sent);
                case 3:
                case "end":
                  return mt.stop();
              }
          }, st, this);
        }));
        function Ye() {
          return Ge.apply(this, arguments);
        }
        return Ye;
      }()
      /**
       * Sends a JSON-RPC 2.0 notification to server.
       * @method
       * @param {String} method - RPC method name
       * @param {Object} params - optional method parameters
       * @return {Promise}
       */
    }, {
      key: "notify",
      value: function(Ye, st) {
        var at = this;
        return new Promise(function(mt, qe) {
          if (!at.ready)
            return qe(new Error("socket not ready"));
          var ze = {
            jsonrpc: "2.0",
            method: Ye,
            params: st
          };
          at.socket.send(at.dataPack.encode(ze), function(ot) {
            if (ot)
              return qe(ot);
            mt();
          });
        });
      }
      /**
       * Subscribes for a defined event.
       * @method
       * @param {String|Array} event - event name
       * @return {Undefined}
       * @throws {Error}
       */
    }, {
      key: "subscribe",
      value: function() {
        var Ge = (0, fe.default)(/* @__PURE__ */ se.default.mark(function st(at) {
          var mt;
          return se.default.wrap(function(ze) {
            for (; ; )
              switch (ze.prev = ze.next) {
                case 0:
                  return typeof at == "string" && (at = [at]), ze.next = 3, this.call("rpc.on", at);
                case 3:
                  if (mt = ze.sent, !(typeof at == "string" && mt[at] !== "ok")) {
                    ze.next = 6;
                    break;
                  }
                  throw new Error("Failed subscribing to an event '" + at + "' with: " + mt[at]);
                case 6:
                  return ze.abrupt("return", mt);
                case 7:
                case "end":
                  return ze.stop();
              }
          }, st, this);
        }));
        function Ye(st) {
          return Ge.apply(this, arguments);
        }
        return Ye;
      }()
      /**
       * Unsubscribes from a defined event.
       * @method
       * @param {String|Array} event - event name
       * @return {Undefined}
       * @throws {Error}
       */
    }, {
      key: "unsubscribe",
      value: function() {
        var Ge = (0, fe.default)(/* @__PURE__ */ se.default.mark(function st(at) {
          var mt;
          return se.default.wrap(function(ze) {
            for (; ; )
              switch (ze.prev = ze.next) {
                case 0:
                  return typeof at == "string" && (at = [at]), ze.next = 3, this.call("rpc.off", at);
                case 3:
                  if (mt = ze.sent, !(typeof at == "string" && mt[at] !== "ok")) {
                    ze.next = 6;
                    break;
                  }
                  throw new Error("Failed unsubscribing from an event with: " + mt);
                case 6:
                  return ze.abrupt("return", mt);
                case 7:
                case "end":
                  return ze.stop();
              }
          }, st, this);
        }));
        function Ye(st) {
          return Ge.apply(this, arguments);
        }
        return Ye;
      }()
      /**
       * Closes a WebSocket connection gracefully.
       * @method
       * @param {Number} code - socket close code
       * @param {String} data - optional data to be sent before closing
       * @return {Undefined}
       */
    }, {
      key: "close",
      value: function(Ye, st) {
        this.socket.close(Ye || 1e3, st);
      }
      /**
       * Connection/Message handler.
       * @method
       * @private
       * @param {String} address - WebSocket API address
       * @param {Object} options - ws options object
       * @return {Undefined}
       */
    }, {
      key: "_connect",
      value: function(Ye, st) {
        var at = this;
        clearTimeout(this.reconnect_timer_id), this.socket = this.webSocketFactory(Ye, st), this.socket.addEventListener("open", function() {
          at.ready = !0, at.emit("open"), at.current_reconnects = 0;
        }), this.socket.addEventListener("message", function(mt) {
          var qe = mt.data;
          qe instanceof ArrayBuffer && (qe = Buffer$F.from(qe).toString());
          try {
            qe = at.dataPack.decode(qe);
          } catch {
            return;
          }
          if (qe.notification && at.listeners(qe.notification).length) {
            if (!Object.keys(qe.params).length)
              return at.emit(qe.notification);
            var ze = [qe.notification];
            if (qe.params.constructor === Object)
              ze.push(qe.params);
            else
              for (var ot = 0; ot < qe.params.length; ot++)
                ze.push(qe.params[ot]);
            return Promise.resolve().then(function() {
              at.emit.apply(at, ze);
            });
          }
          if (!at.queue[qe.id])
            return qe.method ? Promise.resolve().then(function() {
              at.emit(qe.method, qe?.params);
            }) : void 0;
          "error" in qe == "result" in qe && at.queue[qe.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')), at.queue[qe.id].timeout && clearTimeout(at.queue[qe.id].timeout), qe.error ? at.queue[qe.id].promise[1](qe.error) : at.queue[qe.id].promise[0](qe.result), delete at.queue[qe.id];
        }), this.socket.addEventListener("error", function(mt) {
          return at.emit("error", mt);
        }), this.socket.addEventListener("close", function(mt) {
          var qe = mt.code, ze = mt.reason;
          at.ready && setTimeout(function() {
            return at.emit("close", qe, ze);
          }, 0), at.ready = !1, at.socket = void 0, qe !== 1e3 && (at.current_reconnects++, at.reconnect && (at.max_reconnects > at.current_reconnects || at.max_reconnects === 0) && (at.reconnect_timer_id = setTimeout(function() {
            return at._connect(Ye, st);
          }, at.reconnect_interval)));
        });
      }
    }]), De;
  }(Se.EventEmitter);
  ae.default = Ne;
})(client);
const RpcWebSocketCommonClient = /* @__PURE__ */ getDefaultExportFromCjs$2(client);
var websocket_browser = {};
(function(ae) {
  var ie = interopRequireDefaultExports;
  Object.defineProperty(ae, "__esModule", {
    value: !0
  }), ae.default = Be;
  var se = ie(requireClassCallCheck()), fe = ie(requireCreateClass()), ue = ie(requireInherits()), ce = ie(requirePossibleConstructorReturn()), de = ie(requireGetPrototypeOf()), me = requireEventemitter3();
  function we(Ce) {
    var Ie = Ee();
    return function() {
      var Ne = (0, de.default)(Ce), ke;
      if (Ie) {
        var He = (0, de.default)(this).constructor;
        ke = Reflect.construct(Ne, arguments, He);
      } else
        ke = Ne.apply(this, arguments);
      return (0, ce.default)(this, ke);
    };
  }
  function Ee() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function")
      return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  var Se = /* @__PURE__ */ function(Ce) {
    (0, ue.default)(Pe, Ce);
    var Ie = we(Pe);
    function Pe(Ne, ke, He) {
      var De;
      return (0, se.default)(this, Pe), De = Ie.call(this), De.socket = new window.WebSocket(Ne, He), De.socket.onopen = function() {
        return De.emit("open");
      }, De.socket.onmessage = function(Ge) {
        return De.emit("message", Ge.data);
      }, De.socket.onerror = function(Ge) {
        return De.emit("error", Ge);
      }, De.socket.onclose = function(Ge) {
        De.emit("close", Ge.code, Ge.reason);
      }, De;
    }
    return (0, fe.default)(Pe, [{
      key: "send",
      value: function(ke, He, De) {
        var Ge = De || He;
        try {
          this.socket.send(ke), Ge();
        } catch (Ye) {
          Ge(Ye);
        }
      }
      /**
       * Closes an underlying socket
       * @method
       * @param {Number} code - status code explaining why the connection is being closed
       * @param {String} reason - a description why the connection is closing
       * @return {Undefined}
       * @throws {Error}
       */
    }, {
      key: "close",
      value: function(ke, He) {
        this.socket.close(ke, He);
      }
    }, {
      key: "addEventListener",
      value: function(ke, He, De) {
        this.socket.addEventListener(ke, He, De);
      }
    }]), Pe;
  }(me.EventEmitter);
  function Be(Ce, Ie) {
    return new Se(Ce, Ie);
  }
})(websocket_browser);
const createRpc = /* @__PURE__ */ getDefaultExportFromCjs$2(websocket_browser), [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []], _0n$1 = /* @__PURE__ */ BigInt(0), _1n$2 = /* @__PURE__ */ BigInt(1), _2n$1 = /* @__PURE__ */ BigInt(2), _7n = /* @__PURE__ */ BigInt(7), _256n = /* @__PURE__ */ BigInt(256), _0x71n = /* @__PURE__ */ BigInt(113);
for (let ae = 0, ie = _1n$2, se = 1, fe = 0; ae < 24; ae++) {
  [se, fe] = [fe, (2 * se + 3 * fe) % 5], SHA3_PI.push(2 * (5 * fe + se)), SHA3_ROTL.push((ae + 1) * (ae + 2) / 2 % 64);
  let ue = _0n$1;
  for (let ce = 0; ce < 7; ce++)
    ie = (ie << _1n$2 ^ (ie >> _7n) * _0x71n) % _256n, ie & _2n$1 && (ue ^= _1n$2 << (_1n$2 << /* @__PURE__ */ BigInt(ce)) - _1n$2);
  _SHA3_IOTA.push(ue);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, !0), rotlH = (ae, ie, se) => se > 32 ? rotlBH(ae, ie, se) : rotlSH(ae, ie, se), rotlL = (ae, ie, se) => se > 32 ? rotlBL(ae, ie, se) : rotlSL(ae, ie, se);
function keccakP(ae, ie = 24) {
  const se = new Uint32Array(10);
  for (let fe = 24 - ie; fe < 24; fe++) {
    for (let de = 0; de < 10; de++)
      se[de] = ae[de] ^ ae[de + 10] ^ ae[de + 20] ^ ae[de + 30] ^ ae[de + 40];
    for (let de = 0; de < 10; de += 2) {
      const me = (de + 8) % 10, we = (de + 2) % 10, Ee = se[we], Se = se[we + 1], Be = rotlH(Ee, Se, 1) ^ se[me], Ce = rotlL(Ee, Se, 1) ^ se[me + 1];
      for (let Ie = 0; Ie < 50; Ie += 10)
        ae[de + Ie] ^= Be, ae[de + Ie + 1] ^= Ce;
    }
    let ue = ae[2], ce = ae[3];
    for (let de = 0; de < 24; de++) {
      const me = SHA3_ROTL[de], we = rotlH(ue, ce, me), Ee = rotlL(ue, ce, me), Se = SHA3_PI[de];
      ue = ae[Se], ce = ae[Se + 1], ae[Se] = we, ae[Se + 1] = Ee;
    }
    for (let de = 0; de < 50; de += 10) {
      for (let me = 0; me < 10; me++)
        se[me] = ae[de + me];
      for (let me = 0; me < 10; me++)
        ae[de + me] ^= ~se[(me + 2) % 10] & se[(me + 4) % 10];
    }
    ae[0] ^= SHA3_IOTA_H[fe], ae[1] ^= SHA3_IOTA_L[fe];
  }
  se.fill(0);
}
class Keccak extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(ie, se, fe, ue = !1, ce = 24) {
    if (super(), this.blockLen = ie, this.suffix = se, this.outputLen = fe, this.enableXOF = ue, this.rounds = ce, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, number$1(fe), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = u32$1(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(ie) {
    exists(this);
    const { blockLen: se, state: fe } = this;
    ie = toBytes(ie);
    const ue = ie.length;
    for (let ce = 0; ce < ue; ) {
      const de = Math.min(se - this.pos, ue - ce);
      for (let me = 0; me < de; me++)
        fe[this.pos++] ^= ie[ce++];
      this.pos === se && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: ie, suffix: se, pos: fe, blockLen: ue } = this;
    ie[fe] ^= se, se & 128 && fe === ue - 1 && this.keccak(), ie[ue - 1] ^= 128, this.keccak();
  }
  writeInto(ie) {
    exists(this, !1), bytes(ie), this.finish();
    const se = this.state, { blockLen: fe } = this;
    for (let ue = 0, ce = ie.length; ue < ce; ) {
      this.posOut >= fe && this.keccak();
      const de = Math.min(fe - this.posOut, ce - ue);
      ie.set(se.subarray(this.posOut, this.posOut + de), ue), this.posOut += de, ue += de;
    }
    return ie;
  }
  xofInto(ie) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(ie);
  }
  xof(ie) {
    return number$1(ie), this.xofInto(new Uint8Array(ie));
  }
  digestInto(ie) {
    if (output(ie, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(ie), this.destroy(), ie;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(ie) {
    const { blockLen: se, suffix: fe, outputLen: ue, rounds: ce, enableXOF: de } = this;
    return ie || (ie = new Keccak(se, fe, ue, de, ce)), ie.state32.set(this.state32), ie.pos = this.pos, ie.posOut = this.posOut, ie.finished = this.finished, ie.rounds = ce, ie.suffix = fe, ie.outputLen = ue, ie.enableXOF = de, ie.destroyed = this.destroyed, ie;
  }
}
const gen = (ae, ie, se) => wrapConstructor(() => new Keccak(ie, ae, se)), sha3_256 = /* @__PURE__ */ gen(6, 136, 256 / 8);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validatePointOpts(ae) {
  const ie = validateBasic(ae);
  validateObject(ie, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: se, Fp: fe, a: ue } = ie;
  if (se) {
    if (!fe.eql(ue, fe.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof se != "object" || typeof se.beta != "bigint" || typeof se.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...ie });
}
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut, DER = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(ie = "") {
      super(ie);
    }
  },
  _parseInt(ae) {
    const { Err: ie } = DER;
    if (ae.length < 2 || ae[0] !== 2)
      throw new ie("Invalid signature integer tag");
    const se = ae[1], fe = ae.subarray(2, se + 2);
    if (!se || fe.length !== se)
      throw new ie("Invalid signature integer: wrong length");
    if (fe[0] & 128)
      throw new ie("Invalid signature integer: negative");
    if (fe[0] === 0 && !(fe[1] & 128))
      throw new ie("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(fe), l: ae.subarray(se + 2) };
  },
  toSig(ae) {
    const { Err: ie } = DER, se = typeof ae == "string" ? h2b(ae) : ae;
    if (!isBytes$1(se))
      throw new Error("ui8a expected");
    let fe = se.length;
    if (fe < 2 || se[0] != 48)
      throw new ie("Invalid signature tag");
    if (se[1] !== fe - 2)
      throw new ie("Invalid signature: incorrect length");
    const { d: ue, l: ce } = DER._parseInt(se.subarray(2)), { d: de, l: me } = DER._parseInt(ce);
    if (me.length)
      throw new ie("Invalid signature: left bytes after parsing");
    return { r: ue, s: de };
  },
  hexFromSig(ae) {
    const ie = (Ee) => Number.parseInt(Ee[0], 16) & 8 ? "00" + Ee : Ee, se = (Ee) => {
      const Se = Ee.toString(16);
      return Se.length & 1 ? `0${Se}` : Se;
    }, fe = ie(se(ae.s)), ue = ie(se(ae.r)), ce = fe.length / 2, de = ue.length / 2, me = se(ce), we = se(de);
    return `30${se(de + ce + 4)}02${we}${ue}02${me}${fe}`;
  }
}, _0n = BigInt(0), _1n$1 = BigInt(1);
BigInt(2);
const _3n = BigInt(3);
BigInt(4);
function weierstrassPoints(ae) {
  const ie = validatePointOpts(ae), { Fp: se } = ie, fe = ie.toBytes || ((Pe, Ne, ke) => {
    const He = Ne.toAffine();
    return concatBytes(Uint8Array.from([4]), se.toBytes(He.x), se.toBytes(He.y));
  }), ue = ie.fromBytes || ((Pe) => {
    const Ne = Pe.subarray(1), ke = se.fromBytes(Ne.subarray(0, se.BYTES)), He = se.fromBytes(Ne.subarray(se.BYTES, 2 * se.BYTES));
    return { x: ke, y: He };
  });
  function ce(Pe) {
    const { a: Ne, b: ke } = ie, He = se.sqr(Pe), De = se.mul(He, Pe);
    return se.add(se.add(De, se.mul(Pe, Ne)), ke);
  }
  if (!se.eql(se.sqr(ie.Gy), ce(ie.Gx)))
    throw new Error("bad generator point: equation left != right");
  function de(Pe) {
    return typeof Pe == "bigint" && _0n < Pe && Pe < ie.n;
  }
  function me(Pe) {
    if (!de(Pe))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function we(Pe) {
    const { allowedPrivateKeyLengths: Ne, nByteLength: ke, wrapPrivateKey: He, n: De } = ie;
    if (Ne && typeof Pe != "bigint") {
      if (isBytes$1(Pe) && (Pe = bytesToHex(Pe)), typeof Pe != "string" || !Ne.includes(Pe.length))
        throw new Error("Invalid key");
      Pe = Pe.padStart(ke * 2, "0");
    }
    let Ge;
    try {
      Ge = typeof Pe == "bigint" ? Pe : bytesToNumberBE(ensureBytes("private key", Pe, ke));
    } catch {
      throw new Error(`private key must be ${ke} bytes, hex or bigint, not ${typeof Pe}`);
    }
    return He && (Ge = mod(Ge, De)), me(Ge), Ge;
  }
  const Ee = /* @__PURE__ */ new Map();
  function Se(Pe) {
    if (!(Pe instanceof Be))
      throw new Error("ProjectivePoint expected");
  }
  class Be {
    constructor(Ne, ke, He) {
      if (this.px = Ne, this.py = ke, this.pz = He, Ne == null || !se.isValid(Ne))
        throw new Error("x required");
      if (ke == null || !se.isValid(ke))
        throw new Error("y required");
      if (He == null || !se.isValid(He))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(Ne) {
      const { x: ke, y: He } = Ne || {};
      if (!Ne || !se.isValid(ke) || !se.isValid(He))
        throw new Error("invalid affine point");
      if (Ne instanceof Be)
        throw new Error("projective point not allowed");
      const De = (Ge) => se.eql(Ge, se.ZERO);
      return De(ke) && De(He) ? Be.ZERO : new Be(ke, He, se.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(Ne) {
      const ke = se.invertBatch(Ne.map((He) => He.pz));
      return Ne.map((He, De) => He.toAffine(ke[De])).map(Be.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(Ne) {
      const ke = Be.fromAffine(ue(ensureBytes("pointHex", Ne)));
      return ke.assertValidity(), ke;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(Ne) {
      return Be.BASE.multiply(we(Ne));
    }
    // "Private method", don't use it directly
    _setWindowSize(Ne) {
      this._WINDOW_SIZE = Ne, Ee.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (ie.allowInfinityPoint && !se.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: Ne, y: ke } = this.toAffine();
      if (!se.isValid(Ne) || !se.isValid(ke))
        throw new Error("bad point: x or y not FE");
      const He = se.sqr(ke), De = ce(Ne);
      if (!se.eql(He, De))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: Ne } = this.toAffine();
      if (se.isOdd)
        return !se.isOdd(Ne);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(Ne) {
      Se(Ne);
      const { px: ke, py: He, pz: De } = this, { px: Ge, py: Ye, pz: st } = Ne, at = se.eql(se.mul(ke, st), se.mul(Ge, De)), mt = se.eql(se.mul(He, st), se.mul(Ye, De));
      return at && mt;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Be(this.px, se.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: Ne, b: ke } = ie, He = se.mul(ke, _3n), { px: De, py: Ge, pz: Ye } = this;
      let st = se.ZERO, at = se.ZERO, mt = se.ZERO, qe = se.mul(De, De), ze = se.mul(Ge, Ge), ot = se.mul(Ye, Ye), $e = se.mul(De, Ge);
      return $e = se.add($e, $e), mt = se.mul(De, Ye), mt = se.add(mt, mt), st = se.mul(Ne, mt), at = se.mul(He, ot), at = se.add(st, at), st = se.sub(ze, at), at = se.add(ze, at), at = se.mul(st, at), st = se.mul($e, st), mt = se.mul(He, mt), ot = se.mul(Ne, ot), $e = se.sub(qe, ot), $e = se.mul(Ne, $e), $e = se.add($e, mt), mt = se.add(qe, qe), qe = se.add(mt, qe), qe = se.add(qe, ot), qe = se.mul(qe, $e), at = se.add(at, qe), ot = se.mul(Ge, Ye), ot = se.add(ot, ot), qe = se.mul(ot, $e), st = se.sub(st, qe), mt = se.mul(ot, ze), mt = se.add(mt, mt), mt = se.add(mt, mt), new Be(st, at, mt);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(Ne) {
      Se(Ne);
      const { px: ke, py: He, pz: De } = this, { px: Ge, py: Ye, pz: st } = Ne;
      let at = se.ZERO, mt = se.ZERO, qe = se.ZERO;
      const ze = ie.a, ot = se.mul(ie.b, _3n);
      let $e = se.mul(ke, Ge), le = se.mul(He, Ye), pe = se.mul(De, st), ge = se.add(ke, He), ye = se.add(Ge, Ye);
      ge = se.mul(ge, ye), ye = se.add($e, le), ge = se.sub(ge, ye), ye = se.add(ke, De);
      let xe = se.add(Ge, st);
      return ye = se.mul(ye, xe), xe = se.add($e, pe), ye = se.sub(ye, xe), xe = se.add(He, De), at = se.add(Ye, st), xe = se.mul(xe, at), at = se.add(le, pe), xe = se.sub(xe, at), qe = se.mul(ze, ye), at = se.mul(ot, pe), qe = se.add(at, qe), at = se.sub(le, qe), qe = se.add(le, qe), mt = se.mul(at, qe), le = se.add($e, $e), le = se.add(le, $e), pe = se.mul(ze, pe), ye = se.mul(ot, ye), le = se.add(le, pe), pe = se.sub($e, pe), pe = se.mul(ze, pe), ye = se.add(ye, pe), $e = se.mul(le, ye), mt = se.add(mt, $e), $e = se.mul(xe, ye), at = se.mul(ge, at), at = se.sub(at, $e), $e = se.mul(ge, le), qe = se.mul(xe, qe), qe = se.add(qe, $e), new Be(at, mt, qe);
    }
    subtract(Ne) {
      return this.add(Ne.negate());
    }
    is0() {
      return this.equals(Be.ZERO);
    }
    wNAF(Ne) {
      return Ie.wNAFCached(this, Ee, Ne, (ke) => {
        const He = se.invertBatch(ke.map((De) => De.pz));
        return ke.map((De, Ge) => De.toAffine(He[Ge])).map(Be.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(Ne) {
      const ke = Be.ZERO;
      if (Ne === _0n)
        return ke;
      if (me(Ne), Ne === _1n$1)
        return this;
      const { endo: He } = ie;
      if (!He)
        return Ie.unsafeLadder(this, Ne);
      let { k1neg: De, k1: Ge, k2neg: Ye, k2: st } = He.splitScalar(Ne), at = ke, mt = ke, qe = this;
      for (; Ge > _0n || st > _0n; )
        Ge & _1n$1 && (at = at.add(qe)), st & _1n$1 && (mt = mt.add(qe)), qe = qe.double(), Ge >>= _1n$1, st >>= _1n$1;
      return De && (at = at.negate()), Ye && (mt = mt.negate()), mt = new Be(se.mul(mt.px, He.beta), mt.py, mt.pz), at.add(mt);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(Ne) {
      me(Ne);
      let ke = Ne, He, De;
      const { endo: Ge } = ie;
      if (Ge) {
        const { k1neg: Ye, k1: st, k2neg: at, k2: mt } = Ge.splitScalar(ke);
        let { p: qe, f: ze } = this.wNAF(st), { p: ot, f: $e } = this.wNAF(mt);
        qe = Ie.constTimeNegate(Ye, qe), ot = Ie.constTimeNegate(at, ot), ot = new Be(se.mul(ot.px, Ge.beta), ot.py, ot.pz), He = qe.add(ot), De = ze.add($e);
      } else {
        const { p: Ye, f: st } = this.wNAF(ke);
        He = Ye, De = st;
      }
      return Be.normalizeZ([He, De])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Ne, ke, He) {
      const De = Be.BASE, Ge = (st, at) => at === _0n || at === _1n$1 || !st.equals(De) ? st.multiplyUnsafe(at) : st.multiply(at), Ye = Ge(this, ke).add(Ge(Ne, He));
      return Ye.is0() ? void 0 : Ye;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(Ne) {
      const { px: ke, py: He, pz: De } = this, Ge = this.is0();
      Ne == null && (Ne = Ge ? se.ONE : se.inv(De));
      const Ye = se.mul(ke, Ne), st = se.mul(He, Ne), at = se.mul(De, Ne);
      if (Ge)
        return { x: se.ZERO, y: se.ZERO };
      if (!se.eql(at, se.ONE))
        throw new Error("invZ was invalid");
      return { x: Ye, y: st };
    }
    isTorsionFree() {
      const { h: Ne, isTorsionFree: ke } = ie;
      if (Ne === _1n$1)
        return !0;
      if (ke)
        return ke(Be, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: Ne, clearCofactor: ke } = ie;
      return Ne === _1n$1 ? this : ke ? ke(Be, this) : this.multiplyUnsafe(ie.h);
    }
    toRawBytes(Ne = !0) {
      return this.assertValidity(), fe(Be, this, Ne);
    }
    toHex(Ne = !0) {
      return bytesToHex(this.toRawBytes(Ne));
    }
  }
  Be.BASE = new Be(ie.Gx, ie.Gy, se.ONE), Be.ZERO = new Be(se.ZERO, se.ONE, se.ZERO);
  const Ce = ie.nBitLength, Ie = wNAF(Be, ie.endo ? Math.ceil(Ce / 2) : Ce);
  return {
    CURVE: ie,
    ProjectivePoint: Be,
    normPrivateKeyToScalar: we,
    weierstrassEquation: ce,
    isWithinCurveOrder: de
  };
}
function validateOpts(ae) {
  const ie = validateBasic(ae);
  return validateObject(ie, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...ie });
}
function weierstrass(ae) {
  const ie = validateOpts(ae), { Fp: se, n: fe } = ie, ue = se.BYTES + 1, ce = 2 * se.BYTES + 1;
  function de(ye) {
    return _0n < ye && ye < se.ORDER;
  }
  function me(ye) {
    return mod(ye, fe);
  }
  function we(ye) {
    return invert(ye, fe);
  }
  const { ProjectivePoint: Ee, normPrivateKeyToScalar: Se, weierstrassEquation: Be, isWithinCurveOrder: Ce } = weierstrassPoints({
    ...ie,
    toBytes(ye, xe, _e) {
      const Ae = xe.toAffine(), ve = se.toBytes(Ae.x), he = concatBytes;
      return _e ? he(Uint8Array.from([xe.hasEvenY() ? 2 : 3]), ve) : he(Uint8Array.from([4]), ve, se.toBytes(Ae.y));
    },
    fromBytes(ye) {
      const xe = ye.length, _e = ye[0], Ae = ye.subarray(1);
      if (xe === ue && (_e === 2 || _e === 3)) {
        const ve = bytesToNumberBE(Ae);
        if (!de(ve))
          throw new Error("Point is not on curve");
        const he = Be(ve);
        let be = se.sqrt(he);
        const Me = (be & _1n$1) === _1n$1;
        return (_e & 1) === 1 !== Me && (be = se.neg(be)), { x: ve, y: be };
      } else if (xe === ce && _e === 4) {
        const ve = se.fromBytes(Ae.subarray(0, se.BYTES)), he = se.fromBytes(Ae.subarray(se.BYTES, 2 * se.BYTES));
        return { x: ve, y: he };
      } else
        throw new Error(`Point of length ${xe} was invalid. Expected ${ue} compressed bytes or ${ce} uncompressed bytes`);
    }
  }), Ie = (ye) => bytesToHex(numberToBytesBE(ye, ie.nByteLength));
  function Pe(ye) {
    const xe = fe >> _1n$1;
    return ye > xe;
  }
  function Ne(ye) {
    return Pe(ye) ? me(-ye) : ye;
  }
  const ke = (ye, xe, _e) => bytesToNumberBE(ye.slice(xe, _e));
  class He {
    constructor(xe, _e, Ae) {
      this.r = xe, this.s = _e, this.recovery = Ae, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(xe) {
      const _e = ie.nByteLength;
      return xe = ensureBytes("compactSignature", xe, _e * 2), new He(ke(xe, 0, _e), ke(xe, _e, 2 * _e));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(xe) {
      const { r: _e, s: Ae } = DER.toSig(ensureBytes("DER", xe));
      return new He(_e, Ae);
    }
    assertValidity() {
      if (!Ce(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!Ce(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(xe) {
      return new He(this.r, this.s, xe);
    }
    recoverPublicKey(xe) {
      const { r: _e, s: Ae, recovery: ve } = this, he = mt(ensureBytes("msgHash", xe));
      if (ve == null || ![0, 1, 2, 3].includes(ve))
        throw new Error("recovery id invalid");
      const be = ve === 2 || ve === 3 ? _e + ie.n : _e;
      if (be >= se.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const Me = ve & 1 ? "03" : "02", Re = Ee.fromHex(Me + Ie(be)), Oe = we(be), Te = me(-he * Oe), Fe = me(Ae * Oe), je = Ee.BASE.multiplyAndAddUnsafe(Re, Te, Fe);
      if (!je)
        throw new Error("point at infinify");
      return je.assertValidity(), je;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return Pe(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new He(this.r, me(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return Ie(this.r) + Ie(this.s);
    }
  }
  const De = {
    isValidPrivateKey(ye) {
      try {
        return Se(ye), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: Se,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const ye = getMinHashLength(ie.n);
      return mapHashToField(ie.randomBytes(ye), ie.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(ye = 8, xe = Ee.BASE) {
      return xe._setWindowSize(ye), xe.multiply(BigInt(3)), xe;
    }
  };
  function Ge(ye, xe = !0) {
    return Ee.fromPrivateKey(ye).toRawBytes(xe);
  }
  function Ye(ye) {
    const xe = isBytes$1(ye), _e = typeof ye == "string", Ae = (xe || _e) && ye.length;
    return xe ? Ae === ue || Ae === ce : _e ? Ae === 2 * ue || Ae === 2 * ce : ye instanceof Ee;
  }
  function st(ye, xe, _e = !0) {
    if (Ye(ye))
      throw new Error("first arg must be private key");
    if (!Ye(xe))
      throw new Error("second arg must be public key");
    return Ee.fromHex(xe).multiply(Se(ye)).toRawBytes(_e);
  }
  const at = ie.bits2int || function(ye) {
    const xe = bytesToNumberBE(ye), _e = ye.length * 8 - ie.nBitLength;
    return _e > 0 ? xe >> BigInt(_e) : xe;
  }, mt = ie.bits2int_modN || function(ye) {
    return me(at(ye));
  }, qe = bitMask(ie.nBitLength);
  function ze(ye) {
    if (typeof ye != "bigint")
      throw new Error("bigint expected");
    if (!(_0n <= ye && ye < qe))
      throw new Error(`bigint expected < 2^${ie.nBitLength}`);
    return numberToBytesBE(ye, ie.nByteLength);
  }
  function ot(ye, xe, _e = $e) {
    if (["recovered", "canonical"].some((nt) => nt in _e))
      throw new Error("sign() legacy options not supported");
    const { hash: Ae, randomBytes: ve } = ie;
    let { lowS: he, prehash: be, extraEntropy: Me } = _e;
    he == null && (he = !0), ye = ensureBytes("msgHash", ye), be && (ye = ensureBytes("prehashed msgHash", Ae(ye)));
    const Re = mt(ye), Oe = Se(xe), Te = [ze(Oe), ze(Re)];
    if (Me != null) {
      const nt = Me === !0 ? ve(se.BYTES) : Me;
      Te.push(ensureBytes("extraEntropy", nt));
    }
    const Fe = concatBytes(...Te), je = Re;
    function ct(nt) {
      const dt = at(nt);
      if (!Ce(dt))
        return;
      const it = we(dt), Je = Ee.BASE.multiply(dt).toAffine(), gt = me(Je.x);
      if (gt === _0n)
        return;
      const Ht = me(it * me(je + gt * Oe));
      if (Ht === _0n)
        return;
      let $t = (Je.x === gt ? 0 : 2) | Number(Je.y & _1n$1), Lt = Ht;
      return he && Pe(Ht) && (Lt = Ne(Ht), $t ^= 1), new He(gt, Lt, $t);
    }
    return { seed: Fe, k2sig: ct };
  }
  const $e = { lowS: ie.lowS, prehash: !1 }, le = { lowS: ie.lowS, prehash: !1 };
  function pe(ye, xe, _e = $e) {
    const { seed: Ae, k2sig: ve } = ot(ye, xe, _e), he = ie;
    return createHmacDrbg(he.hash.outputLen, he.nByteLength, he.hmac)(Ae, ve);
  }
  Ee.BASE._setWindowSize(8);
  function ge(ye, xe, _e, Ae = le) {
    const ve = ye;
    if (xe = ensureBytes("msgHash", xe), _e = ensureBytes("publicKey", _e), "strict" in Ae)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: he, prehash: be } = Ae;
    let Me, Re;
    try {
      if (typeof ve == "string" || isBytes$1(ve))
        try {
          Me = He.fromDER(ve);
        } catch (Je) {
          if (!(Je instanceof DER.Err))
            throw Je;
          Me = He.fromCompact(ve);
        }
      else if (typeof ve == "object" && typeof ve.r == "bigint" && typeof ve.s == "bigint") {
        const { r: Je, s: gt } = ve;
        Me = new He(Je, gt);
      } else
        throw new Error("PARSE");
      Re = Ee.fromHex(_e);
    } catch (Je) {
      if (Je.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (he && Me.hasHighS())
      return !1;
    be && (xe = ie.hash(xe));
    const { r: Oe, s: Te } = Me, Fe = mt(xe), je = we(Te), ct = me(Fe * je), nt = me(Oe * je), dt = Ee.BASE.multiplyAndAddUnsafe(Re, ct, nt)?.toAffine();
    return dt ? me(dt.x) === Oe : !1;
  }
  return {
    CURVE: ie,
    getPublicKey: Ge,
    getSharedSecret: st,
    sign: pe,
    verify: ge,
    ProjectivePoint: Ee,
    Signature: He,
    utils: De
  };
}
class HMAC extends Hash {
  constructor(ie, se) {
    super(), this.finished = !1, this.destroyed = !1, hash(ie);
    const fe = toBytes(se);
    if (this.iHash = ie.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const ue = this.blockLen, ce = new Uint8Array(ue);
    ce.set(fe.length > ue ? ie.create().update(fe).digest() : fe);
    for (let de = 0; de < ce.length; de++)
      ce[de] ^= 54;
    this.iHash.update(ce), this.oHash = ie.create();
    for (let de = 0; de < ce.length; de++)
      ce[de] ^= 106;
    this.oHash.update(ce), ce.fill(0);
  }
  update(ie) {
    return exists(this), this.iHash.update(ie), this;
  }
  digestInto(ie) {
    exists(this), bytes(ie, this.outputLen), this.finished = !0, this.iHash.digestInto(ie), this.oHash.update(ie), this.oHash.digestInto(ie), this.destroy();
  }
  digest() {
    const ie = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(ie), ie;
  }
  _cloneInto(ie) {
    ie || (ie = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: se, iHash: fe, finished: ue, destroyed: ce, blockLen: de, outputLen: me } = this;
    return ie = ie, ie.finished = ue, ie.destroyed = ce, ie.blockLen = de, ie.outputLen = me, ie.oHash = se._cloneInto(ie.oHash), ie.iHash = fe._cloneInto(ie.iHash), ie;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const hmac = (ae, ie, se) => new HMAC(ae, ie).update(se).digest();
hmac.create = (ae, ie) => new HMAC(ae, ie);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash(ae) {
  return {
    hash: ae,
    hmac: (ie, ...se) => hmac(ae, ie, concatBytes$1(...se)),
    randomBytes
  };
}
function createCurve(ae, ie) {
  const se = (fe) => weierstrass({ ...ae, ...getHash(fe) });
  return Object.freeze({ ...se(ie), create: se });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), _1n = BigInt(1), _2n = BigInt(2), divNearest = (ae, ie) => (ae + ie / _2n) / ie;
function sqrtMod(ae) {
  const ie = secp256k1P, se = BigInt(3), fe = BigInt(6), ue = BigInt(11), ce = BigInt(22), de = BigInt(23), me = BigInt(44), we = BigInt(88), Ee = ae * ae * ae % ie, Se = Ee * Ee * ae % ie, Be = pow2(Se, se, ie) * Se % ie, Ce = pow2(Be, se, ie) * Se % ie, Ie = pow2(Ce, _2n, ie) * Ee % ie, Pe = pow2(Ie, ue, ie) * Ie % ie, Ne = pow2(Pe, ce, ie) * Pe % ie, ke = pow2(Ne, me, ie) * Ne % ie, He = pow2(ke, we, ie) * ke % ie, De = pow2(He, me, ie) * Ne % ie, Ge = pow2(De, se, ie) * Se % ie, Ye = pow2(Ge, de, ie) * Pe % ie, st = pow2(Ye, fe, ie) * Ee % ie, at = pow2(st, _2n, ie);
  if (!Fp.eql(Fp.sqr(at), ae))
    throw new Error("Cannot find square root");
  return at;
}
const Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod }), secp256k1 = createCurve({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: secp256k1N,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: !0,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (ae) => {
      const ie = secp256k1N, se = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), fe = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), ue = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), ce = se, de = BigInt("0x100000000000000000000000000000000"), me = divNearest(ce * ae, ie), we = divNearest(-fe * ae, ie);
      let Ee = mod(ae - me * se - we * ue, ie), Se = mod(-me * fe - we * ce, ie);
      const Be = Ee > de, Ce = Se > de;
      if (Be && (Ee = ie - Ee), Ce && (Se = ie - Se), Ee > de || Se > de)
        throw new Error("splitScalar: Endomorphism failed, k=" + ae);
      return { k1neg: Be, k1: Ee, k2neg: Ce, k2: Se };
    }
  }
}, sha256);
BigInt(0);
secp256k1.ProjectivePoint;
function isOnCurve(ae) {
  try {
    return ed25519.ExtendedPoint.fromHex(ae), !0;
  } catch {
    return !1;
  }
}
const sign = (ae, ie) => ed25519.sign(ae, ie.slice(0, 32)), verify = ed25519.verify, toBuffer = (ae) => Buffer$1$1.isBuffer(ae) ? ae : ae instanceof Uint8Array ? Buffer$1$1.from(ae.buffer, ae.byteOffset, ae.byteLength) : Buffer$1$1.from(ae);
class Struct {
  constructor(ie) {
    Object.assign(this, ie);
  }
  encode() {
    return Buffer$1$1.from(serialize_1(SOLANA_SCHEMA, this));
  }
  static decode(ie) {
    return deserialize_1(SOLANA_SCHEMA, this, ie);
  }
  static decodeUnchecked(ie) {
    return deserializeUnchecked_1(SOLANA_SCHEMA, this, ie);
  }
}
const SOLANA_SCHEMA = /* @__PURE__ */ new Map();
var _class;
let _Symbol$toStringTag;
const MAX_SEED_LENGTH = 32, PUBLIC_KEY_LENGTH = 32;
function isPublicKeyData(ae) {
  return ae._bn !== void 0;
}
let uniquePublicKeyCounter = 1;
_Symbol$toStringTag = Symbol.toStringTag;
class PublicKey extends Struct {
  /**
   * Create a new PublicKey object
   * @param value ed25519 public key as buffer or base-58 encoded string
   */
  constructor(ie) {
    if (super({}), this._bn = void 0, isPublicKeyData(ie))
      this._bn = ie._bn;
    else {
      if (typeof ie == "string") {
        const se = bs58$1.decode(ie);
        if (se.length != PUBLIC_KEY_LENGTH)
          throw new Error("Invalid public key input");
        this._bn = new BN$d(se);
      } else
        this._bn = new BN$d(ie);
      if (this._bn.byteLength() > PUBLIC_KEY_LENGTH)
        throw new Error("Invalid public key input");
    }
  }
  /**
   * Returns a unique PublicKey for tests and benchmarks using a counter
   */
  static unique() {
    const ie = new PublicKey(uniquePublicKeyCounter);
    return uniquePublicKeyCounter += 1, new PublicKey(ie.toBuffer());
  }
  /**
   * Default public key value. The base58-encoded string representation is all ones (as seen below)
   * The underlying BN number is 32 bytes that are all zeros
   */
  /**
   * Checks if two publicKeys are equal
   */
  equals(ie) {
    return this._bn.eq(ie._bn);
  }
  /**
   * Return the base-58 representation of the public key
   */
  toBase58() {
    return bs58$1.encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }
  /**
   * Return the byte array representation of the public key in big endian
   */
  toBytes() {
    const ie = this.toBuffer();
    return new Uint8Array(ie.buffer, ie.byteOffset, ie.byteLength);
  }
  /**
   * Return the Buffer representation of the public key in big endian
   */
  toBuffer() {
    const ie = this._bn.toArrayLike(Buffer$1$1);
    if (ie.length === PUBLIC_KEY_LENGTH)
      return ie;
    const se = Buffer$1$1.alloc(32);
    return ie.copy(se, 32 - ie.length), se;
  }
  get [_Symbol$toStringTag]() {
    return `PublicKey(${this.toString()})`;
  }
  /**
   * Return the base-58 representation of the public key
   */
  toString() {
    return this.toBase58();
  }
  /**
   * Derive a public key from another key, a seed, and a program ID.
   * The program ID will also serve as the owner of the public key, giving
   * it permission to write data to the account.
   */
  /* eslint-disable require-await */
  static async createWithSeed(ie, se, fe) {
    const ue = Buffer$1$1.concat([ie.toBuffer(), Buffer$1$1.from(se), fe.toBuffer()]), ce = sha256(ue);
    return new PublicKey(ce);
  }
  /**
   * Derive a program address from seeds and a program ID.
   */
  /* eslint-disable require-await */
  static createProgramAddressSync(ie, se) {
    let fe = Buffer$1$1.alloc(0);
    ie.forEach(function(ce) {
      if (ce.length > MAX_SEED_LENGTH)
        throw new TypeError("Max seed length exceeded");
      fe = Buffer$1$1.concat([fe, toBuffer(ce)]);
    }), fe = Buffer$1$1.concat([fe, se.toBuffer(), Buffer$1$1.from("ProgramDerivedAddress")]);
    const ue = sha256(fe);
    if (isOnCurve(ue))
      throw new Error("Invalid seeds, address must fall off the curve");
    return new PublicKey(ue);
  }
  /**
   * Async version of createProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link createProgramAddressSync} instead
   */
  /* eslint-disable require-await */
  static async createProgramAddress(ie, se) {
    return this.createProgramAddressSync(ie, se);
  }
  /**
   * Find a valid program address
   *
   * Valid program addresses must fall off the ed25519 curve.  This function
   * iterates a nonce until it finds one that when combined with the seeds
   * results in a valid program address.
   */
  static findProgramAddressSync(ie, se) {
    let fe = 255, ue;
    for (; fe != 0; ) {
      try {
        const ce = ie.concat(Buffer$1$1.from([fe]));
        ue = this.createProgramAddressSync(ce, se);
      } catch (ce) {
        if (ce instanceof TypeError)
          throw ce;
        fe--;
        continue;
      }
      return [ue, fe];
    }
    throw new Error("Unable to find a viable program address nonce");
  }
  /**
   * Async version of findProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link findProgramAddressSync} instead
   */
  static async findProgramAddress(ie, se) {
    return this.findProgramAddressSync(ie, se);
  }
  /**
   * Check that a pubkey is on the ed25519 curve.
   */
  static isOnCurve(ie) {
    const se = new PublicKey(ie);
    return isOnCurve(se.toBytes());
  }
}
_class = PublicKey;
PublicKey.default = new _class("11111111111111111111111111111111");
SOLANA_SCHEMA.set(PublicKey, {
  kind: "struct",
  fields: [["_bn", "u256"]]
});
new PublicKey("BPFLoader1111111111111111111111111111111111");
const PACKET_DATA_SIZE = 1232, VERSION_PREFIX_MASK = 127, SIGNATURE_LENGTH_IN_BYTES = 64;
class TransactionExpiredBlockheightExceededError extends Error {
  constructor(ie) {
    super(`Signature ${ie} has expired: block height exceeded.`), this.signature = void 0, this.signature = ie;
  }
}
Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, "name", {
  value: "TransactionExpiredBlockheightExceededError"
});
class TransactionExpiredTimeoutError extends Error {
  constructor(ie, se) {
    super(`Transaction was not confirmed in ${se.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${ie} using the Solana Explorer or CLI tools.`), this.signature = void 0, this.signature = ie;
  }
}
Object.defineProperty(TransactionExpiredTimeoutError.prototype, "name", {
  value: "TransactionExpiredTimeoutError"
});
class TransactionExpiredNonceInvalidError extends Error {
  constructor(ie) {
    super(`Signature ${ie} has expired: the nonce is no longer valid.`), this.signature = void 0, this.signature = ie;
  }
}
Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, "name", {
  value: "TransactionExpiredNonceInvalidError"
});
class MessageAccountKeys {
  constructor(ie, se) {
    this.staticAccountKeys = void 0, this.accountKeysFromLookups = void 0, this.staticAccountKeys = ie, this.accountKeysFromLookups = se;
  }
  keySegments() {
    const ie = [this.staticAccountKeys];
    return this.accountKeysFromLookups && (ie.push(this.accountKeysFromLookups.writable), ie.push(this.accountKeysFromLookups.readonly)), ie;
  }
  get(ie) {
    for (const se of this.keySegments()) {
      if (ie < se.length)
        return se[ie];
      ie -= se.length;
    }
  }
  get length() {
    return this.keySegments().flat().length;
  }
  compileInstructions(ie) {
    if (this.length > 256)
      throw new Error("Account index overflow encountered during compilation");
    const fe = /* @__PURE__ */ new Map();
    this.keySegments().flat().forEach((ce, de) => {
      fe.set(ce.toBase58(), de);
    });
    const ue = (ce) => {
      const de = fe.get(ce.toBase58());
      if (de === void 0)
        throw new Error("Encountered an unknown instruction account key during compilation");
      return de;
    };
    return ie.map((ce) => ({
      programIdIndex: ue(ce.programId),
      accountKeyIndexes: ce.keys.map((de) => ue(de.pubkey)),
      data: ce.data
    }));
  }
}
const publicKey = (ae = "publicKey") => blob(32, ae), signature = (ae = "signature") => blob(64, ae), rustString = (ae = "string") => {
  const ie = struct([u32("length"), u32("lengthPadding"), blob(offset(u32(), -8), "chars")], ae), se = ie.decode.bind(ie), fe = ie.encode.bind(ie), ue = ie;
  return ue.decode = (ce, de) => se(ce, de).chars.toString(), ue.encode = (ce, de, me) => {
    const we = {
      chars: Buffer$1$1.from(ce, "utf8")
    };
    return fe(we, de, me);
  }, ue.alloc = (ce) => u32().span + u32().span + Buffer$1$1.from(ce, "utf8").length, ue;
}, authorized = (ae = "authorized") => struct([publicKey("staker"), publicKey("withdrawer")], ae), lockup = (ae = "lockup") => struct([ns64("unixTimestamp"), ns64("epoch"), publicKey("custodian")], ae), voteInit = (ae = "voteInit") => struct([publicKey("nodePubkey"), publicKey("authorizedVoter"), publicKey("authorizedWithdrawer"), u8("commission")], ae), voteAuthorizeWithSeedArgs = (ae = "voteAuthorizeWithSeedArgs") => struct([u32("voteAuthorizationType"), publicKey("currentAuthorityDerivedKeyOwnerPubkey"), rustString("currentAuthorityDerivedKeySeed"), publicKey("newAuthorized")], ae);
function getAlloc(ae, ie) {
  const se = (ue) => {
    if (ue.span >= 0)
      return ue.span;
    if (typeof ue.alloc == "function")
      return ue.alloc(ie[ue.property]);
    if ("count" in ue && "elementLayout" in ue) {
      const ce = ie[ue.property];
      if (Array.isArray(ce))
        return ce.length * se(ue.elementLayout);
    } else if ("fields" in ue)
      return getAlloc({
        layout: ue
      }, ie[ue.property]);
    return 0;
  };
  let fe = 0;
  return ae.layout.fields.forEach((ue) => {
    fe += se(ue);
  }), fe;
}
function decodeLength(ae) {
  let ie = 0, se = 0;
  for (; ; ) {
    let fe = ae.shift();
    if (ie |= (fe & 127) << se * 7, se += 1, !(fe & 128))
      break;
  }
  return ie;
}
function encodeLength(ae, ie) {
  let se = ie;
  for (; ; ) {
    let fe = se & 127;
    if (se >>= 7, se == 0) {
      ae.push(fe);
      break;
    } else
      fe |= 128, ae.push(fe);
  }
}
function assert(ae, ie) {
  if (!ae)
    throw new Error(ie || "Assertion failed");
}
class CompiledKeys {
  constructor(ie, se) {
    this.payer = void 0, this.keyMetaMap = void 0, this.payer = ie, this.keyMetaMap = se;
  }
  static compile(ie, se) {
    const fe = /* @__PURE__ */ new Map(), ue = (de) => {
      const me = de.toBase58();
      let we = fe.get(me);
      return we === void 0 && (we = {
        isSigner: !1,
        isWritable: !1,
        isInvoked: !1
      }, fe.set(me, we)), we;
    }, ce = ue(se);
    ce.isSigner = !0, ce.isWritable = !0;
    for (const de of ie) {
      ue(de.programId).isInvoked = !0;
      for (const me of de.keys) {
        const we = ue(me.pubkey);
        we.isSigner ||= me.isSigner, we.isWritable ||= me.isWritable;
      }
    }
    return new CompiledKeys(se, fe);
  }
  getMessageComponents() {
    const ie = [...this.keyMetaMap.entries()];
    assert(ie.length <= 256, "Max static account keys length exceeded");
    const se = ie.filter(([, we]) => we.isSigner && we.isWritable), fe = ie.filter(([, we]) => we.isSigner && !we.isWritable), ue = ie.filter(([, we]) => !we.isSigner && we.isWritable), ce = ie.filter(([, we]) => !we.isSigner && !we.isWritable), de = {
      numRequiredSignatures: se.length + fe.length,
      numReadonlySignedAccounts: fe.length,
      numReadonlyUnsignedAccounts: ce.length
    };
    {
      assert(se.length > 0, "Expected at least one writable signer key");
      const [we] = se[0];
      assert(we === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
    }
    const me = [...se.map(([we]) => new PublicKey(we)), ...fe.map(([we]) => new PublicKey(we)), ...ue.map(([we]) => new PublicKey(we)), ...ce.map(([we]) => new PublicKey(we))];
    return [de, me];
  }
  extractTableLookup(ie) {
    const [se, fe] = this.drainKeysFoundInLookupTable(ie.state.addresses, (de) => !de.isSigner && !de.isInvoked && de.isWritable), [ue, ce] = this.drainKeysFoundInLookupTable(ie.state.addresses, (de) => !de.isSigner && !de.isInvoked && !de.isWritable);
    if (!(se.length === 0 && ue.length === 0))
      return [{
        accountKey: ie.key,
        writableIndexes: se,
        readonlyIndexes: ue
      }, {
        writable: fe,
        readonly: ce
      }];
  }
  /** @internal */
  drainKeysFoundInLookupTable(ie, se) {
    const fe = new Array(), ue = new Array();
    for (const [ce, de] of this.keyMetaMap.entries())
      if (se(de)) {
        const me = new PublicKey(ce), we = ie.findIndex((Ee) => Ee.equals(me));
        we >= 0 && (assert(we < 256, "Max lookup table index exceeded"), fe.push(we), ue.push(me), this.keyMetaMap.delete(ce));
      }
    return [fe, ue];
  }
}
class Message {
  constructor(ie) {
    this.header = void 0, this.accountKeys = void 0, this.recentBlockhash = void 0, this.instructions = void 0, this.indexToProgramIds = /* @__PURE__ */ new Map(), this.header = ie.header, this.accountKeys = ie.accountKeys.map((se) => new PublicKey(se)), this.recentBlockhash = ie.recentBlockhash, this.instructions = ie.instructions, this.instructions.forEach((se) => this.indexToProgramIds.set(se.programIdIndex, this.accountKeys[se.programIdIndex]));
  }
  get version() {
    return "legacy";
  }
  get staticAccountKeys() {
    return this.accountKeys;
  }
  get compiledInstructions() {
    return this.instructions.map((ie) => ({
      programIdIndex: ie.programIdIndex,
      accountKeyIndexes: ie.accounts,
      data: bs58$1.decode(ie.data)
    }));
  }
  get addressTableLookups() {
    return [];
  }
  getAccountKeys() {
    return new MessageAccountKeys(this.staticAccountKeys);
  }
  static compile(ie) {
    const se = CompiledKeys.compile(ie.instructions, ie.payerKey), [fe, ue] = se.getMessageComponents(), de = new MessageAccountKeys(ue).compileInstructions(ie.instructions).map((me) => ({
      programIdIndex: me.programIdIndex,
      accounts: me.accountKeyIndexes,
      data: bs58$1.encode(me.data)
    }));
    return new Message({
      header: fe,
      accountKeys: ue,
      recentBlockhash: ie.recentBlockhash,
      instructions: de
    });
  }
  isAccountSigner(ie) {
    return ie < this.header.numRequiredSignatures;
  }
  isAccountWritable(ie) {
    const se = this.header.numRequiredSignatures;
    if (ie >= this.header.numRequiredSignatures) {
      const fe = ie - se, ce = this.accountKeys.length - se - this.header.numReadonlyUnsignedAccounts;
      return fe < ce;
    } else {
      const fe = se - this.header.numReadonlySignedAccounts;
      return ie < fe;
    }
  }
  isProgramId(ie) {
    return this.indexToProgramIds.has(ie);
  }
  programIds() {
    return [...this.indexToProgramIds.values()];
  }
  nonProgramIds() {
    return this.accountKeys.filter((ie, se) => !this.isProgramId(se));
  }
  serialize() {
    const ie = this.accountKeys.length;
    let se = [];
    encodeLength(se, ie);
    const fe = this.instructions.map((Be) => {
      const {
        accounts: Ce,
        programIdIndex: Ie
      } = Be, Pe = Array.from(bs58$1.decode(Be.data));
      let Ne = [];
      encodeLength(Ne, Ce.length);
      let ke = [];
      return encodeLength(ke, Pe.length), {
        programIdIndex: Ie,
        keyIndicesCount: Buffer$1$1.from(Ne),
        keyIndices: Ce,
        dataLength: Buffer$1$1.from(ke),
        data: Pe
      };
    });
    let ue = [];
    encodeLength(ue, fe.length);
    let ce = Buffer$1$1.alloc(PACKET_DATA_SIZE);
    Buffer$1$1.from(ue).copy(ce);
    let de = ue.length;
    fe.forEach((Be) => {
      const Ie = struct([u8("programIdIndex"), blob(Be.keyIndicesCount.length, "keyIndicesCount"), seq(u8("keyIndex"), Be.keyIndices.length, "keyIndices"), blob(Be.dataLength.length, "dataLength"), seq(u8("userdatum"), Be.data.length, "data")]).encode(Be, ce, de);
      de += Ie;
    }), ce = ce.slice(0, de);
    const me = struct([blob(1, "numRequiredSignatures"), blob(1, "numReadonlySignedAccounts"), blob(1, "numReadonlyUnsignedAccounts"), blob(se.length, "keyCount"), seq(publicKey("key"), ie, "keys"), publicKey("recentBlockhash")]), we = {
      numRequiredSignatures: Buffer$1$1.from([this.header.numRequiredSignatures]),
      numReadonlySignedAccounts: Buffer$1$1.from([this.header.numReadonlySignedAccounts]),
      numReadonlyUnsignedAccounts: Buffer$1$1.from([this.header.numReadonlyUnsignedAccounts]),
      keyCount: Buffer$1$1.from(se),
      keys: this.accountKeys.map((Be) => toBuffer(Be.toBytes())),
      recentBlockhash: bs58$1.decode(this.recentBlockhash)
    };
    let Ee = Buffer$1$1.alloc(2048);
    const Se = me.encode(we, Ee);
    return ce.copy(Ee, Se), Ee.slice(0, Se + ce.length);
  }
  /**
   * Decode a compiled message into a Message object.
   */
  static from(ie) {
    let se = [...ie];
    const fe = se.shift();
    if (fe !== (fe & VERSION_PREFIX_MASK))
      throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
    const ue = se.shift(), ce = se.shift(), de = decodeLength(se);
    let me = [];
    for (let Ce = 0; Ce < de; Ce++) {
      const Ie = se.slice(0, PUBLIC_KEY_LENGTH);
      se = se.slice(PUBLIC_KEY_LENGTH), me.push(new PublicKey(Buffer$1$1.from(Ie)));
    }
    const we = se.slice(0, PUBLIC_KEY_LENGTH);
    se = se.slice(PUBLIC_KEY_LENGTH);
    const Ee = decodeLength(se);
    let Se = [];
    for (let Ce = 0; Ce < Ee; Ce++) {
      const Ie = se.shift(), Pe = decodeLength(se), Ne = se.slice(0, Pe);
      se = se.slice(Pe);
      const ke = decodeLength(se), He = se.slice(0, ke), De = bs58$1.encode(Buffer$1$1.from(He));
      se = se.slice(ke), Se.push({
        programIdIndex: Ie,
        accounts: Ne,
        data: De
      });
    }
    const Be = {
      header: {
        numRequiredSignatures: fe,
        numReadonlySignedAccounts: ue,
        numReadonlyUnsignedAccounts: ce
      },
      recentBlockhash: bs58$1.encode(Buffer$1$1.from(we)),
      accountKeys: me,
      instructions: Se
    };
    return new Message(Be);
  }
}
class MessageV0 {
  constructor(ie) {
    this.header = void 0, this.staticAccountKeys = void 0, this.recentBlockhash = void 0, this.compiledInstructions = void 0, this.addressTableLookups = void 0, this.header = ie.header, this.staticAccountKeys = ie.staticAccountKeys, this.recentBlockhash = ie.recentBlockhash, this.compiledInstructions = ie.compiledInstructions, this.addressTableLookups = ie.addressTableLookups;
  }
  get version() {
    return 0;
  }
  get numAccountKeysFromLookups() {
    let ie = 0;
    for (const se of this.addressTableLookups)
      ie += se.readonlyIndexes.length + se.writableIndexes.length;
    return ie;
  }
  getAccountKeys(ie) {
    let se;
    if (ie && "accountKeysFromLookups" in ie && ie.accountKeysFromLookups) {
      if (this.numAccountKeysFromLookups != ie.accountKeysFromLookups.writable.length + ie.accountKeysFromLookups.readonly.length)
        throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
      se = ie.accountKeysFromLookups;
    } else if (ie && "addressLookupTableAccounts" in ie && ie.addressLookupTableAccounts)
      se = this.resolveAddressTableLookups(ie.addressLookupTableAccounts);
    else if (this.addressTableLookups.length > 0)
      throw new Error("Failed to get account keys because address table lookups were not resolved");
    return new MessageAccountKeys(this.staticAccountKeys, se);
  }
  isAccountSigner(ie) {
    return ie < this.header.numRequiredSignatures;
  }
  isAccountWritable(ie) {
    const se = this.header.numRequiredSignatures, fe = this.staticAccountKeys.length;
    if (ie >= fe) {
      const ue = ie - fe, ce = this.addressTableLookups.reduce((de, me) => de + me.writableIndexes.length, 0);
      return ue < ce;
    } else if (ie >= this.header.numRequiredSignatures) {
      const ue = ie - se, de = fe - se - this.header.numReadonlyUnsignedAccounts;
      return ue < de;
    } else {
      const ue = se - this.header.numReadonlySignedAccounts;
      return ie < ue;
    }
  }
  resolveAddressTableLookups(ie) {
    const se = {
      writable: [],
      readonly: []
    };
    for (const fe of this.addressTableLookups) {
      const ue = ie.find((ce) => ce.key.equals(fe.accountKey));
      if (!ue)
        throw new Error(`Failed to find address lookup table account for table key ${fe.accountKey.toBase58()}`);
      for (const ce of fe.writableIndexes)
        if (ce < ue.state.addresses.length)
          se.writable.push(ue.state.addresses[ce]);
        else
          throw new Error(`Failed to find address for index ${ce} in address lookup table ${fe.accountKey.toBase58()}`);
      for (const ce of fe.readonlyIndexes)
        if (ce < ue.state.addresses.length)
          se.readonly.push(ue.state.addresses[ce]);
        else
          throw new Error(`Failed to find address for index ${ce} in address lookup table ${fe.accountKey.toBase58()}`);
    }
    return se;
  }
  static compile(ie) {
    const se = CompiledKeys.compile(ie.instructions, ie.payerKey), fe = new Array(), ue = {
      writable: new Array(),
      readonly: new Array()
    }, ce = ie.addressLookupTableAccounts || [];
    for (const Se of ce) {
      const Be = se.extractTableLookup(Se);
      if (Be !== void 0) {
        const [Ce, {
          writable: Ie,
          readonly: Pe
        }] = Be;
        fe.push(Ce), ue.writable.push(...Ie), ue.readonly.push(...Pe);
      }
    }
    const [de, me] = se.getMessageComponents(), Ee = new MessageAccountKeys(me, ue).compileInstructions(ie.instructions);
    return new MessageV0({
      header: de,
      staticAccountKeys: me,
      recentBlockhash: ie.recentBlockhash,
      compiledInstructions: Ee,
      addressTableLookups: fe
    });
  }
  serialize() {
    const ie = Array();
    encodeLength(ie, this.staticAccountKeys.length);
    const se = this.serializeInstructions(), fe = Array();
    encodeLength(fe, this.compiledInstructions.length);
    const ue = this.serializeAddressTableLookups(), ce = Array();
    encodeLength(ce, this.addressTableLookups.length);
    const de = struct([u8("prefix"), struct([u8("numRequiredSignatures"), u8("numReadonlySignedAccounts"), u8("numReadonlyUnsignedAccounts")], "header"), blob(ie.length, "staticAccountKeysLength"), seq(publicKey(), this.staticAccountKeys.length, "staticAccountKeys"), publicKey("recentBlockhash"), blob(fe.length, "instructionsLength"), blob(se.length, "serializedInstructions"), blob(ce.length, "addressTableLookupsLength"), blob(ue.length, "serializedAddressTableLookups")]), me = new Uint8Array(PACKET_DATA_SIZE), Ee = de.encode({
      prefix: 128,
      header: this.header,
      staticAccountKeysLength: new Uint8Array(ie),
      staticAccountKeys: this.staticAccountKeys.map((Se) => Se.toBytes()),
      recentBlockhash: bs58$1.decode(this.recentBlockhash),
      instructionsLength: new Uint8Array(fe),
      serializedInstructions: se,
      addressTableLookupsLength: new Uint8Array(ce),
      serializedAddressTableLookups: ue
    }, me);
    return me.slice(0, Ee);
  }
  serializeInstructions() {
    let ie = 0;
    const se = new Uint8Array(PACKET_DATA_SIZE);
    for (const fe of this.compiledInstructions) {
      const ue = Array();
      encodeLength(ue, fe.accountKeyIndexes.length);
      const ce = Array();
      encodeLength(ce, fe.data.length);
      const de = struct([u8("programIdIndex"), blob(ue.length, "encodedAccountKeyIndexesLength"), seq(u8(), fe.accountKeyIndexes.length, "accountKeyIndexes"), blob(ce.length, "encodedDataLength"), blob(fe.data.length, "data")]);
      ie += de.encode({
        programIdIndex: fe.programIdIndex,
        encodedAccountKeyIndexesLength: new Uint8Array(ue),
        accountKeyIndexes: fe.accountKeyIndexes,
        encodedDataLength: new Uint8Array(ce),
        data: fe.data
      }, se, ie);
    }
    return se.slice(0, ie);
  }
  serializeAddressTableLookups() {
    let ie = 0;
    const se = new Uint8Array(PACKET_DATA_SIZE);
    for (const fe of this.addressTableLookups) {
      const ue = Array();
      encodeLength(ue, fe.writableIndexes.length);
      const ce = Array();
      encodeLength(ce, fe.readonlyIndexes.length);
      const de = struct([publicKey("accountKey"), blob(ue.length, "encodedWritableIndexesLength"), seq(u8(), fe.writableIndexes.length, "writableIndexes"), blob(ce.length, "encodedReadonlyIndexesLength"), seq(u8(), fe.readonlyIndexes.length, "readonlyIndexes")]);
      ie += de.encode({
        accountKey: fe.accountKey.toBytes(),
        encodedWritableIndexesLength: new Uint8Array(ue),
        writableIndexes: fe.writableIndexes,
        encodedReadonlyIndexesLength: new Uint8Array(ce),
        readonlyIndexes: fe.readonlyIndexes
      }, se, ie);
    }
    return se.slice(0, ie);
  }
  static deserialize(ie) {
    let se = [...ie];
    const fe = se.shift(), ue = fe & VERSION_PREFIX_MASK;
    assert(fe !== ue, "Expected versioned message but received legacy message");
    const ce = ue;
    assert(ce === 0, `Expected versioned message with version 0 but found version ${ce}`);
    const de = {
      numRequiredSignatures: se.shift(),
      numReadonlySignedAccounts: se.shift(),
      numReadonlyUnsignedAccounts: se.shift()
    }, me = [], we = decodeLength(se);
    for (let Pe = 0; Pe < we; Pe++)
      me.push(new PublicKey(se.splice(0, PUBLIC_KEY_LENGTH)));
    const Ee = bs58$1.encode(se.splice(0, PUBLIC_KEY_LENGTH)), Se = decodeLength(se), Be = [];
    for (let Pe = 0; Pe < Se; Pe++) {
      const Ne = se.shift(), ke = decodeLength(se), He = se.splice(0, ke), De = decodeLength(se), Ge = new Uint8Array(se.splice(0, De));
      Be.push({
        programIdIndex: Ne,
        accountKeyIndexes: He,
        data: Ge
      });
    }
    const Ce = decodeLength(se), Ie = [];
    for (let Pe = 0; Pe < Ce; Pe++) {
      const Ne = new PublicKey(se.splice(0, PUBLIC_KEY_LENGTH)), ke = decodeLength(se), He = se.splice(0, ke), De = decodeLength(se), Ge = se.splice(0, De);
      Ie.push({
        accountKey: Ne,
        writableIndexes: He,
        readonlyIndexes: Ge
      });
    }
    return new MessageV0({
      header: de,
      staticAccountKeys: me,
      recentBlockhash: Ee,
      compiledInstructions: Be,
      addressTableLookups: Ie
    });
  }
}
const VersionedMessage = {
  deserializeMessageVersion(ae) {
    const ie = ae[0], se = ie & VERSION_PREFIX_MASK;
    return se === ie ? "legacy" : se;
  },
  deserialize: (ae) => {
    const ie = VersionedMessage.deserializeMessageVersion(ae);
    if (ie === "legacy")
      return Message.from(ae);
    if (ie === 0)
      return MessageV0.deserialize(ae);
    throw new Error(`Transaction message version ${ie} deserialization is not supported`);
  }
};
let TransactionStatus = /* @__PURE__ */ function(ae) {
  return ae[ae.BLOCKHEIGHT_EXCEEDED = 0] = "BLOCKHEIGHT_EXCEEDED", ae[ae.PROCESSED = 1] = "PROCESSED", ae[ae.TIMED_OUT = 2] = "TIMED_OUT", ae[ae.NONCE_INVALID = 3] = "NONCE_INVALID", ae;
}({});
const DEFAULT_SIGNATURE = Buffer$1$1.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);
class TransactionInstruction {
  constructor(ie) {
    this.keys = void 0, this.programId = void 0, this.data = Buffer$1$1.alloc(0), this.programId = ie.programId, this.keys = ie.keys, ie.data && (this.data = ie.data);
  }
  /**
   * @internal
   */
  toJSON() {
    return {
      keys: this.keys.map(({
        pubkey: ie,
        isSigner: se,
        isWritable: fe
      }) => ({
        pubkey: ie.toJSON(),
        isSigner: se,
        isWritable: fe
      })),
      programId: this.programId.toJSON(),
      data: [...this.data]
    };
  }
}
class Transaction {
  /**
   * The first (payer) Transaction signature
   *
   * @returns {Buffer | null} Buffer of payer's signature
   */
  get signature() {
    return this.signatures.length > 0 ? this.signatures[0].signature : null;
  }
  /**
   * The transaction fee payer
   */
  // Construct a transaction with a blockhash and lastValidBlockHeight
  // Construct a transaction using a durable nonce
  /**
   * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.
   * Please supply a `TransactionBlockhashCtor` instead.
   */
  /**
   * Construct an empty Transaction
   */
  constructor(ie) {
    if (this.signatures = [], this.feePayer = void 0, this.instructions = [], this.recentBlockhash = void 0, this.lastValidBlockHeight = void 0, this.nonceInfo = void 0, this.minNonceContextSlot = void 0, this._message = void 0, this._json = void 0, !!ie)
      if (ie.feePayer && (this.feePayer = ie.feePayer), ie.signatures && (this.signatures = ie.signatures), Object.prototype.hasOwnProperty.call(ie, "nonceInfo")) {
        const {
          minContextSlot: se,
          nonceInfo: fe
        } = ie;
        this.minNonceContextSlot = se, this.nonceInfo = fe;
      } else if (Object.prototype.hasOwnProperty.call(ie, "lastValidBlockHeight")) {
        const {
          blockhash: se,
          lastValidBlockHeight: fe
        } = ie;
        this.recentBlockhash = se, this.lastValidBlockHeight = fe;
      } else {
        const {
          recentBlockhash: se,
          nonceInfo: fe
        } = ie;
        fe && (this.nonceInfo = fe), this.recentBlockhash = se;
      }
  }
  /**
   * @internal
   */
  toJSON() {
    return {
      recentBlockhash: this.recentBlockhash || null,
      feePayer: this.feePayer ? this.feePayer.toJSON() : null,
      nonceInfo: this.nonceInfo ? {
        nonce: this.nonceInfo.nonce,
        nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
      } : null,
      instructions: this.instructions.map((ie) => ie.toJSON()),
      signers: this.signatures.map(({
        publicKey: ie
      }) => ie.toJSON())
    };
  }
  /**
   * Add one or more instructions to this Transaction
   *
   * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction
   */
  add(...ie) {
    if (ie.length === 0)
      throw new Error("No instructions");
    return ie.forEach((se) => {
      "instructions" in se ? this.instructions = this.instructions.concat(se.instructions) : "data" in se && "programId" in se && "keys" in se ? this.instructions.push(se) : this.instructions.push(new TransactionInstruction(se));
    }), this;
  }
  /**
   * Compile transaction data
   */
  compileMessage() {
    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json))
      return this._message;
    let ie, se;
    if (this.nonceInfo ? (ie = this.nonceInfo.nonce, this.instructions[0] != this.nonceInfo.nonceInstruction ? se = [this.nonceInfo.nonceInstruction, ...this.instructions] : se = this.instructions) : (ie = this.recentBlockhash, se = this.instructions), !ie)
      throw new Error("Transaction recentBlockhash required");
    se.length < 1 && console.warn("No instructions provided");
    let fe;
    if (this.feePayer)
      fe = this.feePayer;
    else if (this.signatures.length > 0 && this.signatures[0].publicKey)
      fe = this.signatures[0].publicKey;
    else
      throw new Error("Transaction fee payer required");
    for (let Ne = 0; Ne < se.length; Ne++)
      if (se[Ne].programId === void 0)
        throw new Error(`Transaction instruction index ${Ne} has undefined program id`);
    const ue = [], ce = [];
    se.forEach((Ne) => {
      Ne.keys.forEach((He) => {
        ce.push({
          ...He
        });
      });
      const ke = Ne.programId.toString();
      ue.includes(ke) || ue.push(ke);
    }), ue.forEach((Ne) => {
      ce.push({
        pubkey: new PublicKey(Ne),
        isSigner: !1,
        isWritable: !1
      });
    });
    const de = [];
    ce.forEach((Ne) => {
      const ke = Ne.pubkey.toString(), He = de.findIndex((De) => De.pubkey.toString() === ke);
      He > -1 ? (de[He].isWritable = de[He].isWritable || Ne.isWritable, de[He].isSigner = de[He].isSigner || Ne.isSigner) : de.push(Ne);
    }), de.sort(function(Ne, ke) {
      if (Ne.isSigner !== ke.isSigner)
        return Ne.isSigner ? -1 : 1;
      if (Ne.isWritable !== ke.isWritable)
        return Ne.isWritable ? -1 : 1;
      const He = {
        localeMatcher: "best fit",
        usage: "sort",
        sensitivity: "variant",
        ignorePunctuation: !1,
        numeric: !1,
        caseFirst: "lower"
      };
      return Ne.pubkey.toBase58().localeCompare(ke.pubkey.toBase58(), "en", He);
    });
    const me = de.findIndex((Ne) => Ne.pubkey.equals(fe));
    if (me > -1) {
      const [Ne] = de.splice(me, 1);
      Ne.isSigner = !0, Ne.isWritable = !0, de.unshift(Ne);
    } else
      de.unshift({
        pubkey: fe,
        isSigner: !0,
        isWritable: !0
      });
    for (const Ne of this.signatures) {
      const ke = de.findIndex((He) => He.pubkey.equals(Ne.publicKey));
      if (ke > -1)
        de[ke].isSigner || (de[ke].isSigner = !0, console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));
      else
        throw new Error(`unknown signer: ${Ne.publicKey.toString()}`);
    }
    let we = 0, Ee = 0, Se = 0;
    const Be = [], Ce = [];
    de.forEach(({
      pubkey: Ne,
      isSigner: ke,
      isWritable: He
    }) => {
      ke ? (Be.push(Ne.toString()), we += 1, He || (Ee += 1)) : (Ce.push(Ne.toString()), He || (Se += 1));
    });
    const Ie = Be.concat(Ce), Pe = se.map((Ne) => {
      const {
        data: ke,
        programId: He
      } = Ne;
      return {
        programIdIndex: Ie.indexOf(He.toString()),
        accounts: Ne.keys.map((De) => Ie.indexOf(De.pubkey.toString())),
        data: bs58$1.encode(ke)
      };
    });
    return Pe.forEach((Ne) => {
      assert(Ne.programIdIndex >= 0), Ne.accounts.forEach((ke) => assert(ke >= 0));
    }), new Message({
      header: {
        numRequiredSignatures: we,
        numReadonlySignedAccounts: Ee,
        numReadonlyUnsignedAccounts: Se
      },
      accountKeys: Ie,
      recentBlockhash: ie,
      instructions: Pe
    });
  }
  /**
   * @internal
   */
  _compile() {
    const ie = this.compileMessage(), se = ie.accountKeys.slice(0, ie.header.numRequiredSignatures);
    return this.signatures.length === se.length && this.signatures.every((ue, ce) => se[ce].equals(ue.publicKey)) || (this.signatures = se.map((fe) => ({
      signature: null,
      publicKey: fe
    }))), ie;
  }
  /**
   * Get a buffer of the Transaction data that need to be covered by signatures
   */
  serializeMessage() {
    return this._compile().serialize();
  }
  /**
   * Get the estimated fee associated with a transaction
   *
   * @param {Connection} connection Connection to RPC Endpoint.
   *
   * @returns {Promise<number | null>} The estimated fee for the transaction
   */
  async getEstimatedFee(ie) {
    return (await ie.getFeeForMessage(this.compileMessage())).value;
  }
  /**
   * Specify the public keys which will be used to sign the Transaction.
   * The first signer will be used as the transaction fee payer account.
   *
   * Signatures can be added with either `partialSign` or `addSignature`
   *
   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
   * specified and it can be set in the Transaction constructor or with the
   * `feePayer` property.
   */
  setSigners(...ie) {
    if (ie.length === 0)
      throw new Error("No signers");
    const se = /* @__PURE__ */ new Set();
    this.signatures = ie.filter((fe) => {
      const ue = fe.toString();
      return se.has(ue) ? !1 : (se.add(ue), !0);
    }).map((fe) => ({
      signature: null,
      publicKey: fe
    }));
  }
  /**
   * Sign the Transaction with the specified signers. Multiple signatures may
   * be applied to a Transaction. The first signature is considered "primary"
   * and is used identify and confirm transactions.
   *
   * If the Transaction `feePayer` is not set, the first signer will be used
   * as the transaction fee payer account.
   *
   * Transaction fields should not be modified after the first call to `sign`,
   * as doing so may invalidate the signature and cause the Transaction to be
   * rejected.
   *
   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
   *
   * @param {Array<Signer>} signers Array of signers that will sign the transaction
   */
  sign(...ie) {
    if (ie.length === 0)
      throw new Error("No signers");
    const se = /* @__PURE__ */ new Set(), fe = [];
    for (const ce of ie) {
      const de = ce.publicKey.toString();
      se.has(de) || (se.add(de), fe.push(ce));
    }
    this.signatures = fe.map((ce) => ({
      signature: null,
      publicKey: ce.publicKey
    }));
    const ue = this._compile();
    this._partialSign(ue, ...fe);
  }
  /**
   * Partially sign a transaction with the specified accounts. All accounts must
   * correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * All the caveats from the `sign` method apply to `partialSign`
   *
   * @param {Array<Signer>} signers Array of signers that will sign the transaction
   */
  partialSign(...ie) {
    if (ie.length === 0)
      throw new Error("No signers");
    const se = /* @__PURE__ */ new Set(), fe = [];
    for (const ce of ie) {
      const de = ce.publicKey.toString();
      se.has(de) || (se.add(de), fe.push(ce));
    }
    const ue = this._compile();
    this._partialSign(ue, ...fe);
  }
  /**
   * @internal
   */
  _partialSign(ie, ...se) {
    const fe = ie.serialize();
    se.forEach((ue) => {
      const ce = sign(fe, ue.secretKey);
      this._addSignature(ue.publicKey, toBuffer(ce));
    });
  }
  /**
   * Add an externally created signature to a transaction. The public key
   * must correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * @param {PublicKey} pubkey Public key that will be added to the transaction.
   * @param {Buffer} signature An externally created signature to add to the transaction.
   */
  addSignature(ie, se) {
    this._compile(), this._addSignature(ie, se);
  }
  /**
   * @internal
   */
  _addSignature(ie, se) {
    assert(se.length === 64);
    const fe = this.signatures.findIndex((ue) => ie.equals(ue.publicKey));
    if (fe < 0)
      throw new Error(`unknown signer: ${ie.toString()}`);
    this.signatures[fe].signature = Buffer$1$1.from(se);
  }
  /**
   * Verify signatures of a Transaction
   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.
   * If no boolean is provided, we expect a fully signed Transaction by default.
   *
   * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction
   */
  verifySignatures(ie = !0) {
    return !this._getMessageSignednessErrors(this.serializeMessage(), ie);
  }
  /**
   * @internal
   */
  _getMessageSignednessErrors(ie, se) {
    const fe = {};
    for (const {
      signature: ue,
      publicKey: ce
    } of this.signatures)
      ue === null ? se && (fe.missing ||= []).push(ce) : verify(ue, ie, ce.toBytes()) || (fe.invalid ||= []).push(ce);
    return fe.invalid || fe.missing ? fe : void 0;
  }
  /**
   * Serialize the Transaction in the wire format.
   *
   * @param {Buffer} [config] Config of transaction.
   *
   * @returns {Buffer} Signature of transaction in wire format.
   */
  serialize(ie) {
    const {
      requireAllSignatures: se,
      verifySignatures: fe
    } = Object.assign({
      requireAllSignatures: !0,
      verifySignatures: !0
    }, ie), ue = this.serializeMessage();
    if (fe) {
      const ce = this._getMessageSignednessErrors(ue, se);
      if (ce) {
        let de = "Signature verification failed.";
        throw ce.invalid && (de += `
Invalid signature for public key${ce.invalid.length === 1 ? "" : "(s)"} [\`${ce.invalid.map((me) => me.toBase58()).join("`, `")}\`].`), ce.missing && (de += `
Missing signature for public key${ce.missing.length === 1 ? "" : "(s)"} [\`${ce.missing.map((me) => me.toBase58()).join("`, `")}\`].`), new Error(de);
      }
    }
    return this._serialize(ue);
  }
  /**
   * @internal
   */
  _serialize(ie) {
    const {
      signatures: se
    } = this, fe = [];
    encodeLength(fe, se.length);
    const ue = fe.length + se.length * 64 + ie.length, ce = Buffer$1$1.alloc(ue);
    return assert(se.length < 256), Buffer$1$1.from(fe).copy(ce, 0), se.forEach(({
      signature: de
    }, me) => {
      de !== null && (assert(de.length === 64, "signature has invalid length"), Buffer$1$1.from(de).copy(ce, fe.length + me * 64));
    }), ie.copy(ce, fe.length + se.length * 64), assert(ce.length <= PACKET_DATA_SIZE, `Transaction too large: ${ce.length} > ${PACKET_DATA_SIZE}`), ce;
  }
  /**
   * Deprecated method
   * @internal
   */
  get keys() {
    return assert(this.instructions.length === 1), this.instructions[0].keys.map((ie) => ie.pubkey);
  }
  /**
   * Deprecated method
   * @internal
   */
  get programId() {
    return assert(this.instructions.length === 1), this.instructions[0].programId;
  }
  /**
   * Deprecated method
   * @internal
   */
  get data() {
    return assert(this.instructions.length === 1), this.instructions[0].data;
  }
  /**
   * Parse a wire transaction into a Transaction object.
   *
   * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction
   *
   * @returns {Transaction} Transaction associated with the signature
   */
  static from(ie) {
    let se = [...ie];
    const fe = decodeLength(se);
    let ue = [];
    for (let ce = 0; ce < fe; ce++) {
      const de = se.slice(0, SIGNATURE_LENGTH_IN_BYTES);
      se = se.slice(SIGNATURE_LENGTH_IN_BYTES), ue.push(bs58$1.encode(Buffer$1$1.from(de)));
    }
    return Transaction.populate(Message.from(se), ue);
  }
  /**
   * Populate Transaction object from message and signatures
   *
   * @param {Message} message Message of transaction
   * @param {Array<string>} signatures List of signatures to assign to the transaction
   *
   * @returns {Transaction} The populated Transaction
   */
  static populate(ie, se = []) {
    const fe = new Transaction();
    return fe.recentBlockhash = ie.recentBlockhash, ie.header.numRequiredSignatures > 0 && (fe.feePayer = ie.accountKeys[0]), se.forEach((ue, ce) => {
      const de = {
        signature: ue == bs58$1.encode(DEFAULT_SIGNATURE) ? null : bs58$1.decode(ue),
        publicKey: ie.accountKeys[ce]
      };
      fe.signatures.push(de);
    }), ie.instructions.forEach((ue) => {
      const ce = ue.accounts.map((de) => {
        const me = ie.accountKeys[de];
        return {
          pubkey: me,
          isSigner: fe.signatures.some((we) => we.publicKey.toString() === me.toString()) || ie.isAccountSigner(de),
          isWritable: ie.isAccountWritable(de)
        };
      });
      fe.instructions.push(new TransactionInstruction({
        keys: ce,
        programId: ie.accountKeys[ue.programIdIndex],
        data: bs58$1.decode(ue.data)
      }));
    }), fe._message = ie, fe._json = fe.toJSON(), fe;
  }
}
class VersionedTransaction {
  get version() {
    return this.message.version;
  }
  constructor(ie, se) {
    if (this.signatures = void 0, this.message = void 0, se !== void 0)
      assert(se.length === ie.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures"), this.signatures = se;
    else {
      const fe = [];
      for (let ue = 0; ue < ie.header.numRequiredSignatures; ue++)
        fe.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));
      this.signatures = fe;
    }
    this.message = ie;
  }
  serialize() {
    const ie = this.message.serialize(), se = Array();
    encodeLength(se, this.signatures.length);
    const fe = struct([blob(se.length, "encodedSignaturesLength"), seq(signature(), this.signatures.length, "signatures"), blob(ie.length, "serializedMessage")]), ue = new Uint8Array(2048), ce = fe.encode({
      encodedSignaturesLength: new Uint8Array(se),
      signatures: this.signatures,
      serializedMessage: ie
    }, ue);
    return ue.slice(0, ce);
  }
  static deserialize(ie) {
    let se = [...ie];
    const fe = [], ue = decodeLength(se);
    for (let de = 0; de < ue; de++)
      fe.push(new Uint8Array(se.splice(0, SIGNATURE_LENGTH_IN_BYTES)));
    const ce = VersionedMessage.deserialize(new Uint8Array(se));
    return new VersionedTransaction(ce, fe);
  }
  sign(ie) {
    const se = this.message.serialize(), fe = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
    for (const ue of ie) {
      const ce = fe.findIndex((de) => de.equals(ue.publicKey));
      assert(ce >= 0, `Cannot sign with non signer key ${ue.publicKey.toBase58()}`), this.signatures[ce] = sign(se, ue.secretKey);
    }
  }
  addSignature(ie, se) {
    assert(se.byteLength === 64, "Signature must be 64 bytes long");
    const ue = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures).findIndex((ce) => ce.equals(ie));
    assert(ue >= 0, `Can not add signature; \`${ie.toBase58()}\` is not required to sign this transaction`), this.signatures[ue] = se;
  }
}
const NUM_TICKS_PER_SECOND = 160, DEFAULT_TICKS_PER_SLOT = 64, NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT, MS_PER_SLOT = 1e3 / NUM_SLOTS_PER_SECOND;
new PublicKey("SysvarC1ock11111111111111111111111111111111");
new PublicKey("SysvarEpochSchedu1e111111111111111111111111");
new PublicKey("Sysvar1nstructions1111111111111111111111111");
const SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey("SysvarRecentB1ockHashes11111111111111111111"), SYSVAR_RENT_PUBKEY = new PublicKey("SysvarRent111111111111111111111111111111111");
new PublicKey("SysvarRewards111111111111111111111111111111");
new PublicKey("SysvarS1otHashes111111111111111111111111111");
new PublicKey("SysvarS1otHistory11111111111111111111111111");
new PublicKey("SysvarStakeHistory1111111111111111111111111");
function sleep(ae) {
  return new Promise((ie) => setTimeout(ie, ae));
}
function encodeData(ae, ie) {
  const se = ae.layout.span >= 0 ? ae.layout.span : getAlloc(ae, ie), fe = Buffer$1$1.alloc(se), ue = Object.assign({
    instruction: ae.index
  }, ie);
  return ae.layout.encode(ue, fe), fe;
}
const FeeCalculatorLayout = nu64("lamportsPerSignature"), NonceAccountLayout = struct([u32("version"), u32("state"), publicKey("authorizedPubkey"), publicKey("nonce"), struct([FeeCalculatorLayout], "feeCalculator")]), NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;
class NonceAccount {
  /**
   * @internal
   */
  constructor(ie) {
    this.authorizedPubkey = void 0, this.nonce = void 0, this.feeCalculator = void 0, this.authorizedPubkey = ie.authorizedPubkey, this.nonce = ie.nonce, this.feeCalculator = ie.feeCalculator;
  }
  /**
   * Deserialize NonceAccount from the account data.
   *
   * @param buffer account data
   * @return NonceAccount
   */
  static fromAccountData(ie) {
    const se = NonceAccountLayout.decode(toBuffer(ie), 0);
    return new NonceAccount({
      authorizedPubkey: new PublicKey(se.authorizedPubkey),
      nonce: new PublicKey(se.nonce).toString(),
      feeCalculator: se.feeCalculator
    });
  }
}
const encodeDecode = (ae) => {
  const ie = ae.decode.bind(ae), se = ae.encode.bind(ae);
  return {
    decode: ie,
    encode: se
  };
}, bigInt = (ae) => (ie) => {
  const se = blob(ae, ie), {
    encode: fe,
    decode: ue
  } = encodeDecode(se), ce = se;
  return ce.decode = (de, me) => {
    const we = ue(de, me);
    return toBigIntLE_1(Buffer$1$1.from(we));
  }, ce.encode = (de, me, we) => {
    const Ee = toBufferLE_1(de, ae);
    return fe(Ee, me, we);
  }, ce;
}, u64 = bigInt(8), SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
  Create: {
    index: 0,
    layout: struct([u32("instruction"), ns64("lamports"), ns64("space"), publicKey("programId")])
  },
  Assign: {
    index: 1,
    layout: struct([u32("instruction"), publicKey("programId")])
  },
  Transfer: {
    index: 2,
    layout: struct([u32("instruction"), u64("lamports")])
  },
  CreateWithSeed: {
    index: 3,
    layout: struct([u32("instruction"), publicKey("base"), rustString("seed"), ns64("lamports"), ns64("space"), publicKey("programId")])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: struct([u32("instruction")])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: struct([u32("instruction"), ns64("lamports")])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: struct([u32("instruction"), publicKey("authorized")])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: struct([u32("instruction"), publicKey("authorized")])
  },
  Allocate: {
    index: 8,
    layout: struct([u32("instruction"), ns64("space")])
  },
  AllocateWithSeed: {
    index: 9,
    layout: struct([u32("instruction"), publicKey("base"), rustString("seed"), ns64("space"), publicKey("programId")])
  },
  AssignWithSeed: {
    index: 10,
    layout: struct([u32("instruction"), publicKey("base"), rustString("seed"), publicKey("programId")])
  },
  TransferWithSeed: {
    index: 11,
    layout: struct([u32("instruction"), u64("lamports"), rustString("seed"), publicKey("programId")])
  },
  UpgradeNonceAccount: {
    index: 12,
    layout: struct([u32("instruction")])
  }
});
class SystemProgram {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the System program
   */
  /**
   * Generate a transaction instruction that creates a new account
   */
  static createAccount(ie) {
    const se = SYSTEM_INSTRUCTION_LAYOUTS.Create, fe = encodeData(se, {
      lamports: ie.lamports,
      space: ie.space,
      programId: toBuffer(ie.programId.toBuffer())
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: ie.fromPubkey,
        isSigner: !0,
        isWritable: !0
      }, {
        pubkey: ie.newAccountPubkey,
        isSigner: !0,
        isWritable: !0
      }],
      programId: this.programId,
      data: fe
    });
  }
  /**
   * Generate a transaction instruction that transfers lamports from one account to another
   */
  static transfer(ie) {
    let se, fe;
    if ("basePubkey" in ie) {
      const ue = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
      se = encodeData(ue, {
        lamports: BigInt(ie.lamports),
        seed: ie.seed,
        programId: toBuffer(ie.programId.toBuffer())
      }), fe = [{
        pubkey: ie.fromPubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: ie.basePubkey,
        isSigner: !0,
        isWritable: !1
      }, {
        pubkey: ie.toPubkey,
        isSigner: !1,
        isWritable: !0
      }];
    } else {
      const ue = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
      se = encodeData(ue, {
        lamports: BigInt(ie.lamports)
      }), fe = [{
        pubkey: ie.fromPubkey,
        isSigner: !0,
        isWritable: !0
      }, {
        pubkey: ie.toPubkey,
        isSigner: !1,
        isWritable: !0
      }];
    }
    return new TransactionInstruction({
      keys: fe,
      programId: this.programId,
      data: se
    });
  }
  /**
   * Generate a transaction instruction that assigns an account to a program
   */
  static assign(ie) {
    let se, fe;
    if ("basePubkey" in ie) {
      const ue = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
      se = encodeData(ue, {
        base: toBuffer(ie.basePubkey.toBuffer()),
        seed: ie.seed,
        programId: toBuffer(ie.programId.toBuffer())
      }), fe = [{
        pubkey: ie.accountPubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: ie.basePubkey,
        isSigner: !0,
        isWritable: !1
      }];
    } else {
      const ue = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
      se = encodeData(ue, {
        programId: toBuffer(ie.programId.toBuffer())
      }), fe = [{
        pubkey: ie.accountPubkey,
        isSigner: !0,
        isWritable: !0
      }];
    }
    return new TransactionInstruction({
      keys: fe,
      programId: this.programId,
      data: se
    });
  }
  /**
   * Generate a transaction instruction that creates a new account at
   *   an address generated with `from`, a seed, and programId
   */
  static createAccountWithSeed(ie) {
    const se = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, fe = encodeData(se, {
      base: toBuffer(ie.basePubkey.toBuffer()),
      seed: ie.seed,
      lamports: ie.lamports,
      space: ie.space,
      programId: toBuffer(ie.programId.toBuffer())
    });
    let ue = [{
      pubkey: ie.fromPubkey,
      isSigner: !0,
      isWritable: !0
    }, {
      pubkey: ie.newAccountPubkey,
      isSigner: !1,
      isWritable: !0
    }];
    return ie.basePubkey != ie.fromPubkey && ue.push({
      pubkey: ie.basePubkey,
      isSigner: !0,
      isWritable: !1
    }), new TransactionInstruction({
      keys: ue,
      programId: this.programId,
      data: fe
    });
  }
  /**
   * Generate a transaction that creates a new Nonce account
   */
  static createNonceAccount(ie) {
    const se = new Transaction();
    "basePubkey" in ie && "seed" in ie ? se.add(SystemProgram.createAccountWithSeed({
      fromPubkey: ie.fromPubkey,
      newAccountPubkey: ie.noncePubkey,
      basePubkey: ie.basePubkey,
      seed: ie.seed,
      lamports: ie.lamports,
      space: NONCE_ACCOUNT_LENGTH,
      programId: this.programId
    })) : se.add(SystemProgram.createAccount({
      fromPubkey: ie.fromPubkey,
      newAccountPubkey: ie.noncePubkey,
      lamports: ie.lamports,
      space: NONCE_ACCOUNT_LENGTH,
      programId: this.programId
    }));
    const fe = {
      noncePubkey: ie.noncePubkey,
      authorizedPubkey: ie.authorizedPubkey
    };
    return se.add(this.nonceInitialize(fe)), se;
  }
  /**
   * Generate an instruction to initialize a Nonce account
   */
  static nonceInitialize(ie) {
    const se = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, fe = encodeData(se, {
      authorized: toBuffer(ie.authorizedPubkey.toBuffer())
    }), ue = {
      keys: [{
        pubkey: ie.noncePubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }],
      programId: this.programId,
      data: fe
    };
    return new TransactionInstruction(ue);
  }
  /**
   * Generate an instruction to advance the nonce in a Nonce account
   */
  static nonceAdvance(ie) {
    const se = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, fe = encodeData(se), ue = {
      keys: [{
        pubkey: ie.noncePubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: ie.authorizedPubkey,
        isSigner: !0,
        isWritable: !1
      }],
      programId: this.programId,
      data: fe
    };
    return new TransactionInstruction(ue);
  }
  /**
   * Generate a transaction instruction that withdraws lamports from a Nonce account
   */
  static nonceWithdraw(ie) {
    const se = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, fe = encodeData(se, {
      lamports: ie.lamports
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: ie.noncePubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: ie.toPubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: ie.authorizedPubkey,
        isSigner: !0,
        isWritable: !1
      }],
      programId: this.programId,
      data: fe
    });
  }
  /**
   * Generate a transaction instruction that authorizes a new PublicKey as the authority
   * on a Nonce account.
   */
  static nonceAuthorize(ie) {
    const se = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, fe = encodeData(se, {
      authorized: toBuffer(ie.newAuthorizedPubkey.toBuffer())
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: ie.noncePubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: ie.authorizedPubkey,
        isSigner: !0,
        isWritable: !1
      }],
      programId: this.programId,
      data: fe
    });
  }
  /**
   * Generate a transaction instruction that allocates space in an account without funding
   */
  static allocate(ie) {
    let se, fe;
    if ("basePubkey" in ie) {
      const ue = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
      se = encodeData(ue, {
        base: toBuffer(ie.basePubkey.toBuffer()),
        seed: ie.seed,
        space: ie.space,
        programId: toBuffer(ie.programId.toBuffer())
      }), fe = [{
        pubkey: ie.accountPubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: ie.basePubkey,
        isSigner: !0,
        isWritable: !1
      }];
    } else {
      const ue = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
      se = encodeData(ue, {
        space: ie.space
      }), fe = [{
        pubkey: ie.accountPubkey,
        isSigner: !0,
        isWritable: !0
      }];
    }
    return new TransactionInstruction({
      keys: fe,
      programId: this.programId,
      data: se
    });
  }
}
SystemProgram.programId = new PublicKey("11111111111111111111111111111111");
new PublicKey("BPFLoader2111111111111111111111111111111111");
function getDefaultExportFromCjs(ae) {
  return ae && ae.__esModule && Object.prototype.hasOwnProperty.call(ae, "default") ? ae.default : ae;
}
var objToString = Object.prototype.toString, objKeys = Object.keys || function(ae) {
  var ie = [];
  for (var se in ae)
    ie.push(se);
  return ie;
};
function stringify(ae, ie) {
  var se, fe, ue, ce, de, me, we;
  if (ae === !0)
    return "true";
  if (ae === !1)
    return "false";
  switch (typeof ae) {
    case "object":
      if (ae === null)
        return null;
      if (ae.toJSON && typeof ae.toJSON == "function")
        return stringify(ae.toJSON(), ie);
      if (we = objToString.call(ae), we === "[object Array]") {
        for (ue = "[", fe = ae.length - 1, se = 0; se < fe; se++)
          ue += stringify(ae[se], !0) + ",";
        return fe > -1 && (ue += stringify(ae[se], !0)), ue + "]";
      } else if (we === "[object Object]") {
        for (ce = objKeys(ae).sort(), fe = ce.length, ue = "", se = 0; se < fe; )
          de = ce[se], me = stringify(ae[de], !1), me !== void 0 && (ue && (ue += ","), ue += JSON.stringify(de) + ":" + me), se++;
        return "{" + ue + "}";
      } else
        return JSON.stringify(ae);
    case "function":
    case "undefined":
      return ie ? null : void 0;
    case "string":
      return JSON.stringify(ae);
    default:
      return isFinite(ae) ? ae : null;
  }
}
var fastStableStringify = function(ae) {
  var ie = stringify(ae, !1);
  if (ie !== void 0)
    return "" + ie;
}, fastStableStringify$1 = /* @__PURE__ */ getDefaultExportFromCjs(fastStableStringify);
const MINIMUM_SLOT_PER_EPOCH = 32;
function trailingZeros(ae) {
  let ie = 0;
  for (; ae > 1; )
    ae /= 2, ie++;
  return ie;
}
function nextPowerOfTwo(ae) {
  return ae === 0 ? 1 : (ae--, ae |= ae >> 1, ae |= ae >> 2, ae |= ae >> 4, ae |= ae >> 8, ae |= ae >> 16, ae |= ae >> 32, ae + 1);
}
class EpochSchedule {
  constructor(ie, se, fe, ue, ce) {
    this.slotsPerEpoch = void 0, this.leaderScheduleSlotOffset = void 0, this.warmup = void 0, this.firstNormalEpoch = void 0, this.firstNormalSlot = void 0, this.slotsPerEpoch = ie, this.leaderScheduleSlotOffset = se, this.warmup = fe, this.firstNormalEpoch = ue, this.firstNormalSlot = ce;
  }
  getEpoch(ie) {
    return this.getEpochAndSlotIndex(ie)[0];
  }
  getEpochAndSlotIndex(ie) {
    if (ie < this.firstNormalSlot) {
      const se = trailingZeros(nextPowerOfTwo(ie + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1, fe = this.getSlotsInEpoch(se), ue = ie - (fe - MINIMUM_SLOT_PER_EPOCH);
      return [se, ue];
    } else {
      const se = ie - this.firstNormalSlot, fe = Math.floor(se / this.slotsPerEpoch), ue = this.firstNormalEpoch + fe, ce = se % this.slotsPerEpoch;
      return [ue, ce];
    }
  }
  getFirstSlotInEpoch(ie) {
    return ie <= this.firstNormalEpoch ? (Math.pow(2, ie) - 1) * MINIMUM_SLOT_PER_EPOCH : (ie - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
  }
  getLastSlotInEpoch(ie) {
    return this.getFirstSlotInEpoch(ie) + this.getSlotsInEpoch(ie) - 1;
  }
  getSlotsInEpoch(ie) {
    return ie < this.firstNormalEpoch ? Math.pow(2, ie + trailingZeros(MINIMUM_SLOT_PER_EPOCH)) : this.slotsPerEpoch;
  }
}
class SendTransactionError extends Error {
  constructor(ie, se) {
    super(ie), this.logs = void 0, this.logs = se;
  }
}
class SolanaJSONRPCError extends Error {
  constructor({
    code: ie,
    message: se,
    data: fe
  }, ue) {
    super(ue != null ? `${ue}: ${se}` : se), this.code = void 0, this.data = void 0, this.code = ie, this.data = fe, this.name = "SolanaJSONRPCError";
  }
}
var fetchImpl = globalThis.fetch;
class RpcWebSocketClient extends RpcWebSocketCommonClient {
  constructor(ie, se, fe) {
    const ue = (ce) => {
      const de = createRpc(ce, {
        autoconnect: !0,
        max_reconnects: 5,
        reconnect: !0,
        reconnect_interval: 1e3,
        ...se
      });
      return "socket" in de ? this.underlyingSocket = de.socket : this.underlyingSocket = de, de;
    };
    super(ue, ie, se, fe), this.underlyingSocket = void 0;
  }
  call(...ie) {
    const se = this.underlyingSocket?.readyState;
    return se === 1 ? super.call(...ie) : Promise.reject(new Error("Tried to call a JSON-RPC method `" + ie[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + se + ")"));
  }
  notify(...ie) {
    const se = this.underlyingSocket?.readyState;
    return se === 1 ? super.notify(...ie) : Promise.reject(new Error("Tried to send a JSON-RPC notification `" + ie[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + se + ")"));
  }
}
function decodeData(ae, ie) {
  let se;
  try {
    se = ae.layout.decode(ie);
  } catch (fe) {
    throw new Error("invalid instruction; " + fe);
  }
  if (se.typeIndex !== ae.index)
    throw new Error(`invalid account data; account type mismatch ${se.typeIndex} != ${ae.index}`);
  return se;
}
const LOOKUP_TABLE_META_SIZE = 56;
class AddressLookupTableAccount {
  constructor(ie) {
    this.key = void 0, this.state = void 0, this.key = ie.key, this.state = ie.state;
  }
  isActive() {
    const ie = BigInt("0xffffffffffffffff");
    return this.state.deactivationSlot === ie;
  }
  static deserialize(ie) {
    const se = decodeData(LookupTableMetaLayout, ie), fe = ie.length - LOOKUP_TABLE_META_SIZE;
    assert(fe >= 0, "lookup table is invalid"), assert(fe % 32 === 0, "lookup table is invalid");
    const ue = fe / 32, {
      addresses: ce
    } = struct([seq(publicKey(), ue, "addresses")]).decode(ie.slice(LOOKUP_TABLE_META_SIZE));
    return {
      deactivationSlot: se.deactivationSlot,
      lastExtendedSlot: se.lastExtendedSlot,
      lastExtendedSlotStartIndex: se.lastExtendedStartIndex,
      authority: se.authority.length !== 0 ? new PublicKey(se.authority[0]) : void 0,
      addresses: ce.map((de) => new PublicKey(de))
    };
  }
}
const LookupTableMetaLayout = {
  index: 1,
  layout: struct([
    u32("typeIndex"),
    u64("deactivationSlot"),
    nu64("lastExtendedSlot"),
    u8("lastExtendedStartIndex"),
    u8(),
    // option
    seq(publicKey(), offset(u8(), -1), "authority")
  ])
}, URL_RE = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
function makeWebsocketUrl(ae) {
  const ie = ae.match(URL_RE);
  if (ie == null)
    throw TypeError(`Failed to validate endpoint URL \`${ae}\``);
  const [
    se,
    // eslint-disable-line @typescript-eslint/no-unused-vars
    fe,
    ue,
    ce
  ] = ie, de = ae.startsWith("https:") ? "wss:" : "ws:", me = ue == null ? null : parseInt(ue.slice(1), 10), we = (
    // Only shift the port by +1 as a convention for ws(s) only if given endpoint
    // is explicitly specifying the endpoint port (HTTP-based RPC), assuming
    // we're directly trying to connect to solana-validator's ws listening port.
    // When the endpoint omits the port, we're connecting to the protocol
    // default ports: http(80) or https(443) and it's assumed we're behind a reverse
    // proxy which manages WebSocket upgrade and backend port redirection.
    me == null ? "" : `:${me + 1}`
  );
  return `${de}//${fe}${we}${ce}`;
}
const PublicKeyFromString = coerce(instance(PublicKey), string(), (ae) => new PublicKey(ae)), RawAccountDataResult = tuple([string(), literal("base64")]), BufferFromRawAccountData = coerce(instance(Buffer$1$1), RawAccountDataResult, (ae) => Buffer$1$1.from(ae[0], "base64")), BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1e3;
function assertEndpointUrl(ae) {
  if (/^https?:/.test(ae) === !1)
    throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
  return ae;
}
function extractCommitmentFromConfig(ae) {
  let ie, se;
  if (typeof ae == "string")
    ie = ae;
  else if (ae) {
    const {
      commitment: fe,
      ...ue
    } = ae;
    ie = fe, se = ue;
  }
  return {
    commitment: ie,
    config: se
  };
}
function createRpcResult(ae) {
  return union([type({
    jsonrpc: literal("2.0"),
    id: string(),
    result: ae
  }), type({
    jsonrpc: literal("2.0"),
    id: string(),
    error: type({
      code: unknown(),
      message: string(),
      data: optional(any())
    })
  })]);
}
const UnknownRpcResult = createRpcResult(unknown());
function jsonRpcResult(ae) {
  return coerce(createRpcResult(ae), UnknownRpcResult, (ie) => "error" in ie ? ie : {
    ...ie,
    result: create(ie.result, ae)
  });
}
function jsonRpcResultAndContext(ae) {
  return jsonRpcResult(type({
    context: type({
      slot: number()
    }),
    value: ae
  }));
}
function notificationResultAndContext(ae) {
  return type({
    context: type({
      slot: number()
    }),
    value: ae
  });
}
function versionedMessageFromResponse(ae, ie) {
  return ae === 0 ? new MessageV0({
    header: ie.header,
    staticAccountKeys: ie.accountKeys.map((se) => new PublicKey(se)),
    recentBlockhash: ie.recentBlockhash,
    compiledInstructions: ie.instructions.map((se) => ({
      programIdIndex: se.programIdIndex,
      accountKeyIndexes: se.accounts,
      data: bs58$1.decode(se.data)
    })),
    addressTableLookups: ie.addressTableLookups
  }) : new Message(ie);
}
const GetInflationGovernorResult = type({
  foundation: number(),
  foundationTerm: number(),
  initial: number(),
  taper: number(),
  terminal: number()
}), GetInflationRewardResult = jsonRpcResult(array(nullable(type({
  epoch: number(),
  effectiveSlot: number(),
  amount: number(),
  postBalance: number(),
  commission: optional(nullable(number()))
})))), GetRecentPrioritizationFeesResult = array(type({
  slot: number(),
  prioritizationFee: number()
})), GetInflationRateResult = type({
  total: number(),
  validator: number(),
  foundation: number(),
  epoch: number()
}), GetEpochInfoResult = type({
  epoch: number(),
  slotIndex: number(),
  slotsInEpoch: number(),
  absoluteSlot: number(),
  blockHeight: optional(number()),
  transactionCount: optional(number())
}), GetEpochScheduleResult = type({
  slotsPerEpoch: number(),
  leaderScheduleSlotOffset: number(),
  warmup: boolean(),
  firstNormalEpoch: number(),
  firstNormalSlot: number()
}), GetLeaderScheduleResult = record(string(), array(number())), TransactionErrorResult = nullable(union([type({}), string()])), SignatureStatusResult = type({
  err: TransactionErrorResult
}), SignatureReceivedResult = literal("receivedSignature"), VersionResult = type({
  "solana-core": string(),
  "feature-set": optional(number())
}), SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type({
  err: nullable(union([type({}), string()])),
  logs: nullable(array(string())),
  accounts: optional(nullable(array(nullable(type({
    executable: boolean(),
    owner: string(),
    lamports: number(),
    data: array(string()),
    rentEpoch: optional(number())
  }))))),
  unitsConsumed: optional(number()),
  returnData: optional(nullable(type({
    programId: string(),
    data: tuple([string(), literal("base64")])
  })))
})), BlockProductionResponseStruct = jsonRpcResultAndContext(type({
  byIdentity: record(string(), array(number())),
  range: type({
    firstSlot: number(),
    lastSlot: number()
  })
}));
function createRpcClient(ae, ie, se, fe, ue, ce) {
  const de = se || fetchImpl;
  let me;
  ce != null && console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");
  let we;
  return fe && (we = async (Se, Be) => {
    const Ce = await new Promise((Ie, Pe) => {
      try {
        fe(Se, Be, (Ne, ke) => Ie([Ne, ke]));
      } catch (Ne) {
        Pe(Ne);
      }
    });
    return await de(...Ce);
  }), new RpcClient(async (Se, Be) => {
    const Ce = {
      method: "POST",
      body: Se,
      agent: me,
      headers: Object.assign({
        "Content-Type": "application/json"
      }, ie || {}, COMMON_HTTP_HEADERS)
    };
    try {
      let Ie = 5, Pe, Ne = 500;
      for (; we ? Pe = await we(ae, Ce) : Pe = await de(ae, Ce), !(Pe.status !== 429 || ue === !0 || (Ie -= 1, Ie === 0)); )
        console.error(`Server responded with ${Pe.status} ${Pe.statusText}.  Retrying after ${Ne}ms delay...`), await sleep(Ne), Ne *= 2;
      const ke = await Pe.text();
      Pe.ok ? Be(null, ke) : Be(new Error(`${Pe.status} ${Pe.statusText}: ${ke}`));
    } catch (Ie) {
      Ie instanceof Error && Be(Ie);
    }
  }, {});
}
function createRpcRequest(ae) {
  return (ie, se) => new Promise((fe, ue) => {
    ae.request(ie, se, (ce, de) => {
      if (ce) {
        ue(ce);
        return;
      }
      fe(de);
    });
  });
}
function createRpcBatchRequest(ae) {
  return (ie) => new Promise((se, fe) => {
    ie.length === 0 && se([]);
    const ue = ie.map((ce) => ae.request(ce.methodName, ce.args));
    ae.request(ue, (ce, de) => {
      if (ce) {
        fe(ce);
        return;
      }
      se(de);
    });
  });
}
const GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult), GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult), GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult), GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult), GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult), GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult), SlotRpcResult = jsonRpcResult(number()), GetSupplyRpcResult = jsonRpcResultAndContext(type({
  total: number(),
  circulating: number(),
  nonCirculating: number(),
  nonCirculatingAccounts: array(PublicKeyFromString)
})), TokenAmountResult = type({
  amount: string(),
  uiAmount: nullable(number()),
  decimals: number(),
  uiAmountString: optional(string())
}), GetTokenLargestAccountsResult = jsonRpcResultAndContext(array(type({
  address: PublicKeyFromString,
  amount: string(),
  uiAmount: nullable(number()),
  decimals: number(),
  uiAmountString: optional(string())
}))), GetTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number(),
    data: BufferFromRawAccountData,
    rentEpoch: number()
  })
}))), ParsedAccountDataResult = type({
  program: string(),
  parsed: unknown(),
  space: number()
}), GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number(),
    data: ParsedAccountDataResult,
    rentEpoch: number()
  })
}))), GetLargestAccountsRpcResult = jsonRpcResultAndContext(array(type({
  lamports: number(),
  address: PublicKeyFromString
}))), AccountInfoResult = type({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number(),
  data: BufferFromRawAccountData,
  rentEpoch: number()
}), KeyedAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
}), ParsedOrRawAccountData = coerce(union([instance(Buffer$1$1), ParsedAccountDataResult]), union([RawAccountDataResult, ParsedAccountDataResult]), (ae) => Array.isArray(ae) ? create(ae, BufferFromRawAccountData) : ae), ParsedAccountInfoResult = type({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number(),
  data: ParsedOrRawAccountData,
  rentEpoch: number()
}), KeyedParsedAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: ParsedAccountInfoResult
}), StakeActivationResult = type({
  state: union([literal("active"), literal("inactive"), literal("activating"), literal("deactivating")]),
  active: number(),
  inactive: number()
}), GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(array(type({
  signature: string(),
  slot: number(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number()))
}))), GetSignaturesForAddressRpcResult = jsonRpcResult(array(type({
  signature: string(),
  slot: number(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number()))
}))), AccountNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(AccountInfoResult)
}), ProgramAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
}), ProgramAccountNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(ProgramAccountInfoResult)
}), SlotInfoResult = type({
  parent: number(),
  slot: number(),
  root: number()
}), SlotNotificationResult = type({
  subscription: number(),
  result: SlotInfoResult
}), SlotUpdateResult = union([type({
  type: union([literal("firstShredReceived"), literal("completed"), literal("optimisticConfirmation"), literal("root")]),
  slot: number(),
  timestamp: number()
}), type({
  type: literal("createdBank"),
  parent: number(),
  slot: number(),
  timestamp: number()
}), type({
  type: literal("frozen"),
  slot: number(),
  timestamp: number(),
  stats: type({
    numTransactionEntries: number(),
    numSuccessfulTransactions: number(),
    numFailedTransactions: number(),
    maxTransactionsPerEntry: number()
  })
}), type({
  type: literal("dead"),
  slot: number(),
  timestamp: number(),
  err: string()
})]), SlotUpdateNotificationResult = type({
  subscription: number(),
  result: SlotUpdateResult
}), SignatureNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(union([SignatureStatusResult, SignatureReceivedResult]))
}), RootNotificationResult = type({
  subscription: number(),
  result: number()
}), ContactInfoResult = type({
  pubkey: string(),
  gossip: nullable(string()),
  tpu: nullable(string()),
  rpc: nullable(string()),
  version: nullable(string())
}), VoteAccountInfoResult = type({
  votePubkey: string(),
  nodePubkey: string(),
  activatedStake: number(),
  epochVoteAccount: boolean(),
  epochCredits: array(tuple([number(), number(), number()])),
  commission: number(),
  lastVote: number(),
  rootSlot: nullable(number())
}), GetVoteAccounts = jsonRpcResult(type({
  current: array(VoteAccountInfoResult),
  delinquent: array(VoteAccountInfoResult)
})), ConfirmationStatus = union([literal("processed"), literal("confirmed"), literal("finalized")]), SignatureStatusResponse = type({
  slot: number(),
  confirmations: nullable(number()),
  err: TransactionErrorResult,
  confirmationStatus: optional(ConfirmationStatus)
}), GetSignatureStatusesRpcResult = jsonRpcResultAndContext(array(nullable(SignatureStatusResponse))), GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(number()), AddressTableLookupStruct = type({
  accountKey: PublicKeyFromString,
  writableIndexes: array(number()),
  readonlyIndexes: array(number())
}), ConfirmedTransactionResult = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(string()),
    header: type({
      numRequiredSignatures: number(),
      numReadonlySignedAccounts: number(),
      numReadonlyUnsignedAccounts: number()
    }),
    instructions: array(type({
      accounts: array(number()),
      data: string(),
      programIdIndex: number()
    })),
    recentBlockhash: string(),
    addressTableLookups: optional(array(AddressTableLookupStruct))
  })
}), AnnotatedAccountKey = type({
  pubkey: PublicKeyFromString,
  signer: boolean(),
  writable: boolean(),
  source: optional(union([literal("transaction"), literal("lookupTable")]))
}), ConfirmedTransactionAccountsModeResult = type({
  accountKeys: array(AnnotatedAccountKey),
  signatures: array(string())
}), ParsedInstructionResult = type({
  parsed: unknown(),
  program: string(),
  programId: PublicKeyFromString
}), RawInstructionResult = type({
  accounts: array(PublicKeyFromString),
  data: string(),
  programId: PublicKeyFromString
}), InstructionResult = union([RawInstructionResult, ParsedInstructionResult]), UnknownInstructionResult = union([type({
  parsed: unknown(),
  program: string(),
  programId: string()
}), type({
  accounts: array(string()),
  data: string(),
  programId: string()
})]), ParsedOrRawInstruction = coerce(InstructionResult, UnknownInstructionResult, (ae) => "accounts" in ae ? create(ae, RawInstructionResult) : create(ae, ParsedInstructionResult)), ParsedConfirmedTransactionResult = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(AnnotatedAccountKey),
    instructions: array(ParsedOrRawInstruction),
    recentBlockhash: string(),
    addressTableLookups: optional(nullable(array(AddressTableLookupStruct)))
  })
}), TokenBalanceResult = type({
  accountIndex: number(),
  mint: string(),
  owner: optional(string()),
  uiTokenAmount: TokenAmountResult
}), LoadedAddressesResult = type({
  writable: array(PublicKeyFromString),
  readonly: array(PublicKeyFromString)
}), ConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number(),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(type({
      accounts: array(number()),
      data: string(),
      programIdIndex: number()
    }))
  })))),
  preBalances: array(number()),
  postBalances: array(number()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number())
}), ParsedConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number(),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(ParsedOrRawInstruction)
  })))),
  preBalances: array(number()),
  postBalances: array(number()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number())
}), TransactionVersionStruct = union([literal(0), literal("legacy")]), RewardsResult = type({
  pubkey: string(),
  lamports: number(),
  postBalance: nullable(number()),
  rewardType: nullable(string()),
  commission: optional(nullable(number()))
}), GetBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
}))), GetNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
}))), GetAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
}))), GetParsedBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ParsedConfirmedTransactionResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
}))), GetParsedAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
}))), GetParsedNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
}))), GetConfirmedBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number())
}))), GetBlockSignaturesRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  signatures: array(string()),
  blockTime: nullable(number())
}))), GetTransactionRpcResult = jsonRpcResult(nullable(type({
  slot: number(),
  meta: nullable(ConfirmedTransactionMetaResult),
  blockTime: optional(nullable(number())),
  transaction: ConfirmedTransactionResult,
  version: optional(TransactionVersionStruct)
}))), GetParsedTransactionRpcResult = jsonRpcResult(nullable(type({
  slot: number(),
  transaction: ParsedConfirmedTransactionResult,
  meta: nullable(ParsedConfirmedTransactionMetaResult),
  blockTime: optional(nullable(number())),
  version: optional(TransactionVersionStruct)
}))), GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext(type({
  blockhash: string(),
  feeCalculator: type({
    lamportsPerSignature: number()
  })
})), GetLatestBlockhashRpcResult = jsonRpcResultAndContext(type({
  blockhash: string(),
  lastValidBlockHeight: number()
})), IsBlockhashValidRpcResult = jsonRpcResultAndContext(boolean()), PerfSampleResult = type({
  slot: number(),
  numTransactions: number(),
  numSlots: number(),
  samplePeriodSecs: number()
}), GetRecentPerformanceSamplesRpcResult = jsonRpcResult(array(PerfSampleResult)), GetFeeCalculatorRpcResult = jsonRpcResultAndContext(nullable(type({
  feeCalculator: type({
    lamportsPerSignature: number()
  })
}))), RequestAirdropRpcResult = jsonRpcResult(string()), SendTransactionRpcResult = jsonRpcResult(string()), LogsResult = type({
  err: TransactionErrorResult,
  logs: array(string()),
  signature: string()
}), LogsNotificationResult = type({
  result: notificationResultAndContext(LogsResult),
  subscription: number()
}), COMMON_HTTP_HEADERS = {
  "solana-client": "js/0.0.0-development"
};
class Connection {
  /**
   * Establish a JSON RPC connection
   *
   * @param endpoint URL to the fullnode JSON RPC endpoint
   * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object
   */
  constructor(ie, se) {
    this._commitment = void 0, this._confirmTransactionInitialTimeout = void 0, this._rpcEndpoint = void 0, this._rpcWsEndpoint = void 0, this._rpcClient = void 0, this._rpcRequest = void 0, this._rpcBatchRequest = void 0, this._rpcWebSocket = void 0, this._rpcWebSocketConnected = !1, this._rpcWebSocketHeartbeat = null, this._rpcWebSocketIdleTimeout = null, this._rpcWebSocketGeneration = 0, this._disableBlockhashCaching = !1, this._pollingBlockhash = !1, this._blockhashInfo = {
      latestBlockhash: null,
      lastFetch: 0,
      transactionSignatures: [],
      simulatedSignatures: []
    }, this._nextClientSubscriptionId = 0, this._subscriptionDisposeFunctionsByClientSubscriptionId = {}, this._subscriptionHashByClientSubscriptionId = {}, this._subscriptionStateChangeCallbacksByHash = {}, this._subscriptionCallbacksByServerSubscriptionId = {}, this._subscriptionsByHash = {}, this._subscriptionsAutoDisposedByRpc = /* @__PURE__ */ new Set(), this.getBlockHeight = /* @__PURE__ */ (() => {
      const Ee = {};
      return async (Se) => {
        const {
          commitment: Be,
          config: Ce
        } = extractCommitmentFromConfig(Se), Ie = this._buildArgs([], Be, void 0, Ce), Pe = fastStableStringify$1(Ie);
        return Ee[Pe] = Ee[Pe] ?? (async () => {
          try {
            const Ne = await this._rpcRequest("getBlockHeight", Ie), ke = create(Ne, jsonRpcResult(number()));
            if ("error" in ke)
              throw new SolanaJSONRPCError(ke.error, "failed to get block height information");
            return ke.result;
          } finally {
            delete Ee[Pe];
          }
        })(), await Ee[Pe];
      };
    })();
    let fe, ue, ce, de, me, we;
    se && typeof se == "string" ? this._commitment = se : se && (this._commitment = se.commitment, this._confirmTransactionInitialTimeout = se.confirmTransactionInitialTimeout, fe = se.wsEndpoint, ue = se.httpHeaders, ce = se.fetch, de = se.fetchMiddleware, me = se.disableRetryOnRateLimit, we = se.httpAgent), this._rpcEndpoint = assertEndpointUrl(ie), this._rpcWsEndpoint = fe || makeWebsocketUrl(ie), this._rpcClient = createRpcClient(ie, ue, ce, de, me, we), this._rpcRequest = createRpcRequest(this._rpcClient), this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient), this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {
      autoconnect: !1,
      max_reconnects: 1 / 0
    }), this._rpcWebSocket.on("open", this._wsOnOpen.bind(this)), this._rpcWebSocket.on("error", this._wsOnError.bind(this)), this._rpcWebSocket.on("close", this._wsOnClose.bind(this)), this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this)), this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this)), this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this)), this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this)), this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this)), this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this)), this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this));
  }
  /**
   * The default commitment used for requests
   */
  get commitment() {
    return this._commitment;
  }
  /**
   * The RPC endpoint
   */
  get rpcEndpoint() {
    return this._rpcEndpoint;
  }
  /**
   * Fetch the balance for the specified public key, return with context
   */
  async getBalanceAndContext(ie, se) {
    const {
      commitment: fe,
      config: ue
    } = extractCommitmentFromConfig(se), ce = this._buildArgs([ie.toBase58()], fe, void 0, ue), de = await this._rpcRequest("getBalance", ce), me = create(de, jsonRpcResultAndContext(number()));
    if ("error" in me)
      throw new SolanaJSONRPCError(me.error, `failed to get balance for ${ie.toBase58()}`);
    return me.result;
  }
  /**
   * Fetch the balance for the specified public key
   */
  async getBalance(ie, se) {
    return await this.getBalanceAndContext(ie, se).then((fe) => fe.value).catch((fe) => {
      throw new Error("failed to get balance of account " + ie.toBase58() + ": " + fe);
    });
  }
  /**
   * Fetch the estimated production time of a block
   */
  async getBlockTime(ie) {
    const se = await this._rpcRequest("getBlockTime", [ie]), fe = create(se, jsonRpcResult(nullable(number())));
    if ("error" in fe)
      throw new SolanaJSONRPCError(fe.error, `failed to get block time for slot ${ie}`);
    return fe.result;
  }
  /**
   * Fetch the lowest slot that the node has information about in its ledger.
   * This value may increase over time if the node is configured to purge older ledger data
   */
  async getMinimumLedgerSlot() {
    const ie = await this._rpcRequest("minimumLedgerSlot", []), se = create(ie, jsonRpcResult(number()));
    if ("error" in se)
      throw new SolanaJSONRPCError(se.error, "failed to get minimum ledger slot");
    return se.result;
  }
  /**
   * Fetch the slot of the lowest confirmed block that has not been purged from the ledger
   */
  async getFirstAvailableBlock() {
    const ie = await this._rpcRequest("getFirstAvailableBlock", []), se = create(ie, SlotRpcResult);
    if ("error" in se)
      throw new SolanaJSONRPCError(se.error, "failed to get first available block");
    return se.result;
  }
  /**
   * Fetch information about the current supply
   */
  async getSupply(ie) {
    let se = {};
    typeof ie == "string" ? se = {
      commitment: ie
    } : ie ? se = {
      ...ie,
      commitment: ie && ie.commitment || this.commitment
    } : se = {
      commitment: this.commitment
    };
    const fe = await this._rpcRequest("getSupply", [se]), ue = create(fe, GetSupplyRpcResult);
    if ("error" in ue)
      throw new SolanaJSONRPCError(ue.error, "failed to get supply");
    return ue.result;
  }
  /**
   * Fetch the current supply of a token mint
   */
  async getTokenSupply(ie, se) {
    const fe = this._buildArgs([ie.toBase58()], se), ue = await this._rpcRequest("getTokenSupply", fe), ce = create(ue, jsonRpcResultAndContext(TokenAmountResult));
    if ("error" in ce)
      throw new SolanaJSONRPCError(ce.error, "failed to get token supply");
    return ce.result;
  }
  /**
   * Fetch the current balance of a token account
   */
  async getTokenAccountBalance(ie, se) {
    const fe = this._buildArgs([ie.toBase58()], se), ue = await this._rpcRequest("getTokenAccountBalance", fe), ce = create(ue, jsonRpcResultAndContext(TokenAmountResult));
    if ("error" in ce)
      throw new SolanaJSONRPCError(ce.error, "failed to get token account balance");
    return ce.result;
  }
  /**
   * Fetch all the token accounts owned by the specified account
   *
   * @return {Promise<RpcResponseAndContext<GetProgramAccountsResponse>}
   */
  async getTokenAccountsByOwner(ie, se, fe) {
    const {
      commitment: ue,
      config: ce
    } = extractCommitmentFromConfig(fe);
    let de = [ie.toBase58()];
    "mint" in se ? de.push({
      mint: se.mint.toBase58()
    }) : de.push({
      programId: se.programId.toBase58()
    });
    const me = this._buildArgs(de, ue, "base64", ce), we = await this._rpcRequest("getTokenAccountsByOwner", me), Ee = create(we, GetTokenAccountsByOwner);
    if ("error" in Ee)
      throw new SolanaJSONRPCError(Ee.error, `failed to get token accounts owned by account ${ie.toBase58()}`);
    return Ee.result;
  }
  /**
   * Fetch parsed token accounts owned by the specified account
   *
   * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}
   */
  async getParsedTokenAccountsByOwner(ie, se, fe) {
    let ue = [ie.toBase58()];
    "mint" in se ? ue.push({
      mint: se.mint.toBase58()
    }) : ue.push({
      programId: se.programId.toBase58()
    });
    const ce = this._buildArgs(ue, fe, "jsonParsed"), de = await this._rpcRequest("getTokenAccountsByOwner", ce), me = create(de, GetParsedTokenAccountsByOwner);
    if ("error" in me)
      throw new SolanaJSONRPCError(me.error, `failed to get token accounts owned by account ${ie.toBase58()}`);
    return me.result;
  }
  /**
   * Fetch the 20 largest accounts with their current balances
   */
  async getLargestAccounts(ie) {
    const se = {
      ...ie,
      commitment: ie && ie.commitment || this.commitment
    }, fe = se.filter || se.commitment ? [se] : [], ue = await this._rpcRequest("getLargestAccounts", fe), ce = create(ue, GetLargestAccountsRpcResult);
    if ("error" in ce)
      throw new SolanaJSONRPCError(ce.error, "failed to get largest accounts");
    return ce.result;
  }
  /**
   * Fetch the 20 largest token accounts with their current balances
   * for a given mint.
   */
  async getTokenLargestAccounts(ie, se) {
    const fe = this._buildArgs([ie.toBase58()], se), ue = await this._rpcRequest("getTokenLargestAccounts", fe), ce = create(ue, GetTokenLargestAccountsResult);
    if ("error" in ce)
      throw new SolanaJSONRPCError(ce.error, "failed to get token largest accounts");
    return ce.result;
  }
  /**
   * Fetch all the account info for the specified public key, return with context
   */
  async getAccountInfoAndContext(ie, se) {
    const {
      commitment: fe,
      config: ue
    } = extractCommitmentFromConfig(se), ce = this._buildArgs([ie.toBase58()], fe, "base64", ue), de = await this._rpcRequest("getAccountInfo", ce), me = create(de, jsonRpcResultAndContext(nullable(AccountInfoResult)));
    if ("error" in me)
      throw new SolanaJSONRPCError(me.error, `failed to get info about account ${ie.toBase58()}`);
    return me.result;
  }
  /**
   * Fetch parsed account info for the specified public key
   */
  async getParsedAccountInfo(ie, se) {
    const {
      commitment: fe,
      config: ue
    } = extractCommitmentFromConfig(se), ce = this._buildArgs([ie.toBase58()], fe, "jsonParsed", ue), de = await this._rpcRequest("getAccountInfo", ce), me = create(de, jsonRpcResultAndContext(nullable(ParsedAccountInfoResult)));
    if ("error" in me)
      throw new SolanaJSONRPCError(me.error, `failed to get info about account ${ie.toBase58()}`);
    return me.result;
  }
  /**
   * Fetch all the account info for the specified public key
   */
  async getAccountInfo(ie, se) {
    try {
      return (await this.getAccountInfoAndContext(ie, se)).value;
    } catch (fe) {
      throw new Error("failed to get info about account " + ie.toBase58() + ": " + fe);
    }
  }
  /**
   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
   */
  async getMultipleParsedAccounts(ie, se) {
    const {
      commitment: fe,
      config: ue
    } = extractCommitmentFromConfig(se), ce = ie.map((Ee) => Ee.toBase58()), de = this._buildArgs([ce], fe, "jsonParsed", ue), me = await this._rpcRequest("getMultipleAccounts", de), we = create(me, jsonRpcResultAndContext(array(nullable(ParsedAccountInfoResult))));
    if ("error" in we)
      throw new SolanaJSONRPCError(we.error, `failed to get info for accounts ${ce}`);
    return we.result;
  }
  /**
   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
   */
  async getMultipleAccountsInfoAndContext(ie, se) {
    const {
      commitment: fe,
      config: ue
    } = extractCommitmentFromConfig(se), ce = ie.map((Ee) => Ee.toBase58()), de = this._buildArgs([ce], fe, "base64", ue), me = await this._rpcRequest("getMultipleAccounts", de), we = create(me, jsonRpcResultAndContext(array(nullable(AccountInfoResult))));
    if ("error" in we)
      throw new SolanaJSONRPCError(we.error, `failed to get info for accounts ${ce}`);
    return we.result;
  }
  /**
   * Fetch all the account info for multiple accounts specified by an array of public keys
   */
  async getMultipleAccountsInfo(ie, se) {
    return (await this.getMultipleAccountsInfoAndContext(ie, se)).value;
  }
  /**
   * Returns epoch activation information for a stake account that has been delegated
   */
  async getStakeActivation(ie, se, fe) {
    const {
      commitment: ue,
      config: ce
    } = extractCommitmentFromConfig(se), de = this._buildArgs([ie.toBase58()], ue, void 0, {
      ...ce,
      epoch: fe ?? ce?.epoch
    }), me = await this._rpcRequest("getStakeActivation", de), we = create(me, jsonRpcResult(StakeActivationResult));
    if ("error" in we)
      throw new SolanaJSONRPCError(we.error, `failed to get Stake Activation ${ie.toBase58()}`);
    return we.result;
  }
  /**
   * Fetch all the accounts owned by the specified program id
   *
   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}
   */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  async getProgramAccounts(ie, se) {
    const {
      commitment: fe,
      config: ue
    } = extractCommitmentFromConfig(se), {
      encoding: ce,
      ...de
    } = ue || {}, me = this._buildArgs([ie.toBase58()], fe, ce || "base64", de), we = await this._rpcRequest("getProgramAccounts", me), Ee = array(KeyedAccountInfoResult), Se = de.withContext === !0 ? create(we, jsonRpcResultAndContext(Ee)) : create(we, jsonRpcResult(Ee));
    if ("error" in Se)
      throw new SolanaJSONRPCError(Se.error, `failed to get accounts owned by program ${ie.toBase58()}`);
    return Se.result;
  }
  /**
   * Fetch and parse all the accounts owned by the specified program id
   *
   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}
   */
  async getParsedProgramAccounts(ie, se) {
    const {
      commitment: fe,
      config: ue
    } = extractCommitmentFromConfig(se), ce = this._buildArgs([ie.toBase58()], fe, "jsonParsed", ue), de = await this._rpcRequest("getProgramAccounts", ce), me = create(de, jsonRpcResult(array(KeyedParsedAccountInfoResult)));
    if ("error" in me)
      throw new SolanaJSONRPCError(me.error, `failed to get accounts owned by program ${ie.toBase58()}`);
    return me.result;
  }
  /** @deprecated Instead, call `confirmTransaction` and pass in {@link TransactionConfirmationStrategy} */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  async confirmTransaction(ie, se) {
    let fe;
    if (typeof ie == "string")
      fe = ie;
    else {
      const ce = ie;
      if (ce.abortSignal?.aborted)
        return Promise.reject(ce.abortSignal.reason);
      fe = ce.signature;
    }
    let ue;
    try {
      ue = bs58$1.decode(fe);
    } catch {
      throw new Error("signature must be base58 encoded: " + fe);
    }
    return assert(ue.length === 64, "signature has invalid length"), typeof ie == "string" ? await this.confirmTransactionUsingLegacyTimeoutStrategy({
      commitment: se || this.commitment,
      signature: fe
    }) : "lastValidBlockHeight" in ie ? await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
      commitment: se || this.commitment,
      strategy: ie
    }) : await this.confirmTransactionUsingDurableNonceStrategy({
      commitment: se || this.commitment,
      strategy: ie
    });
  }
  getCancellationPromise(ie) {
    return new Promise((se, fe) => {
      ie != null && (ie.aborted ? fe(ie.reason) : ie.addEventListener("abort", () => {
        fe(ie.reason);
      }));
    });
  }
  getTransactionConfirmationPromise({
    commitment: ie,
    signature: se
  }) {
    let fe, ue, ce = !1;
    const de = new Promise((we, Ee) => {
      try {
        fe = this.onSignature(se, (Be, Ce) => {
          fe = void 0;
          const Ie = {
            context: Ce,
            value: Be
          };
          we({
            __type: TransactionStatus.PROCESSED,
            response: Ie
          });
        }, ie);
        const Se = new Promise((Be) => {
          fe == null ? Be() : ue = this._onSubscriptionStateChange(fe, (Ce) => {
            Ce === "subscribed" && Be();
          });
        });
        (async () => {
          if (await Se, ce)
            return;
          const Be = await this.getSignatureStatus(se);
          if (ce || Be == null)
            return;
          const {
            context: Ce,
            value: Ie
          } = Be;
          if (Ie != null)
            if (Ie?.err)
              Ee(Ie.err);
            else {
              switch (ie) {
                case "confirmed":
                case "single":
                case "singleGossip": {
                  if (Ie.confirmationStatus === "processed")
                    return;
                  break;
                }
                case "finalized":
                case "max":
                case "root": {
                  if (Ie.confirmationStatus === "processed" || Ie.confirmationStatus === "confirmed")
                    return;
                  break;
                }
                case "processed":
                case "recent":
              }
              ce = !0, we({
                __type: TransactionStatus.PROCESSED,
                response: {
                  context: Ce,
                  value: Ie
                }
              });
            }
        })();
      } catch (Se) {
        Ee(Se);
      }
    });
    return {
      abortConfirmation: () => {
        ue && (ue(), ue = void 0), fe != null && (this.removeSignatureListener(fe), fe = void 0);
      },
      confirmationPromise: de
    };
  }
  async confirmTransactionUsingBlockHeightExceedanceStrategy({
    commitment: ie,
    strategy: {
      abortSignal: se,
      lastValidBlockHeight: fe,
      signature: ue
    }
  }) {
    let ce = !1;
    const de = new Promise((Be) => {
      const Ce = async () => {
        try {
          return await this.getBlockHeight(ie);
        } catch {
          return -1;
        }
      };
      (async () => {
        let Ie = await Ce();
        if (!ce) {
          for (; Ie <= fe; )
            if (await sleep(1e3), ce || (Ie = await Ce(), ce))
              return;
          Be({
            __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED
          });
        }
      })();
    }), {
      abortConfirmation: me,
      confirmationPromise: we
    } = this.getTransactionConfirmationPromise({
      commitment: ie,
      signature: ue
    }), Ee = this.getCancellationPromise(se);
    let Se;
    try {
      const Be = await Promise.race([Ee, we, de]);
      if (Be.__type === TransactionStatus.PROCESSED)
        Se = Be.response;
      else
        throw new TransactionExpiredBlockheightExceededError(ue);
    } finally {
      ce = !0, me();
    }
    return Se;
  }
  async confirmTransactionUsingDurableNonceStrategy({
    commitment: ie,
    strategy: {
      abortSignal: se,
      minContextSlot: fe,
      nonceAccountPubkey: ue,
      nonceValue: ce,
      signature: de
    }
  }) {
    let me = !1;
    const we = new Promise((Ie) => {
      let Pe = ce, Ne = null;
      const ke = async () => {
        try {
          const {
            context: He,
            value: De
          } = await this.getNonceAndContext(ue, {
            commitment: ie,
            minContextSlot: fe
          });
          return Ne = He.slot, De?.nonce;
        } catch {
          return Pe;
        }
      };
      (async () => {
        if (Pe = await ke(), !me)
          for (; ; ) {
            if (ce !== Pe) {
              Ie({
                __type: TransactionStatus.NONCE_INVALID,
                slotInWhichNonceDidAdvance: Ne
              });
              return;
            }
            if (await sleep(2e3), me || (Pe = await ke(), me))
              return;
          }
      })();
    }), {
      abortConfirmation: Ee,
      confirmationPromise: Se
    } = this.getTransactionConfirmationPromise({
      commitment: ie,
      signature: de
    }), Be = this.getCancellationPromise(se);
    let Ce;
    try {
      const Ie = await Promise.race([Be, Se, we]);
      if (Ie.__type === TransactionStatus.PROCESSED)
        Ce = Ie.response;
      else {
        let Pe;
        for (; ; ) {
          const Ne = await this.getSignatureStatus(de);
          if (Ne == null)
            break;
          if (Ne.context.slot < (Ie.slotInWhichNonceDidAdvance ?? fe)) {
            await sleep(400);
            continue;
          }
          Pe = Ne;
          break;
        }
        if (Pe?.value) {
          const Ne = ie || "finalized", {
            confirmationStatus: ke
          } = Pe.value;
          switch (Ne) {
            case "processed":
            case "recent":
              if (ke !== "processed" && ke !== "confirmed" && ke !== "finalized")
                throw new TransactionExpiredNonceInvalidError(de);
              break;
            case "confirmed":
            case "single":
            case "singleGossip":
              if (ke !== "confirmed" && ke !== "finalized")
                throw new TransactionExpiredNonceInvalidError(de);
              break;
            case "finalized":
            case "max":
            case "root":
              if (ke !== "finalized")
                throw new TransactionExpiredNonceInvalidError(de);
              break;
            default:
          }
          Ce = {
            context: Pe.context,
            value: {
              err: Pe.value.err
            }
          };
        } else
          throw new TransactionExpiredNonceInvalidError(de);
      }
    } finally {
      me = !0, Ee();
    }
    return Ce;
  }
  async confirmTransactionUsingLegacyTimeoutStrategy({
    commitment: ie,
    signature: se
  }) {
    let fe;
    const ue = new Promise((we) => {
      let Ee = this._confirmTransactionInitialTimeout || 6e4;
      switch (ie) {
        case "processed":
        case "recent":
        case "single":
        case "confirmed":
        case "singleGossip": {
          Ee = this._confirmTransactionInitialTimeout || 3e4;
          break;
        }
      }
      fe = setTimeout(() => we({
        __type: TransactionStatus.TIMED_OUT,
        timeoutMs: Ee
      }), Ee);
    }), {
      abortConfirmation: ce,
      confirmationPromise: de
    } = this.getTransactionConfirmationPromise({
      commitment: ie,
      signature: se
    });
    let me;
    try {
      const we = await Promise.race([de, ue]);
      if (we.__type === TransactionStatus.PROCESSED)
        me = we.response;
      else
        throw new TransactionExpiredTimeoutError(se, we.timeoutMs / 1e3);
    } finally {
      clearTimeout(fe), ce();
    }
    return me;
  }
  /**
   * Return the list of nodes that are currently participating in the cluster
   */
  async getClusterNodes() {
    const ie = await this._rpcRequest("getClusterNodes", []), se = create(ie, jsonRpcResult(array(ContactInfoResult)));
    if ("error" in se)
      throw new SolanaJSONRPCError(se.error, "failed to get cluster nodes");
    return se.result;
  }
  /**
   * Return the list of nodes that are currently participating in the cluster
   */
  async getVoteAccounts(ie) {
    const se = this._buildArgs([], ie), fe = await this._rpcRequest("getVoteAccounts", se), ue = create(fe, GetVoteAccounts);
    if ("error" in ue)
      throw new SolanaJSONRPCError(ue.error, "failed to get vote accounts");
    return ue.result;
  }
  /**
   * Fetch the current slot that the node is processing
   */
  async getSlot(ie) {
    const {
      commitment: se,
      config: fe
    } = extractCommitmentFromConfig(ie), ue = this._buildArgs([], se, void 0, fe), ce = await this._rpcRequest("getSlot", ue), de = create(ce, jsonRpcResult(number()));
    if ("error" in de)
      throw new SolanaJSONRPCError(de.error, "failed to get slot");
    return de.result;
  }
  /**
   * Fetch the current slot leader of the cluster
   */
  async getSlotLeader(ie) {
    const {
      commitment: se,
      config: fe
    } = extractCommitmentFromConfig(ie), ue = this._buildArgs([], se, void 0, fe), ce = await this._rpcRequest("getSlotLeader", ue), de = create(ce, jsonRpcResult(string()));
    if ("error" in de)
      throw new SolanaJSONRPCError(de.error, "failed to get slot leader");
    return de.result;
  }
  /**
   * Fetch `limit` number of slot leaders starting from `startSlot`
   *
   * @param startSlot fetch slot leaders starting from this slot
   * @param limit number of slot leaders to return
   */
  async getSlotLeaders(ie, se) {
    const fe = [ie, se], ue = await this._rpcRequest("getSlotLeaders", fe), ce = create(ue, jsonRpcResult(array(PublicKeyFromString)));
    if ("error" in ce)
      throw new SolanaJSONRPCError(ce.error, "failed to get slot leaders");
    return ce.result;
  }
  /**
   * Fetch the current status of a signature
   */
  async getSignatureStatus(ie, se) {
    const {
      context: fe,
      value: ue
    } = await this.getSignatureStatuses([ie], se);
    assert(ue.length === 1);
    const ce = ue[0];
    return {
      context: fe,
      value: ce
    };
  }
  /**
   * Fetch the current statuses of a batch of signatures
   */
  async getSignatureStatuses(ie, se) {
    const fe = [ie];
    se && fe.push(se);
    const ue = await this._rpcRequest("getSignatureStatuses", fe), ce = create(ue, GetSignatureStatusesRpcResult);
    if ("error" in ce)
      throw new SolanaJSONRPCError(ce.error, "failed to get signature status");
    return ce.result;
  }
  /**
   * Fetch the current transaction count of the cluster
   */
  async getTransactionCount(ie) {
    const {
      commitment: se,
      config: fe
    } = extractCommitmentFromConfig(ie), ue = this._buildArgs([], se, void 0, fe), ce = await this._rpcRequest("getTransactionCount", ue), de = create(ce, jsonRpcResult(number()));
    if ("error" in de)
      throw new SolanaJSONRPCError(de.error, "failed to get transaction count");
    return de.result;
  }
  /**
   * Fetch the current total currency supply of the cluster in lamports
   *
   * @deprecated Deprecated since v1.2.8. Please use {@link getSupply} instead.
   */
  async getTotalSupply(ie) {
    return (await this.getSupply({
      commitment: ie,
      excludeNonCirculatingAccountsList: !0
    })).value.total;
  }
  /**
   * Fetch the cluster InflationGovernor parameters
   */
  async getInflationGovernor(ie) {
    const se = this._buildArgs([], ie), fe = await this._rpcRequest("getInflationGovernor", se), ue = create(fe, GetInflationGovernorRpcResult);
    if ("error" in ue)
      throw new SolanaJSONRPCError(ue.error, "failed to get inflation");
    return ue.result;
  }
  /**
   * Fetch the inflation reward for a list of addresses for an epoch
   */
  async getInflationReward(ie, se, fe) {
    const {
      commitment: ue,
      config: ce
    } = extractCommitmentFromConfig(fe), de = this._buildArgs([ie.map((Ee) => Ee.toBase58())], ue, void 0, {
      ...ce,
      epoch: se ?? ce?.epoch
    }), me = await this._rpcRequest("getInflationReward", de), we = create(me, GetInflationRewardResult);
    if ("error" in we)
      throw new SolanaJSONRPCError(we.error, "failed to get inflation reward");
    return we.result;
  }
  /**
   * Fetch the specific inflation values for the current epoch
   */
  async getInflationRate() {
    const ie = await this._rpcRequest("getInflationRate", []), se = create(ie, GetInflationRateRpcResult);
    if ("error" in se)
      throw new SolanaJSONRPCError(se.error, "failed to get inflation rate");
    return se.result;
  }
  /**
   * Fetch the Epoch Info parameters
   */
  async getEpochInfo(ie) {
    const {
      commitment: se,
      config: fe
    } = extractCommitmentFromConfig(ie), ue = this._buildArgs([], se, void 0, fe), ce = await this._rpcRequest("getEpochInfo", ue), de = create(ce, GetEpochInfoRpcResult);
    if ("error" in de)
      throw new SolanaJSONRPCError(de.error, "failed to get epoch info");
    return de.result;
  }
  /**
   * Fetch the Epoch Schedule parameters
   */
  async getEpochSchedule() {
    const ie = await this._rpcRequest("getEpochSchedule", []), se = create(ie, GetEpochScheduleRpcResult);
    if ("error" in se)
      throw new SolanaJSONRPCError(se.error, "failed to get epoch schedule");
    const fe = se.result;
    return new EpochSchedule(fe.slotsPerEpoch, fe.leaderScheduleSlotOffset, fe.warmup, fe.firstNormalEpoch, fe.firstNormalSlot);
  }
  /**
   * Fetch the leader schedule for the current epoch
   * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}
   */
  async getLeaderSchedule() {
    const ie = await this._rpcRequest("getLeaderSchedule", []), se = create(ie, GetLeaderScheduleRpcResult);
    if ("error" in se)
      throw new SolanaJSONRPCError(se.error, "failed to get leader schedule");
    return se.result;
  }
  /**
   * Fetch the minimum balance needed to exempt an account of `dataLength`
   * size from rent
   */
  async getMinimumBalanceForRentExemption(ie, se) {
    const fe = this._buildArgs([ie], se), ue = await this._rpcRequest("getMinimumBalanceForRentExemption", fe), ce = create(ue, GetMinimumBalanceForRentExemptionRpcResult);
    return "error" in ce ? (console.warn("Unable to fetch minimum balance for rent exemption"), 0) : ce.result;
  }
  /**
   * Fetch a recent blockhash from the cluster, return with context
   * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.
   */
  async getRecentBlockhashAndContext(ie) {
    const se = this._buildArgs([], ie), fe = await this._rpcRequest("getRecentBlockhash", se), ue = create(fe, GetRecentBlockhashAndContextRpcResult);
    if ("error" in ue)
      throw new SolanaJSONRPCError(ue.error, "failed to get recent blockhash");
    return ue.result;
  }
  /**
   * Fetch recent performance samples
   * @return {Promise<Array<PerfSample>>}
   */
  async getRecentPerformanceSamples(ie) {
    const se = await this._rpcRequest("getRecentPerformanceSamples", ie ? [ie] : []), fe = create(se, GetRecentPerformanceSamplesRpcResult);
    if ("error" in fe)
      throw new SolanaJSONRPCError(fe.error, "failed to get recent performance samples");
    return fe.result;
  }
  /**
   * Fetch the fee calculator for a recent blockhash from the cluster, return with context
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getFeeForMessage} instead.
   */
  async getFeeCalculatorForBlockhash(ie, se) {
    const fe = this._buildArgs([ie], se), ue = await this._rpcRequest("getFeeCalculatorForBlockhash", fe), ce = create(ue, GetFeeCalculatorRpcResult);
    if ("error" in ce)
      throw new SolanaJSONRPCError(ce.error, "failed to get fee calculator");
    const {
      context: de,
      value: me
    } = ce.result;
    return {
      context: de,
      value: me !== null ? me.feeCalculator : null
    };
  }
  /**
   * Fetch the fee for a message from the cluster, return with context
   */
  async getFeeForMessage(ie, se) {
    const fe = toBuffer(ie.serialize()).toString("base64"), ue = this._buildArgs([fe], se), ce = await this._rpcRequest("getFeeForMessage", ue), de = create(ce, jsonRpcResultAndContext(nullable(number())));
    if ("error" in de)
      throw new SolanaJSONRPCError(de.error, "failed to get fee for message");
    if (de.result === null)
      throw new Error("invalid blockhash");
    return de.result;
  }
  /**
   * Fetch a list of prioritization fees from recent blocks.
   */
  async getRecentPrioritizationFees(ie) {
    const se = ie?.lockedWritableAccounts?.map((de) => de.toBase58()), fe = se?.length ? [se] : [], ue = await this._rpcRequest("getRecentPrioritizationFees", fe), ce = create(ue, GetRecentPrioritizationFeesRpcResult);
    if ("error" in ce)
      throw new SolanaJSONRPCError(ce.error, "failed to get recent prioritization fees");
    return ce.result;
  }
  /**
   * Fetch a recent blockhash from the cluster
   * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.
   */
  async getRecentBlockhash(ie) {
    try {
      return (await this.getRecentBlockhashAndContext(ie)).value;
    } catch (se) {
      throw new Error("failed to get recent blockhash: " + se);
    }
  }
  /**
   * Fetch the latest blockhash from the cluster
   * @return {Promise<BlockhashWithExpiryBlockHeight>}
   */
  async getLatestBlockhash(ie) {
    try {
      return (await this.getLatestBlockhashAndContext(ie)).value;
    } catch (se) {
      throw new Error("failed to get recent blockhash: " + se);
    }
  }
  /**
   * Fetch the latest blockhash from the cluster
   * @return {Promise<BlockhashWithExpiryBlockHeight>}
   */
  async getLatestBlockhashAndContext(ie) {
    const {
      commitment: se,
      config: fe
    } = extractCommitmentFromConfig(ie), ue = this._buildArgs([], se, void 0, fe), ce = await this._rpcRequest("getLatestBlockhash", ue), de = create(ce, GetLatestBlockhashRpcResult);
    if ("error" in de)
      throw new SolanaJSONRPCError(de.error, "failed to get latest blockhash");
    return de.result;
  }
  /**
   * Returns whether a blockhash is still valid or not
   */
  async isBlockhashValid(ie, se) {
    const {
      commitment: fe,
      config: ue
    } = extractCommitmentFromConfig(se), ce = this._buildArgs([ie], fe, void 0, ue), de = await this._rpcRequest("isBlockhashValid", ce), me = create(de, IsBlockhashValidRpcResult);
    if ("error" in me)
      throw new SolanaJSONRPCError(me.error, "failed to determine if the blockhash `" + ie + "`is valid");
    return me.result;
  }
  /**
   * Fetch the node version
   */
  async getVersion() {
    const ie = await this._rpcRequest("getVersion", []), se = create(ie, jsonRpcResult(VersionResult));
    if ("error" in se)
      throw new SolanaJSONRPCError(se.error, "failed to get version");
    return se.result;
  }
  /**
   * Fetch the genesis hash
   */
  async getGenesisHash() {
    const ie = await this._rpcRequest("getGenesisHash", []), se = create(ie, jsonRpcResult(string()));
    if ("error" in se)
      throw new SolanaJSONRPCError(se.error, "failed to get genesis hash");
    return se.result;
  }
  /**
   * Fetch a processed block from the cluster.
   *
   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
   * setting the `maxSupportedTransactionVersion` property.
   */
  /**
   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
   * setting the `maxSupportedTransactionVersion` property.
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
   * setting the `maxSupportedTransactionVersion` property.
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Fetch a processed block from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Fetch a processed block from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  async getBlock(ie, se) {
    const {
      commitment: fe,
      config: ue
    } = extractCommitmentFromConfig(se), ce = this._buildArgsAtLeastConfirmed([ie], fe, void 0, ue), de = await this._rpcRequest("getBlock", ce);
    try {
      switch (ue?.transactionDetails) {
        case "accounts": {
          const me = create(de, GetAccountsModeBlockRpcResult);
          if ("error" in me)
            throw me.error;
          return me.result;
        }
        case "none": {
          const me = create(de, GetNoneModeBlockRpcResult);
          if ("error" in me)
            throw me.error;
          return me.result;
        }
        default: {
          const me = create(de, GetBlockRpcResult);
          if ("error" in me)
            throw me.error;
          const {
            result: we
          } = me;
          return we ? {
            ...we,
            transactions: we.transactions.map(({
              transaction: Ee,
              meta: Se,
              version: Be
            }) => ({
              meta: Se,
              transaction: {
                ...Ee,
                message: versionedMessageFromResponse(Be, Ee.message)
              },
              version: Be
            }))
          } : null;
        }
      }
    } catch (me) {
      throw new SolanaJSONRPCError(me, "failed to get confirmed block");
    }
  }
  /**
   * Fetch parsed transaction details for a confirmed or finalized block
   */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  async getParsedBlock(ie, se) {
    const {
      commitment: fe,
      config: ue
    } = extractCommitmentFromConfig(se), ce = this._buildArgsAtLeastConfirmed([ie], fe, "jsonParsed", ue), de = await this._rpcRequest("getBlock", ce);
    try {
      switch (ue?.transactionDetails) {
        case "accounts": {
          const me = create(de, GetParsedAccountsModeBlockRpcResult);
          if ("error" in me)
            throw me.error;
          return me.result;
        }
        case "none": {
          const me = create(de, GetParsedNoneModeBlockRpcResult);
          if ("error" in me)
            throw me.error;
          return me.result;
        }
        default: {
          const me = create(de, GetParsedBlockRpcResult);
          if ("error" in me)
            throw me.error;
          return me.result;
        }
      }
    } catch (me) {
      throw new SolanaJSONRPCError(me, "failed to get block");
    }
  }
  /*
   * Returns recent block production information from the current or previous epoch
   */
  async getBlockProduction(ie) {
    let se, fe;
    if (typeof ie == "string")
      fe = ie;
    else if (ie) {
      const {
        commitment: me,
        ...we
      } = ie;
      fe = me, se = we;
    }
    const ue = this._buildArgs([], fe, "base64", se), ce = await this._rpcRequest("getBlockProduction", ue), de = create(ce, BlockProductionResponseStruct);
    if ("error" in de)
      throw new SolanaJSONRPCError(de.error, "failed to get block production information");
    return de.result;
  }
  /**
   * Fetch a confirmed or finalized transaction from the cluster.
   *
   * @deprecated Instead, call `getTransaction` using a
   * `GetVersionedTransactionConfig` by setting the
   * `maxSupportedTransactionVersion` property.
   */
  /**
   * Fetch a confirmed or finalized transaction from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Fetch a confirmed or finalized transaction from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  async getTransaction(ie, se) {
    const {
      commitment: fe,
      config: ue
    } = extractCommitmentFromConfig(se), ce = this._buildArgsAtLeastConfirmed([ie], fe, void 0, ue), de = await this._rpcRequest("getTransaction", ce), me = create(de, GetTransactionRpcResult);
    if ("error" in me)
      throw new SolanaJSONRPCError(me.error, "failed to get transaction");
    const we = me.result;
    return we && {
      ...we,
      transaction: {
        ...we.transaction,
        message: versionedMessageFromResponse(we.version, we.transaction.message)
      }
    };
  }
  /**
   * Fetch parsed transaction details for a confirmed or finalized transaction
   */
  async getParsedTransaction(ie, se) {
    const {
      commitment: fe,
      config: ue
    } = extractCommitmentFromConfig(se), ce = this._buildArgsAtLeastConfirmed([ie], fe, "jsonParsed", ue), de = await this._rpcRequest("getTransaction", ce), me = create(de, GetParsedTransactionRpcResult);
    if ("error" in me)
      throw new SolanaJSONRPCError(me.error, "failed to get transaction");
    return me.result;
  }
  /**
   * Fetch parsed transaction details for a batch of confirmed transactions
   */
  async getParsedTransactions(ie, se) {
    const {
      commitment: fe,
      config: ue
    } = extractCommitmentFromConfig(se), ce = ie.map((we) => ({
      methodName: "getTransaction",
      args: this._buildArgsAtLeastConfirmed([we], fe, "jsonParsed", ue)
    }));
    return (await this._rpcBatchRequest(ce)).map((we) => {
      const Ee = create(we, GetParsedTransactionRpcResult);
      if ("error" in Ee)
        throw new SolanaJSONRPCError(Ee.error, "failed to get transactions");
      return Ee.result;
    });
  }
  /**
   * Fetch transaction details for a batch of confirmed transactions.
   * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.
   *
   * @deprecated Instead, call `getTransactions` using a
   * `GetVersionedTransactionConfig` by setting the
   * `maxSupportedTransactionVersion` property.
   */
  /**
   * Fetch transaction details for a batch of confirmed transactions.
   * Similar to {@link getParsedTransactions} but returns a {@link
   * VersionedTransactionResponse}.
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Fetch transaction details for a batch of confirmed transactions.
   * Similar to {@link getParsedTransactions} but returns a {@link
   * VersionedTransactionResponse}.
   */
  // eslint-disable-next-line no-dupe-class-members
  async getTransactions(ie, se) {
    const {
      commitment: fe,
      config: ue
    } = extractCommitmentFromConfig(se), ce = ie.map((we) => ({
      methodName: "getTransaction",
      args: this._buildArgsAtLeastConfirmed([we], fe, void 0, ue)
    }));
    return (await this._rpcBatchRequest(ce)).map((we) => {
      const Ee = create(we, GetTransactionRpcResult);
      if ("error" in Ee)
        throw new SolanaJSONRPCError(Ee.error, "failed to get transactions");
      const Se = Ee.result;
      return Se && {
        ...Se,
        transaction: {
          ...Se.transaction,
          message: versionedMessageFromResponse(Se.version, Se.transaction.message)
        }
      };
    });
  }
  /**
   * Fetch a list of Transactions and transaction statuses from the cluster
   * for a confirmed block.
   *
   * @deprecated Deprecated since v1.13.0. Please use {@link getBlock} instead.
   */
  async getConfirmedBlock(ie, se) {
    const fe = this._buildArgsAtLeastConfirmed([ie], se), ue = await this._rpcRequest("getConfirmedBlock", fe), ce = create(ue, GetConfirmedBlockRpcResult);
    if ("error" in ce)
      throw new SolanaJSONRPCError(ce.error, "failed to get confirmed block");
    const de = ce.result;
    if (!de)
      throw new Error("Confirmed block " + ie + " not found");
    const me = {
      ...de,
      transactions: de.transactions.map(({
        transaction: we,
        meta: Ee
      }) => {
        const Se = new Message(we.message);
        return {
          meta: Ee,
          transaction: {
            ...we,
            message: Se
          }
        };
      })
    };
    return {
      ...me,
      transactions: me.transactions.map(({
        transaction: we,
        meta: Ee
      }) => ({
        meta: Ee,
        transaction: Transaction.populate(we.message, we.signatures)
      }))
    };
  }
  /**
   * Fetch confirmed blocks between two slots
   */
  async getBlocks(ie, se, fe) {
    const ue = this._buildArgsAtLeastConfirmed(se !== void 0 ? [ie, se] : [ie], fe), ce = await this._rpcRequest("getBlocks", ue), de = create(ce, jsonRpcResult(array(number())));
    if ("error" in de)
      throw new SolanaJSONRPCError(de.error, "failed to get blocks");
    return de.result;
  }
  /**
   * Fetch a list of Signatures from the cluster for a block, excluding rewards
   */
  async getBlockSignatures(ie, se) {
    const fe = this._buildArgsAtLeastConfirmed([ie], se, void 0, {
      transactionDetails: "signatures",
      rewards: !1
    }), ue = await this._rpcRequest("getBlock", fe), ce = create(ue, GetBlockSignaturesRpcResult);
    if ("error" in ce)
      throw new SolanaJSONRPCError(ce.error, "failed to get block");
    const de = ce.result;
    if (!de)
      throw new Error("Block " + ie + " not found");
    return de;
  }
  /**
   * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getBlockSignatures} instead.
   */
  async getConfirmedBlockSignatures(ie, se) {
    const fe = this._buildArgsAtLeastConfirmed([ie], se, void 0, {
      transactionDetails: "signatures",
      rewards: !1
    }), ue = await this._rpcRequest("getConfirmedBlock", fe), ce = create(ue, GetBlockSignaturesRpcResult);
    if ("error" in ce)
      throw new SolanaJSONRPCError(ce.error, "failed to get confirmed block");
    const de = ce.result;
    if (!de)
      throw new Error("Confirmed block " + ie + " not found");
    return de;
  }
  /**
   * Fetch a transaction details for a confirmed transaction
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getTransaction} instead.
   */
  async getConfirmedTransaction(ie, se) {
    const fe = this._buildArgsAtLeastConfirmed([ie], se), ue = await this._rpcRequest("getConfirmedTransaction", fe), ce = create(ue, GetTransactionRpcResult);
    if ("error" in ce)
      throw new SolanaJSONRPCError(ce.error, "failed to get transaction");
    const de = ce.result;
    if (!de)
      return de;
    const me = new Message(de.transaction.message), we = de.transaction.signatures;
    return {
      ...de,
      transaction: Transaction.populate(me, we)
    };
  }
  /**
   * Fetch parsed transaction details for a confirmed transaction
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransaction} instead.
   */
  async getParsedConfirmedTransaction(ie, se) {
    const fe = this._buildArgsAtLeastConfirmed([ie], se, "jsonParsed"), ue = await this._rpcRequest("getConfirmedTransaction", fe), ce = create(ue, GetParsedTransactionRpcResult);
    if ("error" in ce)
      throw new SolanaJSONRPCError(ce.error, "failed to get confirmed transaction");
    return ce.result;
  }
  /**
   * Fetch parsed transaction details for a batch of confirmed transactions
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransactions} instead.
   */
  async getParsedConfirmedTransactions(ie, se) {
    const fe = ie.map((de) => ({
      methodName: "getConfirmedTransaction",
      args: this._buildArgsAtLeastConfirmed([de], se, "jsonParsed")
    }));
    return (await this._rpcBatchRequest(fe)).map((de) => {
      const me = create(de, GetParsedTransactionRpcResult);
      if ("error" in me)
        throw new SolanaJSONRPCError(me.error, "failed to get confirmed transactions");
      return me.result;
    });
  }
  /**
   * Fetch a list of all the confirmed signatures for transactions involving an address
   * within a specified slot range. Max range allowed is 10,000 slots.
   *
   * @deprecated Deprecated since v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.
   *
   * @param address queried address
   * @param startSlot start slot, inclusive
   * @param endSlot end slot, inclusive
   */
  async getConfirmedSignaturesForAddress(ie, se, fe) {
    let ue = {}, ce = await this.getFirstAvailableBlock();
    for (; !("until" in ue) && (se--, !(se <= 0 || se < ce)); )
      try {
        const we = await this.getConfirmedBlockSignatures(se, "finalized");
        we.signatures.length > 0 && (ue.until = we.signatures[we.signatures.length - 1].toString());
      } catch (we) {
        if (we instanceof Error && we.message.includes("skipped"))
          continue;
        throw we;
      }
    let de = await this.getSlot("finalized");
    for (; !("before" in ue) && (fe++, !(fe > de)); )
      try {
        const we = await this.getConfirmedBlockSignatures(fe);
        we.signatures.length > 0 && (ue.before = we.signatures[we.signatures.length - 1].toString());
      } catch (we) {
        if (we instanceof Error && we.message.includes("skipped"))
          continue;
        throw we;
      }
    return (await this.getConfirmedSignaturesForAddress2(ie, ue)).map((we) => we.signature);
  }
  /**
   * Returns confirmed signatures for transactions involving an
   * address backwards in time from the provided signature or most recent confirmed block
   *
   *
   * @param address queried address
   * @param options
   */
  async getConfirmedSignaturesForAddress2(ie, se, fe) {
    const ue = this._buildArgsAtLeastConfirmed([ie.toBase58()], fe, void 0, se), ce = await this._rpcRequest("getConfirmedSignaturesForAddress2", ue), de = create(ce, GetConfirmedSignaturesForAddress2RpcResult);
    if ("error" in de)
      throw new SolanaJSONRPCError(de.error, "failed to get confirmed signatures for address");
    return de.result;
  }
  /**
   * Returns confirmed signatures for transactions involving an
   * address backwards in time from the provided signature or most recent confirmed block
   *
   *
   * @param address queried address
   * @param options
   */
  async getSignaturesForAddress(ie, se, fe) {
    const ue = this._buildArgsAtLeastConfirmed([ie.toBase58()], fe, void 0, se), ce = await this._rpcRequest("getSignaturesForAddress", ue), de = create(ce, GetSignaturesForAddressRpcResult);
    if ("error" in de)
      throw new SolanaJSONRPCError(de.error, "failed to get signatures for address");
    return de.result;
  }
  async getAddressLookupTable(ie, se) {
    const {
      context: fe,
      value: ue
    } = await this.getAccountInfoAndContext(ie, se);
    let ce = null;
    return ue !== null && (ce = new AddressLookupTableAccount({
      key: ie,
      state: AddressLookupTableAccount.deserialize(ue.data)
    })), {
      context: fe,
      value: ce
    };
  }
  /**
   * Fetch the contents of a Nonce account from the cluster, return with context
   */
  async getNonceAndContext(ie, se) {
    const {
      context: fe,
      value: ue
    } = await this.getAccountInfoAndContext(ie, se);
    let ce = null;
    return ue !== null && (ce = NonceAccount.fromAccountData(ue.data)), {
      context: fe,
      value: ce
    };
  }
  /**
   * Fetch the contents of a Nonce account from the cluster
   */
  async getNonce(ie, se) {
    return await this.getNonceAndContext(ie, se).then((fe) => fe.value).catch((fe) => {
      throw new Error("failed to get nonce for account " + ie.toBase58() + ": " + fe);
    });
  }
  /**
   * Request an allocation of lamports to the specified address
   *
   * ```typescript
   * import { Connection, PublicKey, LAMPORTS_PER_SOL } from "@solana/web3.js";
   *
   * (async () => {
   *   const connection = new Connection("https://api.testnet.solana.com", "confirmed");
   *   const myAddress = new PublicKey("2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM");
   *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);
   *   await connection.confirmTransaction(signature);
   * })();
   * ```
   */
  async requestAirdrop(ie, se) {
    const fe = await this._rpcRequest("requestAirdrop", [ie.toBase58(), se]), ue = create(fe, RequestAirdropRpcResult);
    if ("error" in ue)
      throw new SolanaJSONRPCError(ue.error, `airdrop to ${ie.toBase58()} failed`);
    return ue.result;
  }
  /**
   * @internal
   */
  async _blockhashWithExpiryBlockHeight(ie) {
    if (!ie) {
      for (; this._pollingBlockhash; )
        await sleep(100);
      const fe = Date.now() - this._blockhashInfo.lastFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;
      if (this._blockhashInfo.latestBlockhash !== null && !fe)
        return this._blockhashInfo.latestBlockhash;
    }
    return await this._pollNewBlockhash();
  }
  /**
   * @internal
   */
  async _pollNewBlockhash() {
    this._pollingBlockhash = !0;
    try {
      const ie = Date.now(), se = this._blockhashInfo.latestBlockhash, fe = se ? se.blockhash : null;
      for (let ue = 0; ue < 50; ue++) {
        const ce = await this.getLatestBlockhash("finalized");
        if (fe !== ce.blockhash)
          return this._blockhashInfo = {
            latestBlockhash: ce,
            lastFetch: Date.now(),
            transactionSignatures: [],
            simulatedSignatures: []
          }, ce;
        await sleep(MS_PER_SLOT / 2);
      }
      throw new Error(`Unable to obtain a new blockhash after ${Date.now() - ie}ms`);
    } finally {
      this._pollingBlockhash = !1;
    }
  }
  /**
   * get the stake minimum delegation
   */
  async getStakeMinimumDelegation(ie) {
    const {
      commitment: se,
      config: fe
    } = extractCommitmentFromConfig(ie), ue = this._buildArgs([], se, "base64", fe), ce = await this._rpcRequest("getStakeMinimumDelegation", ue), de = create(ce, jsonRpcResultAndContext(number()));
    if ("error" in de)
      throw new SolanaJSONRPCError(de.error, "failed to get stake minimum delegation");
    return de.result;
  }
  /**
   * Simulate a transaction
   *
   * @deprecated Instead, call {@link simulateTransaction} with {@link
   * VersionedTransaction} and {@link SimulateTransactionConfig} parameters
   */
  /**
   * Simulate a transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Simulate a transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  async simulateTransaction(ie, se, fe) {
    if ("message" in ie) {
      const Ne = ie.serialize(), ke = Buffer$1$1.from(Ne).toString("base64");
      if (Array.isArray(se) || fe !== void 0)
        throw new Error("Invalid arguments");
      const He = se || {};
      He.encoding = "base64", "commitment" in He || (He.commitment = this.commitment);
      const De = [ke, He], Ge = await this._rpcRequest("simulateTransaction", De), Ye = create(Ge, SimulatedTransactionResponseStruct);
      if ("error" in Ye)
        throw new Error("failed to simulate transaction: " + Ye.error.message);
      return Ye.result;
    }
    let ue;
    if (ie instanceof Transaction) {
      let Pe = ie;
      ue = new Transaction(), ue.feePayer = Pe.feePayer, ue.instructions = ie.instructions, ue.nonceInfo = Pe.nonceInfo, ue.signatures = Pe.signatures;
    } else
      ue = Transaction.populate(ie), ue._message = ue._json = void 0;
    if (se !== void 0 && !Array.isArray(se))
      throw new Error("Invalid arguments");
    const ce = se;
    if (ue.nonceInfo && ce)
      ue.sign(...ce);
    else {
      let Pe = this._disableBlockhashCaching;
      for (; ; ) {
        const Ne = await this._blockhashWithExpiryBlockHeight(Pe);
        if (ue.lastValidBlockHeight = Ne.lastValidBlockHeight, ue.recentBlockhash = Ne.blockhash, !ce)
          break;
        if (ue.sign(...ce), !ue.signature)
          throw new Error("!signature");
        const ke = ue.signature.toString("base64");
        if (!this._blockhashInfo.simulatedSignatures.includes(ke) && !this._blockhashInfo.transactionSignatures.includes(ke)) {
          this._blockhashInfo.simulatedSignatures.push(ke);
          break;
        } else
          Pe = !0;
      }
    }
    const de = ue._compile(), me = de.serialize(), Ee = ue._serialize(me).toString("base64"), Se = {
      encoding: "base64",
      commitment: this.commitment
    };
    if (fe) {
      const Pe = (Array.isArray(fe) ? fe : de.nonProgramIds()).map((Ne) => Ne.toBase58());
      Se.accounts = {
        encoding: "base64",
        addresses: Pe
      };
    }
    ce && (Se.sigVerify = !0);
    const Be = [Ee, Se], Ce = await this._rpcRequest("simulateTransaction", Be), Ie = create(Ce, SimulatedTransactionResponseStruct);
    if ("error" in Ie) {
      let Pe;
      if ("data" in Ie.error && (Pe = Ie.error.data.logs, Pe && Array.isArray(Pe))) {
        const Ne = `
    `, ke = Ne + Pe.join(Ne);
        console.error(Ie.error.message, ke);
      }
      throw new SendTransactionError("failed to simulate transaction: " + Ie.error.message, Pe);
    }
    return Ie.result;
  }
  /**
   * Sign and send a transaction
   *
   * @deprecated Instead, call {@link sendTransaction} with a {@link
   * VersionedTransaction}
   */
  /**
   * Send a signed transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Sign and send a transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  async sendTransaction(ie, se, fe) {
    if ("version" in ie) {
      if (se && Array.isArray(se))
        throw new Error("Invalid arguments");
      const de = ie.serialize();
      return await this.sendRawTransaction(de, se);
    }
    if (se === void 0 || !Array.isArray(se))
      throw new Error("Invalid arguments");
    const ue = se;
    if (ie.nonceInfo)
      ie.sign(...ue);
    else {
      let de = this._disableBlockhashCaching;
      for (; ; ) {
        const me = await this._blockhashWithExpiryBlockHeight(de);
        if (ie.lastValidBlockHeight = me.lastValidBlockHeight, ie.recentBlockhash = me.blockhash, ie.sign(...ue), !ie.signature)
          throw new Error("!signature");
        const we = ie.signature.toString("base64");
        if (this._blockhashInfo.transactionSignatures.includes(we))
          de = !0;
        else {
          this._blockhashInfo.transactionSignatures.push(we);
          break;
        }
      }
    }
    const ce = ie.serialize();
    return await this.sendRawTransaction(ce, fe);
  }
  /**
   * Send a transaction that has already been signed and serialized into the
   * wire format
   */
  async sendRawTransaction(ie, se) {
    const fe = toBuffer(ie).toString("base64");
    return await this.sendEncodedTransaction(fe, se);
  }
  /**
   * Send a transaction that has already been signed, serialized into the
   * wire format, and encoded as a base64 string
   */
  async sendEncodedTransaction(ie, se) {
    const fe = {
      encoding: "base64"
    }, ue = se && se.skipPreflight, ce = se && se.preflightCommitment || this.commitment;
    se && se.maxRetries != null && (fe.maxRetries = se.maxRetries), se && se.minContextSlot != null && (fe.minContextSlot = se.minContextSlot), ue && (fe.skipPreflight = ue), ce && (fe.preflightCommitment = ce);
    const de = [ie, fe], me = await this._rpcRequest("sendTransaction", de), we = create(me, SendTransactionRpcResult);
    if ("error" in we) {
      let Ee;
      throw "data" in we.error && (Ee = we.error.data.logs), new SendTransactionError("failed to send transaction: " + we.error.message, Ee);
    }
    return we.result;
  }
  /**
   * @internal
   */
  _wsOnOpen() {
    this._rpcWebSocketConnected = !0, this._rpcWebSocketHeartbeat = setInterval(() => {
      (async () => {
        try {
          await this._rpcWebSocket.notify("ping");
        } catch {
        }
      })();
    }, 5e3), this._updateSubscriptions();
  }
  /**
   * @internal
   */
  _wsOnError(ie) {
    this._rpcWebSocketConnected = !1, console.error("ws error:", ie.message);
  }
  /**
   * @internal
   */
  _wsOnClose(ie) {
    if (this._rpcWebSocketConnected = !1, this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER, this._rpcWebSocketIdleTimeout && (clearTimeout(this._rpcWebSocketIdleTimeout), this._rpcWebSocketIdleTimeout = null), this._rpcWebSocketHeartbeat && (clearInterval(this._rpcWebSocketHeartbeat), this._rpcWebSocketHeartbeat = null), ie === 1e3) {
      this._updateSubscriptions();
      return;
    }
    this._subscriptionCallbacksByServerSubscriptionId = {}, Object.entries(this._subscriptionsByHash).forEach(([se, fe]) => {
      this._setSubscription(se, {
        ...fe,
        state: "pending"
      });
    });
  }
  /**
   * @internal
   */
  _setSubscription(ie, se) {
    const fe = this._subscriptionsByHash[ie]?.state;
    if (this._subscriptionsByHash[ie] = se, fe !== se.state) {
      const ue = this._subscriptionStateChangeCallbacksByHash[ie];
      ue && ue.forEach((ce) => {
        try {
          ce(se.state);
        } catch {
        }
      });
    }
  }
  /**
   * @internal
   */
  _onSubscriptionStateChange(ie, se) {
    const fe = this._subscriptionHashByClientSubscriptionId[ie];
    if (fe == null)
      return () => {
      };
    const ue = this._subscriptionStateChangeCallbacksByHash[fe] ||= /* @__PURE__ */ new Set();
    return ue.add(se), () => {
      ue.delete(se), ue.size === 0 && delete this._subscriptionStateChangeCallbacksByHash[fe];
    };
  }
  /**
   * @internal
   */
  async _updateSubscriptions() {
    if (Object.keys(this._subscriptionsByHash).length === 0) {
      this._rpcWebSocketConnected && (this._rpcWebSocketConnected = !1, this._rpcWebSocketIdleTimeout = setTimeout(() => {
        this._rpcWebSocketIdleTimeout = null;
        try {
          this._rpcWebSocket.close();
        } catch (fe) {
          fe instanceof Error && console.log(`Error when closing socket connection: ${fe.message}`);
        }
      }, 500));
      return;
    }
    if (this._rpcWebSocketIdleTimeout !== null && (clearTimeout(this._rpcWebSocketIdleTimeout), this._rpcWebSocketIdleTimeout = null, this._rpcWebSocketConnected = !0), !this._rpcWebSocketConnected) {
      this._rpcWebSocket.connect();
      return;
    }
    const ie = this._rpcWebSocketGeneration, se = () => ie === this._rpcWebSocketGeneration;
    await Promise.all(
      // Don't be tempted to change this to `Object.entries`. We call
      // `_updateSubscriptions` recursively when processing the state,
      // so it's important that we look up the *current* version of
      // each subscription, every time we process a hash.
      Object.keys(this._subscriptionsByHash).map(async (fe) => {
        const ue = this._subscriptionsByHash[fe];
        if (ue !== void 0)
          switch (ue.state) {
            case "pending":
            case "unsubscribed":
              if (ue.callbacks.size === 0) {
                delete this._subscriptionsByHash[fe], ue.state === "unsubscribed" && delete this._subscriptionCallbacksByServerSubscriptionId[ue.serverSubscriptionId], await this._updateSubscriptions();
                return;
              }
              await (async () => {
                const {
                  args: ce,
                  method: de
                } = ue;
                try {
                  this._setSubscription(fe, {
                    ...ue,
                    state: "subscribing"
                  });
                  const me = await this._rpcWebSocket.call(de, ce);
                  this._setSubscription(fe, {
                    ...ue,
                    serverSubscriptionId: me,
                    state: "subscribed"
                  }), this._subscriptionCallbacksByServerSubscriptionId[me] = ue.callbacks, await this._updateSubscriptions();
                } catch (me) {
                  if (me instanceof Error && console.error(`${de} error for argument`, ce, me.message), !se())
                    return;
                  this._setSubscription(fe, {
                    ...ue,
                    state: "pending"
                  }), await this._updateSubscriptions();
                }
              })();
              break;
            case "subscribed":
              ue.callbacks.size === 0 && await (async () => {
                const {
                  serverSubscriptionId: ce,
                  unsubscribeMethod: de
                } = ue;
                if (this._subscriptionsAutoDisposedByRpc.has(ce))
                  this._subscriptionsAutoDisposedByRpc.delete(ce);
                else {
                  this._setSubscription(fe, {
                    ...ue,
                    state: "unsubscribing"
                  }), this._setSubscription(fe, {
                    ...ue,
                    state: "unsubscribing"
                  });
                  try {
                    await this._rpcWebSocket.call(de, [ce]);
                  } catch (me) {
                    if (me instanceof Error && console.error(`${de} error:`, me.message), !se())
                      return;
                    this._setSubscription(fe, {
                      ...ue,
                      state: "subscribed"
                    }), await this._updateSubscriptions();
                    return;
                  }
                }
                this._setSubscription(fe, {
                  ...ue,
                  state: "unsubscribed"
                }), await this._updateSubscriptions();
              })();
              break;
          }
      })
    );
  }
  /**
   * @internal
   */
  _handleServerNotification(ie, se) {
    const fe = this._subscriptionCallbacksByServerSubscriptionId[ie];
    fe !== void 0 && fe.forEach((ue) => {
      try {
        ue(
          ...se
        );
      } catch (ce) {
        console.error(ce);
      }
    });
  }
  /**
   * @internal
   */
  _wsOnAccountNotification(ie) {
    const {
      result: se,
      subscription: fe
    } = create(ie, AccountNotificationResult);
    this._handleServerNotification(fe, [se.value, se.context]);
  }
  /**
   * @internal
   */
  _makeSubscription(ie, se) {
    const fe = this._nextClientSubscriptionId++, ue = fastStableStringify$1(
      [ie.method, se],
      !0
      /* isArrayProp */
    ), ce = this._subscriptionsByHash[ue];
    return ce === void 0 ? this._subscriptionsByHash[ue] = {
      ...ie,
      args: se,
      callbacks: /* @__PURE__ */ new Set([ie.callback]),
      state: "pending"
    } : ce.callbacks.add(ie.callback), this._subscriptionHashByClientSubscriptionId[fe] = ue, this._subscriptionDisposeFunctionsByClientSubscriptionId[fe] = async () => {
      delete this._subscriptionDisposeFunctionsByClientSubscriptionId[fe], delete this._subscriptionHashByClientSubscriptionId[fe];
      const de = this._subscriptionsByHash[ue];
      assert(de !== void 0, `Could not find a \`Subscription\` when tearing down client subscription #${fe}`), de.callbacks.delete(ie.callback), await this._updateSubscriptions();
    }, this._updateSubscriptions(), fe;
  }
  /**
   * Register a callback to be invoked whenever the specified account changes
   *
   * @param publicKey Public key of the account to monitor
   * @param callback Function to invoke whenever the account is changed
   * @param commitment Specify the commitment level account changes must reach before notification
   * @return subscription id
   */
  onAccountChange(ie, se, fe) {
    const ue = this._buildArgs(
      [ie.toBase58()],
      fe || this._commitment || "finalized",
      // Apply connection/server default.
      "base64"
    );
    return this._makeSubscription({
      callback: se,
      method: "accountSubscribe",
      unsubscribeMethod: "accountUnsubscribe"
    }, ue);
  }
  /**
   * Deregister an account notification callback
   *
   * @param id client subscription id to deregister
   */
  async removeAccountChangeListener(ie) {
    await this._unsubscribeClientSubscription(ie, "account change");
  }
  /**
   * @internal
   */
  _wsOnProgramAccountNotification(ie) {
    const {
      result: se,
      subscription: fe
    } = create(ie, ProgramAccountNotificationResult);
    this._handleServerNotification(fe, [{
      accountId: se.value.pubkey,
      accountInfo: se.value.account
    }, se.context]);
  }
  /**
   * Register a callback to be invoked whenever accounts owned by the
   * specified program change
   *
   * @param programId Public key of the program to monitor
   * @param callback Function to invoke whenever the account is changed
   * @param commitment Specify the commitment level account changes must reach before notification
   * @param filters The program account filters to pass into the RPC method
   * @return subscription id
   */
  onProgramAccountChange(ie, se, fe, ue) {
    const ce = this._buildArgs(
      [ie.toBase58()],
      fe || this._commitment || "finalized",
      // Apply connection/server default.
      "base64",
      ue ? {
        filters: ue
      } : void 0
      /* extra */
    );
    return this._makeSubscription({
      callback: se,
      method: "programSubscribe",
      unsubscribeMethod: "programUnsubscribe"
    }, ce);
  }
  /**
   * Deregister an account notification callback
   *
   * @param id client subscription id to deregister
   */
  async removeProgramAccountChangeListener(ie) {
    await this._unsubscribeClientSubscription(ie, "program account change");
  }
  /**
   * Registers a callback to be invoked whenever logs are emitted.
   */
  onLogs(ie, se, fe) {
    const ue = this._buildArgs(
      [typeof ie == "object" ? {
        mentions: [ie.toString()]
      } : ie],
      fe || this._commitment || "finalized"
      // Apply connection/server default.
    );
    return this._makeSubscription({
      callback: se,
      method: "logsSubscribe",
      unsubscribeMethod: "logsUnsubscribe"
    }, ue);
  }
  /**
   * Deregister a logs callback.
   *
   * @param id client subscription id to deregister.
   */
  async removeOnLogsListener(ie) {
    await this._unsubscribeClientSubscription(ie, "logs");
  }
  /**
   * @internal
   */
  _wsOnLogsNotification(ie) {
    const {
      result: se,
      subscription: fe
    } = create(ie, LogsNotificationResult);
    this._handleServerNotification(fe, [se.value, se.context]);
  }
  /**
   * @internal
   */
  _wsOnSlotNotification(ie) {
    const {
      result: se,
      subscription: fe
    } = create(ie, SlotNotificationResult);
    this._handleServerNotification(fe, [se]);
  }
  /**
   * Register a callback to be invoked upon slot changes
   *
   * @param callback Function to invoke whenever the slot changes
   * @return subscription id
   */
  onSlotChange(ie) {
    return this._makeSubscription(
      {
        callback: ie,
        method: "slotSubscribe",
        unsubscribeMethod: "slotUnsubscribe"
      },
      []
      /* args */
    );
  }
  /**
   * Deregister a slot notification callback
   *
   * @param id client subscription id to deregister
   */
  async removeSlotChangeListener(ie) {
    await this._unsubscribeClientSubscription(ie, "slot change");
  }
  /**
   * @internal
   */
  _wsOnSlotUpdatesNotification(ie) {
    const {
      result: se,
      subscription: fe
    } = create(ie, SlotUpdateNotificationResult);
    this._handleServerNotification(fe, [se]);
  }
  /**
   * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s
   * may be useful to track live progress of a cluster.
   *
   * @param callback Function to invoke whenever the slot updates
   * @return subscription id
   */
  onSlotUpdate(ie) {
    return this._makeSubscription(
      {
        callback: ie,
        method: "slotsUpdatesSubscribe",
        unsubscribeMethod: "slotsUpdatesUnsubscribe"
      },
      []
      /* args */
    );
  }
  /**
   * Deregister a slot update notification callback
   *
   * @param id client subscription id to deregister
   */
  async removeSlotUpdateListener(ie) {
    await this._unsubscribeClientSubscription(ie, "slot update");
  }
  /**
   * @internal
   */
  async _unsubscribeClientSubscription(ie, se) {
    const fe = this._subscriptionDisposeFunctionsByClientSubscriptionId[ie];
    fe ? await fe() : console.warn(`Ignored unsubscribe request because an active subscription with id \`${ie}\` for '${se}' events could not be found.`);
  }
  _buildArgs(ie, se, fe, ue) {
    const ce = se || this._commitment;
    if (ce || fe || ue) {
      let de = {};
      fe && (de.encoding = fe), ce && (de.commitment = ce), ue && (de = Object.assign(de, ue)), ie.push(de);
    }
    return ie;
  }
  /**
   * @internal
   */
  _buildArgsAtLeastConfirmed(ie, se, fe, ue) {
    const ce = se || this._commitment;
    if (ce && !["confirmed", "finalized"].includes(ce))
      throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
    return this._buildArgs(ie, se, fe, ue);
  }
  /**
   * @internal
   */
  _wsOnSignatureNotification(ie) {
    const {
      result: se,
      subscription: fe
    } = create(ie, SignatureNotificationResult);
    se.value !== "receivedSignature" && this._subscriptionsAutoDisposedByRpc.add(fe), this._handleServerNotification(fe, se.value === "receivedSignature" ? [{
      type: "received"
    }, se.context] : [{
      type: "status",
      result: se.value
    }, se.context]);
  }
  /**
   * Register a callback to be invoked upon signature updates
   *
   * @param signature Transaction signature string in base 58
   * @param callback Function to invoke on signature notifications
   * @param commitment Specify the commitment level signature must reach before notification
   * @return subscription id
   */
  onSignature(ie, se, fe) {
    const ue = this._buildArgs(
      [ie],
      fe || this._commitment || "finalized"
      // Apply connection/server default.
    ), ce = this._makeSubscription({
      callback: (de, me) => {
        if (de.type === "status") {
          se(de.result, me);
          try {
            this.removeSignatureListener(ce);
          } catch {
          }
        }
      },
      method: "signatureSubscribe",
      unsubscribeMethod: "signatureUnsubscribe"
    }, ue);
    return ce;
  }
  /**
   * Register a callback to be invoked when a transaction is
   * received and/or processed.
   *
   * @param signature Transaction signature string in base 58
   * @param callback Function to invoke on signature notifications
   * @param options Enable received notifications and set the commitment
   *   level that signature must reach before notification
   * @return subscription id
   */
  onSignatureWithOptions(ie, se, fe) {
    const {
      commitment: ue,
      ...ce
    } = {
      ...fe,
      commitment: fe && fe.commitment || this._commitment || "finalized"
      // Apply connection/server default.
    }, de = this._buildArgs([ie], ue, void 0, ce), me = this._makeSubscription({
      callback: (we, Ee) => {
        se(we, Ee);
        try {
          this.removeSignatureListener(me);
        } catch {
        }
      },
      method: "signatureSubscribe",
      unsubscribeMethod: "signatureUnsubscribe"
    }, de);
    return me;
  }
  /**
   * Deregister a signature notification callback
   *
   * @param id client subscription id to deregister
   */
  async removeSignatureListener(ie) {
    await this._unsubscribeClientSubscription(ie, "signature result");
  }
  /**
   * @internal
   */
  _wsOnRootNotification(ie) {
    const {
      result: se,
      subscription: fe
    } = create(ie, RootNotificationResult);
    this._handleServerNotification(fe, [se]);
  }
  /**
   * Register a callback to be invoked upon root changes
   *
   * @param callback Function to invoke whenever the root changes
   * @return subscription id
   */
  onRootChange(ie) {
    return this._makeSubscription(
      {
        callback: ie,
        method: "rootSubscribe",
        unsubscribeMethod: "rootUnsubscribe"
      },
      []
      /* args */
    );
  }
  /**
   * Deregister a root notification callback
   *
   * @param id client subscription id to deregister
   */
  async removeRootChangeListener(ie) {
    await this._unsubscribeClientSubscription(ie, "root change");
  }
}
Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: struct([u32("instruction"), u64("recentSlot"), u8("bumpSeed")])
  },
  FreezeLookupTable: {
    index: 1,
    layout: struct([u32("instruction")])
  },
  ExtendLookupTable: {
    index: 2,
    layout: struct([u32("instruction"), u64(), seq(publicKey(), offset(u32(), -8), "addresses")])
  },
  DeactivateLookupTable: {
    index: 3,
    layout: struct([u32("instruction")])
  },
  CloseLookupTable: {
    index: 4,
    layout: struct([u32("instruction")])
  }
});
new PublicKey("AddressLookupTab1e1111111111111111111111111");
Object.freeze({
  RequestUnits: {
    index: 0,
    layout: struct([u8("instruction"), u32("units"), u32("additionalFee")])
  },
  RequestHeapFrame: {
    index: 1,
    layout: struct([u8("instruction"), u32("bytes")])
  },
  SetComputeUnitLimit: {
    index: 2,
    layout: struct([u8("instruction"), u32("units")])
  },
  SetComputeUnitPrice: {
    index: 3,
    layout: struct([u8("instruction"), u64("microLamports")])
  }
});
new PublicKey("ComputeBudget111111111111111111111111111111");
struct([u8("numSignatures"), u8("padding"), u16("signatureOffset"), u16("signatureInstructionIndex"), u16("publicKeyOffset"), u16("publicKeyInstructionIndex"), u16("messageDataOffset"), u16("messageDataSize"), u16("messageInstructionIndex")]);
new PublicKey("Ed25519SigVerify111111111111111111111111111");
secp256k1.utils.isValidPrivateKey;
secp256k1.getPublicKey;
struct([u8("numSignatures"), u16("signatureOffset"), u8("signatureInstructionIndex"), u16("ethAddressOffset"), u8("ethAddressInstructionIndex"), u16("messageDataOffset"), u16("messageDataSize"), u8("messageInstructionIndex"), blob(20, "ethAddress"), blob(64, "signature"), u8("recoveryId")]);
new PublicKey("KeccakSecp256k11111111111111111111111111111");
var _class2;
new PublicKey("StakeConfig11111111111111111111111111111111");
class Lockup {
  /**
   * Create a new Lockup object
   */
  constructor(ie, se, fe) {
    this.unixTimestamp = void 0, this.epoch = void 0, this.custodian = void 0, this.unixTimestamp = ie, this.epoch = se, this.custodian = fe;
  }
  /**
   * Default, inactive Lockup value
   */
}
_class2 = Lockup;
Lockup.default = new _class2(0, 0, PublicKey.default);
Object.freeze({
  Initialize: {
    index: 0,
    layout: struct([u32("instruction"), authorized(), lockup()])
  },
  Authorize: {
    index: 1,
    layout: struct([u32("instruction"), publicKey("newAuthorized"), u32("stakeAuthorizationType")])
  },
  Delegate: {
    index: 2,
    layout: struct([u32("instruction")])
  },
  Split: {
    index: 3,
    layout: struct([u32("instruction"), ns64("lamports")])
  },
  Withdraw: {
    index: 4,
    layout: struct([u32("instruction"), ns64("lamports")])
  },
  Deactivate: {
    index: 5,
    layout: struct([u32("instruction")])
  },
  Merge: {
    index: 7,
    layout: struct([u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 8,
    layout: struct([u32("instruction"), publicKey("newAuthorized"), u32("stakeAuthorizationType"), rustString("authoritySeed"), publicKey("authorityOwner")])
  }
});
new PublicKey("Stake11111111111111111111111111111111111111");
Object.freeze({
  InitializeAccount: {
    index: 0,
    layout: struct([u32("instruction"), voteInit()])
  },
  Authorize: {
    index: 1,
    layout: struct([u32("instruction"), publicKey("newAuthorized"), u32("voteAuthorizationType")])
  },
  Withdraw: {
    index: 3,
    layout: struct([u32("instruction"), ns64("lamports")])
  },
  AuthorizeWithSeed: {
    index: 10,
    layout: struct([u32("instruction"), voteAuthorizeWithSeedArgs()])
  }
});
new PublicKey("Vote111111111111111111111111111111111111111");
new PublicKey("Va1idator1nfo111111111111111111111111111111");
type({
  name: string(),
  website: optional(string()),
  details: optional(string()),
  keybaseUsername: optional(string())
});
new PublicKey("Vote111111111111111111111111111111111111111");
struct([
  publicKey("nodePubkey"),
  publicKey("authorizedWithdrawer"),
  u8("commission"),
  nu64(),
  // votes.length
  seq(struct([nu64("slot"), u32("confirmationCount")]), offset(u32(), -8), "votes"),
  u8("rootSlotValid"),
  nu64("rootSlot"),
  nu64(),
  // authorizedVoters.length
  seq(struct([nu64("epoch"), publicKey("authorizedVoter")]), offset(u32(), -8), "authorizedVoters"),
  struct([seq(struct([publicKey("authorizedPubkey"), nu64("epochOfLastAuthorizedSwitch"), nu64("targetEpoch")]), 32, "buf"), nu64("idx"), u8("isEmpty")], "priorVoters"),
  nu64(),
  // epochCredits.length
  seq(struct([nu64("epoch"), nu64("credits"), nu64("prevCredits")]), offset(u32(), -8), "epochCredits"),
  struct([nu64("slot"), nu64("timestamp")], "lastTimestamp")
]);
class SolanaConfig extends BaseWebToken {
  signer;
  minConfirm = 1;
  finality = "finalized";
  constructor(ie) {
    super(ie), this.base = ["lamports", 1e9], this.finality = this?.opts?.finality ?? "finalized";
  }
  async getProvider() {
    return this.providerInstance || (this.providerInstance = new Connection(this.providerUrl, {
      confirmTransactionInitialTimeout: 6e4,
      commitment: this.finality
    })), this.providerInstance;
  }
  async getTx(ie) {
    const se = await this.getProvider(), fe = await se.getTransaction(ie, { commitment: this.finality, maxSupportedTransactionVersion: 0 });
    if (!fe)
      throw new Error("Confirmed tx not found");
    const ue = await se.getSlot(this.finality);
    if (!fe.meta)
      throw new Error(`Unable to resolve transaction ${ie}`);
    const ce = new BigNumber$1(fe.meta.postBalances[1]).minus(new BigNumber$1(fe.meta.preBalances[1])), de = fe.transaction.message.getAccountKeys().staticAccountKeys;
    return {
      from: de[0].toBase58(),
      to: de[1].toBase58(),
      amount: ce,
      blockHeight: new BigNumber$1(fe.slot),
      pending: !1,
      confirmed: ue - fe.slot >= 1
    };
  }
  ownerToAddress(ie) {
    return typeof ie == "string" && (ie = Buffer$F.from(ie)), bs58$3.encode(ie);
  }
  async sign(ie) {
    return await (await this.getSigner()).sign(ie);
  }
  getSigner() {
    return this.signer || (this.signer = new HexSolanaSigner$1(this.wallet)), this.signer;
  }
  verify(ie, se, fe) {
    return HexSolanaSigner$1.verify(ie, se, fe);
  }
  async getCurrentHeight() {
    return new BigNumber$1((await (await this.getProvider()).getEpochInfo()).blockHeight ?? 0);
  }
  async getFee(ie, se) {
    return new BigNumber$1(5e3);
  }
  async sendTx(ie) {
    return await this.wallet.sendTransaction(ie, await this.getProvider(), { skipPreflight: !0 });
  }
  async createTx(ie, se, fe) {
    const ue = new PublicKey(await this.getPublicKey()), ce = await retry$1(async (me) => {
      try {
        return await (await this.getProvider()).getLatestBlockhash(this.finality);
      } catch (we) {
        throw we.message?.includes("blockhash") ? we : (me(we), new Error("Unreachable"));
      }
    }, { retries: 3, minTimeout: 1e3 }), de = new Transaction({ ...ce, feePayer: ue });
    return de.add(SystemProgram.transfer({
      fromPubkey: ue,
      toPubkey: new PublicKey(se),
      lamports: +new BigNumber$1(ie).toNumber()
    })), { tx: de, txId: void 0 };
  }
  async getPublicKey() {
    if (!this.wallet.publicKey)
      throw new Error("Wallet.publicKey is undefined");
    return this.wallet.publicKey.toBuffer();
  }
}
const version$1 = "abi/5.7.0", logger$5 = new Logger(version$1), _constructorGuard = {};
let ModifiersBytes = { calldata: !0, memory: !0, storage: !0 }, ModifiersNest = { calldata: !0, memory: !0 };
function checkModifier(ae, ie) {
  if (ae === "bytes" || ae === "string") {
    if (ModifiersBytes[ie])
      return !0;
  } else if (ae === "address") {
    if (ie === "payable")
      return !0;
  } else if ((ae.indexOf("[") >= 0 || ae === "tuple") && ModifiersNest[ie])
    return !0;
  return (ModifiersBytes[ie] || ie === "payable") && logger$5.throwArgumentError("invalid modifier", "name", ie), !1;
}
function parseParamType(ae, ie) {
  let se = ae;
  function fe(me) {
    logger$5.throwArgumentError(`unexpected character at position ${me}`, "param", ae);
  }
  ae = ae.replace(/\s/g, " ");
  function ue(me) {
    let we = { type: "", name: "", parent: me, state: { allowType: !0 } };
    return ie && (we.indexed = !1), we;
  }
  let ce = { type: "", name: "", state: { allowType: !0 } }, de = ce;
  for (let me = 0; me < ae.length; me++) {
    let we = ae[me];
    switch (we) {
      case "(":
        de.state.allowType && de.type === "" ? de.type = "tuple" : de.state.allowParams || fe(me), de.state.allowType = !1, de.type = verifyType(de.type), de.components = [ue(de)], de = de.components[0];
        break;
      case ")":
        delete de.state, de.name === "indexed" && (ie || fe(me), de.indexed = !0, de.name = ""), checkModifier(de.type, de.name) && (de.name = ""), de.type = verifyType(de.type);
        let Ee = de;
        de = de.parent, de || fe(me), delete Ee.parent, de.state.allowParams = !1, de.state.allowName = !0, de.state.allowArray = !0;
        break;
      case ",":
        delete de.state, de.name === "indexed" && (ie || fe(me), de.indexed = !0, de.name = ""), checkModifier(de.type, de.name) && (de.name = ""), de.type = verifyType(de.type);
        let Se = ue(de.parent);
        de.parent.components.push(Se), delete de.parent, de = Se;
        break;
      case " ":
        de.state.allowType && de.type !== "" && (de.type = verifyType(de.type), delete de.state.allowType, de.state.allowName = !0, de.state.allowParams = !0), de.state.allowName && de.name !== "" && (de.name === "indexed" ? (ie || fe(me), de.indexed && fe(me), de.indexed = !0, de.name = "") : checkModifier(de.type, de.name) ? de.name = "" : de.state.allowName = !1);
        break;
      case "[":
        de.state.allowArray || fe(me), de.type += we, de.state.allowArray = !1, de.state.allowName = !1, de.state.readArray = !0;
        break;
      case "]":
        de.state.readArray || fe(me), de.type += we, de.state.readArray = !1, de.state.allowArray = !0, de.state.allowName = !0;
        break;
      default:
        de.state.allowType ? (de.type += we, de.state.allowParams = !0, de.state.allowArray = !0) : de.state.allowName ? (de.name += we, delete de.state.allowArray) : de.state.readArray ? de.type += we : fe(me);
    }
  }
  return de.parent && logger$5.throwArgumentError("unexpected eof", "param", ae), delete ce.state, de.name === "indexed" ? (ie || fe(se.length - 7), de.indexed && fe(se.length - 7), de.indexed = !0, de.name = "") : checkModifier(de.type, de.name) && (de.name = ""), ce.type = verifyType(ce.type), ce;
}
function populate(ae, ie) {
  for (let se in ie)
    defineReadOnly(ae, se, ie[se]);
}
const FormatTypes = Object.freeze({
  // Bare formatting, as is needed for computing a sighash of an event or function
  sighash: "sighash",
  // Human-Readable with Minimal spacing and without names (compact human-readable)
  minimal: "minimal",
  // Human-Readable with nice spacing, including all names
  full: "full",
  // JSON-format a la Solidity
  json: "json"
}), paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
class ParamType {
  constructor(ie, se) {
    ie !== _constructorGuard && logger$5.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new ParamType()"
    }), populate(this, se);
    let fe = this.type.match(paramTypeArray);
    fe ? populate(this, {
      arrayLength: parseInt(fe[2] || "-1"),
      arrayChildren: ParamType.fromObject({
        type: fe[1],
        components: this.components
      }),
      baseType: "array"
    }) : populate(this, {
      arrayLength: null,
      arrayChildren: null,
      baseType: this.components != null ? "tuple" : this.type
    }), this._isParamType = !0, Object.freeze(this);
  }
  // Format the parameter fragment
  //   - sighash: "(uint256,address)"
  //   - minimal: "tuple(uint256,address) indexed"
  //   - full:    "tuple(uint256 foo, address bar) indexed baz"
  format(ie) {
    if (ie || (ie = FormatTypes.sighash), FormatTypes[ie] || logger$5.throwArgumentError("invalid format type", "format", ie), ie === FormatTypes.json) {
      let fe = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0
      };
      return typeof this.indexed == "boolean" && (fe.indexed = this.indexed), this.components && (fe.components = this.components.map((ue) => JSON.parse(ue.format(ie)))), JSON.stringify(fe);
    }
    let se = "";
    return this.baseType === "array" ? (se += this.arrayChildren.format(ie), se += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]") : this.baseType === "tuple" ? (ie !== FormatTypes.sighash && (se += this.type), se += "(" + this.components.map((fe) => fe.format(ie)).join(ie === FormatTypes.full ? ", " : ",") + ")") : se += this.type, ie !== FormatTypes.sighash && (this.indexed === !0 && (se += " indexed"), ie === FormatTypes.full && this.name && (se += " " + this.name)), se;
  }
  static from(ie, se) {
    return typeof ie == "string" ? ParamType.fromString(ie, se) : ParamType.fromObject(ie);
  }
  static fromObject(ie) {
    return ParamType.isParamType(ie) ? ie : new ParamType(_constructorGuard, {
      name: ie.name || null,
      type: verifyType(ie.type),
      indexed: ie.indexed == null ? null : !!ie.indexed,
      components: ie.components ? ie.components.map(ParamType.fromObject) : null
    });
  }
  static fromString(ie, se) {
    function fe(ue) {
      return ParamType.fromObject({
        name: ue.name,
        type: ue.type,
        indexed: ue.indexed,
        components: ue.components
      });
    }
    return fe(parseParamType(ie, !!se));
  }
  static isParamType(ie) {
    return !!(ie != null && ie._isParamType);
  }
}
function parseParams(ae, ie) {
  return splitNesting(ae).map((se) => ParamType.fromString(se, ie));
}
class Fragment {
  constructor(ie, se) {
    ie !== _constructorGuard && logger$5.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new Fragment()"
    }), populate(this, se), this._isFragment = !0, Object.freeze(this);
  }
  static from(ie) {
    return Fragment.isFragment(ie) ? ie : typeof ie == "string" ? Fragment.fromString(ie) : Fragment.fromObject(ie);
  }
  static fromObject(ie) {
    if (Fragment.isFragment(ie))
      return ie;
    switch (ie.type) {
      case "function":
        return FunctionFragment.fromObject(ie);
      case "event":
        return EventFragment.fromObject(ie);
      case "constructor":
        return ConstructorFragment.fromObject(ie);
      case "error":
        return ErrorFragment.fromObject(ie);
      case "fallback":
      case "receive":
        return null;
    }
    return logger$5.throwArgumentError("invalid fragment object", "value", ie);
  }
  static fromString(ie) {
    return ie = ie.replace(/\s/g, " "), ie = ie.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " "), ie = ie.trim(), ie.split(" ")[0] === "event" ? EventFragment.fromString(ie.substring(5).trim()) : ie.split(" ")[0] === "function" ? FunctionFragment.fromString(ie.substring(8).trim()) : ie.split("(")[0].trim() === "constructor" ? ConstructorFragment.fromString(ie.trim()) : ie.split(" ")[0] === "error" ? ErrorFragment.fromString(ie.substring(5).trim()) : logger$5.throwArgumentError("unsupported fragment", "value", ie);
  }
  static isFragment(ie) {
    return !!(ie && ie._isFragment);
  }
}
class EventFragment extends Fragment {
  format(ie) {
    if (ie || (ie = FormatTypes.sighash), FormatTypes[ie] || logger$5.throwArgumentError("invalid format type", "format", ie), ie === FormatTypes.json)
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((fe) => JSON.parse(fe.format(ie)))
      });
    let se = "";
    return ie !== FormatTypes.sighash && (se += "event "), se += this.name + "(" + this.inputs.map((fe) => fe.format(ie)).join(ie === FormatTypes.full ? ", " : ",") + ") ", ie !== FormatTypes.sighash && this.anonymous && (se += "anonymous "), se.trim();
  }
  static from(ie) {
    return typeof ie == "string" ? EventFragment.fromString(ie) : EventFragment.fromObject(ie);
  }
  static fromObject(ie) {
    if (EventFragment.isEventFragment(ie))
      return ie;
    ie.type !== "event" && logger$5.throwArgumentError("invalid event object", "value", ie);
    const se = {
      name: verifyIdentifier(ie.name),
      anonymous: ie.anonymous,
      inputs: ie.inputs ? ie.inputs.map(ParamType.fromObject) : [],
      type: "event"
    };
    return new EventFragment(_constructorGuard, se);
  }
  static fromString(ie) {
    let se = ie.match(regexParen);
    se || logger$5.throwArgumentError("invalid event string", "value", ie);
    let fe = !1;
    return se[3].split(" ").forEach((ue) => {
      switch (ue.trim()) {
        case "anonymous":
          fe = !0;
          break;
        case "":
          break;
        default:
          logger$5.warn("unknown modifier: " + ue);
      }
    }), EventFragment.fromObject({
      name: se[1].trim(),
      anonymous: fe,
      inputs: parseParams(se[2], !0),
      type: "event"
    });
  }
  static isEventFragment(ie) {
    return ie && ie._isFragment && ie.type === "event";
  }
}
function parseGas(ae, ie) {
  ie.gas = null;
  let se = ae.split("@");
  return se.length !== 1 ? (se.length > 2 && logger$5.throwArgumentError("invalid human-readable ABI signature", "value", ae), se[1].match(/^[0-9]+$/) || logger$5.throwArgumentError("invalid human-readable ABI signature gas", "value", ae), ie.gas = BigNumber.from(se[1]), se[0]) : ae;
}
function parseModifiers(ae, ie) {
  ie.constant = !1, ie.payable = !1, ie.stateMutability = "nonpayable", ae.split(" ").forEach((se) => {
    switch (se.trim()) {
      case "constant":
        ie.constant = !0;
        break;
      case "payable":
        ie.payable = !0, ie.stateMutability = "payable";
        break;
      case "nonpayable":
        ie.payable = !1, ie.stateMutability = "nonpayable";
        break;
      case "pure":
        ie.constant = !0, ie.stateMutability = "pure";
        break;
      case "view":
        ie.constant = !0, ie.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + se);
    }
  });
}
function verifyState(ae) {
  let ie = {
    constant: !1,
    payable: !0,
    stateMutability: "payable"
  };
  return ae.stateMutability != null ? (ie.stateMutability = ae.stateMutability, ie.constant = ie.stateMutability === "view" || ie.stateMutability === "pure", ae.constant != null && !!ae.constant !== ie.constant && logger$5.throwArgumentError("cannot have constant function with mutability " + ie.stateMutability, "value", ae), ie.payable = ie.stateMutability === "payable", ae.payable != null && !!ae.payable !== ie.payable && logger$5.throwArgumentError("cannot have payable function with mutability " + ie.stateMutability, "value", ae)) : ae.payable != null ? (ie.payable = !!ae.payable, ae.constant == null && !ie.payable && ae.type !== "constructor" && logger$5.throwArgumentError("unable to determine stateMutability", "value", ae), ie.constant = !!ae.constant, ie.constant ? ie.stateMutability = "view" : ie.stateMutability = ie.payable ? "payable" : "nonpayable", ie.payable && ie.constant && logger$5.throwArgumentError("cannot have constant payable function", "value", ae)) : ae.constant != null ? (ie.constant = !!ae.constant, ie.payable = !ie.constant, ie.stateMutability = ie.constant ? "view" : "payable") : ae.type !== "constructor" && logger$5.throwArgumentError("unable to determine stateMutability", "value", ae), ie;
}
class ConstructorFragment extends Fragment {
  format(ie) {
    if (ie || (ie = FormatTypes.sighash), FormatTypes[ie] || logger$5.throwArgumentError("invalid format type", "format", ie), ie === FormatTypes.json)
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((fe) => JSON.parse(fe.format(ie)))
      });
    ie === FormatTypes.sighash && logger$5.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "format(sighash)"
    });
    let se = "constructor(" + this.inputs.map((fe) => fe.format(ie)).join(ie === FormatTypes.full ? ", " : ",") + ") ";
    return this.stateMutability && this.stateMutability !== "nonpayable" && (se += this.stateMutability + " "), se.trim();
  }
  static from(ie) {
    return typeof ie == "string" ? ConstructorFragment.fromString(ie) : ConstructorFragment.fromObject(ie);
  }
  static fromObject(ie) {
    if (ConstructorFragment.isConstructorFragment(ie))
      return ie;
    ie.type !== "constructor" && logger$5.throwArgumentError("invalid constructor object", "value", ie);
    let se = verifyState(ie);
    se.constant && logger$5.throwArgumentError("constructor cannot be constant", "value", ie);
    const fe = {
      name: null,
      type: ie.type,
      inputs: ie.inputs ? ie.inputs.map(ParamType.fromObject) : [],
      payable: se.payable,
      stateMutability: se.stateMutability,
      gas: ie.gas ? BigNumber.from(ie.gas) : null
    };
    return new ConstructorFragment(_constructorGuard, fe);
  }
  static fromString(ie) {
    let se = { type: "constructor" };
    ie = parseGas(ie, se);
    let fe = ie.match(regexParen);
    return (!fe || fe[1].trim() !== "constructor") && logger$5.throwArgumentError("invalid constructor string", "value", ie), se.inputs = parseParams(fe[2].trim(), !1), parseModifiers(fe[3].trim(), se), ConstructorFragment.fromObject(se);
  }
  static isConstructorFragment(ie) {
    return ie && ie._isFragment && ie.type === "constructor";
  }
}
class FunctionFragment extends ConstructorFragment {
  format(ie) {
    if (ie || (ie = FormatTypes.sighash), FormatTypes[ie] || logger$5.throwArgumentError("invalid format type", "format", ie), ie === FormatTypes.json)
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((fe) => JSON.parse(fe.format(ie))),
        outputs: this.outputs.map((fe) => JSON.parse(fe.format(ie)))
      });
    let se = "";
    return ie !== FormatTypes.sighash && (se += "function "), se += this.name + "(" + this.inputs.map((fe) => fe.format(ie)).join(ie === FormatTypes.full ? ", " : ",") + ") ", ie !== FormatTypes.sighash && (this.stateMutability ? this.stateMutability !== "nonpayable" && (se += this.stateMutability + " ") : this.constant && (se += "view "), this.outputs && this.outputs.length && (se += "returns (" + this.outputs.map((fe) => fe.format(ie)).join(", ") + ") "), this.gas != null && (se += "@" + this.gas.toString() + " ")), se.trim();
  }
  static from(ie) {
    return typeof ie == "string" ? FunctionFragment.fromString(ie) : FunctionFragment.fromObject(ie);
  }
  static fromObject(ie) {
    if (FunctionFragment.isFunctionFragment(ie))
      return ie;
    ie.type !== "function" && logger$5.throwArgumentError("invalid function object", "value", ie);
    let se = verifyState(ie);
    const fe = {
      type: ie.type,
      name: verifyIdentifier(ie.name),
      constant: se.constant,
      inputs: ie.inputs ? ie.inputs.map(ParamType.fromObject) : [],
      outputs: ie.outputs ? ie.outputs.map(ParamType.fromObject) : [],
      payable: se.payable,
      stateMutability: se.stateMutability,
      gas: ie.gas ? BigNumber.from(ie.gas) : null
    };
    return new FunctionFragment(_constructorGuard, fe);
  }
  static fromString(ie) {
    let se = { type: "function" };
    ie = parseGas(ie, se);
    let fe = ie.split(" returns ");
    fe.length > 2 && logger$5.throwArgumentError("invalid function string", "value", ie);
    let ue = fe[0].match(regexParen);
    if (ue || logger$5.throwArgumentError("invalid function signature", "value", ie), se.name = ue[1].trim(), se.name && verifyIdentifier(se.name), se.inputs = parseParams(ue[2], !1), parseModifiers(ue[3].trim(), se), fe.length > 1) {
      let ce = fe[1].match(regexParen);
      (ce[1].trim() != "" || ce[3].trim() != "") && logger$5.throwArgumentError("unexpected tokens", "value", ie), se.outputs = parseParams(ce[2], !1);
    } else
      se.outputs = [];
    return FunctionFragment.fromObject(se);
  }
  static isFunctionFragment(ie) {
    return ie && ie._isFragment && ie.type === "function";
  }
}
function checkForbidden(ae) {
  const ie = ae.format();
  return (ie === "Error(string)" || ie === "Panic(uint256)") && logger$5.throwArgumentError(`cannot specify user defined ${ie} error`, "fragment", ae), ae;
}
class ErrorFragment extends Fragment {
  format(ie) {
    if (ie || (ie = FormatTypes.sighash), FormatTypes[ie] || logger$5.throwArgumentError("invalid format type", "format", ie), ie === FormatTypes.json)
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((fe) => JSON.parse(fe.format(ie)))
      });
    let se = "";
    return ie !== FormatTypes.sighash && (se += "error "), se += this.name + "(" + this.inputs.map((fe) => fe.format(ie)).join(ie === FormatTypes.full ? ", " : ",") + ") ", se.trim();
  }
  static from(ie) {
    return typeof ie == "string" ? ErrorFragment.fromString(ie) : ErrorFragment.fromObject(ie);
  }
  static fromObject(ie) {
    if (ErrorFragment.isErrorFragment(ie))
      return ie;
    ie.type !== "error" && logger$5.throwArgumentError("invalid error object", "value", ie);
    const se = {
      type: ie.type,
      name: verifyIdentifier(ie.name),
      inputs: ie.inputs ? ie.inputs.map(ParamType.fromObject) : []
    };
    return checkForbidden(new ErrorFragment(_constructorGuard, se));
  }
  static fromString(ie) {
    let se = { type: "error" }, fe = ie.match(regexParen);
    return fe || logger$5.throwArgumentError("invalid error signature", "value", ie), se.name = fe[1].trim(), se.name && verifyIdentifier(se.name), se.inputs = parseParams(fe[2], !1), checkForbidden(ErrorFragment.fromObject(se));
  }
  static isErrorFragment(ie) {
    return ie && ie._isFragment && ie.type === "error";
  }
}
function verifyType(ae) {
  return ae.match(/^uint($|[^1-9])/) ? ae = "uint256" + ae.substring(4) : ae.match(/^int($|[^1-9])/) && (ae = "int256" + ae.substring(3)), ae;
}
const regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(ae) {
  return (!ae || !ae.match(regexIdentifier)) && logger$5.throwArgumentError(`invalid identifier "${ae}"`, "value", ae), ae;
}
const regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(ae) {
  ae = ae.trim();
  let ie = [], se = "", fe = 0;
  for (let ue = 0; ue < ae.length; ue++) {
    let ce = ae[ue];
    ce === "," && fe === 0 ? (ie.push(se), se = "") : (se += ce, ce === "(" ? fe++ : ce === ")" && (fe--, fe === -1 && logger$5.throwArgumentError("unbalanced parenthesis", "value", ae)));
  }
  return se && ie.push(se), ie;
}
const logger$4 = new Logger(version$1);
function checkResultErrors(ae) {
  const ie = [], se = function(fe, ue) {
    if (Array.isArray(ue))
      for (let ce in ue) {
        const de = fe.slice();
        de.push(ce);
        try {
          se(de, ue[ce]);
        } catch (me) {
          ie.push({ path: de, error: me });
        }
      }
  };
  return se([], ae), ie;
}
class Coder {
  constructor(ie, se, fe, ue) {
    this.name = ie, this.type = se, this.localName = fe, this.dynamic = ue;
  }
  _throwError(ie, se) {
    logger$4.throwArgumentError(ie, this.localName, se);
  }
}
class Writer {
  constructor(ie) {
    defineReadOnly(this, "wordSize", ie || 32), this._data = [], this._dataLength = 0, this._padding = new Uint8Array(ie);
  }
  get data() {
    return hexConcat(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(ie) {
    return this._data.push(ie), this._dataLength += ie.length, ie.length;
  }
  appendWriter(ie) {
    return this._writeData(concat(ie._data));
  }
  // Arrayish items; padded on the right to wordSize
  writeBytes(ie) {
    let se = arrayify(ie);
    const fe = se.length % this.wordSize;
    return fe && (se = concat([se, this._padding.slice(fe)])), this._writeData(se);
  }
  _getValue(ie) {
    let se = arrayify(BigNumber.from(ie));
    return se.length > this.wordSize && logger$4.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
      length: this.wordSize,
      offset: se.length
    }), se.length % this.wordSize && (se = concat([this._padding.slice(se.length % this.wordSize), se])), se;
  }
  // BigNumberish items; padded on the left to wordSize
  writeValue(ie) {
    return this._writeData(this._getValue(ie));
  }
  writeUpdatableValue() {
    const ie = this._data.length;
    return this._data.push(this._padding), this._dataLength += this.wordSize, (se) => {
      this._data[ie] = this._getValue(se);
    };
  }
}
class Reader {
  constructor(ie, se, fe, ue) {
    defineReadOnly(this, "_data", arrayify(ie)), defineReadOnly(this, "wordSize", se || 32), defineReadOnly(this, "_coerceFunc", fe), defineReadOnly(this, "allowLoose", ue), this._offset = 0;
  }
  get data() {
    return hexlify(this._data);
  }
  get consumed() {
    return this._offset;
  }
  // The default Coerce function
  static coerce(ie, se) {
    let fe = ie.match("^u?int([0-9]+)$");
    return fe && parseInt(fe[1]) <= 48 && (se = se.toNumber()), se;
  }
  coerce(ie, se) {
    return this._coerceFunc ? this._coerceFunc(ie, se) : Reader.coerce(ie, se);
  }
  _peekBytes(ie, se, fe) {
    let ue = Math.ceil(se / this.wordSize) * this.wordSize;
    return this._offset + ue > this._data.length && (this.allowLoose && fe && this._offset + se <= this._data.length ? ue = se : logger$4.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
      length: this._data.length,
      offset: this._offset + ue
    })), this._data.slice(this._offset, this._offset + ue);
  }
  subReader(ie) {
    return new Reader(this._data.slice(this._offset + ie), this.wordSize, this._coerceFunc, this.allowLoose);
  }
  readBytes(ie, se) {
    let fe = this._peekBytes(0, ie, !!se);
    return this._offset += fe.length, fe.slice(0, ie);
  }
  readValue() {
    return BigNumber.from(this.readBytes(this.wordSize));
  }
}
class AddressCoder extends Coder {
  constructor(ie) {
    super("address", "address", ie, !1);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(ie, se) {
    try {
      se = getAddress(se);
    } catch (fe) {
      this._throwError(fe.message, se);
    }
    return ie.writeValue(se);
  }
  decode(ie) {
    return getAddress(hexZeroPad(ie.readValue().toHexString(), 20));
  }
}
class AnonymousCoder extends Coder {
  constructor(ie) {
    super(ie.name, ie.type, void 0, ie.dynamic), this.coder = ie;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(ie, se) {
    return this.coder.encode(ie, se);
  }
  decode(ie) {
    return this.coder.decode(ie);
  }
}
const logger$3 = new Logger(version$1);
function pack(ae, ie, se) {
  let fe = null;
  if (Array.isArray(se))
    fe = se;
  else if (se && typeof se == "object") {
    let we = {};
    fe = ie.map((Ee) => {
      const Se = Ee.localName;
      return Se || logger$3.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
        argument: "values",
        coder: Ee,
        value: se
      }), we[Se] && logger$3.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
        argument: "values",
        coder: Ee,
        value: se
      }), we[Se] = !0, se[Se];
    });
  } else
    logger$3.throwArgumentError("invalid tuple value", "tuple", se);
  ie.length !== fe.length && logger$3.throwArgumentError("types/value length mismatch", "tuple", se);
  let ue = new Writer(ae.wordSize), ce = new Writer(ae.wordSize), de = [];
  ie.forEach((we, Ee) => {
    let Se = fe[Ee];
    if (we.dynamic) {
      let Be = ce.length;
      we.encode(ce, Se);
      let Ce = ue.writeUpdatableValue();
      de.push((Ie) => {
        Ce(Ie + Be);
      });
    } else
      we.encode(ue, Se);
  }), de.forEach((we) => {
    we(ue.length);
  });
  let me = ae.appendWriter(ue);
  return me += ae.appendWriter(ce), me;
}
function unpack(ae, ie) {
  let se = [], fe = ae.subReader(0);
  ie.forEach((ce) => {
    let de = null;
    if (ce.dynamic) {
      let me = ae.readValue(), we = fe.subReader(me.toNumber());
      try {
        de = ce.decode(we);
      } catch (Ee) {
        if (Ee.code === Logger.errors.BUFFER_OVERRUN)
          throw Ee;
        de = Ee, de.baseType = ce.name, de.name = ce.localName, de.type = ce.type;
      }
    } else
      try {
        de = ce.decode(ae);
      } catch (me) {
        if (me.code === Logger.errors.BUFFER_OVERRUN)
          throw me;
        de = me, de.baseType = ce.name, de.name = ce.localName, de.type = ce.type;
      }
    de != null && se.push(de);
  });
  const ue = ie.reduce((ce, de) => {
    const me = de.localName;
    return me && (ce[me] || (ce[me] = 0), ce[me]++), ce;
  }, {});
  ie.forEach((ce, de) => {
    let me = ce.localName;
    if (!me || ue[me] !== 1 || (me === "length" && (me = "_length"), se[me] != null))
      return;
    const we = se[de];
    we instanceof Error ? Object.defineProperty(se, me, {
      enumerable: !0,
      get: () => {
        throw we;
      }
    }) : se[me] = we;
  });
  for (let ce = 0; ce < se.length; ce++) {
    const de = se[ce];
    de instanceof Error && Object.defineProperty(se, ce, {
      enumerable: !0,
      get: () => {
        throw de;
      }
    });
  }
  return Object.freeze(se);
}
class ArrayCoder extends Coder {
  constructor(ie, se, fe) {
    const ue = ie.type + "[" + (se >= 0 ? se : "") + "]", ce = se === -1 || ie.dynamic;
    super("array", ue, fe, ce), this.coder = ie, this.length = se;
  }
  defaultValue() {
    const ie = this.coder.defaultValue(), se = [];
    for (let fe = 0; fe < this.length; fe++)
      se.push(ie);
    return se;
  }
  encode(ie, se) {
    Array.isArray(se) || this._throwError("expected array value", se);
    let fe = this.length;
    fe === -1 && (fe = se.length, ie.writeValue(se.length)), logger$3.checkArgumentCount(se.length, fe, "coder array" + (this.localName ? " " + this.localName : ""));
    let ue = [];
    for (let ce = 0; ce < se.length; ce++)
      ue.push(this.coder);
    return pack(ie, ue, se);
  }
  decode(ie) {
    let se = this.length;
    se === -1 && (se = ie.readValue().toNumber(), se * 32 > ie._data.length && logger$3.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, {
      length: ie._data.length,
      count: se
    }));
    let fe = [];
    for (let ue = 0; ue < se; ue++)
      fe.push(new AnonymousCoder(this.coder));
    return ie.coerce(this.name, unpack(ie, fe));
  }
}
class BooleanCoder extends Coder {
  constructor(ie) {
    super("bool", "bool", ie, !1);
  }
  defaultValue() {
    return !1;
  }
  encode(ie, se) {
    return ie.writeValue(se ? 1 : 0);
  }
  decode(ie) {
    return ie.coerce(this.type, !ie.readValue().isZero());
  }
}
class DynamicBytesCoder extends Coder {
  constructor(ie, se) {
    super(ie, ie, se, !0);
  }
  defaultValue() {
    return "0x";
  }
  encode(ie, se) {
    se = arrayify(se);
    let fe = ie.writeValue(se.length);
    return fe += ie.writeBytes(se), fe;
  }
  decode(ie) {
    return ie.readBytes(ie.readValue().toNumber(), !0);
  }
}
class BytesCoder extends DynamicBytesCoder {
  constructor(ie) {
    super("bytes", ie);
  }
  decode(ie) {
    return ie.coerce(this.name, hexlify(super.decode(ie)));
  }
}
class FixedBytesCoder extends Coder {
  constructor(ie, se) {
    let fe = "bytes" + String(ie);
    super(fe, fe, se, !1), this.size = ie;
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(ie, se) {
    let fe = arrayify(se);
    return fe.length !== this.size && this._throwError("incorrect data length", se), ie.writeBytes(fe);
  }
  decode(ie) {
    return ie.coerce(this.name, hexlify(ie.readBytes(this.size)));
  }
}
class NullCoder extends Coder {
  constructor(ie) {
    super("null", "", ie, !1);
  }
  defaultValue() {
    return null;
  }
  encode(ie, se) {
    return se != null && this._throwError("not null", se), ie.writeBytes([]);
  }
  decode(ie) {
    return ie.readBytes(0), ie.coerce(this.name, null);
  }
}
class NumberCoder extends Coder {
  constructor(ie, se, fe) {
    const ue = (se ? "int" : "uint") + ie * 8;
    super(ue, ue, fe, !1), this.size = ie, this.signed = se;
  }
  defaultValue() {
    return 0;
  }
  encode(ie, se) {
    let fe = BigNumber.from(se), ue = MaxUint256$1.mask(ie.wordSize * 8);
    if (this.signed) {
      let ce = ue.mask(this.size * 8 - 1);
      (fe.gt(ce) || fe.lt(ce.add(One$1).mul(NegativeOne$1))) && this._throwError("value out-of-bounds", se);
    } else
      (fe.lt(Zero$1) || fe.gt(ue.mask(this.size * 8))) && this._throwError("value out-of-bounds", se);
    return fe = fe.toTwos(this.size * 8).mask(this.size * 8), this.signed && (fe = fe.fromTwos(this.size * 8).toTwos(8 * ie.wordSize)), ie.writeValue(fe);
  }
  decode(ie) {
    let se = ie.readValue().mask(this.size * 8);
    return this.signed && (se = se.fromTwos(this.size * 8)), ie.coerce(this.name, se);
  }
}
class StringCoder extends DynamicBytesCoder {
  constructor(ie) {
    super("string", ie);
  }
  defaultValue() {
    return "";
  }
  encode(ie, se) {
    return super.encode(ie, toUtf8Bytes(se));
  }
  decode(ie) {
    return toUtf8String(super.decode(ie));
  }
}
class TupleCoder extends Coder {
  constructor(ie, se) {
    let fe = !1;
    const ue = [];
    ie.forEach((de) => {
      de.dynamic && (fe = !0), ue.push(de.type);
    });
    const ce = "tuple(" + ue.join(",") + ")";
    super("tuple", ce, se, fe), this.coders = ie;
  }
  defaultValue() {
    const ie = [];
    this.coders.forEach((fe) => {
      ie.push(fe.defaultValue());
    });
    const se = this.coders.reduce((fe, ue) => {
      const ce = ue.localName;
      return ce && (fe[ce] || (fe[ce] = 0), fe[ce]++), fe;
    }, {});
    return this.coders.forEach((fe, ue) => {
      let ce = fe.localName;
      !ce || se[ce] !== 1 || (ce === "length" && (ce = "_length"), ie[ce] == null && (ie[ce] = ie[ue]));
    }), Object.freeze(ie);
  }
  encode(ie, se) {
    return pack(ie, this.coders, se);
  }
  decode(ie) {
    return ie.coerce(this.name, unpack(ie, this.coders));
  }
}
const logger$2 = new Logger(version$1), paramTypeBytes = new RegExp(/^bytes([0-9]*)$/), paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
class AbiCoder {
  constructor(ie) {
    defineReadOnly(this, "coerceFunc", ie || null);
  }
  _getCoder(ie) {
    switch (ie.baseType) {
      case "address":
        return new AddressCoder(ie.name);
      case "bool":
        return new BooleanCoder(ie.name);
      case "string":
        return new StringCoder(ie.name);
      case "bytes":
        return new BytesCoder(ie.name);
      case "array":
        return new ArrayCoder(this._getCoder(ie.arrayChildren), ie.arrayLength, ie.name);
      case "tuple":
        return new TupleCoder((ie.components || []).map((fe) => this._getCoder(fe)), ie.name);
      case "":
        return new NullCoder(ie.name);
    }
    let se = ie.type.match(paramTypeNumber);
    if (se) {
      let fe = parseInt(se[2] || "256");
      return (fe === 0 || fe > 256 || fe % 8 !== 0) && logger$2.throwArgumentError("invalid " + se[1] + " bit length", "param", ie), new NumberCoder(fe / 8, se[1] === "int", ie.name);
    }
    if (se = ie.type.match(paramTypeBytes), se) {
      let fe = parseInt(se[1]);
      return (fe === 0 || fe > 32) && logger$2.throwArgumentError("invalid bytes length", "param", ie), new FixedBytesCoder(fe, ie.name);
    }
    return logger$2.throwArgumentError("invalid type", "type", ie.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(ie, se) {
    return new Reader(ie, this._getWordSize(), this.coerceFunc, se);
  }
  _getWriter() {
    return new Writer(this._getWordSize());
  }
  getDefaultValue(ie) {
    const se = ie.map((ue) => this._getCoder(ParamType.from(ue)));
    return new TupleCoder(se, "_").defaultValue();
  }
  encode(ie, se) {
    ie.length !== se.length && logger$2.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
      count: { types: ie.length, values: se.length },
      value: { types: ie, values: se }
    });
    const fe = ie.map((de) => this._getCoder(ParamType.from(de))), ue = new TupleCoder(fe, "_"), ce = this._getWriter();
    return ue.encode(ce, se), ce.data;
  }
  decode(ie, se, fe) {
    const ue = ie.map((de) => this._getCoder(ParamType.from(de)));
    return new TupleCoder(ue, "_").decode(this._getReader(arrayify(se), fe));
  }
}
const defaultAbiCoder = new AbiCoder(), logger$1 = new Logger(version$1);
class LogDescription extends Description {
}
class TransactionDescription extends Description {
}
class ErrorDescription extends Description {
}
class Indexed extends Description {
  static isIndexed(ie) {
    return !!(ie && ie._isIndexed);
  }
}
const BuiltinErrors = {
  "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: !0 },
  "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function wrapAccessError(ae, ie) {
  const se = new Error(`deferred error during ABI decoding triggered accessing ${ae}`);
  return se.error = ie, se;
}
class Interface {
  constructor(ie) {
    let se = [];
    typeof ie == "string" ? se = JSON.parse(ie) : se = ie, defineReadOnly(this, "fragments", se.map((fe) => Fragment.from(fe)).filter((fe) => fe != null)), defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")()), defineReadOnly(this, "functions", {}), defineReadOnly(this, "errors", {}), defineReadOnly(this, "events", {}), defineReadOnly(this, "structs", {}), this.fragments.forEach((fe) => {
      let ue = null;
      switch (fe.type) {
        case "constructor":
          if (this.deploy) {
            logger$1.warn("duplicate definition - constructor");
            return;
          }
          defineReadOnly(this, "deploy", fe);
          return;
        case "function":
          ue = this.functions;
          break;
        case "event":
          ue = this.events;
          break;
        case "error":
          ue = this.errors;
          break;
        default:
          return;
      }
      let ce = fe.format();
      if (ue[ce]) {
        logger$1.warn("duplicate definition - " + ce);
        return;
      }
      ue[ce] = fe;
    }), this.deploy || defineReadOnly(this, "deploy", ConstructorFragment.from({
      payable: !1,
      type: "constructor"
    })), defineReadOnly(this, "_isInterface", !0);
  }
  format(ie) {
    ie || (ie = FormatTypes.full), ie === FormatTypes.sighash && logger$1.throwArgumentError("interface does not support formatting sighash", "format", ie);
    const se = this.fragments.map((fe) => fe.format(ie));
    return ie === FormatTypes.json ? JSON.stringify(se.map((fe) => JSON.parse(fe))) : se;
  }
  // Sub-classes can override these to handle other blockchains
  static getAbiCoder() {
    return defaultAbiCoder;
  }
  static getAddress(ie) {
    return getAddress(ie);
  }
  static getSighash(ie) {
    return hexDataSlice(id(ie.format()), 0, 4);
  }
  static getEventTopic(ie) {
    return id(ie.format());
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getFunction(ie) {
    if (isHexString$1(ie)) {
      for (const fe in this.functions)
        if (ie === this.getSighash(fe))
          return this.functions[fe];
      logger$1.throwArgumentError("no matching function", "sighash", ie);
    }
    if (ie.indexOf("(") === -1) {
      const fe = ie.trim(), ue = Object.keys(this.functions).filter((ce) => ce.split(
        "("
        /* fix:) */
      )[0] === fe);
      return ue.length === 0 ? logger$1.throwArgumentError("no matching function", "name", fe) : ue.length > 1 && logger$1.throwArgumentError("multiple matching functions", "name", fe), this.functions[ue[0]];
    }
    const se = this.functions[FunctionFragment.fromString(ie).format()];
    return se || logger$1.throwArgumentError("no matching function", "signature", ie), se;
  }
  // Find an event definition by any means necessary (unless it is ambiguous)
  getEvent(ie) {
    if (isHexString$1(ie)) {
      const fe = ie.toLowerCase();
      for (const ue in this.events)
        if (fe === this.getEventTopic(ue))
          return this.events[ue];
      logger$1.throwArgumentError("no matching event", "topichash", fe);
    }
    if (ie.indexOf("(") === -1) {
      const fe = ie.trim(), ue = Object.keys(this.events).filter((ce) => ce.split(
        "("
        /* fix:) */
      )[0] === fe);
      return ue.length === 0 ? logger$1.throwArgumentError("no matching event", "name", fe) : ue.length > 1 && logger$1.throwArgumentError("multiple matching events", "name", fe), this.events[ue[0]];
    }
    const se = this.events[EventFragment.fromString(ie).format()];
    return se || logger$1.throwArgumentError("no matching event", "signature", ie), se;
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getError(ie) {
    if (isHexString$1(ie)) {
      const fe = getStatic(this.constructor, "getSighash");
      for (const ue in this.errors) {
        const ce = this.errors[ue];
        if (ie === fe(ce))
          return this.errors[ue];
      }
      logger$1.throwArgumentError("no matching error", "sighash", ie);
    }
    if (ie.indexOf("(") === -1) {
      const fe = ie.trim(), ue = Object.keys(this.errors).filter((ce) => ce.split(
        "("
        /* fix:) */
      )[0] === fe);
      return ue.length === 0 ? logger$1.throwArgumentError("no matching error", "name", fe) : ue.length > 1 && logger$1.throwArgumentError("multiple matching errors", "name", fe), this.errors[ue[0]];
    }
    const se = this.errors[FunctionFragment.fromString(ie).format()];
    return se || logger$1.throwArgumentError("no matching error", "signature", ie), se;
  }
  // Get the sighash (the bytes4 selector) used by Solidity to identify a function
  getSighash(ie) {
    if (typeof ie == "string")
      try {
        ie = this.getFunction(ie);
      } catch (se) {
        try {
          ie = this.getError(ie);
        } catch {
          throw se;
        }
      }
    return getStatic(this.constructor, "getSighash")(ie);
  }
  // Get the topic (the bytes32 hash) used by Solidity to identify an event
  getEventTopic(ie) {
    return typeof ie == "string" && (ie = this.getEvent(ie)), getStatic(this.constructor, "getEventTopic")(ie);
  }
  _decodeParams(ie, se) {
    return this._abiCoder.decode(ie, se);
  }
  _encodeParams(ie, se) {
    return this._abiCoder.encode(ie, se);
  }
  encodeDeploy(ie) {
    return this._encodeParams(this.deploy.inputs, ie || []);
  }
  decodeErrorResult(ie, se) {
    typeof ie == "string" && (ie = this.getError(ie));
    const fe = arrayify(se);
    return hexlify(fe.slice(0, 4)) !== this.getSighash(ie) && logger$1.throwArgumentError(`data signature does not match error ${ie.name}.`, "data", hexlify(fe)), this._decodeParams(ie.inputs, fe.slice(4));
  }
  encodeErrorResult(ie, se) {
    return typeof ie == "string" && (ie = this.getError(ie)), hexlify(concat([
      this.getSighash(ie),
      this._encodeParams(ie.inputs, se || [])
    ]));
  }
  // Decode the data for a function call (e.g. tx.data)
  decodeFunctionData(ie, se) {
    typeof ie == "string" && (ie = this.getFunction(ie));
    const fe = arrayify(se);
    return hexlify(fe.slice(0, 4)) !== this.getSighash(ie) && logger$1.throwArgumentError(`data signature does not match function ${ie.name}.`, "data", hexlify(fe)), this._decodeParams(ie.inputs, fe.slice(4));
  }
  // Encode the data for a function call (e.g. tx.data)
  encodeFunctionData(ie, se) {
    return typeof ie == "string" && (ie = this.getFunction(ie)), hexlify(concat([
      this.getSighash(ie),
      this._encodeParams(ie.inputs, se || [])
    ]));
  }
  // Decode the result from a function call (e.g. from eth_call)
  decodeFunctionResult(ie, se) {
    typeof ie == "string" && (ie = this.getFunction(ie));
    let fe = arrayify(se), ue = null, ce = "", de = null, me = null, we = null;
    switch (fe.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(ie.outputs, fe);
        } catch {
        }
        break;
      case 4: {
        const Ee = hexlify(fe.slice(0, 4)), Se = BuiltinErrors[Ee];
        if (Se)
          de = this._abiCoder.decode(Se.inputs, fe.slice(4)), me = Se.name, we = Se.signature, Se.reason && (ue = de[0]), me === "Error" ? ce = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(de[0])}` : me === "Panic" && (ce = `; VM Exception while processing transaction: reverted with panic code ${de[0]}`);
        else
          try {
            const Be = this.getError(Ee);
            de = this._abiCoder.decode(Be.inputs, fe.slice(4)), me = Be.name, we = Be.format();
          } catch {
          }
        break;
      }
    }
    return logger$1.throwError("call revert exception" + ce, Logger.errors.CALL_EXCEPTION, {
      method: ie.format(),
      data: hexlify(se),
      errorArgs: de,
      errorName: me,
      errorSignature: we,
      reason: ue
    });
  }
  // Encode the result for a function call (e.g. for eth_call)
  encodeFunctionResult(ie, se) {
    return typeof ie == "string" && (ie = this.getFunction(ie)), hexlify(this._abiCoder.encode(ie.outputs, se || []));
  }
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(ie, se) {
    typeof ie == "string" && (ie = this.getEvent(ie)), se.length > ie.inputs.length && logger$1.throwError("too many arguments for " + ie.format(), Logger.errors.UNEXPECTED_ARGUMENT, {
      argument: "values",
      value: se
    });
    let fe = [];
    ie.anonymous || fe.push(this.getEventTopic(ie));
    const ue = (ce, de) => ce.type === "string" ? id(de) : ce.type === "bytes" ? keccak256$1(hexlify(de)) : (ce.type === "bool" && typeof de == "boolean" && (de = de ? "0x01" : "0x00"), ce.type.match(/^u?int/) && (de = BigNumber.from(de).toHexString()), ce.type === "address" && this._abiCoder.encode(["address"], [de]), hexZeroPad(hexlify(de), 32));
    for (se.forEach((ce, de) => {
      let me = ie.inputs[de];
      if (!me.indexed) {
        ce != null && logger$1.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + me.name, ce);
        return;
      }
      ce == null ? fe.push(null) : me.baseType === "array" || me.baseType === "tuple" ? logger$1.throwArgumentError("filtering with tuples or arrays not supported", "contract." + me.name, ce) : Array.isArray(ce) ? fe.push(ce.map((we) => ue(me, we))) : fe.push(ue(me, ce));
    }); fe.length && fe[fe.length - 1] === null; )
      fe.pop();
    return fe;
  }
  encodeEventLog(ie, se) {
    typeof ie == "string" && (ie = this.getEvent(ie));
    const fe = [], ue = [], ce = [];
    return ie.anonymous || fe.push(this.getEventTopic(ie)), se.length !== ie.inputs.length && logger$1.throwArgumentError("event arguments/values mismatch", "values", se), ie.inputs.forEach((de, me) => {
      const we = se[me];
      if (de.indexed)
        if (de.type === "string")
          fe.push(id(we));
        else if (de.type === "bytes")
          fe.push(keccak256$1(we));
        else {
          if (de.baseType === "tuple" || de.baseType === "array")
            throw new Error("not implemented");
          fe.push(this._abiCoder.encode([de.type], [we]));
        }
      else
        ue.push(de), ce.push(we);
    }), {
      data: this._abiCoder.encode(ue, ce),
      topics: fe
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(ie, se, fe) {
    if (typeof ie == "string" && (ie = this.getEvent(ie)), fe != null && !ie.anonymous) {
      let Ce = this.getEventTopic(ie);
      (!isHexString$1(fe[0], 32) || fe[0].toLowerCase() !== Ce) && logger$1.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: Ce, value: fe[0] }), fe = fe.slice(1);
    }
    let ue = [], ce = [], de = [];
    ie.inputs.forEach((Ce, Ie) => {
      Ce.indexed ? Ce.type === "string" || Ce.type === "bytes" || Ce.baseType === "tuple" || Ce.baseType === "array" ? (ue.push(ParamType.fromObject({ type: "bytes32", name: Ce.name })), de.push(!0)) : (ue.push(Ce), de.push(!1)) : (ce.push(Ce), de.push(!1));
    });
    let me = fe != null ? this._abiCoder.decode(ue, concat(fe)) : null, we = this._abiCoder.decode(ce, se, !0), Ee = [], Se = 0, Be = 0;
    ie.inputs.forEach((Ce, Ie) => {
      if (Ce.indexed)
        if (me == null)
          Ee[Ie] = new Indexed({ _isIndexed: !0, hash: null });
        else if (de[Ie])
          Ee[Ie] = new Indexed({ _isIndexed: !0, hash: me[Be++] });
        else
          try {
            Ee[Ie] = me[Be++];
          } catch (Pe) {
            Ee[Ie] = Pe;
          }
      else
        try {
          Ee[Ie] = we[Se++];
        } catch (Pe) {
          Ee[Ie] = Pe;
        }
      if (Ce.name && Ee[Ce.name] == null) {
        const Pe = Ee[Ie];
        Pe instanceof Error ? Object.defineProperty(Ee, Ce.name, {
          enumerable: !0,
          get: () => {
            throw wrapAccessError(`property ${JSON.stringify(Ce.name)}`, Pe);
          }
        }) : Ee[Ce.name] = Pe;
      }
    });
    for (let Ce = 0; Ce < Ee.length; Ce++) {
      const Ie = Ee[Ce];
      Ie instanceof Error && Object.defineProperty(Ee, Ce, {
        enumerable: !0,
        get: () => {
          throw wrapAccessError(`index ${Ce}`, Ie);
        }
      });
    }
    return Object.freeze(Ee);
  }
  // Given a transaction, find the matching function fragment (if any) and
  // determine all its properties and call parameters
  parseTransaction(ie) {
    let se = this.getFunction(ie.data.substring(0, 10).toLowerCase());
    return se ? new TransactionDescription({
      args: this._abiCoder.decode(se.inputs, "0x" + ie.data.substring(10)),
      functionFragment: se,
      name: se.name,
      signature: se.format(),
      sighash: this.getSighash(se),
      value: BigNumber.from(ie.value || "0")
    }) : null;
  }
  // @TODO
  //parseCallResult(data: BytesLike): ??
  // Given an event log, find the matching event fragment (if any) and
  // determine all its properties and values
  parseLog(ie) {
    let se = this.getEvent(ie.topics[0]);
    return !se || se.anonymous ? null : new LogDescription({
      eventFragment: se,
      name: se.name,
      signature: se.format(),
      topic: this.getEventTopic(se),
      args: this.decodeEventLog(se, ie.data, ie.topics)
    });
  }
  parseError(ie) {
    const se = hexlify(ie);
    let fe = this.getError(se.substring(0, 10).toLowerCase());
    return fe ? new ErrorDescription({
      args: this._abiCoder.decode(fe.inputs, "0x" + se.substring(10)),
      errorFragment: fe,
      name: fe.name,
      signature: fe.format(),
      sighash: this.getSighash(fe)
    }) : null;
  }
  /*
  static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
      if (Interface.isInterface(value)) {
          return value;
      }
      if (typeof(value) === "string") {
          return new Interface(JSON.parse(value));
      }
      return new Interface(value);
  }
  */
  static isInterface(ie) {
    return !!(ie && ie._isInterface);
  }
}
const version = "contracts/5.7.0";
var __awaiter$4 = function(ae, ie, se, fe) {
  function ue(ce) {
    return ce instanceof se ? ce : new se(function(de) {
      de(ce);
    });
  }
  return new (se || (se = Promise))(function(ce, de) {
    function me(Se) {
      try {
        Ee(fe.next(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function we(Se) {
      try {
        Ee(fe.throw(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function Ee(Se) {
      Se.done ? ce(Se.value) : ue(Se.value).then(me, we);
    }
    Ee((fe = fe.apply(ae, ie || [])).next());
  });
};
const logger = new Logger(version);
function resolveName(ae, ie) {
  return __awaiter$4(this, void 0, void 0, function* () {
    const se = yield ie;
    typeof se != "string" && logger.throwArgumentError("invalid address or ENS name", "name", se);
    try {
      return getAddress(se);
    } catch {
    }
    ae || logger.throwError("a provider or signer is needed to resolve ENS names", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "resolveName"
    });
    const fe = yield ae.resolveName(se);
    return fe == null && logger.throwArgumentError("resolver or addr is not configured for ENS name", "name", se), fe;
  });
}
function resolveAddresses(ae, ie, se) {
  return __awaiter$4(this, void 0, void 0, function* () {
    return Array.isArray(se) ? yield Promise.all(se.map((fe, ue) => resolveAddresses(ae, Array.isArray(ie) ? ie[ue] : ie[fe.name], fe))) : se.type === "address" ? yield resolveName(ae, ie) : se.type === "tuple" ? yield resolveAddresses(ae, ie, se.components) : se.baseType === "array" ? Array.isArray(ie) ? yield Promise.all(ie.map((fe) => resolveAddresses(ae, fe, se.arrayChildren))) : Promise.reject(logger.makeError("invalid value for array", Logger.errors.INVALID_ARGUMENT, {
      argument: "value",
      value: ie
    })) : ie;
  });
}
function populateTransaction(ae, ie, se) {
  return __awaiter$4(this, void 0, void 0, function* () {
    let fe = {};
    se.length === ie.inputs.length + 1 && typeof se[se.length - 1] == "object" && (fe = shallowCopy(se.pop())), logger.checkArgumentCount(se.length, ie.inputs.length, "passed to contract"), ae.signer ? fe.from ? fe.from = resolveProperties({
      override: resolveName(ae.signer, fe.from),
      signer: ae.signer.getAddress()
    }).then((Ee) => __awaiter$4(this, void 0, void 0, function* () {
      return getAddress(Ee.signer) !== Ee.override && logger.throwError("Contract with a Signer cannot override from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides.from"
      }), Ee.override;
    })) : fe.from = ae.signer.getAddress() : fe.from && (fe.from = resolveName(ae.provider, fe.from));
    const ue = yield resolveProperties({
      args: resolveAddresses(ae.signer || ae.provider, se, ie.inputs),
      address: ae.resolvedAddress,
      overrides: resolveProperties(fe) || {}
    }), ce = ae.interface.encodeFunctionData(ie, ue.args), de = {
      data: ce,
      to: ue.address
    }, me = ue.overrides;
    if (me.nonce != null && (de.nonce = BigNumber.from(me.nonce).toNumber()), me.gasLimit != null && (de.gasLimit = BigNumber.from(me.gasLimit)), me.gasPrice != null && (de.gasPrice = BigNumber.from(me.gasPrice)), me.maxFeePerGas != null && (de.maxFeePerGas = BigNumber.from(me.maxFeePerGas)), me.maxPriorityFeePerGas != null && (de.maxPriorityFeePerGas = BigNumber.from(me.maxPriorityFeePerGas)), me.from != null && (de.from = me.from), me.type != null && (de.type = me.type), me.accessList != null && (de.accessList = accessListify(me.accessList)), de.gasLimit == null && ie.gas != null) {
      let Ee = 21e3;
      const Se = arrayify(ce);
      for (let Be = 0; Be < Se.length; Be++)
        Ee += 4, Se[Be] && (Ee += 64);
      de.gasLimit = BigNumber.from(ie.gas).add(Ee);
    }
    if (me.value) {
      const Ee = BigNumber.from(me.value);
      !Ee.isZero() && !ie.payable && logger.throwError("non-payable method cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides.value",
        value: fe.value
      }), de.value = Ee;
    }
    me.customData && (de.customData = shallowCopy(me.customData)), me.ccipReadEnabled && (de.ccipReadEnabled = !!me.ccipReadEnabled), delete fe.nonce, delete fe.gasLimit, delete fe.gasPrice, delete fe.from, delete fe.value, delete fe.type, delete fe.accessList, delete fe.maxFeePerGas, delete fe.maxPriorityFeePerGas, delete fe.customData, delete fe.ccipReadEnabled;
    const we = Object.keys(fe).filter((Ee) => fe[Ee] != null);
    return we.length && logger.throwError(`cannot override ${we.map((Ee) => JSON.stringify(Ee)).join(",")}`, Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "overrides",
      overrides: we
    }), de;
  });
}
function buildPopulate(ae, ie) {
  return function(...se) {
    return populateTransaction(ae, ie, se);
  };
}
function buildEstimate(ae, ie) {
  const se = ae.signer || ae.provider;
  return function(...fe) {
    return __awaiter$4(this, void 0, void 0, function* () {
      se || logger.throwError("estimate require a provider or signer", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "estimateGas"
      });
      const ue = yield populateTransaction(ae, ie, fe);
      return yield se.estimateGas(ue);
    });
  };
}
function addContractWait(ae, ie) {
  const se = ie.wait.bind(ie);
  ie.wait = (fe) => se(fe).then((ue) => (ue.events = ue.logs.map((ce) => {
    let de = deepCopy(ce), me = null;
    try {
      me = ae.interface.parseLog(ce);
    } catch {
    }
    return me && (de.args = me.args, de.decode = (we, Ee) => ae.interface.decodeEventLog(me.eventFragment, we, Ee), de.event = me.name, de.eventSignature = me.signature), de.removeListener = () => ae.provider, de.getBlock = () => ae.provider.getBlock(ue.blockHash), de.getTransaction = () => ae.provider.getTransaction(ue.transactionHash), de.getTransactionReceipt = () => Promise.resolve(ue), de;
  }), ue));
}
function buildCall(ae, ie, se) {
  const fe = ae.signer || ae.provider;
  return function(...ue) {
    return __awaiter$4(this, void 0, void 0, function* () {
      let ce;
      if (ue.length === ie.inputs.length + 1 && typeof ue[ue.length - 1] == "object") {
        const we = shallowCopy(ue.pop());
        we.blockTag != null && (ce = yield we.blockTag), delete we.blockTag, ue.push(we);
      }
      ae.deployTransaction != null && (yield ae._deployed(ce));
      const de = yield populateTransaction(ae, ie, ue), me = yield fe.call(de, ce);
      try {
        let we = ae.interface.decodeFunctionResult(ie, me);
        return se && ie.outputs.length === 1 && (we = we[0]), we;
      } catch (we) {
        throw we.code === Logger.errors.CALL_EXCEPTION && (we.address = ae.address, we.args = ue, we.transaction = de), we;
      }
    });
  };
}
function buildSend(ae, ie) {
  return function(...se) {
    return __awaiter$4(this, void 0, void 0, function* () {
      ae.signer || logger.throwError("sending a transaction requires a signer", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "sendTransaction"
      }), ae.deployTransaction != null && (yield ae._deployed());
      const fe = yield populateTransaction(ae, ie, se), ue = yield ae.signer.sendTransaction(fe);
      return addContractWait(ae, ue), ue;
    });
  };
}
function buildDefault(ae, ie, se) {
  return ie.constant ? buildCall(ae, ie, se) : buildSend(ae, ie);
}
function getEventTag(ae) {
  return ae.address && (ae.topics == null || ae.topics.length === 0) ? "*" : (ae.address || "*") + "@" + (ae.topics ? ae.topics.map((ie) => Array.isArray(ie) ? ie.join("|") : ie).join(":") : "");
}
class RunningEvent {
  constructor(ie, se) {
    defineReadOnly(this, "tag", ie), defineReadOnly(this, "filter", se), this._listeners = [];
  }
  addListener(ie, se) {
    this._listeners.push({ listener: ie, once: se });
  }
  removeListener(ie) {
    let se = !1;
    this._listeners = this._listeners.filter((fe) => se || fe.listener !== ie ? !0 : (se = !0, !1));
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map((ie) => ie.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(ie) {
    const se = this.listenerCount();
    return this._listeners = this._listeners.filter((fe) => {
      const ue = ie.slice();
      return setTimeout(() => {
        fe.listener.apply(this, ue);
      }, 0), !fe.once;
    }), se;
  }
  prepareEvent(ie) {
  }
  // Returns the array that will be applied to an emit
  getEmit(ie) {
    return [ie];
  }
}
class ErrorRunningEvent extends RunningEvent {
  constructor() {
    super("error", null);
  }
}
class FragmentRunningEvent extends RunningEvent {
  constructor(ie, se, fe, ue) {
    const ce = {
      address: ie
    };
    let de = se.getEventTopic(fe);
    ue ? (de !== ue[0] && logger.throwArgumentError("topic mismatch", "topics", ue), ce.topics = ue.slice()) : ce.topics = [de], super(getEventTag(ce), ce), defineReadOnly(this, "address", ie), defineReadOnly(this, "interface", se), defineReadOnly(this, "fragment", fe);
  }
  prepareEvent(ie) {
    super.prepareEvent(ie), ie.event = this.fragment.name, ie.eventSignature = this.fragment.format(), ie.decode = (se, fe) => this.interface.decodeEventLog(this.fragment, se, fe);
    try {
      ie.args = this.interface.decodeEventLog(this.fragment, ie.data, ie.topics);
    } catch (se) {
      ie.args = null, ie.decodeError = se;
    }
  }
  getEmit(ie) {
    const se = checkResultErrors(ie.args);
    if (se.length)
      throw se[0].error;
    const fe = (ie.args || []).slice();
    return fe.push(ie), fe;
  }
}
class WildcardRunningEvent extends RunningEvent {
  constructor(ie, se) {
    super("*", { address: ie }), defineReadOnly(this, "address", ie), defineReadOnly(this, "interface", se);
  }
  prepareEvent(ie) {
    super.prepareEvent(ie);
    try {
      const se = this.interface.parseLog(ie);
      ie.event = se.name, ie.eventSignature = se.signature, ie.decode = (fe, ue) => this.interface.decodeEventLog(se.eventFragment, fe, ue), ie.args = se.args;
    } catch {
    }
  }
}
class BaseContract {
  constructor(ie, se, fe) {
    defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(se)), fe == null ? (defineReadOnly(this, "provider", null), defineReadOnly(this, "signer", null)) : Signer.isSigner(fe) ? (defineReadOnly(this, "provider", fe.provider || null), defineReadOnly(this, "signer", fe)) : Provider.isProvider(fe) ? (defineReadOnly(this, "provider", fe), defineReadOnly(this, "signer", null)) : logger.throwArgumentError("invalid signer or provider", "signerOrProvider", fe), defineReadOnly(this, "callStatic", {}), defineReadOnly(this, "estimateGas", {}), defineReadOnly(this, "functions", {}), defineReadOnly(this, "populateTransaction", {}), defineReadOnly(this, "filters", {});
    {
      const de = {};
      Object.keys(this.interface.events).forEach((me) => {
        const we = this.interface.events[me];
        defineReadOnly(this.filters, me, (...Ee) => ({
          address: this.address,
          topics: this.interface.encodeFilterTopics(we, Ee)
        })), de[we.name] || (de[we.name] = []), de[we.name].push(me);
      }), Object.keys(de).forEach((me) => {
        const we = de[me];
        we.length === 1 ? defineReadOnly(this.filters, me, this.filters[we[0]]) : logger.warn(`Duplicate definition of ${me} (${we.join(", ")})`);
      });
    }
    if (defineReadOnly(this, "_runningEvents", {}), defineReadOnly(this, "_wrappedEmits", {}), ie == null && logger.throwArgumentError("invalid contract address or ENS name", "addressOrName", ie), defineReadOnly(this, "address", ie), this.provider)
      defineReadOnly(this, "resolvedAddress", resolveName(this.provider, ie));
    else
      try {
        defineReadOnly(this, "resolvedAddress", Promise.resolve(getAddress(ie)));
      } catch {
        logger.throwError("provider is required to use ENS name as contract address", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new Contract"
        });
      }
    this.resolvedAddress.catch((de) => {
    });
    const ue = {}, ce = {};
    Object.keys(this.interface.functions).forEach((de) => {
      const me = this.interface.functions[de];
      if (ce[de]) {
        logger.warn(`Duplicate ABI entry for ${JSON.stringify(de)}`);
        return;
      }
      ce[de] = !0;
      {
        const we = me.name;
        ue[`%${we}`] || (ue[`%${we}`] = []), ue[`%${we}`].push(de);
      }
      this[de] == null && defineReadOnly(this, de, buildDefault(this, me, !0)), this.functions[de] == null && defineReadOnly(this.functions, de, buildDefault(this, me, !1)), this.callStatic[de] == null && defineReadOnly(this.callStatic, de, buildCall(this, me, !0)), this.populateTransaction[de] == null && defineReadOnly(this.populateTransaction, de, buildPopulate(this, me)), this.estimateGas[de] == null && defineReadOnly(this.estimateGas, de, buildEstimate(this, me));
    }), Object.keys(ue).forEach((de) => {
      const me = ue[de];
      if (me.length > 1)
        return;
      de = de.substring(1);
      const we = me[0];
      try {
        this[de] == null && defineReadOnly(this, de, this[we]);
      } catch {
      }
      this.functions[de] == null && defineReadOnly(this.functions, de, this.functions[we]), this.callStatic[de] == null && defineReadOnly(this.callStatic, de, this.callStatic[we]), this.populateTransaction[de] == null && defineReadOnly(this.populateTransaction, de, this.populateTransaction[we]), this.estimateGas[de] == null && defineReadOnly(this.estimateGas, de, this.estimateGas[we]);
    });
  }
  static getContractAddress(ie) {
    return getContractAddress(ie);
  }
  static getInterface(ie) {
    return Interface.isInterface(ie) ? ie : new Interface(ie);
  }
  // @TODO: Allow timeout?
  deployed() {
    return this._deployed();
  }
  _deployed(ie) {
    return this._deployedPromise || (this.deployTransaction ? this._deployedPromise = this.deployTransaction.wait().then(() => this) : this._deployedPromise = this.provider.getCode(this.address, ie).then((se) => (se === "0x" && logger.throwError("contract not deployed", Logger.errors.UNSUPPORTED_OPERATION, {
      contractAddress: this.address,
      operation: "getDeployed"
    }), this))), this._deployedPromise;
  }
  // @TODO:
  // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
  // @TODO:
  // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>
  fallback(ie) {
    this.signer || logger.throwError("sending a transactions require a signer", Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
    const se = shallowCopy(ie || {});
    return ["from", "to"].forEach(function(fe) {
      se[fe] != null && logger.throwError("cannot override " + fe, Logger.errors.UNSUPPORTED_OPERATION, { operation: fe });
    }), se.to = this.resolvedAddress, this.deployed().then(() => this.signer.sendTransaction(se));
  }
  // Reconnect to a different signer or provider
  connect(ie) {
    typeof ie == "string" && (ie = new VoidSigner(ie, this.provider));
    const se = new this.constructor(this.address, this.interface, ie);
    return this.deployTransaction && defineReadOnly(se, "deployTransaction", this.deployTransaction), se;
  }
  // Re-attach to a different on-chain instance of this contract
  attach(ie) {
    return new this.constructor(ie, this.interface, this.signer || this.provider);
  }
  static isIndexed(ie) {
    return Indexed.isIndexed(ie);
  }
  _normalizeRunningEvent(ie) {
    return this._runningEvents[ie.tag] ? this._runningEvents[ie.tag] : ie;
  }
  _getRunningEvent(ie) {
    if (typeof ie == "string") {
      if (ie === "error")
        return this._normalizeRunningEvent(new ErrorRunningEvent());
      if (ie === "event")
        return this._normalizeRunningEvent(new RunningEvent("event", null));
      if (ie === "*")
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
      const se = this.interface.getEvent(ie);
      return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, se));
    }
    if (ie.topics && ie.topics.length > 0) {
      try {
        const fe = ie.topics[0];
        if (typeof fe != "string")
          throw new Error("invalid topic");
        const ue = this.interface.getEvent(fe);
        return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, ue, ie.topics));
      } catch {
      }
      const se = {
        address: this.address,
        topics: ie.topics
      };
      return this._normalizeRunningEvent(new RunningEvent(getEventTag(se), se));
    }
    return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
  }
  _checkRunningEvents(ie) {
    if (ie.listenerCount() === 0) {
      delete this._runningEvents[ie.tag];
      const se = this._wrappedEmits[ie.tag];
      se && ie.filter && (this.provider.off(ie.filter, se), delete this._wrappedEmits[ie.tag]);
    }
  }
  // Subclasses can override this to gracefully recover
  // from parse errors if they wish
  _wrapEvent(ie, se, fe) {
    const ue = deepCopy(se);
    return ue.removeListener = () => {
      fe && (ie.removeListener(fe), this._checkRunningEvents(ie));
    }, ue.getBlock = () => this.provider.getBlock(se.blockHash), ue.getTransaction = () => this.provider.getTransaction(se.transactionHash), ue.getTransactionReceipt = () => this.provider.getTransactionReceipt(se.transactionHash), ie.prepareEvent(ue), ue;
  }
  _addEventListener(ie, se, fe) {
    if (this.provider || logger.throwError("events require a provider or a signer with a provider", Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" }), ie.addListener(se, fe), this._runningEvents[ie.tag] = ie, !this._wrappedEmits[ie.tag]) {
      const ue = (ce) => {
        let de = this._wrapEvent(ie, ce, se);
        if (de.decodeError == null)
          try {
            const me = ie.getEmit(de);
            this.emit(ie.filter, ...me);
          } catch (me) {
            de.decodeError = me.error;
          }
        ie.filter != null && this.emit("event", de), de.decodeError != null && this.emit("error", de.decodeError, de);
      };
      this._wrappedEmits[ie.tag] = ue, ie.filter != null && this.provider.on(ie.filter, ue);
    }
  }
  queryFilter(ie, se, fe) {
    const ue = this._getRunningEvent(ie), ce = shallowCopy(ue.filter);
    return typeof se == "string" && isHexString$1(se, 32) ? (fe != null && logger.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", fe), ce.blockHash = se) : (ce.fromBlock = se ?? 0, ce.toBlock = fe ?? "latest"), this.provider.getLogs(ce).then((de) => de.map((me) => this._wrapEvent(ue, me, null)));
  }
  on(ie, se) {
    return this._addEventListener(this._getRunningEvent(ie), se, !1), this;
  }
  once(ie, se) {
    return this._addEventListener(this._getRunningEvent(ie), se, !0), this;
  }
  emit(ie, ...se) {
    if (!this.provider)
      return !1;
    const fe = this._getRunningEvent(ie), ue = fe.run(se) > 0;
    return this._checkRunningEvents(fe), ue;
  }
  listenerCount(ie) {
    return this.provider ? ie == null ? Object.keys(this._runningEvents).reduce((se, fe) => se + this._runningEvents[fe].listenerCount(), 0) : this._getRunningEvent(ie).listenerCount() : 0;
  }
  listeners(ie) {
    if (!this.provider)
      return [];
    if (ie == null) {
      const se = [];
      for (let fe in this._runningEvents)
        this._runningEvents[fe].listeners().forEach((ue) => {
          se.push(ue);
        });
      return se;
    }
    return this._getRunningEvent(ie).listeners();
  }
  removeAllListeners(ie) {
    if (!this.provider)
      return this;
    if (ie == null) {
      for (const fe in this._runningEvents) {
        const ue = this._runningEvents[fe];
        ue.removeAllListeners(), this._checkRunningEvents(ue);
      }
      return this;
    }
    const se = this._getRunningEvent(ie);
    return se.removeAllListeners(), this._checkRunningEvents(se), this;
  }
  off(ie, se) {
    if (!this.provider)
      return this;
    const fe = this._getRunningEvent(ie);
    return fe.removeListener(se), this._checkRunningEvents(fe), this;
  }
  removeListener(ie, se) {
    return this.off(ie, se);
  }
}
class Contract extends BaseContract {
}
class ERC20Config extends EthereumConfig {
  contractInstance;
  contractAddress;
  constructor(ie) {
    super(ie), this.contractAddress = ie.contractAddress;
  }
  async getContract() {
    return this.contractInstance || (this.contractInstance = new Contract(this.contractAddress, erc20abi, this.w3signer), this.base = ["wei", Math.pow(10, await this.contractInstance.decimals())]), this.contractInstance;
  }
  async getTx(ie) {
    const se = await this.providerInstance.getTransaction(ie);
    if (!se)
      throw new Error("Tx doesn't exist");
    if (se.data.length !== 138 || se.data.slice(2, 10) !== "a9059cbb")
      throw new Error("Tx isn't a ERC20 transfer");
    const fe = `0x${se.data.slice(34, 74)}`, ue = new BigNumber$1(se.data.slice(74), 16);
    return {
      from: se.from,
      to: fe,
      blockHeight: se.blockNumber ? new BigNumber$1(se.blockNumber) : void 0,
      amount: ue,
      pending: !se.blockNumber,
      confirmed: se.confirmations >= this.minConfirm
    };
  }
  async getFee(ie, se) {
    const fe = "0x" + new BigNumber$1(ie).toString(16), ue = await this.getContract(), ce = await this.providerInstance.getGasPrice(), de = await ue.estimateGas.transfer(se, fe);
    return new BigNumber$1(ce.mul(de).toString());
  }
  async createTx(ie, se, fe) {
    const ue = await this.getContract(), ce = "0x" + new BigNumber$1(ie).toString(16), de = await ue.populateTransaction.transfer(se, ce);
    if (de.gasPrice = await this.providerInstance.getGasPrice(), de.gasLimit = await ue.estimateGas.transfer(se, ce), de.chainId = (await this.providerInstance.getNetwork()).chainId, !this.address)
      throw new Error("Address is undefined - you might be missing a wallet, or have not run Irys.ready()");
    return de.nonce = await this.providerInstance.getTransactionCount(this.address), { txId: void 0, tx: de };
  }
}
var t$9 = 255, n$c = 65535, U$8 = 4294967295, _$4 = 18446744073709551615n, o$d = 340282366920938463463374607431768211455n, i$8 = 115792089237316195423570985008687907853269984665640564039457584007913129639935n, s$5 = class extends Error {
  constructor(ie, se) {
    super(ie), this.invalidReason = se;
  }
}, l$8 = ((ae) => (ae.TOO_SHORT = "too_short", ae.INVALID_LENGTH = "invalid_length", ae.INVALID_HEX_CHARS = "invalid_hex_chars", ae))(l$8 || {}), i$7 = class Cn {
  constructor(ie) {
    this.data = ie;
  }
  toUint8Array() {
    return this.data;
  }
  toStringWithoutPrefix() {
    return bytesToHex$1(this.data);
  }
  toString() {
    return `0x${this.toStringWithoutPrefix()}`;
  }
  static fromString(ie) {
    let se = ie;
    if (se.startsWith("0x") && (se = se.slice(2)), se.length === 0)
      throw new s$5("Hex string is too short, must be at least 1 char long, excluding the optional leading 0x.", "too_short");
    if (se.length % 2 !== 0)
      throw new s$5("Hex string must be an even number of hex characters.", "invalid_length");
    try {
      return new Cn(hexToBytes$1(se));
    } catch (fe) {
      throw new s$5(`Hex string contains invalid hex characters: ${fe?.message}`, "invalid_hex_chars");
    }
  }
  static fromHexInput(ie) {
    return ie instanceof Uint8Array ? new Cn(ie) : Cn.fromString(ie);
  }
  static isValid(ie) {
    try {
      return Cn.fromString(ie), { valid: !0 };
    } catch (se) {
      return { valid: !1, invalidReason: se?.invalidReason, invalidReasonMessage: se?.message };
    }
  }
  equals(ie) {
    return this.data.length !== ie.data.length ? !1 : this.data.every((se, fe) => se === ie.data[fe]);
  }
}, h$c = Object.defineProperty, i$6 = Object.getOwnPropertyDescriptor, j$1 = (ae, ie, se, fe) => {
  for (var ue = fe > 1 ? void 0 : fe ? i$6(ie, se) : ie, ce = ae.length - 1, de; ce >= 0; ce--)
    (de = ae[ce]) && (ue = (fe ? de(ie, se, ue) : de(ue)) || ue);
  return fe && ue && h$c(ie, se, ue), ue;
}, B$4 = class {
  bcsToBytes() {
    let ie = new n$b();
    return this.serialize(ie), ie.toUint8Array();
  }
  bcsToHex() {
    let ie = this.bcsToBytes();
    return i$7.fromHexInput(ie);
  }
}, n$b = class {
  constructor(ie = 64) {
    if (ie <= 0)
      throw new Error("Length needs to be greater than 0");
    this.buffer = new ArrayBuffer(ie), this.offset = 0;
  }
  ensureBufferWillHandleSize(ie) {
    for (; this.buffer.byteLength < this.offset + ie; ) {
      let se = new ArrayBuffer(this.buffer.byteLength * 2);
      new Uint8Array(se).set(new Uint8Array(this.buffer)), this.buffer = se;
    }
  }
  appendToBuffer(ie) {
    this.ensureBufferWillHandleSize(ie.length), new Uint8Array(this.buffer, this.offset).set(ie), this.offset += ie.length;
  }
  serializeWithFunction(ie, se, fe) {
    this.ensureBufferWillHandleSize(se);
    let ue = new DataView(this.buffer, this.offset);
    ie.apply(ue, [0, fe, !0]), this.offset += se;
  }
  serializeStr(ie) {
    let se = new TextEncoder();
    this.serializeBytes(se.encode(ie));
  }
  serializeBytes(ie) {
    this.serializeU32AsUleb128(ie.length), this.appendToBuffer(ie);
  }
  serializeFixedBytes(ie) {
    this.appendToBuffer(ie);
  }
  serializeBool(ie) {
    A$a(ie);
    let se = ie ? 1 : 0;
    this.appendToBuffer(new Uint8Array([se]));
  }
  serializeU8(ie) {
    this.appendToBuffer(new Uint8Array([ie]));
  }
  serializeU16(ie) {
    this.serializeWithFunction(DataView.prototype.setUint16, 2, ie);
  }
  serializeU32(ie) {
    this.serializeWithFunction(DataView.prototype.setUint32, 4, ie);
  }
  serializeU64(ie) {
    let se = BigInt(ie) & BigInt(U$8), fe = BigInt(ie) >> BigInt(32);
    this.serializeU32(Number(se)), this.serializeU32(Number(fe));
  }
  serializeU128(ie) {
    let se = BigInt(ie) & _$4, fe = BigInt(ie) >> BigInt(64);
    this.serializeU64(se), this.serializeU64(fe);
  }
  serializeU256(ie) {
    let se = BigInt(ie) & o$d, fe = BigInt(ie) >> BigInt(128);
    this.serializeU128(se), this.serializeU128(fe);
  }
  serializeU32AsUleb128(ie) {
    let se = ie, fe = [];
    for (; se >>> 7; )
      fe.push(se & 127 | 128), se >>>= 7;
    fe.push(se), this.appendToBuffer(new Uint8Array(fe));
  }
  toUint8Array() {
    return new Uint8Array(this.buffer).slice(0, this.offset);
  }
  serialize(ie) {
    ie.serialize(this);
  }
  serializeVector(ie) {
    this.serializeU32AsUleb128(ie.length), ie.forEach((se) => {
      se.serialize(this);
    });
  }
};
j$1([o$c(0, t$9)], n$b.prototype, "serializeU8", 1), j$1([o$c(0, n$c)], n$b.prototype, "serializeU16", 1), j$1([o$c(0, U$8)], n$b.prototype, "serializeU32", 1), j$1([o$c(BigInt(0), _$4)], n$b.prototype, "serializeU64", 1), j$1([o$c(BigInt(0), o$d)], n$b.prototype, "serializeU128", 1), j$1([o$c(BigInt(0), i$8)], n$b.prototype, "serializeU256", 1), j$1([o$c(0, U$8)], n$b.prototype, "serializeU32AsUleb128", 1);
function A$a(ae) {
  if (typeof ae != "boolean")
    throw new Error(`${ae} is not a boolean value`);
}
var g$7 = (ae, ie, se) => `${ae} is out of range: [${ie}, ${se}]`;
function w$3(ae, ie, se) {
  let fe = BigInt(ae);
  if (fe > BigInt(se) || fe < BigInt(ie))
    throw new Error(g$7(ae, ie, se));
}
function o$c(ae, ie) {
  return (se, fe, ue) => {
    let ce = ue.value;
    return ue.value = function(de) {
      return w$3(de, ae, ie), ce.apply(this, [de]);
    }, ue;
  };
}
var h$b = ((ae) => (ae.INCORRECT_NUMBER_OF_BYTES = "incorrect_number_of_bytes", ae.INVALID_HEX_CHARS = "invalid_hex_chars", ae.TOO_SHORT = "too_short", ae.TOO_LONG = "too_long", ae.LEADING_ZERO_X_REQUIRED = "leading_zero_x_required", ae.LONG_FORM_REQUIRED_UNLESS_SPECIAL = "long_form_required_unless_special", ae.INVALID_PADDING_ZEROES = "INVALID_PADDING_ZEROES", ae))(h$b || {}), r$9 = class _n extends B$4 {
  constructor(ie) {
    if (super(), ie.length !== _n.LENGTH)
      throw new s$5("AccountAddress data should be exactly 32 bytes long", "incorrect_number_of_bytes");
    this.data = ie;
  }
  isSpecial() {
    return this.data.slice(0, this.data.length - 1).every((ie) => ie === 0) && this.data[this.data.length - 1] < 16;
  }
  toString() {
    return `0x${this.toStringWithoutPrefix()}`;
  }
  toStringWithoutPrefix() {
    let ie = bytesToHex$1(this.data);
    return this.isSpecial() && (ie = ie[ie.length - 1]), ie;
  }
  toStringLong() {
    return `0x${this.toStringLongWithoutPrefix()}`;
  }
  toStringLongWithoutPrefix() {
    return bytesToHex$1(this.data);
  }
  toUint8Array() {
    return this.data;
  }
  serialize(ie) {
    ie.serializeFixedBytes(this.data);
  }
  serializeForEntryFunction(ie) {
    let se = this.bcsToBytes();
    ie.serializeBytes(se);
  }
  serializeForScriptFunction(ie) {
    ie.serializeU32AsUleb128(3), ie.serialize(this);
  }
  static deserialize(ie) {
    let se = ie.deserializeFixedBytes(_n.LENGTH);
    return new _n(se);
  }
  static fromStringStrict(ie) {
    if (!ie.startsWith("0x"))
      throw new s$5("Hex string must start with a leading 0x.", "leading_zero_x_required");
    let se = _n.fromString(ie);
    if (ie.length !== _n.LONG_STRING_LENGTH + 2)
      if (se.isSpecial()) {
        if (ie.length !== 3)
          throw new s$5(`The given hex string ${ie} is a special address not in LONG form, it must be 0x0 to 0xf without padding zeroes.`, "INVALID_PADDING_ZEROES");
      } else
        throw new s$5(`The given hex string ${ie} is not a special address, it must be represented as 0x + 64 chars.`, "long_form_required_unless_special");
    return se;
  }
  static fromString(ie) {
    let se = ie;
    if (ie.startsWith("0x") && (se = ie.slice(2)), se.length === 0)
      throw new s$5("Hex string is too short, must be 1 to 64 chars long, excluding the leading 0x.", "too_short");
    if (se.length > 64)
      throw new s$5("Hex string is too long, must be 1 to 64 chars long, excluding the leading 0x.", "too_long");
    let fe;
    try {
      fe = hexToBytes$1(se.padStart(64, "0"));
    } catch (ue) {
      throw new s$5(`Hex characters are invalid: ${ue?.message}`, "invalid_hex_chars");
    }
    return new _n(fe);
  }
  static from(ie) {
    return ie instanceof _n ? ie : ie instanceof Uint8Array ? new _n(ie) : _n.fromString(ie);
  }
  static fromStrict(ie) {
    return ie instanceof _n ? ie : ie instanceof Uint8Array ? new _n(ie) : _n.fromStringStrict(ie);
  }
  static isValid(ie) {
    try {
      return ie.strict ? _n.fromStrict(ie.input) : _n.from(ie.input), { valid: !0 };
    } catch (se) {
      return { valid: !1, invalidReason: se?.invalidReason, invalidReasonMessage: se?.message };
    }
  }
  equals(ie) {
    return this.data.length !== ie.data.length ? !1 : this.data.every((se, fe) => se === ie.data[fe]);
  }
};
r$9.LENGTH = 32, r$9.LONG_STRING_LENGTH = 64, r$9.ZERO = r$9.from("0x0"), r$9.ONE = r$9.from("0x1"), r$9.TWO = r$9.from("0x2"), r$9.THREE = r$9.from("0x3"), r$9.FOUR = r$9.from("0x4");
var c$b = r$9, i$5 = `
    fragment TokenActivitiesFields on token_activities_v2 {
  after_value
  before_value
  entry_function_id_str
  event_account_address
  event_index
  from_address
  is_fungible_v2
  property_version_v1
  to_address
  token_amount
  token_data_id
  token_standard
  transaction_timestamp
  transaction_version
  type
}
    `, a$b = `
    fragment AnsTokenFragment on current_aptos_names {
  domain
  expiration_timestamp
  registered_address
  subdomain
  token_standard
  is_primary
  owner_address
}
    `, s$4 = `
    fragment CurrentTokenOwnershipFields on current_token_ownerships_v2 {
  token_standard
  token_properties_mutated_v1
  token_data_id
  table_type_v1
  storage_id
  property_version_v1
  owner_address
  last_transaction_version
  last_transaction_timestamp
  is_soulbound_v2
  is_fungible_v2
  amount
  current_token_data {
    collection_id
    description
    is_fungible_v2
    largest_property_version_v1
    last_transaction_timestamp
    last_transaction_version
    maximum
    supply
    token_data_id
    token_name
    token_properties
    token_standard
    token_uri
    decimals
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      max_supply
      mutable_description
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
  }
}
    `, _$3 = `
    query getAccountCoinsCount($address: String) {
  current_fungible_asset_balances_aggregate(
    where: {owner_address: {_eq: $address}}
  ) {
    aggregate {
      count
    }
  }
}
    `, u$8 = `
    query getAccountCoinsData($where_condition: current_fungible_asset_balances_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_fungible_asset_balances_order_by!]) {
  current_fungible_asset_balances(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    amount
    asset_type
    is_frozen
    is_primary
    last_transaction_timestamp
    last_transaction_version
    owner_address
    storage_id
    token_standard
    metadata {
      token_standard
      symbol
      supply_aggregator_table_key_v1
      supply_aggregator_table_handle_v1
      project_uri
      name
      last_transaction_version
      last_transaction_timestamp
      icon_uri
      decimals
      creator_address
      asset_type
    }
  }
}
    `, c$a = `
    query getAccountCollectionsWithOwnedTokens($where_condition: current_collection_ownership_v2_view_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_collection_ownership_v2_view_order_by!]) {
  current_collection_ownership_v2_view(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      mutable_description
      max_supply
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
    collection_id
    collection_name
    collection_uri
    creator_address
    distinct_tokens
    last_transaction_version
    owner_address
    single_token_uri
  }
}
    `, d$7 = `
    query getAccountOwnedObjects($where_condition: current_objects_bool_exp, $offset: Int, $limit: Int, $order_by: [current_objects_order_by!]) {
  current_objects(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    allow_ungated_transfer
    state_key_hash
    owner_address
    object_address
    last_transaction_version
    last_guid_creation_num
    is_deleted
  }
}
    `, l$7 = `
    query getAccountOwnedTokens($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${s$4}`, p$8 = `
    query getAccountOwnedTokensFromCollection($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${s$4}`, m$b = `
    query getAccountTokensCount($where_condition: current_token_ownerships_v2_bool_exp, $offset: Int, $limit: Int) {
  current_token_ownerships_v2_aggregate(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    aggregate {
      count
    }
  }
}
    `, g$6 = `
    query getAccountTransactionsCount($address: String) {
  account_transactions_aggregate(where: {account_address: {_eq: $address}}) {
    aggregate {
      count
    }
  }
}
    `, b$8 = `
    query getChainTopUserTransactions($limit: Int) {
  user_transactions(limit: $limit, order_by: {version: desc}) {
    version
  }
}
    `, T$7 = `
    query getCollectionData($where_condition: current_collections_v2_bool_exp!) {
  current_collections_v2(where: $where_condition) {
    collection_id
    collection_name
    creator_address
    current_supply
    description
    last_transaction_timestamp
    last_transaction_version
    max_supply
    mutable_description
    mutable_uri
    table_handle_v1
    token_standard
    total_minted_v2
    uri
  }
}
    `, k = `
    query getCurrentFungibleAssetBalances($where_condition: current_fungible_asset_balances_bool_exp, $offset: Int, $limit: Int) {
  current_fungible_asset_balances(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    amount
    asset_type
    is_frozen
    is_primary
    last_transaction_timestamp
    last_transaction_version
    owner_address
    storage_id
    token_standard
  }
}
    `, $$4 = `
    query getDelegatedStakingActivities($delegatorAddress: String, $poolAddress: String) {
  delegated_staking_activities(
    where: {delegator_address: {_eq: $delegatorAddress}, pool_address: {_eq: $poolAddress}}
  ) {
    amount
    delegator_address
    event_index
    event_type
    pool_address
    transaction_version
  }
}
    `, f$b = `
    query getEvents($where_condition: events_bool_exp, $offset: Int, $limit: Int, $order_by: [events_order_by!]) {
  events(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    account_address
    creation_number
    data
    event_index
    sequence_number
    transaction_block_height
    transaction_version
    type
    indexed_type
  }
}
    `, v$5 = `
    query getFungibleAssetActivities($where_condition: fungible_asset_activities_bool_exp, $offset: Int, $limit: Int) {
  fungible_asset_activities(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    amount
    asset_type
    block_height
    entry_function_id_str
    event_index
    gas_fee_payer_address
    is_frozen
    is_gas_fee
    is_transaction_success
    owner_address
    storage_id
    storage_refund_amount
    token_standard
    transaction_timestamp
    transaction_version
    type
  }
}
    `, h$a = `
    query getFungibleAssetMetadata($where_condition: fungible_asset_metadata_bool_exp, $offset: Int, $limit: Int) {
  fungible_asset_metadata(where: $where_condition, offset: $offset, limit: $limit) {
    icon_uri
    project_uri
    supply_aggregator_table_handle_v1
    supply_aggregator_table_key_v1
    creator_address
    asset_type
    decimals
    last_transaction_timestamp
    last_transaction_version
    name
    symbol
    token_standard
  }
}
    `, A$9 = `
    query getNames($offset: Int, $limit: Int, $where_condition: current_aptos_names_bool_exp, $order_by: [current_aptos_names_order_by!]) {
  current_aptos_names(
    limit: $limit
    where: $where_condition
    order_by: $order_by
    offset: $offset
  ) {
    ...AnsTokenFragment
  }
}
    ${a$b}`, w$2 = `
    query getNumberOfDelegators($where_condition: num_active_delegator_per_pool_bool_exp, $order_by: [num_active_delegator_per_pool_order_by!]) {
  num_active_delegator_per_pool(where: $where_condition, order_by: $order_by) {
    num_active_delegator
    pool_address
  }
}
    `, G$6 = `
    query getProcessorStatus($where_condition: processor_status_bool_exp) {
  processor_status(where: $where_condition) {
    last_success_version
    processor
    last_updated
  }
}
    `, C$3 = `
    query getTokenActivity($where_condition: token_activities_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [token_activities_v2_order_by!]) {
  token_activities_v2(
    where: $where_condition
    order_by: $order_by
    offset: $offset
    limit: $limit
  ) {
    ...TokenActivitiesFields
  }
}
    ${i$5}`, q$2 = `
    query getCurrentTokenOwnership($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${s$4}`, Q$2 = `
    query getTokenData($where_condition: current_token_datas_v2_bool_exp, $offset: Int, $limit: Int, $order_by: [current_token_datas_v2_order_by!]) {
  current_token_datas_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    collection_id
    description
    is_fungible_v2
    largest_property_version_v1
    last_transaction_timestamp
    last_transaction_version
    maximum
    supply
    token_data_id
    token_name
    token_properties
    token_standard
    token_uri
    decimals
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      max_supply
      mutable_description
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
  }
}
    `, s$3 = class extends Error {
  constructor(ie, se, fe) {
    super(fe), this.name = "AptosApiError", this.url = se.url, this.status = se.status, this.statusText = se.statusText, this.data = se.data, this.request = ie;
  }
}, o$b = "1.9.1", l$6 = { 400: "Bad Request", 401: "Unauthorized", 403: "Forbidden", 404: "Not Found", 429: "Too Many Requests", 500: "Internal Server Error", 502: "Bad Gateway", 503: "Service Unavailable" };
async function c$9(ae, ie) {
  let { url: se, method: fe, body: ue, contentType: ce, params: de, overrides: me } = ae, we = { ...me?.HEADERS, "x-aptos-client": `aptos-typescript-sdk/${o$b}`, "content-type": ce ?? "application/json" };
  return me?.AUTH_TOKEN && se.includes("faucet") && (we.Authorization = `Bearer ${me?.AUTH_TOKEN}`), me?.API_KEY && !se.includes("faucet") && (we.Authorization = `Bearer ${me?.API_KEY}`), ie.provider({ url: se, method: fe, body: ue, params: de, headers: we, overrides: me });
}
async function T$6(ae, ie) {
  let { url: se, path: fe } = ae, ue = fe ? `${se}/${fe}` : se, ce = await c$9({ ...ae, url: ue }, ie.client), de = { status: ce.status, statusText: ce.statusText, data: ce.data, headers: ce.headers, config: ce.config, request: ce.request, url: ue };
  if (ie.isIndexerRequest(se)) {
    let we = de.data;
    if (we.errors)
      throw new s$3(ae, de, `Indexer error: ${we.errors[0].message}` ?? `Indexer unhandled Error ${ce.status} : ${ce.statusText}`);
    de.data = we.data;
  }
  if (de.status >= 200 && de.status < 300)
    return de;
  let me;
  throw de && de.data && "message" in de.data && "error_code" in de.data ? me = JSON.stringify(de.data) : de.status in l$6 ? me = l$6[de.status] : me = `Unhandled Error ${de.status} : ${de.statusText}`, new s$3(ae, de, `${ie.isFullnodeRequest(se) ? "Fullnode" : "Faucet"} error: ${me}`);
}
async function p$7(ae) {
  let { aptosConfig: ie, overrides: se, params: fe, contentType: ue, acceptType: ce, path: de, originMethod: me, type: we } = ae, Ee = ie.getRequestUrl(we);
  return T$6({ url: Ee, method: "GET", originMethod: me, path: de, contentType: ue?.valueOf(), acceptType: ce?.valueOf(), params: fe, overrides: { ...ie.clientConfig, ...se } }, ie);
}
async function g$5(ae) {
  return p$7({ ...ae, type: 0 });
}
async function f$a(ae) {
  let ie = [], se, fe = ae.params;
  do {
    let ue = await p$7({ type: 0, aptosConfig: ae.aptosConfig, originMethod: ae.originMethod, path: ae.path, params: fe, overrides: ae.overrides });
    se = ue.headers["x-aptos-cursor"], delete ue.headers, ie.push(...ue.data), fe.start = se;
  } while (se != null);
  return ie;
}
async function s$2(ae) {
  let { type: ie, originMethod: se, path: fe, body: ue, acceptType: ce, contentType: de, params: me, aptosConfig: we, overrides: Ee } = ae, Se = we.getRequestUrl(ie);
  return T$6({ url: Se, method: "POST", originMethod: se, path: fe, body: ue, contentType: de?.valueOf(), acceptType: ce?.valueOf(), params: me, overrides: { ...we.clientConfig, ...Ee } }, we);
}
async function A$8(ae) {
  return s$2({ ...ae, type: 0 });
}
async function f$9(ae) {
  return s$2({ ...ae, type: 1 });
}
async function x$7(ae) {
  return s$2({ ...ae, type: 2 });
}
async function l$5(ae) {
  let { aptosConfig: ie } = ae, { data: se } = await g$5({ aptosConfig: ie, originMethod: "getLedgerInfo", path: "" });
  return se;
}
async function h$9(ae) {
  let { aptosConfig: ie, ledgerVersion: se, options: fe } = ae, { data: ue } = await g$5({ aptosConfig: ie, originMethod: "getBlockByVersion", path: `blocks/by_version/${se}`, params: { with_transactions: fe?.withTransactions } });
  return ue;
}
async function m$a(ae) {
  let { aptosConfig: ie, blockHeight: se, options: fe } = ae, { data: ue } = await g$5({ aptosConfig: ie, originMethod: "getBlockByHeight", path: `blocks/by_height/${se}`, params: { with_transactions: fe?.withTransactions } });
  return ue;
}
async function C$2(ae) {
  let { aptosConfig: ie, handle: se, data: fe, options: ue } = ae;
  return (await A$8({ aptosConfig: ie, originMethod: "getTableItem", path: `tables/${se}/item`, params: { ledger_version: ue?.ledgerVersion }, body: fe })).data;
}
async function T$5(ae) {
  let { aptosConfig: ie, payload: se, options: fe } = ae, { data: ue } = await A$8({ aptosConfig: ie, originMethod: "view", path: "view", params: { ledger_version: fe?.ledgerVersion }, body: { function: se.function, type_arguments: se.typeArguments ?? [], arguments: se.functionArguments ?? [] } });
  return ue;
}
async function q$1(ae) {
  let { aptosConfig: ie, limit: se } = ae;
  return (await p$6({ aptosConfig: ie, query: { query: b$8, variables: { limit: se } }, originMethod: "getChainTopUserTransactions" })).user_transactions;
}
async function p$6(ae) {
  let { aptosConfig: ie, query: se, originMethod: fe } = ae, { data: ue } = await f$9({ aptosConfig: ie, originMethod: fe ?? "queryIndexer", path: "", body: se, overrides: { WITH_CREDENTIALS: !1 } });
  return ue;
}
async function f$8(ae) {
  let { aptosConfig: ie } = ae;
  return (await p$6({ aptosConfig: ie, query: { query: G$6 }, originMethod: "getProcessorStatuses" })).processor_status;
}
async function w$1(ae) {
  let ie = await f$8({ aptosConfig: ae.aptosConfig });
  return BigInt(ie[0].last_success_version);
}
async function A$7(ae) {
  let { aptosConfig: ie, processorType: se } = ae, fe = { processor: { _eq: se.valueOf() } };
  return (await p$6({ aptosConfig: ie, query: { query: G$6, variables: { where_condition: fe } }, originMethod: "getProcessorStatus" })).processor_status[0];
}
var g$4 = 300, y$b = (ae) => {
  if (ae && ae.length > g$4)
    throw new Error(`Event type length exceeds the maximum length of ${g$4}`);
};
async function f$7(ae) {
  let { aptosConfig: ie, eventType: se, options: fe } = ae, ue = { where: { account_address: { _eq: "0x0000000000000000000000000000000000000000000000000000000000000000" }, creation_number: { _eq: "0" }, sequence_number: { _eq: "0" }, indexed_type: { _eq: se } }, pagination: fe, orderBy: fe?.orderBy };
  return c$8({ aptosConfig: ie, options: ue });
}
async function h$8(ae) {
  let { accountAddress: ie, aptosConfig: se, creationNumber: fe, options: ue } = ae, ce = { where: { account_address: { _eq: c$b.from(ie).toStringLong() }, creation_number: { _eq: fe } }, pagination: ue, orderBy: ue?.orderBy };
  return c$8({ aptosConfig: se, options: ce });
}
async function _$2(ae) {
  let { accountAddress: ie, aptosConfig: se, eventType: fe, options: ue } = ae, ce = { where: { account_address: { _eq: c$b.from(ie).toStringLong() }, indexed_type: { _eq: fe } }, pagination: ue, orderBy: ue?.orderBy };
  return c$8({ aptosConfig: se, options: ce });
}
async function c$8(ae) {
  let { aptosConfig: ie, options: se } = ae;
  y$b(se?.where?.indexed_type?._eq);
  let fe = { query: f$b, variables: { where_condition: se?.where, offset: se?.offset, limit: se?.limit, order_by: se?.orderBy } };
  return (await p$6({ aptosConfig: ie, query: fe, originMethod: "getEvents" })).events;
}
var n$a = /* @__PURE__ */ new Map();
function m$9(ae, ie, se) {
  return async (...fe) => {
    if (n$a.has(ie)) {
      let { value: ce, timestamp: de } = n$a.get(ie);
      if (se === void 0 || Date.now() - de <= se)
        return ce;
    }
    let ue = await ae(...fe);
    return n$a.set(ie, { value: ue, timestamp: Date.now() }), ue;
  };
}
async function r$8(ae) {
  return new Promise((ie) => {
    setTimeout(ie, ae);
  });
}
var O$1 = ((ae) => (ae[ae.FULLNODE = 0] = "FULLNODE", ae[ae.INDEXER = 1] = "INDEXER", ae[ae.FAUCET = 2] = "FAUCET", ae))(O$1 || {}), N$5 = "0x1::aptos_coin::AptosCoin", T$4 = "APTOS::RawTransaction", o$a = "APTOS::RawTransactionWithData", E$3 = ((ae) => (ae.ACCOUNT_TRANSACTION_PROCESSOR = "account_transactions_processor", ae.DEFAULT = "default_processor", ae.EVENTS_PROCESSOR = "events_processor", ae.FUNGIBLE_ASSET_PROCESSOR = "fungible_asset_processor", ae.STAKE_PROCESSOR = "stake_processor", ae.TOKEN_V2_PROCESSOR = "token_v2_processor", ae.USER_TRANSACTION_PROCESSOR = "user_transaction_processor", ae))(E$3 || {});
async function F$3(ae) {
  let { aptosConfig: ie, options: se } = ae;
  return f$a({ aptosConfig: ie, originMethod: "getTransactions", path: "transactions", params: { start: se?.offset, limit: se?.limit } });
}
async function L$2(ae) {
  let { aptosConfig: ie } = ae;
  return m$9(async () => {
    let { data: se } = await g$5({ aptosConfig: ie, originMethod: "getGasPriceEstimation", path: "estimate_gas_price" });
    return se;
  }, `gas-price-${ie.network}`, 1e3 * 60 * 5)();
}
async function v$4(ae) {
  let { aptosConfig: ie, ledgerVersion: se } = ae, { data: fe } = await g$5({ aptosConfig: ie, originMethod: "getTransactionByVersion", path: `transactions/by_version/${se}` });
  return fe;
}
async function x$6(ae) {
  let { aptosConfig: ie, transactionHash: se } = ae, { data: fe } = await g$5({ aptosConfig: ie, path: `transactions/by_hash/${se}`, originMethod: "getTransactionByHash" });
  return fe;
}
async function N$4(ae) {
  let { aptosConfig: ie, transactionHash: se } = ae;
  try {
    return (await x$6({ aptosConfig: ie, transactionHash: se })).type === "pending_transaction";
  } catch (fe) {
    if (fe?.status === 404)
      return !0;
    throw fe;
  }
}
async function G$5(ae) {
  let { aptosConfig: ie, transactionHash: se, options: fe } = ae, ue = fe?.timeoutSecs ?? 20, ce = fe?.checkSuccess ?? !0, de = !0, me = 0, we, Ee, Se = 200, Be = 1.5;
  for (; de && !(me >= ue); ) {
    try {
      if (we = await x$6({ aptosConfig: ie, transactionHash: se }), de = we.type === "pending_transaction", !de)
        break;
    } catch (Ce) {
      if (!(Ce instanceof s$3) || (Ee = Ce, Ce.status !== 404 && Ce.status >= 400 && Ce.status < 500))
        throw Ce;
    }
    await r$8(Se), me += Se / 1e3, Se *= Be;
  }
  if (we === void 0)
    throw Ee || new p$5(`Fetching transaction ${se} failed and timed out after ${ue} seconds`, we);
  if (we.type === "pending_transaction")
    throw new p$5(`Transaction ${se} timed out in pending state after ${ue} seconds`, we);
  if (!ce)
    return we;
  if (!we.success)
    throw new T$3(`Transaction ${se} failed with an error: ${we.vm_status}`, we);
  return we;
}
async function D$5(ae) {
  let { aptosConfig: ie, processorType: se } = ae, fe = BigInt(ae.minimumLedgerVersion), ue = 3e3, ce = (/* @__PURE__ */ new Date()).getTime(), de = BigInt(-1);
  for (; de < fe; ) {
    if ((/* @__PURE__ */ new Date()).getTime() - ce > ue)
      throw new Error("waitForLastSuccessIndexerVersionSync timeout");
    if (se === void 0 ? de = await w$1({ aptosConfig: ie }) : de = (await A$7({ aptosConfig: ie, processorType: se })).last_success_version, de >= fe)
      break;
    await r$8(200);
  }
}
var p$5 = class extends Error {
  constructor(ie, se) {
    super(ie), this.lastSubmittedTransaction = se;
  }
}, T$3 = class extends Error {
  constructor(ie, se) {
    super(ie), this.transaction = se;
  }
};
async function i$4(ae) {
  ae.minimumLedgerVersion !== void 0 && await D$5({ aptosConfig: ae.config, minimumLedgerVersion: ae.minimumLedgerVersion, processorType: ae.processorType });
}
var i$3 = class {
  constructor(ie) {
    this.config = ie;
  }
  async getModuleEventsByEventType(ie) {
    return await i$4({ config: this.config, minimumLedgerVersion: ie.minimumLedgerVersion, processorType: "events_processor" }), f$7({ aptosConfig: this.config, ...ie });
  }
  async getAccountEventsByCreationNumber(ie) {
    return await i$4({ config: this.config, minimumLedgerVersion: ie.minimumLedgerVersion, processorType: "events_processor" }), h$8({ aptosConfig: this.config, ...ie });
  }
  async getAccountEventsByEventType(ie) {
    return await i$4({ config: this.config, minimumLedgerVersion: ie.minimumLedgerVersion, processorType: "events_processor" }), _$2({ aptosConfig: this.config, ...ie });
  }
  async getEvents(ie) {
    return await i$4({ config: this.config, minimumLedgerVersion: ie?.minimumLedgerVersion, processorType: "events_processor" }), c$8({ aptosConfig: this.config, ...ie });
  }
};
async function x$5(ae) {
  let { aptosConfig: ie, accountAddress: se, amount: fe, options: ue } = ae, ce = ue?.timeoutSecs || 20, { data: de } = await x$7({ aptosConfig: ie, path: "fund", body: { address: c$b.from(se).toString(), amount: fe }, originMethod: "fundAccount" }), me = de.txn_hashes[0], we = await G$5({ aptosConfig: ie, transactionHash: me, options: { timeoutSecs: ce, checkSuccess: ue?.checkSuccess } });
  if (we.type === "user_transaction")
    return we;
  throw new Error(`Unexpected transaction received for fund account: ${we.type}`);
}
var r$7 = class {
  constructor(ie) {
    this.config = ie;
  }
  async fundAccount(ie) {
    let se = await x$5({ aptosConfig: this.config, ...ie });
    return ie.options?.waitForIndexer !== !1 && await D$5({ aptosConfig: this.config, minimumLedgerVersion: BigInt(se.version) }), se;
  }
}, r$6 = class ii extends B$4 {
  constructor(ie) {
    super(), this.identifier = ie;
  }
  serialize(ie) {
    ie.serializeStr(this.identifier);
  }
  static deserialize(ie) {
    let se = ie.deserializeStr();
    return new ii(se);
  }
}, t$8 = class extends B$4 {
  static deserialize(ie) {
    let se = ie.deserializeUleb128AsU32();
    switch (se) {
      case 0:
        return c$7.load(ie);
      case 1:
        return u$7.load(ie);
      case 2:
        return p$4.load(ie);
      case 3:
        return z$2.load(ie);
      case 4:
        return S$4.load(ie);
      case 5:
        return U$7.load(ie);
      case 6:
        return y$a.load(ie);
      case 7:
        return b$7.load(ie);
      case 8:
        return d$6.load(ie);
      case 9:
        return g$3.load(ie);
      case 10:
        return T$2.load(ie);
      case 255:
        return h$7.load(ie);
      default:
        throw new Error(`Unknown variant index for TypeTag: ${se}`);
    }
  }
  isBool() {
    return this instanceof c$7;
  }
  isAddress() {
    return this instanceof S$4;
  }
  isGeneric() {
    return this instanceof h$7;
  }
  isSigner() {
    return this instanceof U$7;
  }
  isVector() {
    return this instanceof y$a;
  }
  isStruct() {
    return this instanceof b$7;
  }
  isU8() {
    return this instanceof u$7;
  }
  isU16() {
    return this instanceof d$6;
  }
  isU32() {
    return this instanceof g$3;
  }
  isU64() {
    return this instanceof p$4;
  }
  isU128() {
    return this instanceof z$2;
  }
  isU256() {
    return this instanceof T$2;
  }
}, c$7 = class si extends t$8 {
  toString() {
    return "bool";
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(0);
  }
  static load(ie) {
    return new si();
  }
}, u$7 = class oi extends t$8 {
  toString() {
    return "u8";
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(1);
  }
  static load(ie) {
    return new oi();
  }
}, d$6 = class ai extends t$8 {
  toString() {
    return "u16";
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(8);
  }
  static load(ie) {
    return new ai();
  }
}, g$3 = class fi extends t$8 {
  toString() {
    return "u32";
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(9);
  }
  static load(ie) {
    return new fi();
  }
}, p$4 = class ci extends t$8 {
  toString() {
    return "u64";
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(2);
  }
  static load(ie) {
    return new ci();
  }
}, z$2 = class ui extends t$8 {
  toString() {
    return "u128";
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(3);
  }
  static load(ie) {
    return new ui();
  }
}, T$2 = class li extends t$8 {
  toString() {
    return "u256";
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(10);
  }
  static load(ie) {
    return new li();
  }
}, S$4 = class hi extends t$8 {
  toString() {
    return "address";
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(4);
  }
  static load(ie) {
    return new hi();
  }
}, U$7 = class di extends t$8 {
  toString() {
    return "signer";
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(5);
  }
  static load(ie) {
    return new di();
  }
}, f$6 = class pi extends t$8 {
  constructor(ie) {
    super(), this.value = ie;
  }
  toString() {
    return `&${this.value.toString()}`;
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(254);
  }
  static load(ie) {
    let se = t$8.deserialize(ie);
    return new pi(se);
  }
}, h$7 = class gi extends t$8 {
  constructor(ie) {
    if (super(), this.value = ie, ie < 0)
      throw new Error("Generic type parameter index cannot be negative");
  }
  toString() {
    return `T${this.value}`;
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(255), ie.serializeU32(this.value);
  }
  static load(ie) {
    let se = ie.deserializeU32();
    return new gi(se);
  }
}, y$a = class zn extends t$8 {
  constructor(ie) {
    super(), this.value = ie;
  }
  toString() {
    return `vector<${this.value.toString()}>`;
  }
  static u8() {
    return new zn(new u$7());
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(6), this.value.serialize(ie);
  }
  static load(ie) {
    let se = t$8.deserialize(ie);
    return new zn(se);
  }
}, b$7 = class yi extends t$8 {
  constructor(ie) {
    super(), this.value = ie;
  }
  toString() {
    let ie = "";
    return this.value.typeArgs.length > 0 && (ie = `<${this.value.typeArgs.map((se) => se.toString()).join(", ")}>`), `${this.value.address.toString()}::${this.value.moduleName.identifier}::${this.value.name.identifier}${ie}`;
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(7), this.value.serialize(ie);
  }
  static load(ie) {
    let se = o$9.deserialize(ie);
    return new yi(se);
  }
  isTypeTag(ie, se, fe) {
    return this.value.moduleName.identifier === se && this.value.name.identifier === fe && this.value.address.equals(ie);
  }
  isString() {
    return this.isTypeTag(c$b.ONE, "string", "String");
  }
  isOption() {
    return this.isTypeTag(c$b.ONE, "option", "Option");
  }
  isObject() {
    return this.isTypeTag(c$b.ONE, "object", "Object");
  }
}, o$9 = class mi extends B$4 {
  constructor(ie, se, fe, ue) {
    super(), this.address = ie, this.moduleName = se, this.name = fe, this.typeArgs = ue;
  }
  serialize(ie) {
    ie.serialize(this.address), ie.serialize(this.moduleName), ie.serialize(this.name), ie.serializeVector(this.typeArgs);
  }
  static deserialize(ie) {
    let se = c$b.deserialize(ie), fe = r$6.deserialize(ie), ue = r$6.deserialize(ie), ce = ie.deserializeVector(t$8);
    return new mi(se, fe, ue, ce);
  }
};
function V$2() {
  return new o$9(c$b.ONE, new r$6("string"), new r$6("String"), []);
}
function G$4(ae) {
  return new o$9(c$b.ONE, new r$6("object"), new r$6("Object"), [ae]);
}
function N$3(ae) {
  return !!ae.match(/^[_a-zA-Z0-9]+$/);
}
function V$1(ae) {
  return !!ae.match(/\s/);
}
function $$3(ae) {
  return !!ae.match(/^T[0-9]+$/);
}
function F$2(ae, ie) {
  let se = ie;
  for (; se < ae.length; se += 1) {
    let fe = ae[se];
    if (!V$1(fe))
      break;
  }
  return se;
}
var S$3 = ((ae) => (ae.InvalidTypeTag = "unknown type", ae.UnexpectedGenericType = "unexpected generic type", ae.UnexpectedTypeArgumentClose = "unexpected '>'", ae.UnexpectedWhitespaceCharacter = "unexpected whitespace character", ae.UnexpectedComma = "unexpected ','", ae.TypeArgumentCountMismatch = "type argument count doesn't match expected amount", ae.MissingTypeArgumentClose = "no matching '>' for '<'", ae.UnexpectedPrimitiveTypeArguments = "primitive types not expected to have type arguments", ae.UnexpectedVectorTypeArgumentCount = "vector type expected to have exactly one type argument", ae.UnexpectedStructFormat = "unexpected struct format, must be of the form 0xaddress::module_name::struct_name", ae.InvalidModuleNameCharacter = "module name must only contain alphanumeric or '_' characters", ae.InvalidStructNameCharacter = "struct name must only contain alphanumeric or '_' characters", ae))(S$3 || {}), r$5 = class extends Error {
  constructor(ie, se) {
    super(`Failed to parse typeTag '${ie}', ${se}`);
  }
};
function Z$3(ae, ie) {
  let se = ie?.allowGenerics ?? !1, fe = [], ue = [], ce = [], de = 0, me = "", we = 1;
  for (; de < ae.length; ) {
    let Ee = ae[de];
    if (Ee === "<")
      fe.push({ savedExpectedTypes: we, savedStr: me, savedTypes: ce }), me = "", ce = [], we = 1;
    else if (Ee === ">") {
      if (me !== "") {
        let Pe = m$8(me, ue, se);
        ce.push(Pe);
      }
      let Se = fe.pop();
      if (Se === void 0)
        throw new r$5(ae, "unexpected '>'");
      if (we !== ce.length)
        throw new r$5(ae, "type argument count doesn't match expected amount");
      let { savedStr: Be, savedTypes: Ce, savedExpectedTypes: Ie } = Se;
      ue = ce, ce = Ce, me = Be, we = Ie;
    } else if (Ee === ",") {
      if (me.length !== 0) {
        let Se = m$8(me, ue, se);
        ue = [], ce.push(Se), me = "", we += 1;
      }
    } else if (V$1(Ee)) {
      let Se = !1;
      if (me.length !== 0) {
        let Ce = m$8(me, ue, se);
        ue = [], ce.push(Ce), me = "", Se = !0;
      }
      de = F$2(ae, de);
      let Be = ae[de];
      if (de < ae.length && Se && Be !== "," && Be !== ">")
        throw new r$5(ae, "unexpected whitespace character");
      continue;
    } else
      me += Ee;
    de += 1;
  }
  if (fe.length > 0)
    throw new r$5(ae, "no matching '>' for '<'");
  switch (ce.length) {
    case 0:
      return m$8(me, ue, se);
    case 1:
      if (me === "")
        return ce[0];
      throw new r$5(ae, "unexpected ','");
    default:
      throw new r$5(ae, "unexpected whitespace character");
  }
}
function m$8(ae, ie, se) {
  switch (ae) {
    case "&signer":
      if (ie.length > 0)
        throw new r$5(ae, "primitive types not expected to have type arguments");
      return new f$6(new U$7());
    case "signer":
      if (ie.length > 0)
        throw new r$5(ae, "primitive types not expected to have type arguments");
      return new U$7();
    case "bool":
      if (ie.length > 0)
        throw new r$5(ae, "primitive types not expected to have type arguments");
      return new c$7();
    case "address":
      if (ie.length > 0)
        throw new r$5(ae, "primitive types not expected to have type arguments");
      return new S$4();
    case "u8":
      if (ie.length > 0)
        throw new r$5(ae, "primitive types not expected to have type arguments");
      return new u$7();
    case "u16":
      if (ie.length > 0)
        throw new r$5(ae, "primitive types not expected to have type arguments");
      return new d$6();
    case "u32":
      if (ie.length > 0)
        throw new r$5(ae, "primitive types not expected to have type arguments");
      return new g$3();
    case "u64":
      if (ie.length > 0)
        throw new r$5(ae, "primitive types not expected to have type arguments");
      return new p$4();
    case "u128":
      if (ie.length > 0)
        throw new r$5(ae, "primitive types not expected to have type arguments");
      return new z$2();
    case "u256":
      if (ie.length > 0)
        throw new r$5(ae, "primitive types not expected to have type arguments");
      return new T$2();
    case "vector":
      if (ie.length !== 1)
        throw new r$5(ae, "vector type expected to have exactly one type argument");
      return new y$a(ie[0]);
    default:
      if ($$3(ae)) {
        if (se)
          return new h$7(Number(ae.split("T")[1]));
        throw new r$5(ae, "unexpected generic type");
      }
      if (!ae.match(/:/))
        throw new r$5(ae, "unknown type");
      let fe = ae.split("::");
      if (fe.length !== 3)
        throw new r$5(ae, "unexpected struct format, must be of the form 0xaddress::module_name::struct_name");
      if (!N$3(fe[1]))
        throw new r$5(ae, "module name must only contain alphanumeric or '_' characters");
      if (!N$3(fe[2]))
        throw new r$5(ae, "struct name must only contain alphanumeric or '_' characters");
      return new b$7(new o$9(c$b.fromString(fe[0]), new r$6(fe[1]), new r$6(fe[2]), ie));
  }
}
var t$7 = class bi extends B$4 {
  constructor(ie) {
    super(), this.value = i$7.fromHexInput(ie).toUint8Array();
  }
  serialize(ie) {
    ie.serializeFixedBytes(this.value);
  }
  serializeForEntryFunction(ie) {
    ie.serialize(this);
  }
  serializeForScriptFunction(ie) {
    ie.serialize(this);
  }
  static deserialize(ie, se) {
    let fe = ie.deserializeFixedBytes(se);
    return new bi(fe);
  }
}, U$6 = class vi extends B$4 {
  constructor(ie) {
    super(), A$a(ie), this.value = ie;
  }
  serialize(ie) {
    ie.serializeBool(this.value);
  }
  serializeForEntryFunction(ie) {
    let se = this.bcsToBytes();
    ie.serializeBytes(se);
  }
  serializeForScriptFunction(ie) {
    ie.serializeU32AsUleb128(5), ie.serialize(this);
  }
  static deserialize(ie) {
    return new vi(ie.deserializeBool());
  }
}, p$3 = class xi extends B$4 {
  constructor(ie) {
    super(), w$3(ie, 0, t$9), this.value = ie;
  }
  serialize(ie) {
    ie.serializeU8(this.value);
  }
  serializeForEntryFunction(ie) {
    let se = this.bcsToBytes();
    ie.serializeBytes(se);
  }
  serializeForScriptFunction(ie) {
    ie.serializeU32AsUleb128(0), ie.serialize(this);
  }
  static deserialize(ie) {
    return new xi(ie.deserializeU8());
  }
}, b$6 = class wi extends B$4 {
  constructor(ie) {
    super(), w$3(ie, 0, n$c), this.value = ie;
  }
  serialize(ie) {
    ie.serializeU16(this.value);
  }
  serializeForEntryFunction(ie) {
    let se = this.bcsToBytes();
    ie.serializeBytes(se);
  }
  serializeForScriptFunction(ie) {
    ie.serializeU32AsUleb128(6), ie.serialize(this);
  }
  static deserialize(ie) {
    return new wi(ie.deserializeU16());
  }
}, y$9 = class _i extends B$4 {
  constructor(ie) {
    super(), w$3(ie, 0, U$8), this.value = ie;
  }
  serialize(ie) {
    ie.serializeU32(this.value);
  }
  serializeForEntryFunction(ie) {
    let se = this.bcsToBytes();
    ie.serializeBytes(se);
  }
  serializeForScriptFunction(ie) {
    ie.serializeU32AsUleb128(7), ie.serialize(this);
  }
  static deserialize(ie) {
    return new _i(ie.deserializeU32());
  }
}, m$7 = class $i extends B$4 {
  constructor(ie) {
    super(), w$3(ie, BigInt(0), _$4), this.value = BigInt(ie);
  }
  serialize(ie) {
    ie.serializeU64(this.value);
  }
  serializeForEntryFunction(ie) {
    let se = this.bcsToBytes();
    ie.serializeBytes(se);
  }
  serializeForScriptFunction(ie) {
    ie.serializeU32AsUleb128(1), ie.serialize(this);
  }
  static deserialize(ie) {
    return new $i(ie.deserializeU64());
  }
}, B$3 = class Ei extends B$4 {
  constructor(ie) {
    super(), w$3(ie, BigInt(0), o$d), this.value = BigInt(ie);
  }
  serialize(ie) {
    ie.serializeU128(this.value);
  }
  serializeForEntryFunction(ie) {
    let se = this.bcsToBytes();
    ie.serializeBytes(se);
  }
  serializeForScriptFunction(ie) {
    ie.serializeU32AsUleb128(2), ie.serialize(this);
  }
  static deserialize(ie) {
    return new Ei(ie.deserializeU128());
  }
}, v$3 = class Si extends B$4 {
  constructor(ie) {
    super(), w$3(ie, BigInt(0), i$8), this.value = BigInt(ie);
  }
  serialize(ie) {
    ie.serializeU256(this.value);
  }
  serializeForEntryFunction(ie) {
    let se = this.bcsToBytes();
    ie.serializeBytes(se);
  }
  serializeForScriptFunction(ie) {
    ie.serializeU32AsUleb128(8), ie.serialize(this);
  }
  static deserialize(ie) {
    return new Si(ie.deserializeU256());
  }
}, t$6 = class En extends B$4 {
  constructor(ie) {
    super(), this.values = ie;
  }
  serializeForEntryFunction(ie) {
    let se = this.bcsToBytes();
    ie.serializeBytes(se);
  }
  serializeForScriptFunction(ie) {
    if (!(this.values[0] instanceof p$3) && this.values[0] !== void 0)
      throw new Error("Script function arguments only accept u8 vectors");
    ie.serializeU32AsUleb128(4), ie.serialize(this);
  }
  static U8(ie) {
    let se;
    if (Array.isArray(ie) && typeof ie[0] == "number")
      se = ie;
    else if (typeof ie == "string") {
      let fe = i$7.fromHexInput(ie);
      se = Array.from(fe.toUint8Array());
    } else if (ie instanceof Uint8Array)
      se = Array.from(ie);
    else
      throw new Error("Invalid input type");
    return new En(se.map((fe) => new p$3(fe)));
  }
  static U16(ie) {
    return new En(ie.map((se) => new b$6(se)));
  }
  static U32(ie) {
    return new En(ie.map((se) => new y$9(se)));
  }
  static U64(ie) {
    return new En(ie.map((se) => new m$7(se)));
  }
  static U128(ie) {
    return new En(ie.map((se) => new B$3(se)));
  }
  static U256(ie) {
    return new En(ie.map((se) => new v$3(se)));
  }
  static Bool(ie) {
    return new En(ie.map((se) => new U$6(se)));
  }
  static MoveString(ie) {
    return new En(ie.map((se) => new a$a(se)));
  }
  serialize(ie) {
    ie.serializeVector(this.values);
  }
  static deserialize(ie, se) {
    let fe = ie.deserializeUleb128AsU32(), ue = new Array();
    for (let ce = 0; ce < fe; ce += 1)
      ue.push(se.deserialize(ie));
    return new En(ue);
  }
}, a$a = class Ai extends B$4 {
  constructor(ie) {
    super(), this.value = ie;
  }
  serialize(ie) {
    ie.serializeStr(this.value);
  }
  serializeForEntryFunction(ie) {
    let se = this.bcsToBytes();
    ie.serializeBytes(se);
  }
  serializeForScriptFunction(ie) {
    let se = this.bcsToBytes().slice(1);
    t$6.U8(se).serializeForScriptFunction(ie);
  }
  static deserialize(ie) {
    return new Ai(ie.deserializeStr());
  }
}, f$5 = class Sn extends B$4 {
  constructor(ie) {
    super(), typeof ie < "u" && ie !== null ? this.vec = new t$6([ie]) : this.vec = new t$6([]), [this.value] = this.vec.values;
  }
  serializeForEntryFunction(ie) {
    let se = this.bcsToBytes();
    ie.serializeBytes(se);
  }
  unwrap() {
    if (this.isSome())
      return this.vec.values[0];
    throw new Error("Called unwrap on a MoveOption with no value");
  }
  isSome() {
    return this.vec.values.length === 1;
  }
  serialize(ie) {
    this.vec.serialize(ie);
  }
  static U8(ie) {
    return new Sn(ie != null ? new p$3(ie) : void 0);
  }
  static U16(ie) {
    return new Sn(ie != null ? new b$6(ie) : void 0);
  }
  static U32(ie) {
    return new Sn(ie != null ? new y$9(ie) : void 0);
  }
  static U64(ie) {
    return new Sn(ie != null ? new m$7(ie) : void 0);
  }
  static U128(ie) {
    return new Sn(ie != null ? new B$3(ie) : void 0);
  }
  static U256(ie) {
    return new Sn(ie != null ? new v$3(ie) : void 0);
  }
  static Bool(ie) {
    return new Sn(ie != null ? new U$6(ie) : void 0);
  }
  static MoveString(ie) {
    return new Sn(ie != null ? new a$a(ie) : void 0);
  }
  static deserialize(ie, se) {
    let fe = t$6.deserialize(ie, se);
    return new Sn(fe.values[0]);
  }
};
function M$4(ae) {
  return typeof ae == "boolean";
}
function D$4(ae) {
  return typeof ae == "string";
}
function N$2(ae) {
  return typeof ae == "number";
}
function P$3(ae) {
  return typeof ae == "number" || typeof ae == "bigint" || typeof ae == "string";
}
function w(ae) {
  return ae == null;
}
function G$3(ae) {
  return A$6(ae) || x$4(ae) || S$2(ae) || B$2(ae) || U$5(ae) || I$2(ae) || b$5(ae) || T$1(ae) || E$2(ae) || d$5(ae) || ae instanceof t$6 || ae instanceof f$5;
}
function A$6(ae) {
  return ae instanceof U$6;
}
function T$1(ae) {
  return ae instanceof c$b;
}
function E$2(ae) {
  return ae instanceof a$a;
}
function d$5(ae) {
  return ae instanceof t$7;
}
function x$4(ae) {
  return ae instanceof p$3;
}
function S$2(ae) {
  return ae instanceof b$6;
}
function B$2(ae) {
  return ae instanceof y$9;
}
function U$5(ae) {
  return ae instanceof m$7;
}
function I$2(ae) {
  return ae instanceof B$3;
}
function b$5(ae) {
  return ae instanceof v$3;
}
function $$2(ae) {
  return "bytecode" in ae;
}
function R$3(ae, ie) {
  throw new Error(`Type mismatch for argument ${ie}, expected '${ae}'`);
}
function W$2(ae) {
  let ie = ae.params.findIndex((se) => se !== "signer" && se !== "&signer");
  return ie < 0 ? ae.params.length : ie;
}
function L$1(ae) {
  let ie = ae.split("::");
  if (ie.length !== 3)
    throw new Error(`Invalid function ${ae}`);
  let se = ie[0], fe = ie[1], ue = ie[2];
  return { moduleAddress: se, moduleName: fe, functionName: ue };
}
var t$5 = class extends B$4 {
  toString() {
    let ie = this.toUint8Array();
    return i$7.fromHexInput(ie).toString();
  }
}, a$9 = class extends t$5 {
}, o$8 = class extends B$4 {
  toString() {
    let ie = this.toUint8Array();
    return i$7.fromHexInput(ie).toString();
  }
};
function pbkdf2Init(ae, ie, se, fe) {
  hash(ae);
  const ue = checkOpts({ dkLen: 32, asyncTick: 10 }, fe), { c: ce, dkLen: de, asyncTick: me } = ue;
  if (number$1(ce), number$1(de), number$1(me), ce < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const we = toBytes(ie), Ee = toBytes(se), Se = new Uint8Array(de), Be = hmac.create(ae, we), Ce = Be._cloneInto().update(Ee);
  return { c: ce, dkLen: de, asyncTick: me, DK: Se, PRF: Be, PRFSalt: Ce };
}
function pbkdf2Output(ae, ie, se, fe, ue) {
  return ae.destroy(), ie.destroy(), fe && fe.destroy(), ue.fill(0), se;
}
function pbkdf2(ae, ie, se, fe) {
  const { c: ue, dkLen: ce, DK: de, PRF: me, PRFSalt: we } = pbkdf2Init(ae, ie, se, fe);
  let Ee;
  const Se = new Uint8Array(4), Be = createView(Se), Ce = new Uint8Array(me.outputLen);
  for (let Ie = 1, Pe = 0; Pe < ce; Ie++, Pe += me.outputLen) {
    const Ne = de.subarray(Pe, Pe + me.outputLen);
    Be.setInt32(0, Ie, !1), (Ee = we._cloneInto(Ee)).update(Se).digestInto(Ce), Ne.set(Ce.subarray(0, Ne.length));
    for (let ke = 1; ke < ue; ke++) {
      me._cloneInto(Ee).update(Ce).digestInto(Ce);
      for (let He = 0; He < Ne.length; He++)
        Ne[He] ^= Ce[He];
    }
  }
  return pbkdf2Output(me, we, de, Ee, Ce);
}
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function isBytes(ae) {
  return ae instanceof Uint8Array || ae != null && typeof ae == "object" && ae.constructor.name === "Uint8Array";
}
// @__NO_SIDE_EFFECTS__
function chain(...ae) {
  const ie = (ce) => ce, se = (ce, de) => (me) => ce(de(me)), fe = ae.map((ce) => ce.encode).reduceRight(se, ie), ue = ae.map((ce) => ce.decode).reduce(se, ie);
  return { encode: fe, decode: ue };
}
// @__NO_SIDE_EFFECTS__
function alphabet(ae) {
  return {
    encode: (ie) => {
      if (!Array.isArray(ie) || ie.length && typeof ie[0] != "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return ie.map((se) => {
        if (se < 0 || se >= ae.length)
          throw new Error(`Digit index outside alphabet: ${se} (alphabet: ${ae.length})`);
        return ae[se];
      });
    },
    decode: (ie) => {
      if (!Array.isArray(ie) || ie.length && typeof ie[0] != "string")
        throw new Error("alphabet.decode input should be array of strings");
      return ie.map((se) => {
        if (typeof se != "string")
          throw new Error(`alphabet.decode: not string element=${se}`);
        const fe = ae.indexOf(se);
        if (fe === -1)
          throw new Error(`Unknown letter: "${se}". Allowed: ${ae}`);
        return fe;
      });
    }
  };
}
// @__NO_SIDE_EFFECTS__
function join(ae = "") {
  if (typeof ae != "string")
    throw new Error("join separator should be string");
  return {
    encode: (ie) => {
      if (!Array.isArray(ie) || ie.length && typeof ie[0] != "string")
        throw new Error("join.encode input should be array of strings");
      for (let se of ie)
        if (typeof se != "string")
          throw new Error(`join.encode: non-string input=${se}`);
      return ie.join(ae);
    },
    decode: (ie) => {
      if (typeof ie != "string")
        throw new Error("join.decode input should be string");
      return ie.split(ae);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function convertRadix(ae, ie, se) {
  if (ie < 2)
    throw new Error(`convertRadix: wrong from=${ie}, base cannot be less than 2`);
  if (se < 2)
    throw new Error(`convertRadix: wrong to=${se}, base cannot be less than 2`);
  if (!Array.isArray(ae))
    throw new Error("convertRadix: data should be array");
  if (!ae.length)
    return [];
  let fe = 0;
  const ue = [], ce = Array.from(ae);
  for (ce.forEach((de) => {
    if (de < 0 || de >= ie)
      throw new Error(`Wrong integer: ${de}`);
  }); ; ) {
    let de = 0, me = !0;
    for (let we = fe; we < ce.length; we++) {
      const Ee = ce[we], Se = ie * de + Ee;
      if (!Number.isSafeInteger(Se) || ie * de / ie !== de || Se - Ee !== ie * de)
        throw new Error("convertRadix: carry overflow");
      de = Se % se;
      const Be = Math.floor(Se / se);
      if (ce[we] = Be, !Number.isSafeInteger(Be) || Be * se + de !== Se)
        throw new Error("convertRadix: carry overflow");
      if (me)
        Be ? me = !1 : fe = we;
      else
        continue;
    }
    if (ue.push(de), me)
      break;
  }
  for (let de = 0; de < ae.length - 1 && ae[de] === 0; de++)
    ue.push(0);
  return ue.reverse();
}
// @__NO_SIDE_EFFECTS__
function radix(ae) {
  return {
    encode: (ie) => {
      if (!isBytes(ie))
        throw new Error("radix.encode input should be Uint8Array");
      return /* @__PURE__ */ convertRadix(Array.from(ie), 2 ** 8, ae);
    },
    decode: (ie) => {
      if (!Array.isArray(ie) || ie.length && typeof ie[0] != "number")
        throw new Error("radix.decode input should be array of numbers");
      return Uint8Array.from(/* @__PURE__ */ convertRadix(ie, ae, 2 ** 8));
    }
  };
}
// @__NO_SIDE_EFFECTS__
function checksum(ae, ie) {
  if (typeof ie != "function")
    throw new Error("checksum fn should be function");
  return {
    encode(se) {
      if (!isBytes(se))
        throw new Error("checksum.encode: input should be Uint8Array");
      const fe = ie(se).slice(0, ae), ue = new Uint8Array(se.length + ae);
      return ue.set(se), ue.set(fe, se.length), ue;
    },
    decode(se) {
      if (!isBytes(se))
        throw new Error("checksum.decode: input should be Uint8Array");
      const fe = se.slice(0, -ae), ue = ie(fe).slice(0, ae), ce = se.slice(-ae);
      for (let de = 0; de < ae; de++)
        if (ue[de] !== ce[de])
          throw new Error("Invalid checksum");
      return fe;
    }
  };
}
const genBase58 = (ae) => /* @__PURE__ */ chain(/* @__PURE__ */ radix(58), /* @__PURE__ */ alphabet(ae), /* @__PURE__ */ join("")), base58 = /* @__PURE__ */ genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), createBase58check = (ae) => /* @__PURE__ */ chain(/* @__PURE__ */ checksum(4, (ie) => ae(ae(ie))), base58);
/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */
function nfkd(ae) {
  if (typeof ae != "string")
    throw new TypeError(`Invalid mnemonic type: ${typeof ae}`);
  return ae.normalize("NFKD");
}
function normalize(ae) {
  const ie = nfkd(ae), se = ie.split(" ");
  if (![12, 15, 18, 21, 24].includes(se.length))
    throw new Error("Invalid mnemonic");
  return { nfkd: ie, words: se };
}
const salt = (ae) => nfkd(`mnemonic${ae}`);
function mnemonicToSeedSync(ae, ie = "") {
  return pbkdf2(sha512, normalize(ae).nfkd, salt(ie), { c: 2048, dkLen: 64 });
}
var d$4 = /^m\/44'\/637'\/[0-9]+'\/[0-9]+'\/[0-9]+'?$/, m$6 = /^m\/44'\/637'\/[0-9]+'\/[0-9]+\/[0-9]+$/, y$8 = ((ae) => (ae.ED25519 = "ed25519 seed", ae))(y$8 || {}), g$2 = 2147483648;
function D$3(ae) {
  return m$6.test(ae);
}
function E$1(ae) {
  return d$4.test(ae);
}
var A$5 = (ae, ie) => {
  let se = hmac.create(sha512, ae).update(ie).digest();
  return { key: se.slice(0, 32), chainCode: se.slice(32) };
}, f$4 = ({ key: ae, chainCode: ie }, se) => {
  let fe = new ArrayBuffer(4);
  new DataView(fe).setUint32(0, se);
  let ue = new Uint8Array(fe), ce = new Uint8Array([0]), de = new Uint8Array([...ce, ...ae, ...ue]);
  return A$5(ie, de);
}, x$3 = (ae) => ae.replace("'", ""), U$4 = (ae) => ae.split("/").slice(1).map(x$3), h$6 = (ae) => {
  let ie = ae.trim().split(/\s+/).map((se) => se.toLowerCase()).join(" ");
  return mnemonicToSeedSync(ie);
}, r$4 = class Pn extends B$4 {
  constructor(ie) {
    super();
    let { data: se } = ie, fe = i$7.fromHexInput(se);
    if (fe.toUint8Array().length !== Pn.LENGTH)
      throw new Error(`Authentication Key length should be ${Pn.LENGTH}`);
    this.data = fe;
  }
  serialize(ie) {
    ie.serializeFixedBytes(this.data.toUint8Array());
  }
  static deserialize(ie) {
    let se = ie.deserializeFixedBytes(Pn.LENGTH);
    return new Pn({ data: se });
  }
  toString() {
    return this.data.toString();
  }
  toUint8Array() {
    return this.data.toUint8Array();
  }
  static fromSchemeAndBytes(ie) {
    let { scheme: se, input: fe } = ie, ue = i$7.fromHexInput(fe).toUint8Array(), ce = new Uint8Array([...ue, se]), de = sha3_256.create();
    de.update(ce);
    let me = de.digest();
    return new Pn({ data: me });
  }
  static fromPublicKeyAndScheme(ie) {
    let { publicKey: se } = ie;
    return se.authKey();
  }
  static fromPublicKey(ie) {
    let { publicKey: se } = ie;
    return se.authKey();
  }
  derivedAddress() {
    return new c$b(this.data.toUint8Array());
  }
};
r$4.LENGTH = 32;
var c$6 = r$4, n$9 = class In extends a$9 {
  constructor(ie) {
    super();
    let se = i$7.fromHexInput(ie);
    if (se.toUint8Array().length !== In.LENGTH)
      throw new Error(`PublicKey length should be ${In.LENGTH}`);
    this.key = se;
  }
  verifySignature(ie) {
    let { message: se, signature: fe } = ie;
    if (!(fe instanceof y$7))
      return !1;
    let ue = i$7.fromHexInput(se).toUint8Array(), ce = fe.toUint8Array(), de = this.key.toUint8Array();
    return o$e.sign.detached.verify(ue, ce, de);
  }
  authKey() {
    return c$6.fromSchemeAndBytes({ scheme: 0, input: this.toUint8Array() });
  }
  toUint8Array() {
    return this.key.toUint8Array();
  }
  serialize(ie) {
    ie.serializeBytes(this.key.toUint8Array());
  }
  static deserialize(ie) {
    let se = ie.deserializeBytes();
    return new In(se);
  }
  static isPublicKey(ie) {
    return ie instanceof In;
  }
};
n$9.LENGTH = 32;
var m$5 = n$9, r$3 = class $n extends B$4 {
  constructor(ie) {
    super();
    let se = i$7.fromHexInput(ie);
    if (se.toUint8Array().length !== $n.LENGTH)
      throw new Error(`PrivateKey length should be ${$n.LENGTH}`);
    this.signingKeyPair = o$e.sign.keyPair.fromSeed(se.toUint8Array().slice(0, $n.LENGTH));
  }
  static generate() {
    let ie = o$e.sign.keyPair();
    return new $n(ie.secretKey.slice(0, $n.LENGTH));
  }
  static fromDerivationPath(ie, se) {
    if (!E$1(ie))
      throw new Error(`Invalid derivation path ${ie}`);
    return $n.fromDerivationPathInner(ie, h$6(se));
  }
  static fromDerivationPathInner(ie, se, fe = g$2) {
    let { key: ue, chainCode: ce } = A$5($n.SLIP_0010_SEED, se), de = U$4(ie).map((we) => parseInt(we, 10)), { key: me } = de.reduce((we, Ee) => f$4(we, Ee + fe), { key: ue, chainCode: ce });
    return new $n(me);
  }
  publicKey() {
    let ie = this.signingKeyPair.publicKey;
    return new m$5(ie);
  }
  sign(ie) {
    let se = i$7.fromHexInput(ie).toUint8Array(), fe = o$e.sign.detached(se, this.signingKeyPair.secretKey);
    return new y$7(fe);
  }
  toUint8Array() {
    return this.signingKeyPair.secretKey.slice(0, $n.LENGTH);
  }
  toString() {
    return i$7.fromHexInput(this.toUint8Array()).toString();
  }
  serialize(ie) {
    ie.serializeBytes(this.toUint8Array());
  }
  static deserialize(ie) {
    let se = ie.deserializeBytes();
    return new $n(se);
  }
  static isPrivateKey(ie) {
    return ie instanceof $n;
  }
};
r$3.LENGTH = 32, r$3.SLIP_0010_SEED = "ed25519 seed";
var x$2 = r$3, a$8 = class Hn extends o$8 {
  constructor(ie) {
    super();
    let se = i$7.fromHexInput(ie);
    if (se.toUint8Array().length !== Hn.LENGTH)
      throw new Error(`Signature length should be ${Hn.LENGTH}`);
    this.data = se;
  }
  toUint8Array() {
    return this.data.toUint8Array();
  }
  serialize(ie) {
    ie.serializeBytes(this.data.toUint8Array());
  }
  static deserialize(ie) {
    let se = ie.deserializeBytes();
    return new Hn(se);
  }
};
a$8.LENGTH = 64;
var y$7 = a$8, o$7 = class Tn extends a$9 {
  constructor(ie) {
    super();
    let { publicKeys: se, threshold: fe } = ie;
    if (se.length > Tn.MAX_KEYS || se.length < Tn.MIN_KEYS)
      throw new Error(`Must have between ${Tn.MIN_KEYS} and ${Tn.MAX_KEYS} public keys, inclusive`);
    if (fe < Tn.MIN_THRESHOLD || fe > se.length)
      throw new Error(`Threshold must be between ${Tn.MIN_THRESHOLD} and ${se.length}, inclusive`);
    this.publicKeys = se, this.threshold = fe;
  }
  verifySignature(ie) {
    let { message: se, signature: fe } = ie;
    if (!(fe instanceof y$6))
      return !1;
    let ue = [];
    for (let ce = 0; ce < 4; ce += 1)
      for (let de = 0; de < 8; de += 1)
        if (fe.bitmap[ce] & 1 << 7 - de) {
          let me = ce * 8 + de;
          ue.push(me);
        }
    if (ue.length !== fe.signatures.length)
      throw new Error("Bitmap and signatures length mismatch");
    if (ue.length < this.threshold)
      throw new Error("Not enough signatures");
    for (let ce = 0; ce < ue.length; ce += 1)
      if (!this.publicKeys[ue[ce]].verifySignature({ message: se, signature: fe.signatures[ce] }))
        return !1;
    return !0;
  }
  authKey() {
    return c$6.fromSchemeAndBytes({ scheme: 1, input: this.toUint8Array() });
  }
  toUint8Array() {
    let ie = new Uint8Array(this.publicKeys.length * m$5.LENGTH + 1);
    return this.publicKeys.forEach((se, fe) => {
      ie.set(se.toUint8Array(), fe * m$5.LENGTH);
    }), ie[this.publicKeys.length * m$5.LENGTH] = this.threshold, ie;
  }
  serialize(ie) {
    ie.serializeBytes(this.toUint8Array());
  }
  static deserialize(ie) {
    let se = ie.deserializeBytes(), fe = se[se.length - 1], ue = [];
    for (let ce = 0; ce < se.length - 1; ce += m$5.LENGTH) {
      let de = ce;
      ue.push(new m$5(se.subarray(de, de + m$5.LENGTH)));
    }
    return new Tn({ publicKeys: ue, threshold: fe });
  }
};
o$7.MAX_KEYS = 32, o$7.MIN_KEYS = 2, o$7.MIN_THRESHOLD = 1;
var d$3 = o$7, a$7 = class Mn extends o$8 {
  constructor(ie) {
    super();
    let { signatures: se, bitmap: fe } = ie;
    if (se.length > Mn.MAX_SIGNATURES_SUPPORTED)
      throw new Error(`The number of signatures cannot be greater than ${Mn.MAX_SIGNATURES_SUPPORTED}`);
    if (this.signatures = se, !(fe instanceof Uint8Array))
      this.bitmap = Mn.createBitmap({ bits: fe });
    else {
      if (fe.length !== Mn.BITMAP_LEN)
        throw new Error(`"bitmap" length should be ${Mn.BITMAP_LEN}`);
      this.bitmap = fe;
    }
  }
  toUint8Array() {
    let ie = new Uint8Array(this.signatures.length * y$7.LENGTH + Mn.BITMAP_LEN);
    return this.signatures.forEach((se, fe) => {
      ie.set(se.toUint8Array(), fe * y$7.LENGTH);
    }), ie.set(this.bitmap, this.signatures.length * y$7.LENGTH), ie;
  }
  serialize(ie) {
    ie.serializeBytes(this.toUint8Array());
  }
  static deserialize(ie) {
    let se = ie.deserializeBytes(), fe = se.subarray(se.length - 4), ue = [];
    for (let ce = 0; ce < se.length - fe.length; ce += y$7.LENGTH) {
      let de = ce;
      ue.push(new y$7(se.subarray(de, de + y$7.LENGTH)));
    }
    return new Mn({ signatures: ue, bitmap: fe });
  }
  static createBitmap(ie) {
    let { bits: se } = ie, fe = 128, ue = new Uint8Array([0, 0, 0, 0]), ce = /* @__PURE__ */ new Set();
    return se.forEach((de, me) => {
      if (de >= Mn.MAX_SIGNATURES_SUPPORTED)
        throw new Error(`Cannot have a signature larger than ${Mn.MAX_SIGNATURES_SUPPORTED - 1}.`);
      if (ce.has(de))
        throw new Error("Duplicate bits detected.");
      if (me > 0 && de <= se[me - 1])
        throw new Error("The bits need to be sorted in ascending order.");
      ce.add(de);
      let we = Math.floor(de / 8), Ee = ue[we];
      Ee |= fe >> de % 8, ue[we] = Ee;
    }), ue;
  }
};
a$7.MAX_SIGNATURES_SUPPORTED = 32, a$7.BITMAP_LEN = 4;
var y$6 = a$7;
const Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (ae, ie) => ie), Pi = /* @__PURE__ */ Id.map((ae) => (9 * ae + 5) % 16);
let idxL = [Id], idxR = [Pi];
for (let ae = 0; ae < 4; ae++)
  for (let ie of [idxL, idxR])
    ie.push(ie[ae].map((se) => Rho[se]));
const shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((ae) => new Uint8Array(ae)), shiftsL = /* @__PURE__ */ idxL.map((ae, ie) => ae.map((se) => shifts[ie][se])), shiftsR = /* @__PURE__ */ idxR.map((ae, ie) => ae.map((se) => shifts[ie][se])), Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]), Kr = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]), rotl = (ae, ie) => ae << ie | ae >>> 32 - ie;
function f$3(ae, ie, se, fe) {
  return ae === 0 ? ie ^ se ^ fe : ae === 1 ? ie & se | ~ie & fe : ae === 2 ? (ie | ~se) ^ fe : ae === 3 ? ie & fe | se & ~fe : ie ^ (se | ~fe);
}
const BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends SHA2 {
  constructor() {
    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: ie, h1: se, h2: fe, h3: ue, h4: ce } = this;
    return [ie, se, fe, ue, ce];
  }
  set(ie, se, fe, ue, ce) {
    this.h0 = ie | 0, this.h1 = se | 0, this.h2 = fe | 0, this.h3 = ue | 0, this.h4 = ce | 0;
  }
  process(ie, se) {
    for (let Ie = 0; Ie < 16; Ie++, se += 4)
      BUF[Ie] = ie.getUint32(se, !0);
    let fe = this.h0 | 0, ue = fe, ce = this.h1 | 0, de = ce, me = this.h2 | 0, we = me, Ee = this.h3 | 0, Se = Ee, Be = this.h4 | 0, Ce = Be;
    for (let Ie = 0; Ie < 5; Ie++) {
      const Pe = 4 - Ie, Ne = Kl[Ie], ke = Kr[Ie], He = idxL[Ie], De = idxR[Ie], Ge = shiftsL[Ie], Ye = shiftsR[Ie];
      for (let st = 0; st < 16; st++) {
        const at = rotl(fe + f$3(Ie, ce, me, Ee) + BUF[He[st]] + Ne, Ge[st]) + Be | 0;
        fe = Be, Be = Ee, Ee = rotl(me, 10) | 0, me = ce, ce = at;
      }
      for (let st = 0; st < 16; st++) {
        const at = rotl(ue + f$3(Pe, de, we, Se) + BUF[De[st]] + ke, Ye[st]) + Ce | 0;
        ue = Ce, Ce = Se, Se = rotl(we, 10) | 0, we = de, de = at;
      }
    }
    this.set(this.h1 + me + Se | 0, this.h2 + Ee + Ce | 0, this.h3 + Be + ue | 0, this.h4 + fe + de | 0, this.h0 + ce + we | 0);
  }
  roundClean() {
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
}
const ripemd160 = /* @__PURE__ */ wrapConstructor(() => new RIPEMD160());
/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */
const Point = secp256k1.ProjectivePoint, base58check = createBase58check(sha256);
function bytesToNumber(ae) {
  return BigInt(`0x${bytesToHex$1(ae)}`);
}
function numberToBytes(ae) {
  return hexToBytes$1(ae.toString(16).padStart(64, "0"));
}
const MASTER_SECRET = utf8ToBytes$1("Bitcoin seed"), BITCOIN_VERSIONS = { private: 76066276, public: 76067358 }, HARDENED_OFFSET = 2147483648, hash160 = (ae) => ripemd160(sha256(ae)), fromU32 = (ae) => createView(ae).getUint32(0, !1), toU32 = (ae) => {
  if (!Number.isSafeInteger(ae) || ae < 0 || ae > 2 ** 32 - 1)
    throw new Error(`Invalid number=${ae}. Should be from 0 to 2 ** 32 - 1`);
  const ie = new Uint8Array(4);
  return createView(ie).setUint32(0, ae, !1), ie;
};
class HDKey {
  get fingerprint() {
    if (!this.pubHash)
      throw new Error("No publicKey set!");
    return fromU32(this.pubHash);
  }
  get identifier() {
    return this.pubHash;
  }
  get pubKeyHash() {
    return this.pubHash;
  }
  get privateKey() {
    return this.privKeyBytes || null;
  }
  get publicKey() {
    return this.pubKey || null;
  }
  get privateExtendedKey() {
    const ie = this.privateKey;
    if (!ie)
      throw new Error("No private key");
    return base58check.encode(this.serialize(this.versions.private, concatBytes$1(new Uint8Array([0]), ie)));
  }
  get publicExtendedKey() {
    if (!this.pubKey)
      throw new Error("No public key");
    return base58check.encode(this.serialize(this.versions.public, this.pubKey));
  }
  static fromMasterSeed(ie, se = BITCOIN_VERSIONS) {
    if (bytes(ie), 8 * ie.length < 128 || 8 * ie.length > 512)
      throw new Error(`HDKey: wrong seed length=${ie.length}. Should be between 128 and 512 bits; 256 bits is advised)`);
    const fe = hmac(sha512, MASTER_SECRET, ie);
    return new HDKey({
      versions: se,
      chainCode: fe.slice(32),
      privateKey: fe.slice(0, 32)
    });
  }
  static fromExtendedKey(ie, se = BITCOIN_VERSIONS) {
    const fe = base58check.decode(ie), ue = createView(fe), ce = ue.getUint32(0, !1), de = {
      versions: se,
      depth: fe[4],
      parentFingerprint: ue.getUint32(5, !1),
      index: ue.getUint32(9, !1),
      chainCode: fe.slice(13, 45)
    }, me = fe.slice(45), we = me[0] === 0;
    if (ce !== se[we ? "private" : "public"])
      throw new Error("Version mismatch");
    return we ? new HDKey({ ...de, privateKey: me.slice(1) }) : new HDKey({ ...de, publicKey: me });
  }
  static fromJSON(ie) {
    return HDKey.fromExtendedKey(ie.xpriv);
  }
  constructor(ie) {
    if (this.depth = 0, this.index = 0, this.chainCode = null, this.parentFingerprint = 0, !ie || typeof ie != "object")
      throw new Error("HDKey.constructor must not be called directly");
    if (this.versions = ie.versions || BITCOIN_VERSIONS, this.depth = ie.depth || 0, this.chainCode = ie.chainCode, this.index = ie.index || 0, this.parentFingerprint = ie.parentFingerprint || 0, !this.depth && (this.parentFingerprint || this.index))
      throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");
    if (ie.publicKey && ie.privateKey)
      throw new Error("HDKey: publicKey and privateKey at same time.");
    if (ie.privateKey) {
      if (!secp256k1.utils.isValidPrivateKey(ie.privateKey))
        throw new Error("Invalid private key");
      this.privKey = typeof ie.privateKey == "bigint" ? ie.privateKey : bytesToNumber(ie.privateKey), this.privKeyBytes = numberToBytes(this.privKey), this.pubKey = secp256k1.getPublicKey(ie.privateKey, !0);
    } else if (ie.publicKey)
      this.pubKey = Point.fromHex(ie.publicKey).toRawBytes(!0);
    else
      throw new Error("HDKey: no public or private key provided");
    this.pubHash = hash160(this.pubKey);
  }
  derive(ie) {
    if (!/^[mM]'?/.test(ie))
      throw new Error('Path must start with "m" or "M"');
    if (/^[mM]'?$/.test(ie))
      return this;
    const se = ie.replace(/^[mM]'?\//, "").split("/");
    let fe = this;
    for (const ue of se) {
      const ce = /^(\d+)('?)$/.exec(ue), de = ce && ce[1];
      if (!ce || ce.length !== 3 || typeof de != "string")
        throw new Error(`Invalid child index: ${ue}`);
      let me = +de;
      if (!Number.isSafeInteger(me) || me >= HARDENED_OFFSET)
        throw new Error("Invalid index");
      ce[2] === "'" && (me += HARDENED_OFFSET), fe = fe.deriveChild(me);
    }
    return fe;
  }
  deriveChild(ie) {
    if (!this.pubKey || !this.chainCode)
      throw new Error("No publicKey or chainCode set");
    let se = toU32(ie);
    if (ie >= HARDENED_OFFSET) {
      const me = this.privateKey;
      if (!me)
        throw new Error("Could not derive hardened child key");
      se = concatBytes$1(new Uint8Array([0]), me, se);
    } else
      se = concatBytes$1(this.pubKey, se);
    const fe = hmac(sha512, this.chainCode, se), ue = bytesToNumber(fe.slice(0, 32)), ce = fe.slice(32);
    if (!secp256k1.utils.isValidPrivateKey(ue))
      throw new Error("Tweak bigger than curve order");
    const de = {
      versions: this.versions,
      chainCode: ce,
      depth: this.depth + 1,
      parentFingerprint: this.fingerprint,
      index: ie
    };
    try {
      if (this.privateKey) {
        const me = mod(this.privKey + ue, secp256k1.CURVE.n);
        if (!secp256k1.utils.isValidPrivateKey(me))
          throw new Error("The tweak was out of range or the resulted private key is invalid");
        de.privateKey = me;
      } else {
        const me = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(ue));
        if (me.equals(Point.ZERO))
          throw new Error("The tweak was equal to negative P, which made the result key invalid");
        de.publicKey = me.toRawBytes(!0);
      }
      return new HDKey(de);
    } catch {
      return this.deriveChild(ie + 1);
    }
  }
  sign(ie) {
    if (!this.privateKey)
      throw new Error("No privateKey set!");
    return bytes(ie, 32), secp256k1.sign(ie, this.privKey).toCompactRawBytes();
  }
  verify(ie, se) {
    if (bytes(ie, 32), bytes(se, 64), !this.publicKey)
      throw new Error("No publicKey set!");
    let fe;
    try {
      fe = secp256k1.Signature.fromCompact(se);
    } catch {
      return !1;
    }
    return secp256k1.verify(fe, ie, this.publicKey);
  }
  wipePrivateData() {
    return this.privKey = void 0, this.privKeyBytes && (this.privKeyBytes.fill(0), this.privKeyBytes = void 0), this;
  }
  toJSON() {
    return {
      xpriv: this.privateExtendedKey,
      xpub: this.publicExtendedKey
    };
  }
  serialize(ie, se) {
    if (!this.chainCode)
      throw new Error("No chainCode set");
    return bytes(se, 33), concatBytes$1(toU32(ie), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, se);
  }
}
var n$8 = class On extends t$5 {
  constructor(ie) {
    super();
    let se = i$7.fromHexInput(ie);
    if (se.toUint8Array().length !== On.LENGTH)
      throw new Error(`PublicKey length should be ${On.LENGTH}`);
    this.key = se;
  }
  verifySignature(ie) {
    let { message: se, signature: fe } = ie;
    if (!(fe instanceof y$5))
      return !1;
    let ue = i$7.fromHexInput(se).toUint8Array(), ce = sha3_256(ue), de = fe.toUint8Array();
    return secp256k1.verify(de, ce, this.key.toUint8Array());
  }
  toUint8Array() {
    return this.key.toUint8Array();
  }
  serialize(ie) {
    ie.serializeBytes(this.key.toUint8Array());
  }
  static deserialize(ie) {
    let se = ie.deserializeBytes();
    return new On(se);
  }
  static isPublicKey(ie) {
    return ie instanceof On;
  }
};
n$8.LENGTH = 65;
var u$6 = n$8, t$4 = class Rn extends B$4 {
  constructor(ie) {
    super();
    let se = i$7.fromHexInput(ie);
    if (se.toUint8Array().length !== Rn.LENGTH)
      throw new Error(`PrivateKey length should be ${Rn.LENGTH}`);
    this.key = se;
  }
  static generate() {
    let ie = secp256k1.utils.randomPrivateKey();
    return new Rn(ie);
  }
  static fromDerivationPath(ie, se) {
    if (!D$3(ie))
      throw new Error(`Invalid derivation path ${ie}`);
    return Rn.fromDerivationPathInner(ie, h$6(se));
  }
  static fromDerivationPathInner(ie, se) {
    let { privateKey: fe } = HDKey.fromMasterSeed(se).derive(ie);
    if (fe === null)
      throw new Error("Invalid key");
    return new Rn(fe);
  }
  sign(ie) {
    let se = i$7.fromHexInput(ie), fe = sha3_256(se.toUint8Array()), ue = secp256k1.sign(fe, this.key.toUint8Array());
    return new y$5(ue.toCompactRawBytes());
  }
  publicKey() {
    let ie = secp256k1.getPublicKey(this.key.toUint8Array(), !1);
    return new u$6(ie);
  }
  toUint8Array() {
    return this.key.toUint8Array();
  }
  toString() {
    return this.key.toString();
  }
  serialize(ie) {
    ie.serializeBytes(this.toUint8Array());
  }
  static deserialize(ie) {
    let se = ie.deserializeBytes();
    return new Rn(se);
  }
  static isPrivateKey(ie) {
    return ie instanceof Rn;
  }
};
t$4.LENGTH = 32;
var g$1 = t$4, s$1 = class qn extends o$8 {
  constructor(ie) {
    super();
    let se = i$7.fromHexInput(ie);
    if (se.toUint8Array().length !== qn.LENGTH)
      throw new Error(`Signature length should be ${qn.LENGTH}, received ${se.toUint8Array().length}`);
    this.data = se;
  }
  toUint8Array() {
    return this.data.toUint8Array();
  }
  serialize(ie) {
    ie.serializeBytes(this.data.toUint8Array());
  }
  static deserialize(ie) {
    let se = ie.deserializeBytes();
    return new qn(se);
  }
};
s$1.LENGTH = 64;
var y$5 = s$1, b$4 = class jn extends a$9 {
  constructor(ie) {
    if (super(), this.publicKey = ie, ie instanceof m$5)
      this.variant = 0;
    else if (ie instanceof u$6)
      this.variant = 1;
    else
      throw new Error("Unsupported public key type");
  }
  verifySignature(ie) {
    let { message: se, signature: fe } = ie;
    return fe instanceof o$6 ? this.publicKey.verifySignature({ message: se, signature: fe.signature }) : !1;
  }
  authKey() {
    return c$6.fromSchemeAndBytes({ scheme: 2, input: this.toUint8Array() });
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(this.variant), this.publicKey.serialize(ie);
  }
  static deserialize(ie) {
    let se = ie.deserializeUleb128AsU32(), fe;
    switch (se) {
      case 0:
        fe = m$5.deserialize(ie);
        break;
      case 1:
        fe = u$6.deserialize(ie);
        break;
      default:
        throw new Error(`Unknown variant index for AnyPublicKey: ${se}`);
    }
    return new jn(fe);
  }
  static isPublicKey(ie) {
    return ie instanceof jn;
  }
  isEd25519() {
    return this.publicKey instanceof m$5;
  }
  isSecp256k1PublicKey() {
    return this.publicKey instanceof u$6;
  }
}, o$6 = class Mi extends o$8 {
  constructor(ie) {
    if (super(), this.signature = ie, ie instanceof y$7)
      this.variant = 0;
    else if (ie instanceof y$5)
      this.variant = 1;
    else
      throw new Error("Unsupported signature type");
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(this.variant), this.signature.serialize(ie);
  }
  static deserialize(ie) {
    let se = ie.deserializeUleb128AsU32(), fe;
    switch (se) {
      case 0:
        fe = y$7.deserialize(ie);
        break;
      case 1:
        fe = y$5.deserialize(ie);
        break;
      default:
        throw new Error(`Unknown variant index for AnySignature: ${se}`);
    }
    return new Mi(fe);
  }
};
function f$2(ae) {
  let ie = ae;
  return ie -= ie >> 1 & 1431655765, ie = (ie & 858993459) + (ie >> 2 & 858993459), (ie + (ie >> 4) & 252645135) * 16843009 >> 24;
}
var A$4 = class Bi extends a$9 {
  constructor(ie) {
    super();
    let { publicKeys: se, signaturesRequired: fe } = ie;
    if (fe < 1)
      throw new Error("The number of required signatures needs to be greater than 0");
    if (se.length < fe)
      throw new Error(`Provided ${se.length} public keys is smaller than the ${fe} required signatures`);
    this.publicKeys = se.map((ue) => ue instanceof b$4 ? ue : new b$4(ue)), this.signaturesRequired = fe;
  }
  verifySignature(ie) {
    throw new Error("not implemented");
  }
  authKey() {
    return c$6.fromSchemeAndBytes({ scheme: 3, input: this.toUint8Array() });
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  serialize(ie) {
    ie.serializeVector(this.publicKeys), ie.serializeU8(this.signaturesRequired);
  }
  static deserialize(ie) {
    let se = ie.deserializeVector(b$4), fe = ie.deserializeU8();
    return new Bi({ publicKeys: se, signaturesRequired: fe });
  }
  createBitmap(ie) {
    let { bits: se } = ie, fe = 128, ue = new Uint8Array([0, 0, 0, 0]), ce = /* @__PURE__ */ new Set();
    return se.forEach((de, me) => {
      if (me + 1 > this.publicKeys.length)
        throw new Error(`Signature index ${me + 1} is out of public keys range, ${this.publicKeys.length}.`);
      if (ce.has(de))
        throw new Error(`Duplicate bit ${de} detected.`);
      ce.add(de);
      let we = Math.floor(de / 8), Ee = ue[we];
      Ee |= fe >> de % 8, ue[we] = Ee;
    }), ue;
  }
}, a$6 = class Bn extends o$8 {
  constructor(ie) {
    super();
    let { signatures: se, bitmap: fe } = ie;
    if (se.length > Bn.MAX_SIGNATURES_SUPPORTED)
      throw new Error(`The number of signatures cannot be greater than ${Bn.MAX_SIGNATURES_SUPPORTED}`);
    if (this.signatures = se.map((ce) => ce instanceof o$6 ? ce : new o$6(ce)), !(fe instanceof Uint8Array))
      this.bitmap = Bn.createBitmap({ bits: fe });
    else {
      if (fe.length !== Bn.BITMAP_LEN)
        throw new Error(`"bitmap" length should be ${Bn.BITMAP_LEN}`);
      this.bitmap = fe;
    }
    let ue = this.bitmap.reduce((ce, de) => ce + f$2(de), 0);
    if (ue !== this.signatures.length)
      throw new Error(`Expecting ${ue} signatures from the bitmap, but got ${this.signatures.length}`);
  }
  static createBitmap(ie) {
    let { bits: se } = ie, fe = 128, ue = new Uint8Array([0, 0, 0, 0]), ce = /* @__PURE__ */ new Set();
    return se.forEach((de) => {
      if (de >= Bn.MAX_SIGNATURES_SUPPORTED)
        throw new Error(`Cannot have a signature larger than ${Bn.MAX_SIGNATURES_SUPPORTED - 1}.`);
      if (ce.has(de))
        throw new Error("Duplicate bits detected.");
      ce.add(de);
      let me = Math.floor(de / 8), we = ue[me];
      we |= fe >> de % 8, ue[me] = we;
    }), ue;
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  serialize(ie) {
    ie.serializeVector(this.signatures), ie.serializeBytes(this.bitmap);
  }
  static deserialize(ie) {
    let se = ie.deserializeBytes(), fe = se.reduce((ce, de) => ce + f$2(de), 0), ue = [];
    for (let ce = 0; ce < fe; ce += 1) {
      let de = o$6.deserialize(ie);
      ue.push(de);
    }
    return new Bn({ signatures: ue, bitmap: se });
  }
};
a$6.BITMAP_LEN = 4, a$6.MAX_SIGNATURES_SUPPORTED = a$6.BITMAP_LEN * 8;
var n$7 = class extends B$4 {
  static deserialize(ie) {
    let se = ie.deserializeUleb128AsU32();
    switch (se) {
      case 0:
        return a$5.load(ie);
      case 1:
        return u$5.load(ie);
      case 2:
        return l$4.load(ie);
      case 3:
        return c$5.load(ie);
      default:
        throw new Error(`Unknown variant index for AccountAuthenticator: ${se}`);
    }
  }
  isEd25519() {
    return this instanceof a$5;
  }
  isMultiEd25519() {
    return this instanceof u$5;
  }
  isSingleKey() {
    return this instanceof l$4;
  }
  isMultiKey() {
    return this instanceof c$5;
  }
}, a$5 = class Ti extends n$7 {
  constructor(ie, se) {
    super(), this.public_key = ie, this.signature = se;
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(0), this.public_key.serialize(ie), this.signature.serialize(ie);
  }
  static load(ie) {
    let se = m$5.deserialize(ie), fe = y$7.deserialize(ie);
    return new Ti(se, fe);
  }
}, u$5 = class Ri extends n$7 {
  constructor(ie, se) {
    super(), this.public_key = ie, this.signature = se;
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(1), this.public_key.serialize(ie), this.signature.serialize(ie);
  }
  static load(ie) {
    let se = d$3.deserialize(ie), fe = y$6.deserialize(ie);
    return new Ri(se, fe);
  }
}, l$4 = class ki extends n$7 {
  constructor(ie, se) {
    super(), this.public_key = ie, this.signature = se;
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(2), this.public_key.serialize(ie), this.signature.serialize(ie);
  }
  static load(ie) {
    let se = b$4.deserialize(ie), fe = o$6.deserialize(ie);
    return new ki(se, fe);
  }
}, c$5 = class Ci extends n$7 {
  constructor(ie, se, fe) {
    super(), this.public_keys = ie, this.signatures = se, this.signatures_bitmap = fe;
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(3), this.public_keys.serialize(ie), ie.serializeVector(this.signatures), ie.serializeBytes(this.signatures_bitmap);
  }
  static load(ie) {
    let se = A$4.deserialize(ie), fe = ie.deserializeVector(o$6), ue = ie.deserializeBytes();
    return new Ci(se, fe, ue);
  }
}, a$4 = class Vn {
  constructor(ie) {
    this.signingScheme = 0;
    let { privateKey: se, address: fe } = ie;
    this.privateKey = se, this.publicKey = se.publicKey(), this.accountAddress = fe ? c$b.from(fe) : this.publicKey.authKey().derivedAddress();
  }
  static generate() {
    let ie = x$2.generate();
    return new Vn({ privateKey: ie });
  }
  static fromDerivationPath(ie) {
    let { path: se, mnemonic: fe } = ie, ue = x$2.fromDerivationPath(se, fe);
    return new Vn({ privateKey: ue });
  }
  verifySignature(ie) {
    return this.publicKey.verifySignature(ie);
  }
  signWithAuthenticator(ie) {
    let se = this.privateKey.sign(ie);
    return new a$5(this.publicKey, se);
  }
  sign(ie) {
    return this.signWithAuthenticator(ie).signature;
  }
}, p$2 = class Zn {
  constructor(ie) {
    this.signingScheme = 2;
    let { privateKey: se, address: fe } = ie;
    this.privateKey = se, this.publicKey = new b$4(se.publicKey()), this.accountAddress = fe ? c$b.from(fe) : this.publicKey.authKey().derivedAddress();
  }
  static generate(ie = {}) {
    let { scheme: se = 0 } = ie, fe;
    switch (se) {
      case 0:
        fe = x$2.generate();
        break;
      case 2:
        fe = g$1.generate();
        break;
      default:
        throw new Error(`Unsupported signature scheme ${se}`);
    }
    return new Zn({ privateKey: fe });
  }
  static fromDerivationPath(ie) {
    let { scheme: se = 0, path: fe, mnemonic: ue } = ie, ce;
    switch (se) {
      case 0:
        ce = x$2.fromDerivationPath(fe, ue);
        break;
      case 2:
        ce = g$1.fromDerivationPath(fe, ue);
        break;
      default:
        throw new Error(`Unsupported signature scheme ${se}`);
    }
    return new Zn({ privateKey: ce });
  }
  verifySignature(ie) {
    return this.publicKey.verifySignature(ie);
  }
  signWithAuthenticator(ie) {
    let se = this.privateKey.sign(ie), fe = new o$6(se);
    return new l$4(this.publicKey, fe);
  }
  sign(ie) {
    return this.signWithAuthenticator(ie).signature;
  }
}, o$5 = class {
  static generate(ie = {}) {
    let { scheme: se = 0, legacy: fe = !0 } = ie;
    return se === 0 && fe ? a$4.generate() : p$2.generate({ scheme: se });
  }
  static fromPrivateKey(ie) {
    let { privateKey: se, address: fe, legacy: ue = !0 } = ie;
    return se instanceof x$2 && ue ? new a$4({ privateKey: se, address: fe }) : new p$2({ privateKey: se, address: fe });
  }
  static fromPrivateKeyAndAddress(ie) {
    return this.fromPrivateKey(ie);
  }
  static fromDerivationPath(ie) {
    let { scheme: se = 0, mnemonic: fe, path: ue, legacy: ce = !0 } = ie;
    return se === 0 && ce ? a$4.fromDerivationPath({ mnemonic: fe, path: ue }) : p$2.fromDerivationPath({ scheme: se, mnemonic: fe, path: ue });
  }
  static authKey(ie) {
    let { publicKey: se } = ie;
    return se.authKey();
  }
  verifySignature(ie) {
    return this.publicKey.verifySignature(ie);
  }
};
async function M$3(ae) {
  let { aptosConfig: ie, accountAddress: se } = ae, { data: fe } = await g$5({ aptosConfig: ie, originMethod: "getInfo", path: `accounts/${c$b.from(se).toString()}` });
  return fe;
}
async function go(ae) {
  let { aptosConfig: ie, accountAddress: se, options: fe } = ae;
  return f$a({ aptosConfig: ie, originMethod: "getModules", path: `accounts/${c$b.from(se).toString()}/modules`, params: { ledger_version: fe?.ledgerVersion, start: fe?.offset, limit: fe?.limit ?? 1e3 } });
}
async function Ao(ae) {
  return ae.options?.ledgerVersion !== void 0 ? P$2(ae) : m$9(async () => P$2(ae), `module-${ae.accountAddress}-${ae.moduleName}`, 1e3 * 60 * 5)();
}
async function P$2(ae) {
  let { aptosConfig: ie, accountAddress: se, moduleName: fe, options: ue } = ae, { data: ce } = await g$5({ aptosConfig: ie, originMethod: "getModule", path: `accounts/${c$b.from(se).toString()}/module/${fe}`, params: { ledger_version: ue?.ledgerVersion } });
  return ce;
}
async function po(ae) {
  let { aptosConfig: ie, accountAddress: se, options: fe } = ae;
  return f$a({ aptosConfig: ie, originMethod: "getTransactions", path: `accounts/${c$b.from(se).toString()}/transactions`, params: { start: fe?.offset, limit: fe?.limit } });
}
async function fo(ae) {
  let { aptosConfig: ie, accountAddress: se, options: fe } = ae;
  return f$a({ aptosConfig: ie, originMethod: "getResources", path: `accounts/${c$b.from(se).toString()}/resources`, params: { ledger_version: fe?.ledgerVersion, start: fe?.offset, limit: fe?.limit ?? 999 } });
}
async function K$2(ae) {
  let { aptosConfig: ie, accountAddress: se, resourceType: fe, options: ue } = ae, { data: ce } = await g$5({ aptosConfig: ie, originMethod: "getResource", path: `accounts/${c$b.from(se).toString()}/resource/${fe}`, params: { ledger_version: ue?.ledgerVersion } });
  return ce.data;
}
async function Q$1(ae) {
  let { aptosConfig: ie, authenticationKey: se, options: fe } = ae, ue = await K$2({ aptosConfig: ie, accountAddress: "0x1", resourceType: "0x1::account::OriginatingAddress", options: fe }), { address_map: { handle: ce } } = ue, de = c$b.from(se);
  try {
    let me = await C$2({ aptosConfig: ie, handle: ce, data: { key: de.toString(), key_type: "address", value_type: "address" }, options: fe });
    return c$b.from(me);
  } catch (me) {
    if (me instanceof s$3 && me.data.error_code === "table_item_not_found")
      return de;
    throw me;
  }
}
async function lo(ae) {
  let { aptosConfig: ie, accountAddress: se } = ae, fe = { owner_address: { _eq: c$b.from(se).toStringLong() }, amount: { _gt: 0 } }, ue = await p$6({ aptosConfig: ie, query: { query: m$b, variables: { where_condition: fe } }, originMethod: "getAccountTokensCount" });
  return ue.current_token_ownerships_v2_aggregate.aggregate ? ue.current_token_ownerships_v2_aggregate.aggregate.count : 0;
}
async function yo(ae) {
  let { aptosConfig: ie, accountAddress: se, options: fe } = ae, ue = { owner_address: { _eq: c$b.from(se).toStringLong() }, amount: { _gt: 0 } };
  fe?.tokenStandard && (ue.token_standard = { _eq: fe?.tokenStandard });
  let ce = { query: l$7, variables: { where_condition: ue, offset: fe?.offset, limit: fe?.limit, order_by: fe?.orderBy } };
  return (await p$6({ aptosConfig: ie, query: ce, originMethod: "getAccountOwnedTokens" })).current_token_ownerships_v2;
}
async function mo(ae) {
  let { aptosConfig: ie, accountAddress: se, collectionAddress: fe, options: ue } = ae, ce = c$b.from(se).toStringLong(), de = c$b.from(fe).toStringLong(), me = { owner_address: { _eq: ce }, current_token_data: { collection_id: { _eq: de } }, amount: { _gt: 0 } };
  ue?.tokenStandard && (me.token_standard = { _eq: ue?.tokenStandard });
  let we = { query: p$8, variables: { where_condition: me, offset: ue?.offset, limit: ue?.limit, order_by: ue?.orderBy } };
  return (await p$6({ aptosConfig: ie, query: we, originMethod: "getAccountOwnedTokensFromCollectionAddress" })).current_token_ownerships_v2;
}
async function _o(ae) {
  let { aptosConfig: ie, accountAddress: se, options: fe } = ae, ue = { owner_address: { _eq: c$b.from(se).toStringLong() }, amount: { _gt: 0 } };
  fe?.tokenStandard && (ue.current_collection = { token_standard: { _eq: fe?.tokenStandard } });
  let ce = { query: c$a, variables: { where_condition: ue, offset: fe?.offset, limit: fe?.limit, order_by: fe?.orderBy } };
  return (await p$6({ aptosConfig: ie, query: ce, originMethod: "getAccountCollectionsWithOwnedTokens" })).current_collection_ownership_v2_view;
}
async function Co(ae) {
  let { aptosConfig: ie, accountAddress: se } = ae, fe = c$b.from(se).toStringLong(), ue = await p$6({ aptosConfig: ie, query: { query: g$6, variables: { address: fe } }, originMethod: "getAccountTransactionsCount" });
  return ue.account_transactions_aggregate.aggregate ? ue.account_transactions_aggregate.aggregate.count : 0;
}
async function ho(ae) {
  let { aptosConfig: ie, accountAddress: se, coinType: fe } = ae, ue = c$b.from(se).toStringLong(), ce = await I$1({ aptosConfig: ie, accountAddress: ue, options: { where: { asset_type: { _eq: fe } } } });
  return ce[0] ? ce[0].amount : 0;
}
async function I$1(ae) {
  let { aptosConfig: ie, accountAddress: se, options: fe } = ae, ue = c$b.from(se).toStringLong(), ce = { ...fe?.where, owner_address: { _eq: ue } }, de = { query: u$8, variables: { where_condition: ce, offset: fe?.offset, limit: fe?.limit, order_by: fe?.orderBy } };
  return (await p$6({ aptosConfig: ie, query: de, originMethod: "getAccountCoinsData" })).current_fungible_asset_balances;
}
async function wo(ae) {
  let { aptosConfig: ie, accountAddress: se } = ae, fe = c$b.from(se).toStringLong(), ue = await p$6({ aptosConfig: ie, query: { query: _$3, variables: { address: fe } }, originMethod: "getAccountCoinsCount" });
  if (!ue.current_fungible_asset_balances_aggregate.aggregate)
    throw Error("Failed to get the count of account coins");
  return ue.current_fungible_asset_balances_aggregate.aggregate.count;
}
async function ko(ae) {
  let { aptosConfig: ie, accountAddress: se, options: fe } = ae, ue = { owner_address: { _eq: c$b.from(se).toStringLong() } }, ce = { query: d$7, variables: { where_condition: ue, offset: fe?.offset, limit: fe?.limit, order_by: fe?.orderBy } };
  return (await p$6({ aptosConfig: ie, query: ce, originMethod: "getAccountOwnedObjects" })).current_objects;
}
async function To(ae) {
  let { aptosConfig: ie, privateKey: se } = ae, fe = new b$4(se.publicKey());
  if (se instanceof g$1) {
    let ue = c$6.fromPublicKeyAndScheme({ publicKey: fe, scheme: 2 }).derivedAddress();
    return o$5.fromPrivateKeyAndAddress({ privateKey: se, address: ue });
  }
  if (se instanceof x$2) {
    let ue = c$6.fromPublicKeyAndScheme({ publicKey: fe, scheme: 2 });
    if (await G$2({ authKey: ue, aptosConfig: ie })) {
      let de = ue.derivedAddress();
      return o$5.fromPrivateKeyAndAddress({ privateKey: se, address: de, legacy: !1 });
    }
    let ce = c$6.fromPublicKeyAndScheme({ publicKey: fe.publicKey, scheme: 0 });
    if (await G$2({ authKey: ce, aptosConfig: ie })) {
      let de = ce.derivedAddress();
      return o$5.fromPrivateKeyAndAddress({ privateKey: se, address: de, legacy: !0 });
    }
  }
  throw new Error(`Can't derive account from private key ${se}`);
}
async function G$2(ae) {
  let { aptosConfig: ie, authKey: se } = ae, fe = await Q$1({ aptosConfig: ie, authenticationKey: se.derivedAddress() });
  try {
    return await M$3({ aptosConfig: ie, accountAddress: fe }), !0;
  } catch (ue) {
    if (ue.status === 404)
      return !1;
    throw new Error(`Error while looking for an account info ${fe.toString()}`);
  }
}
var R$2 = new TextEncoder();
function Z$2(ae) {
  return ae?.map((ie) => D$4(ie) ? Z$3(ie) : ie) ?? [];
}
async function P$1(ae, ie, se, fe) {
  let ue = (await Ao({ aptosConfig: fe, accountAddress: ae, moduleName: ie })).abi?.exposed_functions.find((me) => me.name === se);
  if (!ue)
    throw new Error(`Could not find entry function ABI for '${ae}::${ie}::${se}'`);
  if (!ue.is_entry)
    throw new Error(`'${ae}::${ie}::${se}' is not an entry function`);
  let ce = W$2(ue), de = [];
  for (let me = ce; me < ue.params.length; me += 1)
    de.push(Z$3(ue.params[me], { allowGenerics: !0 }));
  return { typeParameters: ue.generic_type_params, parameters: de };
}
function a$3(ae, ie, se, fe, ue) {
  if (fe >= ie.parameters.length)
    throw new Error(`Too many arguments for '${ae}', expected ${ie.parameters.length}`);
  let ce = ie.parameters[fe];
  return U$3(se, ce, fe, ue);
}
function U$3(ae, ie, se, fe) {
  return G$3(ae) ? (m$4(ie, ae, se), ae) : X$2(ae, ie, se, fe);
}
function X$2(ae, ie, se, fe) {
  if (ie.isBool()) {
    if (M$4(ae))
      return new U$6(ae);
    R$3("boolean", se);
  }
  if (ie.isAddress()) {
    if (D$4(ae))
      return c$b.fromString(ae);
    R$3("string | AccountAddress", se);
  }
  if (ie.isU8()) {
    if (N$2(ae))
      return new p$3(ae);
    R$3("number", se);
  }
  if (ie.isU16()) {
    if (N$2(ae))
      return new b$6(ae);
    R$3("number", se);
  }
  if (ie.isU32()) {
    if (N$2(ae))
      return new y$9(ae);
    R$3("number", se);
  }
  if (ie.isU64()) {
    if (P$3(ae))
      return new m$7(BigInt(ae));
    R$3("bigint | number | string", se);
  }
  if (ie.isU128()) {
    if (P$3(ae))
      return new B$3(BigInt(ae));
    R$3("bigint | number | string", se);
  }
  if (ie.isU256()) {
    if (P$3(ae))
      return new v$3(BigInt(ae));
    R$3("bigint | number | string", se);
  }
  if (ie.isGeneric()) {
    let ue = ie.value;
    if (ue < 0 || ue >= fe.length)
      throw new Error(`Generic argument ${ie.toString()} is invalid for argument ${se}`);
    return U$3(ae, fe[ue], se, fe);
  }
  if (ie.isVector()) {
    if (ie.value.isU8()) {
      if (D$4(ae))
        return t$6.U8(R$2.encode(ae));
      if (ae instanceof Uint8Array)
        return t$6.U8(ae);
      if (ae instanceof ArrayBuffer)
        return t$6.U8(new Uint8Array(ae));
    }
    if (Array.isArray(ae))
      return new t$6(ae.map((ue) => U$3(ue, ie.value, se, fe)));
    throw new Error(`Type mismatch for argument ${se}, type '${ie.toString()}'`);
  }
  if (ie.isStruct()) {
    if (ie.isString()) {
      if (D$4(ae))
        return new a$a(ae);
      R$3("string", se);
    }
    if (ie.isObject()) {
      if (D$4(ae))
        return c$b.fromString(ae);
      R$3("string | AccountAddress", se);
    }
    if (ie.isOption())
      return w(ae) ? new f$5(null) : new f$5(U$3(ae, ie.value.typeArgs[0], se, fe));
    throw new Error(`Unsupported struct input type for argument ${se}, type '${ie.toString()}'`);
  }
  throw new Error(`Type mismatch for argument ${se}, type '${ie.toString()}'`);
}
function m$4(ae, ie, se) {
  if (ae.isBool()) {
    if (A$6(ie))
      return;
    R$3("Bool", se);
  }
  if (ae.isAddress()) {
    if (T$1(ie))
      return;
    R$3("AccountAddress", se);
  }
  if (ae.isU8()) {
    if (x$4(ie))
      return;
    R$3("U8", se);
  }
  if (ae.isU16()) {
    if (S$2(ie))
      return;
    R$3("U16", se);
  }
  if (ae.isU32()) {
    if (B$2(ie))
      return;
    R$3("U32", se);
  }
  if (ae.isU64()) {
    if (U$5(ie))
      return;
    R$3("U64", se);
  }
  if (ae.isU128()) {
    if (I$2(ie))
      return;
    R$3("U128", se);
  }
  if (ae.isU256()) {
    if (b$5(ie))
      return;
    R$3("U256", se);
  }
  if (ae.isVector()) {
    if (ie instanceof t$6) {
      ie.values.length > 0 && m$4(ae.value, ie.values[0], se);
      return;
    }
    R$3("MoveVector", se);
  }
  if (ae instanceof b$7) {
    if (ae.isString()) {
      if (E$2(ie))
        return;
      R$3("MoveString", se);
    }
    if (ae.isObject()) {
      if (T$1(ie))
        return;
      R$3("AccountAddress", se);
    }
    if (ae.isOption()) {
      if (ie instanceof f$5) {
        ie.value !== void 0 && m$4(ae.value.typeArgs[0], ie.value, se);
        return;
      }
      R$3("MoveOption", se);
    }
  }
  throw new Error(`Type mismatch for argument ${se}, expected '${ae.toString()}'`);
}
var c$4 = class extends B$4 {
  static deserialize(ie) {
    let se = ie.deserializeUleb128AsU32();
    switch (se) {
      case 0:
        return d$2.load(ie);
      case 1:
        return u$4.load(ie);
      case 2:
        return l$3.load(ie);
      case 3:
        return A$3.load(ie);
      case 4:
        return y$4.load(ie);
      default:
        throw new Error(`Unknown variant index for TransactionAuthenticator: ${se}`);
    }
  }
}, d$2 = class Ii extends c$4 {
  constructor(ie, se) {
    super(), this.public_key = ie, this.signature = se;
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(0), this.public_key.serialize(ie), this.signature.serialize(ie);
  }
  static load(ie) {
    let se = m$5.deserialize(ie), fe = y$7.deserialize(ie);
    return new Ii(se, fe);
  }
}, u$4 = class Ni extends c$4 {
  constructor(ie, se) {
    super(), this.public_key = ie, this.signature = se;
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(1), this.public_key.serialize(ie), this.signature.serialize(ie);
  }
  static load(ie) {
    let se = d$3.deserialize(ie), fe = y$6.deserialize(ie);
    return new Ni(se, fe);
  }
}, l$3 = class Oi extends c$4 {
  constructor(ie, se, fe) {
    super(), this.sender = ie, this.secondary_signer_addresses = se, this.secondary_signers = fe;
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(2), this.sender.serialize(ie), ie.serializeVector(this.secondary_signer_addresses), ie.serializeVector(this.secondary_signers);
  }
  static load(ie) {
    let se = n$7.deserialize(ie), fe = ie.deserializeVector(c$b), ue = ie.deserializeVector(n$7);
    return new Oi(se, fe, ue);
  }
}, A$3 = class Li extends c$4 {
  constructor(ie, se, fe, ue) {
    super(), this.sender = ie, this.secondary_signer_addresses = se, this.secondary_signers = fe, this.fee_payer = ue;
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(3), this.sender.serialize(ie), ie.serializeVector(this.secondary_signer_addresses), ie.serializeVector(this.secondary_signers), this.fee_payer.address.serialize(ie), this.fee_payer.authenticator.serialize(ie);
  }
  static load(ie) {
    let se = n$7.deserialize(ie), fe = ie.deserializeVector(c$b), ue = ie.deserializeVector(n$7), ce = c$b.deserialize(ie), de = n$7.deserialize(ie), me = { address: ce, authenticator: de };
    return new Li(se, fe, ue, me);
  }
}, y$4 = class Ui extends c$4 {
  constructor(ie) {
    super(), this.sender = ie;
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(4), this.sender.serialize(ie);
  }
  static load(ie) {
    let se = n$7.deserialize(ie);
    return new Ui(se);
  }
}, o$4 = class Jn extends B$4 {
  constructor(ie, se) {
    super(), this.address = ie, this.name = se;
  }
  static fromStr(ie) {
    let se = ie.split("::");
    if (se.length !== 2)
      throw new Error("Invalid module id.");
    return new Jn(c$b.fromString(se[0]), new r$6(se[1]));
  }
  serialize(ie) {
    this.address.serialize(ie), this.name.serialize(ie);
  }
  static deserialize(ie) {
    let se = c$b.deserialize(ie), fe = r$6.deserialize(ie);
    return new Jn(se, fe);
  }
}, t$3 = class Fi extends B$4 {
  constructor(ie) {
    super(), this.value = new t$7(ie);
  }
  serialize(ie) {
    ie.serialize(this.value);
  }
  serializeForEntryFunction(ie) {
    ie.serializeU32AsUleb128(this.value.value.length), ie.serialize(this);
  }
  static deserialize(ie, se) {
    let fe = t$7.deserialize(ie, se);
    return new Fi(fe.value);
  }
};
function D$2(ae) {
  let ie = ae.deserializeUleb128AsU32();
  switch (ie) {
    case 0:
      return p$3.deserialize(ae);
    case 1:
      return m$7.deserialize(ae);
    case 2:
      return B$3.deserialize(ae);
    case 3:
      return c$b.deserialize(ae);
    case 4:
      return t$6.deserialize(ae, p$3);
    case 5:
      return U$6.deserialize(ae);
    case 6:
      return b$6.deserialize(ae);
    case 7:
      return y$9.deserialize(ae);
    case 8:
      return v$3.deserialize(ae);
    default:
      throw new Error(`Unknown variant index for ScriptTransactionArgument: ${ie}`);
  }
}
var a$2 = class extends B$4 {
  static deserialize(ie) {
    let se = ie.deserializeUleb128AsU32();
    switch (se) {
      case 0:
        return A$2.load(ie);
      case 2:
        return z$1.load(ie);
      case 3:
        return h$5.load(ie);
      default:
        throw new Error(`Unknown variant index for TransactionPayload: ${se}`);
    }
  }
}, A$2 = class Di extends a$2 {
  constructor(ie) {
    super(), this.script = ie;
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(0), this.script.serialize(ie);
  }
  static load(ie) {
    let se = U$2.deserialize(ie);
    return new Di(se);
  }
}, z$1 = class Hi extends a$2 {
  constructor(ie) {
    super(), this.entryFunction = ie;
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(2), this.entryFunction.serialize(ie);
  }
  static load(ie) {
    let se = l$2.deserialize(ie);
    return new Hi(se);
  }
}, h$5 = class qi extends a$2 {
  constructor(ie) {
    super(), this.multiSig = ie;
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(3), this.multiSig.serialize(ie);
  }
  static load(ie) {
    let se = f$1.deserialize(ie);
    return new qi(se);
  }
}, l$2 = class Xn {
  constructor(ie, se, fe, ue) {
    this.module_name = ie, this.function_name = se, this.type_args = fe, this.args = ue;
  }
  static build(ie, se, fe, ue) {
    return new Xn(o$4.fromStr(ie), new r$6(se), fe, ue);
  }
  serialize(ie) {
    this.module_name.serialize(ie), this.function_name.serialize(ie), ie.serializeVector(this.type_args), ie.serializeU32AsUleb128(this.args.length), this.args.forEach((se) => {
      se.serializeForEntryFunction(ie);
    });
  }
  static deserialize(ie) {
    let se = o$4.deserialize(ie), fe = r$6.deserialize(ie), ue = ie.deserializeVector(t$8), ce = ie.deserializeUleb128AsU32(), de = new Array();
    for (let me = 0; me < ce; me += 1) {
      let we = ie.deserializeUleb128AsU32(), Ee = t$3.deserialize(ie, we);
      de.push(Ee);
    }
    return new Xn(se, fe, ue, de);
  }
}, U$2 = class Ki {
  constructor(ie, se, fe) {
    this.bytecode = ie, this.type_args = se, this.args = fe;
  }
  serialize(ie) {
    ie.serializeBytes(this.bytecode), ie.serializeVector(this.type_args), ie.serializeU32AsUleb128(this.args.length), this.args.forEach((se) => {
      se.serializeForScriptFunction(ie);
    });
  }
  static deserialize(ie) {
    let se = ie.deserializeBytes(), fe = ie.deserializeVector(t$8), ue = ie.deserializeUleb128AsU32(), ce = new Array();
    for (let de = 0; de < ue; de += 1) {
      let me = D$2(ie);
      ce.push(me);
    }
    return new Ki(se, fe, ce);
  }
}, f$1 = class zi {
  constructor(ie, se) {
    this.multisig_address = ie, this.transaction_payload = se;
  }
  serialize(ie) {
    this.multisig_address.serialize(ie), this.transaction_payload === void 0 ? ie.serializeBool(!1) : (ie.serializeBool(!0), this.transaction_payload.serialize(ie));
  }
  static deserialize(ie) {
    let se = c$b.deserialize(ie), fe = ie.deserializeBool(), ue;
    return fe && (ue = b$3.deserialize(ie)), new zi(se, ue);
  }
}, b$3 = class ji extends B$4 {
  constructor(ie) {
    super(), this.transaction_payload = ie;
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(0), this.transaction_payload.serialize(ie);
  }
  static deserialize(ie) {
    return ie.deserializeUleb128AsU32(), new ji(l$2.deserialize(ie));
  }
}, r$2 = class Gi extends B$4 {
  constructor(ie) {
    super(), this.chainId = ie;
  }
  serialize(ie) {
    ie.serializeU8(this.chainId);
  }
  static deserialize(ie) {
    let se = ie.deserializeU8();
    return new Gi(se);
  }
}, o$3 = class Vi extends B$4 {
  constructor(ie, se, fe, ue, ce, de, me) {
    super(), this.sender = ie, this.sequence_number = se, this.payload = fe, this.max_gas_amount = ue, this.gas_unit_price = ce, this.expiration_timestamp_secs = de, this.chain_id = me;
  }
  serialize(ie) {
    this.sender.serialize(ie), ie.serializeU64(this.sequence_number), this.payload.serialize(ie), ie.serializeU64(this.max_gas_amount), ie.serializeU64(this.gas_unit_price), ie.serializeU64(this.expiration_timestamp_secs), this.chain_id.serialize(ie);
  }
  static deserialize(ie) {
    let se = c$b.deserialize(ie), fe = ie.deserializeU64(), ue = a$2.deserialize(ie), ce = ie.deserializeU64(), de = ie.deserializeU64(), me = ie.deserializeU64(), we = r$2.deserialize(ie);
    return new Vi(se, fe, ue, ce, de, me, we);
  }
}, c$3 = class extends B$4 {
  static deserialize(ie) {
    let se = ie.deserializeUleb128AsU32();
    switch (se) {
      case 0:
        return p$1.load(ie);
      case 1:
        return y$3.load(ie);
      default:
        throw new Error(`Unknown variant index for RawTransactionWithData: ${se}`);
    }
  }
}, p$1 = class Wi extends c$3 {
  constructor(ie, se) {
    super(), this.raw_txn = ie, this.secondary_signer_addresses = se;
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(0), this.raw_txn.serialize(ie), ie.serializeVector(this.secondary_signer_addresses);
  }
  static load(ie) {
    let se = o$3.deserialize(ie), fe = ie.deserializeVector(c$b);
    return new Wi(se, fe);
  }
}, y$3 = class Zi extends c$3 {
  constructor(ie, se, fe) {
    super(), this.raw_txn = ie, this.secondary_signer_addresses = se, this.fee_payer_address = fe;
  }
  serialize(ie) {
    ie.serializeU32AsUleb128(1), this.raw_txn.serialize(ie), ie.serializeVector(this.secondary_signer_addresses), this.fee_payer_address.serialize(ie);
  }
  static load(ie) {
    let se = o$3.deserialize(ie), fe = ie.deserializeVector(c$b), ue = c$b.deserialize(ie);
    return new Zi(se, fe, ue);
  }
}, n$6 = class Ji extends B$4 {
  constructor(ie, se) {
    super(), this.raw_txn = ie, this.authenticator = se;
  }
  serialize(ie) {
    this.raw_txn.serialize(ie), this.authenticator.serialize(ie);
  }
  static deserialize(ie) {
    let se = o$3.deserialize(ie), fe = c$4.deserialize(ie);
    return new Ji(se, fe);
  }
}, n$5 = { mainnet: "https://indexer.mainnet.aptoslabs.com/v1/graphql", testnet: "https://indexer-testnet.staging.gcp.aptosdev.com/v1/graphql", devnet: "https://indexer-devnet.staging.gcp.aptosdev.com/v1/graphql", randomnet: "https://indexer-randomnet.hasura.app/v1/graphql", local: "http://127.0.0.1:8090/v1/graphql" }, o$2 = { mainnet: "https://fullnode.mainnet.aptoslabs.com/v1", testnet: "https://fullnode.testnet.aptoslabs.com/v1", devnet: "https://fullnode.devnet.aptoslabs.com/v1", randomnet: "https://fullnode.random.aptoslabs.com/v1", local: "http://127.0.0.1:8080/v1" }, a$1 = { mainnet: "https://faucet.mainnet.aptoslabs.com", testnet: "https://faucet.testnet.aptoslabs.com", devnet: "https://faucet.devnet.aptoslabs.com", randomnet: "https://faucet.random.aptoslabs.com", local: "http://127.0.0.1:8081" }, e = ((ae) => (ae.MAINNET = "mainnet", ae.TESTNET = "testnet", ae.DEVNET = "devnet", ae.RANDOMNET = "randomnet", ae.LOCAL = "local", ae.CUSTOM = "custom", ae))(e || {}), s = { mainnet: 1, testnet: 2, randomnet: 70 };
async function Fn(ae) {
  if ($$2(ae))
    return cn(ae);
  let { moduleAddress: ie, moduleName: se, functionName: fe } = L$1(ae.function), ue = await m$9(async () => P$1(ie, se, fe, ae.aptosConfig), `entry-function-${ae.aptosConfig.network}-${ie}-${se}-${fe}`, 1e3 * 60 * 5)();
  return sn({ abi: ue, ...ae });
}
function sn(ae) {
  let ie = ae.abi, { moduleAddress: se, moduleName: fe, functionName: ue } = L$1(ae.function), ce = Z$2(ae.typeArguments);
  if (ce.length !== ie.typeParameters.length)
    throw new Error(`Type argument count mismatch, expected ${ie.typeParameters.length}, received ${ce.length}`);
  let de = ae.functionArguments.map((we, Ee) => a$3(ae.function, ie, we, Ee, ce));
  if (de.length !== ie.parameters.length)
    throw new Error(`Too few arguments for '${se}::${fe}::${ue}', expected ${ie.parameters.length} but got ${de.length}`);
  let me = l$2.build(`${se}::${fe}`, ue, ce, de);
  if ("multisigAddress" in ae) {
    let we = c$b.from(ae.multisigAddress);
    return new h$5(new f$1(we, new b$3(me)));
  }
  return new z$1(me);
}
function cn(ae) {
  return new A$2(new U$2(i$7.fromHexInput(ae.bytecode).toUint8Array(), ae.typeArguments ?? [], ae.functionArguments));
}
async function un(ae) {
  let { aptosConfig: ie, sender: se, payload: fe, options: ue, feePayerAddress: ce } = ae, de = s[ie.network] ? Promise.resolve({ chain_id: s[ie.network] }) : l$5({ aptosConfig: ie }), me = ue?.gasUnitPrice ? Promise.resolve({ gas_estimate: ue.gasUnitPrice }) : L$2({ aptosConfig: ie }), [{ chain_id: we }, { gas_estimate: Ee }] = await Promise.all([de, me]), Se = ue?.accountSequenceNumber !== void 0 ? Promise.resolve({ sequence_number: ue.accountSequenceNumber }) : M$3({ aptosConfig: ie, accountAddress: se }), Be;
  if (ce && c$b.from(ce).equals(c$b.ZERO))
    try {
      let { sequence_number: Ne } = await Se;
      Be = Ne;
    } catch {
      Be = "0";
    }
  else {
    let { sequence_number: Ne } = await Se;
    Be = Ne;
  }
  let { maxGasAmount: Ce, gasUnitPrice: Ie, expireTimestamp: Pe } = { maxGasAmount: ue?.maxGasAmount ? BigInt(ue.maxGasAmount) : BigInt(2e5), gasUnitPrice: BigInt(Ee), expireTimestamp: BigInt(Math.floor(Date.now() / 1e3) + 20), ...ue };
  return new o$3(c$b.from(se), BigInt(Be), fe, BigInt(Ce), BigInt(Ie), BigInt(Pe), new r$2(we));
}
async function Nn(ae) {
  let { aptosConfig: ie, sender: se, payload: fe, options: ue, feePayerAddress: ce } = ae, de = await un({ aptosConfig: ie, sender: se, payload: fe, options: ue, feePayerAddress: ce });
  if ("secondarySignerAddresses" in ae) {
    let me = ae.secondarySignerAddresses?.map((we) => c$b.from(we)) ?? [];
    return { rawTransaction: de, secondarySignerAddresses: me, feePayerAddress: ae.feePayerAddress ? c$b.from(ae.feePayerAddress) : void 0 };
  }
  return { rawTransaction: de, feePayerAddress: ae.feePayerAddress ? c$b.from(ae.feePayerAddress) : void 0 };
}
function Wn(ae) {
  let { signerPublicKey: ie, transaction: se, secondarySignersPublicKeys: fe, feePayerPublicKey: ue } = ae, ce = h$4(ie);
  if (se.feePayerAddress) {
    let me = new y$3(se.rawTransaction, se.secondarySignerAddresses ?? [], se.feePayerAddress), we = [];
    fe && (we = fe.map((Be) => h$4(Be)));
    let Ee = h$4(ue), Se = new A$3(ce, se.secondarySignerAddresses ?? [], we, { address: se.feePayerAddress, authenticator: Ee });
    return new n$6(me.raw_txn, Se).bcsToBytes();
  }
  if (se.secondarySignerAddresses) {
    let me = new p$1(se.rawTransaction, se.secondarySignerAddresses), we = [];
    we = fe.map((Se) => h$4(Se));
    let Ee = new l$3(ce, se.secondarySignerAddresses, we);
    return new n$6(me.raw_txn, Ee).bcsToBytes();
  }
  let de;
  if (ce instanceof a$5)
    de = new d$2(ce.public_key, ce.signature);
  else if (ce instanceof l$4)
    de = new y$4(ce);
  else
    throw new Error("Invalid public key");
  return new n$6(se.rawTransaction, de).bcsToBytes();
}
function h$4(ae) {
  if (ae instanceof b$4) {
    if (ae.publicKey instanceof m$5)
      return new l$4(ae, new o$6(new y$7(new Uint8Array(64))));
    if (ae.publicKey instanceof u$6)
      return new l$4(ae, new o$6(new y$5(new Uint8Array(64))));
  }
  return new a$5(new m$5(ae.toUint8Array()), new y$7(new Uint8Array(64)));
}
function Gn(ae) {
  let { signer: ie, transaction: se } = ae, fe = An(se);
  return ie.signWithAuthenticator(fe);
}
function Un(ae) {
  let { transaction: ie, senderAuthenticator: se, feePayerAuthenticator: fe, additionalSignersAuthenticators: ue } = ae, ce = tn$1(ie);
  if ((fe || ue) && (ce instanceof p$1 || ce instanceof y$3))
    return dn(ce, se, fe, ue);
  if (se instanceof a$5 && ce instanceof o$3) {
    let de = new d$2(se.public_key, se.signature);
    return new n$6(ce, de).bcsToBytes();
  }
  if ((se instanceof l$4 || se instanceof c$5) && ce instanceof o$3) {
    let de = new y$4(se);
    return new n$6(ce, de).bcsToBytes();
  }
  throw new Error(`Cannot generate a signed transaction, ${se} is not a supported account authentication scheme`);
}
function tn$1(ae) {
  return ae.feePayerAddress ? new y$3(ae.rawTransaction, ae.secondarySignerAddresses ?? [], ae.feePayerAddress) : ae.secondarySignerAddresses ? new p$1(ae.rawTransaction, ae.secondarySignerAddresses) : ae.rawTransaction;
}
function dn(ae, ie, se, fe) {
  if (ae instanceof y$3) {
    if (!se)
      throw new Error("Must provide a feePayerAuthenticator argument to generate a signed fee payer transaction");
    let ue = new A$3(ie, ae.secondary_signer_addresses, fe ?? [], { address: ae.fee_payer_address, authenticator: se });
    return new n$6(ae.raw_txn, ue).bcsToBytes();
  }
  if (ae instanceof p$1) {
    if (!fe)
      throw new Error("Must provide a additionalSignersAuthenticators argument to generate a signed multi agent transaction");
    let ue = new l$3(ie, ae.secondary_signer_addresses, fe ?? []);
    return new n$6(ae.raw_txn, ue).bcsToBytes();
  }
  throw new Error(`Cannot prepare multi signers transaction to submission, ${typeof ae} transaction is not supported`);
}
function An(ae) {
  let ie = tn$1(ae), se = sha3_256.create();
  if (ie instanceof o$3)
    se.update(T$4);
  else if (ie instanceof p$1)
    se.update(o$a);
  else if (ie instanceof y$3)
    se.update(o$a);
  else
    throw new Error(`Unknown transaction type to sign on: ${ie}`);
  let fe = se.digest(), ue = ie.bcsToBytes(), ce = new Uint8Array(fe.length + ue.length);
  return ce.set(fe), ce.set(ue, fe.length), ce;
}
var c$2 = class extends B$4 {
  constructor(ie) {
    super(), this.accountAddress = c$b.ONE, this.moduleName = new a$a("account"), this.structName = new a$a("RotationProofChallenge"), this.sequenceNumber = new m$7(ie.sequenceNumber), this.originator = ie.originator, this.currentAuthKey = ie.currentAuthKey, this.newPublicKey = t$6.U8(ie.newPublicKey.toUint8Array());
  }
  serialize(ie) {
    ie.serialize(this.accountAddress), ie.serialize(this.moduleName), ie.serialize(this.structName), ie.serialize(this.sequenceNumber), ie.serialize(this.originator), ie.serialize(this.currentAuthKey), ie.serialize(this.newPublicKey);
  }
};
async function h$3(ae) {
  let ie = await D$1(ae);
  return G$1(ae, ie);
}
async function D$1(ae) {
  let { aptosConfig: ie, data: se } = ae, fe, ue;
  return "bytecode" in se ? ue = await Fn(se) : "multisigAddress" in se ? se.abi ? ue = sn({ abi: se.abi, ...se }) : (fe = { aptosConfig: ie, multisigAddress: se.multisigAddress, function: se.function, functionArguments: se.functionArguments, typeArguments: se.typeArguments }, ue = await Fn(fe)) : se.abi ? ue = sn({ abi: se.abi, ...se }) : (fe = { aptosConfig: ie, function: se.function, functionArguments: se.functionArguments, typeArguments: se.typeArguments }, ue = await Fn(fe)), ue;
}
async function G$1(ae, ie) {
  let { aptosConfig: se, sender: fe, options: ue } = ae, ce;
  if (U$1(ae) && (ce = c$b.ZERO.toString()), _$1(ae)) {
    let { secondarySignerAddresses: de } = ae;
    return Nn({ aptosConfig: se, sender: fe, payload: ie, options: ue, secondarySignerAddresses: de, feePayerAddress: ce });
  }
  return Nn({ aptosConfig: se, sender: fe, payload: ie, options: ue, feePayerAddress: ce });
}
function U$1(ae) {
  return ae.withFeePayer === !0;
}
function _$1(ae) {
  return "secondarySignerAddresses" in ae;
}
function Y$1(ae) {
  let { transaction: ie } = ae;
  return An(ie);
}
function K$1(ae) {
  return Gn({ ...ae });
}
async function $$1(ae) {
  let { aptosConfig: ie, transaction: se, signerPublicKey: fe, secondarySignersPublicKeys: ue, feePayerPublicKey: ce, options: de } = ae, me = Wn({ transaction: se, signerPublicKey: fe, secondarySignersPublicKeys: ue, feePayerPublicKey: ce, options: de }), { data: we } = await A$8({ aptosConfig: ie, body: me, path: "transactions/simulate", params: { estimate_gas_unit_price: ae.options?.estimateGasUnitPrice ?? !1, estimate_max_gas_amount: ae.options?.estimateMaxGasAmount ?? !1, estimate_prioritized_gas_unit_price: ae.options?.estimatePrioritizedGasUnitPrice ?? !1 }, originMethod: "simulateTransaction", contentType: "application/x.aptos.signed_transaction+bcs" });
  return we;
}
async function B$1(ae) {
  let { aptosConfig: ie } = ae, se = Un({ ...ae }), { data: fe } = await A$8({ aptosConfig: ie, body: se, path: "transactions", originMethod: "submitTransaction", contentType: "application/x.aptos.signed_transaction+bcs" });
  return fe;
}
async function M$2(ae) {
  let { aptosConfig: ie, signer: se, transaction: fe } = ae, ue = K$1({ signer: se, transaction: fe });
  return B$1({ aptosConfig: ie, transaction: fe, senderAuthenticator: ue });
}
var v$2 = { typeParameters: [], parameters: [y$a.u8(), new y$a(y$a.u8())] };
async function nn(ae) {
  let { aptosConfig: ie, account: se, metadataBytes: fe, moduleBytecode: ue, options: ce } = ae, de = ue.map((me) => t$6.U8(me));
  return h$3({ aptosConfig: ie, sender: c$b.from(se), data: { function: "0x1::code::publish_package_txn", functionArguments: [t$6.U8(fe), new t$6(de)], abi: v$2 }, options: ce });
}
var N$1 = { typeParameters: [], parameters: [new u$7(), y$a.u8(), new u$7(), y$a.u8(), y$a.u8(), y$a.u8()] };
async function tn(ae) {
  let { aptosConfig: ie, fromAccount: se, toNewPrivateKey: fe } = ae, ue = await M$3({ aptosConfig: ie, accountAddress: se.accountAddress }), ce = o$5.fromPrivateKey({ privateKey: fe, legacy: !0 }), de = new c$2({ sequenceNumber: BigInt(ue.sequence_number), originator: se.accountAddress, currentAuthKey: c$b.from(ue.authentication_key), newPublicKey: ce.publicKey }).bcsToBytes(), me = se.sign(de), we = ce.sign(de), Ee = await h$3({ aptosConfig: ie, sender: se.accountAddress, data: { function: "0x1::account::rotate_authentication_key", functionArguments: [new p$3(se.signingScheme.valueOf()), t$6.U8(se.publicKey.toUint8Array()), new p$3(ce.signingScheme.valueOf()), t$6.U8(ce.publicKey.toUint8Array()), t$6.U8(me.toUint8Array()), t$6.U8(we.toUint8Array())], abi: N$1 } });
  return M$2({ aptosConfig: ie, signer: se, transaction: Ee });
}
async function h$2(ae) {
  let { aptosConfig: ie, options: se } = ae, fe = { query: h$a, variables: { where_condition: se?.where, limit: se?.limit, offset: se?.offset } };
  return (await p$6({ aptosConfig: ie, query: fe, originMethod: "getFungibleAssetMetadata" })).fungible_asset_metadata;
}
async function M$1(ae) {
  let { aptosConfig: ie, options: se } = ae, fe = { query: v$5, variables: { where_condition: se?.where, limit: se?.limit, offset: se?.offset } };
  return (await p$6({ aptosConfig: ie, query: fe, originMethod: "getFungibleAssetActivities" })).fungible_asset_activities;
}
async function x$1(ae) {
  let { aptosConfig: ie, options: se } = ae, fe = { query: k, variables: { where_condition: se?.where, limit: se?.limit, offset: se?.offset } };
  return (await p$6({ aptosConfig: ie, query: fe, originMethod: "getCurrentFungibleAssetBalances" })).current_fungible_asset_balances;
}
var b$2 = { typeParameters: [], parameters: [Z$3("0x1::object::Object"), new S$4(), new p$4()] };
async function v$1(ae) {
  let { aptosConfig: ie, sender: se, fungibleAssetMetadataAddress: fe, recipient: ue, amount: ce, options: de } = ae;
  return h$3({ aptosConfig: ie, sender: se.accountAddress, data: { function: "0x1::primary_fungible_store::transfer", typeArguments: ["0x1::fungible_asset::Metadata"], functionArguments: [fe, ue, ce], abi: b$2 }, options: de });
}
var r$1 = class {
  constructor(ie) {
    this.config = ie;
  }
  async getFungibleAssetMetadata(ie) {
    return await i$4({ config: this.config, minimumLedgerVersion: ie?.minimumLedgerVersion, processorType: "fungible_asset_processor" }), h$2({ aptosConfig: this.config, ...ie });
  }
  async getFungibleAssetMetadataByAssetType(ie) {
    return await i$4({ config: this.config, minimumLedgerVersion: ie?.minimumLedgerVersion, processorType: "fungible_asset_processor" }), (await h$2({ aptosConfig: this.config, options: { where: { asset_type: { _eq: ie.assetType } } } }))[0];
  }
  async getFungibleAssetActivities(ie) {
    return await i$4({ config: this.config, minimumLedgerVersion: ie?.minimumLedgerVersion, processorType: "fungible_asset_processor" }), M$1({ aptosConfig: this.config, ...ie });
  }
  async getCurrentFungibleAssetBalances(ie) {
    return await i$4({ config: this.config, minimumLedgerVersion: ie?.minimumLedgerVersion, processorType: "fungible_asset_processor" }), x$1({ aptosConfig: this.config, ...ie });
  }
  async transferFungibleAsset(ie) {
    return v$1({ aptosConfig: this.config, ...ie });
  }
}, u$3 = class {
  constructor(ie) {
    this.config = ie;
  }
  async getLedgerInfo() {
    return l$5({ aptosConfig: this.config });
  }
  async getChainId() {
    return (await this.getLedgerInfo()).chain_id;
  }
  async getBlockByVersion(ie) {
    return h$9({ aptosConfig: this.config, ...ie });
  }
  async getBlockByHeight(ie) {
    return m$a({ aptosConfig: this.config, ...ie });
  }
  async getTableItem(ie) {
    return C$2({ aptosConfig: this.config, ...ie });
  }
  async view(ie) {
    return T$5({ aptosConfig: this.config, ...ie });
  }
  async getChainTopUserTransactions(ie) {
    return q$1({ aptosConfig: this.config, ...ie });
  }
  async queryIndexer(ie) {
    return p$6({ aptosConfig: this.config, ...ie });
  }
  async getIndexerLastSuccessVersion() {
    return w$1({ aptosConfig: this.config });
  }
  async getProcessorStatus(ie) {
    return A$7({ aptosConfig: this.config, processorType: ie });
  }
};
async function m$3(ae) {
  let { aptosConfig: ie, poolAddress: se } = ae, fe = c$b.from(se).toStringLong(), ue = await p$6({ aptosConfig: ie, query: { query: w$2, variables: { where_condition: { pool_address: { _eq: fe } } } } });
  return ue.num_active_delegator_per_pool[0] ? ue.num_active_delegator_per_pool[0].num_active_delegator : 0;
}
async function f(ae) {
  let { aptosConfig: ie, options: se } = ae, fe = { query: w$2, variables: { order_by: se?.orderBy } };
  return (await p$6({ aptosConfig: ie, query: fe })).num_active_delegator_per_pool;
}
async function A$1(ae) {
  let { aptosConfig: ie, delegatorAddress: se, poolAddress: fe } = ae, ue = { query: $$4, variables: { delegatorAddress: c$b.from(se).toStringLong(), poolAddress: c$b.from(fe).toStringLong() } };
  return (await p$6({ aptosConfig: ie, query: ue })).delegated_staking_activities;
}
var t$2 = class {
  constructor(ie) {
    this.config = ie;
  }
  async getNumberOfDelegators(ie) {
    return await i$4({ config: this.config, minimumLedgerVersion: ie?.minimumLedgerVersion, processorType: "stake_processor" }), m$3({ aptosConfig: this.config, ...ie });
  }
  async getNumberOfDelegatorsForAllPools(ie) {
    return await i$4({ config: this.config, minimumLedgerVersion: ie?.minimumLedgerVersion, processorType: "stake_processor" }), f({ aptosConfig: this.config, ...ie });
  }
  async getDelegatedStakingActivities(ie) {
    return await i$4({ config: this.config, minimumLedgerVersion: ie?.minimumLedgerVersion, processorType: "stake_processor" }), A$1({ aptosConfig: this.config, ...ie });
  }
};
function o$1(ae, ie, se) {
  let fe = se.value;
  return se.value = async function(...ue) {
    let [ce] = ue;
    if (ce.transaction.feePayerAddress && !ce.feePayerAuthenticator)
      throw new Error("You are submitting a Fee Payer transaction but missing the feePayerAuthenticator");
    return fe.apply(this, ue);
  }, se;
}
function u$2(ae, ie, se) {
  let fe = se.value;
  return se.value = async function(...ue) {
    let [ce] = ue;
    if (ce.transaction.feePayerAddress && !ce.feePayerPublicKey)
      throw new Error("You are simulating a Fee Payer transaction but missing the feePayerPublicKey");
    return fe.apply(this, ue);
  }, se;
}
var i$2 = class {
  constructor(ie) {
    this.config = ie;
  }
  async simple(ie) {
    return $$1({ aptosConfig: this.config, ...ie });
  }
  async multiAgent(ie) {
    return $$1({ aptosConfig: this.config, ...ie });
  }
};
j$1([u$2], i$2.prototype, "simple", 1), j$1([u$2], i$2.prototype, "multiAgent", 1);
var n$4 = class {
  constructor(ie) {
    this.config = ie;
  }
  async simple(ie) {
    return B$1({ aptosConfig: this.config, ...ie });
  }
  async multiAgent(ie) {
    return B$1({ aptosConfig: this.config, ...ie });
  }
};
j$1([o$1], n$4.prototype, "simple", 1), j$1([o$1], n$4.prototype, "multiAgent", 1);
var o = class {
  constructor(ae) {
    this.config = ae;
  }
  async simple(ae) {
    return h$3({ aptosConfig: this.config, ...ae });
  }
  async multiAgent(ae) {
    return h$3({ aptosConfig: this.config, ...ae });
  }
}, n$3 = () => Math.floor(Date.now() / 1e3), r = class {
  constructor(ae, ie, se, fe, ue) {
    this.lastUncommintedNumber = null, this.currentNumber = null, this.lock = !1, this.aptosConfig = ae, this.account = ie, this.maxWaitTime = se, this.maximumInFlight = fe, this.sleepTime = ue;
  }
  async nextSequenceNumber() {
    for (; this.lock; )
      await r$8(this.sleepTime);
    this.lock = !0;
    let ae = BigInt(0);
    try {
      if ((this.lastUncommintedNumber === null || this.currentNumber === null) && await this.initialize(), this.currentNumber - this.lastUncommintedNumber >= this.maximumInFlight) {
        await this.update();
        let ie = n$3();
        for (; this.currentNumber - this.lastUncommintedNumber >= this.maximumInFlight; )
          await r$8(this.sleepTime), n$3() - ie > this.maxWaitTime ? (console.warn(`Waited over 30 seconds for a transaction to commit, resyncing ${this.account.accountAddress.toString()}`), await this.initialize()) : await this.update();
      }
      ae = this.currentNumber, this.currentNumber += BigInt(1);
    } catch (ie) {
      console.error("error in getting next sequence number for this account", ie);
    } finally {
      this.lock = !1;
    }
    return ae;
  }
  async initialize() {
    let { sequence_number: ae } = await M$3({ aptosConfig: this.aptosConfig, accountAddress: this.account.accountAddress });
    this.currentNumber = BigInt(ae), this.lastUncommintedNumber = BigInt(ae);
  }
  async update() {
    let { sequence_number: ae } = await M$3({ aptosConfig: this.aptosConfig, accountAddress: this.account.accountAddress });
    return this.lastUncommintedNumber = BigInt(ae), this.lastUncommintedNumber;
  }
  async synchronize() {
    if (this.lastUncommintedNumber !== this.currentNumber) {
      for (; this.lock; )
        await r$8(this.sleepTime);
      this.lock = !0;
      try {
        await this.update();
        let ae = n$3();
        for (; this.lastUncommintedNumber !== this.currentNumber; )
          n$3() - ae > this.maxWaitTime ? (console.warn(`Waited over 30 seconds for a transaction to commit, resyncing ${this.account.accountAddress.toString()}`), await this.initialize()) : (await r$8(this.sleepTime), await this.update());
      } catch (ae) {
        console.error("error in synchronizing this account sequence number with the one on chain", ae);
      } finally {
        this.lock = !1;
      }
    }
  }
}, i$1 = class {
  constructor() {
    this.queue = [], this.pendingDequeue = [], this.cancelled = !1;
  }
  enqueue(ie) {
    if (this.cancelled = !1, this.pendingDequeue.length > 0) {
      this.pendingDequeue.shift()?.resolve(ie);
      return;
    }
    this.queue.push(ie);
  }
  async dequeue() {
    return this.queue.length > 0 ? Promise.resolve(this.queue.shift()) : new Promise((ie, se) => {
      this.pendingDequeue.push({ resolve: ie, reject: se });
    });
  }
  isEmpty() {
    return this.queue.length === 0;
  }
  cancel() {
    this.cancelled = !0, this.pendingDequeue.forEach(async ({ reject: ie }) => {
      ie(new n$2("Task cancelled"));
    }), this.pendingDequeue = [], this.queue.length = 0;
  }
  isCancelled() {
    return this.cancelled;
  }
  pendingDequeueLength() {
    return this.pendingDequeue.length;
  }
}, n$2 = class extends Error {
}, eventemitter3$1 = { exports: {} };
(function(ae) {
  var ie = Object.prototype.hasOwnProperty, se = "~";
  function fe() {
  }
  Object.create && (fe.prototype = /* @__PURE__ */ Object.create(null), new fe().__proto__ || (se = !1));
  function ue(we, Ee, Se) {
    this.fn = we, this.context = Ee, this.once = Se || !1;
  }
  function ce(we, Ee, Se, Be, Ce) {
    if (typeof Se != "function")
      throw new TypeError("The listener must be a function");
    var Ie = new ue(Se, Be || we, Ce), Pe = se ? se + Ee : Ee;
    return we._events[Pe] ? we._events[Pe].fn ? we._events[Pe] = [we._events[Pe], Ie] : we._events[Pe].push(Ie) : (we._events[Pe] = Ie, we._eventsCount++), we;
  }
  function de(we, Ee) {
    --we._eventsCount === 0 ? we._events = new fe() : delete we._events[Ee];
  }
  function me() {
    this._events = new fe(), this._eventsCount = 0;
  }
  me.prototype.eventNames = function() {
    var Ee = [], Se, Be;
    if (this._eventsCount === 0)
      return Ee;
    for (Be in Se = this._events)
      ie.call(Se, Be) && Ee.push(se ? Be.slice(1) : Be);
    return Object.getOwnPropertySymbols ? Ee.concat(Object.getOwnPropertySymbols(Se)) : Ee;
  }, me.prototype.listeners = function(Ee) {
    var Se = se ? se + Ee : Ee, Be = this._events[Se];
    if (!Be)
      return [];
    if (Be.fn)
      return [Be.fn];
    for (var Ce = 0, Ie = Be.length, Pe = new Array(Ie); Ce < Ie; Ce++)
      Pe[Ce] = Be[Ce].fn;
    return Pe;
  }, me.prototype.listenerCount = function(Ee) {
    var Se = se ? se + Ee : Ee, Be = this._events[Se];
    return Be ? Be.fn ? 1 : Be.length : 0;
  }, me.prototype.emit = function(Ee, Se, Be, Ce, Ie, Pe) {
    var Ne = se ? se + Ee : Ee;
    if (!this._events[Ne])
      return !1;
    var ke = this._events[Ne], He = arguments.length, De, Ge;
    if (ke.fn) {
      switch (ke.once && this.removeListener(Ee, ke.fn, void 0, !0), He) {
        case 1:
          return ke.fn.call(ke.context), !0;
        case 2:
          return ke.fn.call(ke.context, Se), !0;
        case 3:
          return ke.fn.call(ke.context, Se, Be), !0;
        case 4:
          return ke.fn.call(ke.context, Se, Be, Ce), !0;
        case 5:
          return ke.fn.call(ke.context, Se, Be, Ce, Ie), !0;
        case 6:
          return ke.fn.call(ke.context, Se, Be, Ce, Ie, Pe), !0;
      }
      for (Ge = 1, De = new Array(He - 1); Ge < He; Ge++)
        De[Ge - 1] = arguments[Ge];
      ke.fn.apply(ke.context, De);
    } else {
      var Ye = ke.length, st;
      for (Ge = 0; Ge < Ye; Ge++)
        switch (ke[Ge].once && this.removeListener(Ee, ke[Ge].fn, void 0, !0), He) {
          case 1:
            ke[Ge].fn.call(ke[Ge].context);
            break;
          case 2:
            ke[Ge].fn.call(ke[Ge].context, Se);
            break;
          case 3:
            ke[Ge].fn.call(ke[Ge].context, Se, Be);
            break;
          case 4:
            ke[Ge].fn.call(ke[Ge].context, Se, Be, Ce);
            break;
          default:
            if (!De)
              for (st = 1, De = new Array(He - 1); st < He; st++)
                De[st - 1] = arguments[st];
            ke[Ge].fn.apply(ke[Ge].context, De);
        }
    }
    return !0;
  }, me.prototype.on = function(Ee, Se, Be) {
    return ce(this, Ee, Se, Be, !1);
  }, me.prototype.once = function(Ee, Se, Be) {
    return ce(this, Ee, Se, Be, !0);
  }, me.prototype.removeListener = function(Ee, Se, Be, Ce) {
    var Ie = se ? se + Ee : Ee;
    if (!this._events[Ie])
      return this;
    if (!Se)
      return de(this, Ie), this;
    var Pe = this._events[Ie];
    if (Pe.fn)
      Pe.fn === Se && (!Ce || Pe.once) && (!Be || Pe.context === Be) && de(this, Ie);
    else {
      for (var Ne = 0, ke = [], He = Pe.length; Ne < He; Ne++)
        (Pe[Ne].fn !== Se || Ce && !Pe[Ne].once || Be && Pe[Ne].context !== Be) && ke.push(Pe[Ne]);
      ke.length ? this._events[Ie] = ke.length === 1 ? ke[0] : ke : de(this, Ie);
    }
    return this;
  }, me.prototype.removeAllListeners = function(Ee) {
    var Se;
    return Ee ? (Se = se ? se + Ee : Ee, this._events[Se] && de(this, Se)) : (this._events = new fe(), this._eventsCount = 0), this;
  }, me.prototype.off = me.prototype.removeListener, me.prototype.addListener = me.prototype.on, me.prefixed = se, me.EventEmitter = me, ae.exports = me;
})(eventemitter3$1);
var eventemitter3Exports$1 = eventemitter3$1.exports;
const EventEmitter$1 = /* @__PURE__ */ getDefaultExportFromCjs$2(eventemitter3Exports$1);
var p = "fulfilled", T = ((ae) => (ae.TransactionSent = "transactionSent", ae.TransactionSendFailed = "transactionSendFailed", ae.TransactionExecuted = "transactionExecuted", ae.TransactionExecutionFailed = "transactionExecutionFailed", ae.ExecutionFinish = "executionFinish", ae))(T || {}), m$2 = class extends EventEmitter$1 {
  constructor(ie, se, fe = 30, ue = 100, ce = 10) {
    super(), this.taskQueue = new i$1(), this.transactionsQueue = new i$1(), this.outstandingTransactions = new i$1(), this.sentTransactions = [], this.executedTransactions = [], this.aptosConfig = ie, this.account = se, this.started = !1, this.accountSequnceNumber = new r(ie, se, fe, ue, ce);
  }
  async submitNextTransaction() {
    try {
      for (; ; ) {
        let ie = await this.accountSequnceNumber.nextSequenceNumber();
        if (ie === null)
          return;
        let se = await this.generateNextTransaction(this.account, ie);
        if (!se)
          return;
        let fe = M$2({ aptosConfig: this.aptosConfig, transaction: se, signer: this.account });
        await this.outstandingTransactions.enqueue([fe, ie]);
      }
    } catch (ie) {
      if (ie instanceof n$2)
        return;
      throw new Error(`Submit transaction failed for ${this.account.accountAddress.toString()} with error ${ie}`);
    }
  }
  async processTransactions() {
    try {
      for (; ; ) {
        let ie = [], se = [], [fe, ue] = await this.outstandingTransactions.dequeue();
        for (ie.push(fe), se.push(ue); !this.outstandingTransactions.isEmpty(); )
          [fe, ue] = await this.outstandingTransactions.dequeue(), ie.push(fe), se.push(ue);
        let ce = await Promise.allSettled(ie);
        for (let de = 0; de < ce.length && de < se.length; de += 1) {
          let me = ce[de];
          ue = se[de], me.status === p ? (this.sentTransactions.push([me.value.hash, ue, null]), this.emit("transactionSent", { message: `transaction hash ${me.value.hash} has been committed to chain`, transactionHash: me.value.hash }), await this.checkTransaction(me, ue)) : (this.sentTransactions.push([me.status, ue, me.reason]), this.emit("transactionSendFailed", { message: `failed to commit transaction ${this.sentTransactions.length} with error ${me.reason}`, error: me.reason }));
        }
        this.emit("executionFinish", { message: `execute ${ce.length} transactions finished` });
      }
    } catch (ie) {
      if (ie instanceof n$2)
        return;
      throw new Error(`Process execution failed for ${this.account.accountAddress.toString()} with error ${ie}`);
    }
  }
  async checkTransaction(ie, se) {
    try {
      let fe = [];
      fe.push(G$5({ aptosConfig: this.aptosConfig, transactionHash: ie.value.hash }));
      let ue = await Promise.allSettled(fe);
      for (let ce = 0; ce < ue.length; ce += 1) {
        let de = ue[ce];
        de.status === p ? (this.executedTransactions.push([de.value.hash, se, null]), this.emit("transactionExecuted", { message: `transaction hash ${de.value.hash} has been executed on chain`, transactionHash: ie.value.hash })) : (this.executedTransactions.push([de.status, se, de.reason]), this.emit("transactionExecutionFailed", { message: `failed to execute transaction ${this.executedTransactions.length} with error ${de.reason}`, error: de.reason }));
      }
    } catch (fe) {
      throw new Error(`Check transaction failed for ${this.account.accountAddress.toString()} with error ${fe}`);
    }
  }
  async push(ie, se) {
    this.transactionsQueue.enqueue([ie, se]);
  }
  async generateNextTransaction(ie, se) {
    if (this.transactionsQueue.isEmpty())
      return;
    let [fe, ue] = await this.transactionsQueue.dequeue();
    return h$3({ aptosConfig: this.aptosConfig, sender: ie.accountAddress, data: fe, options: { ...ue, accountSequenceNumber: se } });
  }
  async run() {
    try {
      for (; !this.taskQueue.isCancelled(); )
        await (await this.taskQueue.dequeue())();
    } catch (ie) {
      throw new Error(`Unable to start transaction batching: ${ie}`);
    }
  }
  start() {
    if (this.started)
      throw new Error("worker has already started");
    this.started = !0, this.taskQueue.enqueue(() => this.submitNextTransaction()), this.taskQueue.enqueue(() => this.processTransactions()), this.run();
  }
  stop() {
    if (this.taskQueue.isCancelled())
      throw new Error("worker has already stopped");
    this.started = !1, this.taskQueue.cancel();
  }
}, i = class extends EventEmitter$1 {
  constructor(ae) {
    super(), this.config = ae;
  }
  start(ae) {
    let { sender: ie } = ae;
    this.account = ie, this.transactionWorker = new m$2(this.config, ie), this.transactionWorker.start(), this.registerToEvents();
  }
  push(ae) {
    let { data: ie, options: se } = ae;
    for (let fe of ie)
      this.transactionWorker.push(fe, se);
  }
  registerToEvents() {
    this.transactionWorker.on("transactionSent", async (ae) => {
      this.emit("transactionSent", ae);
    }), this.transactionWorker.on("transactionSendFailed", async (ae) => {
      this.emit("transactionSendFailed", ae);
    }), this.transactionWorker.on("transactionExecuted", async (ae) => {
      this.emit("transactionExecuted", ae);
    }), this.transactionWorker.on("transactionExecutionFailed", async (ae) => {
      this.emit("transactionExecutionFailed", ae);
    }), this.transactionWorker.on("executionFinish", async (ae) => {
      this.emit("executionFinish", ae);
    });
  }
  forSingleAccount(ae) {
    try {
      let { sender: ie, data: se, options: fe } = ae;
      this.start({ sender: ie }), this.push({ data: se, options: fe });
    } catch (ie) {
      throw new Error(`failed to submit transactions with error: ${ie}`);
    }
  }
}, h$1 = class {
  constructor(ie) {
    this.config = ie, this.build = new o(this.config), this.simulate = new i$2(this.config), this.submit = new n$4(this.config), this.batch = new i(this.config);
  }
  async getTransactions(ie) {
    return F$3({ aptosConfig: this.config, ...ie });
  }
  async getTransactionByVersion(ie) {
    return v$4({ aptosConfig: this.config, ...ie });
  }
  async getTransactionByHash(ie) {
    return x$6({ aptosConfig: this.config, ...ie });
  }
  async isPendingTransaction(ie) {
    return N$4({ aptosConfig: this.config, ...ie });
  }
  async waitForTransaction(ie) {
    return G$5({ aptosConfig: this.config, ...ie });
  }
  async getGasPriceEstimation() {
    return L$2({ aptosConfig: this.config });
  }
  getSigningMessage(ie) {
    return Y$1(ie);
  }
  async publishPackageTransaction(ie) {
    return nn({ aptosConfig: this.config, ...ie });
  }
  async rotateAuthKey(ie) {
    return tn({ aptosConfig: this.config, ...ie });
  }
  sign(ie) {
    return K$1({ ...ie });
  }
  signAsFeePayer(ie) {
    let { signer: se, transaction: fe } = ie;
    if (!fe.feePayerAddress)
      throw new Error(`Transaction ${fe} is not a Fee Payer transaction`);
    return fe.feePayerAddress = se.accountAddress, K$1({ signer: se, transaction: fe });
  }
  async batchTransactionsForSingleAccount(ie) {
    try {
      let { sender: se, data: fe, options: ue } = ie;
      this.batch.forSingleAccount({ sender: se, data: fe, options: ue });
    } catch (se) {
      throw new Error(`failed to submit transactions with error: ${se}`);
    }
  }
  async signAndSubmitTransaction(ie) {
    let { signer: se, transaction: fe } = ie;
    return M$2({ aptosConfig: this.config, signer: se, transaction: fe });
  }
}, l$1 = class {
  constructor(ie) {
    this.config = ie;
  }
  async getAccountInfo(ie) {
    return M$3({ aptosConfig: this.config, ...ie });
  }
  async getAccountModules(ie) {
    return go({ aptosConfig: this.config, ...ie });
  }
  async getAccountModule(ie) {
    return Ao({ aptosConfig: this.config, ...ie });
  }
  async getAccountTransactions(ie) {
    return po({ aptosConfig: this.config, ...ie });
  }
  async getAccountResources(ie) {
    return fo({ aptosConfig: this.config, ...ie });
  }
  async getAccountResource(ie) {
    return K$2({ aptosConfig: this.config, ...ie });
  }
  async lookupOriginalAccountAddress(ie) {
    return Q$1({ aptosConfig: this.config, ...ie });
  }
  async getAccountTokensCount(ie) {
    return await i$4({ config: this.config, minimumLedgerVersion: ie.minimumLedgerVersion, processorType: "account_transactions_processor" }), lo({ aptosConfig: this.config, ...ie });
  }
  async getAccountOwnedTokens(ie) {
    return await i$4({ config: this.config, minimumLedgerVersion: ie.minimumLedgerVersion, processorType: "token_v2_processor" }), yo({ aptosConfig: this.config, ...ie });
  }
  async getAccountOwnedTokensFromCollectionAddress(ie) {
    return await i$4({ config: this.config, minimumLedgerVersion: ie.minimumLedgerVersion, processorType: "token_v2_processor" }), mo({ aptosConfig: this.config, ...ie });
  }
  async getAccountCollectionsWithOwnedTokens(ie) {
    return await i$4({ config: this.config, minimumLedgerVersion: ie.minimumLedgerVersion, processorType: "token_v2_processor" }), _o({ aptosConfig: this.config, ...ie });
  }
  async getAccountTransactionsCount(ie) {
    return await i$4({ config: this.config, minimumLedgerVersion: ie.minimumLedgerVersion, processorType: "account_transactions_processor" }), Co({ aptosConfig: this.config, ...ie });
  }
  async getAccountCoinsData(ie) {
    return await i$4({ config: this.config, minimumLedgerVersion: ie.minimumLedgerVersion, processorType: "fungible_asset_processor" }), I$1({ aptosConfig: this.config, ...ie });
  }
  async getAccountCoinsCount(ie) {
    return await i$4({ config: this.config, minimumLedgerVersion: ie.minimumLedgerVersion, processorType: "fungible_asset_processor" }), wo({ aptosConfig: this.config, ...ie });
  }
  async getAccountAPTAmount(ie) {
    return this.getAccountCoinAmount({ coinType: N$5, ...ie });
  }
  async getAccountCoinAmount(ie) {
    return await i$4({ config: this.config, minimumLedgerVersion: ie.minimumLedgerVersion, processorType: "fungible_asset_processor" }), ho({ aptosConfig: this.config, ...ie });
  }
  async getAccountOwnedObjects(ie) {
    return await i$4({ config: this.config, minimumLedgerVersion: ie.minimumLedgerVersion, processorType: "default_processor" }), ko({ aptosConfig: this.config, ...ie });
  }
  async deriveAccountFromPrivateKey(ie) {
    return To({ aptosConfig: this.config, ...ie });
  }
}, E = ["A name must be between 3 and 63 characters long,", "and can only contain lowercase a-z, 0-9, and hyphens.", "A name may not start or end with a hyphen."].join(" ");
function D(ae) {
  return !(!ae || ae.length < 3 || ae.length > 63 || !/^[a-z\d][a-z\d-]{1,61}[a-z\d]$/.test(ae));
}
function c$1(ae) {
  let [ie, se, ...fe] = ae.replace(/\.apt$/, "").split(".");
  if (fe.length > 0)
    throw new Error(`${ae} is invalid. A name can only have two parts, a domain and a subdomain separated by a "."`);
  if (!D(ie))
    throw new Error(`${ie} is not valid. ${E}`);
  if (se && !D(se))
    throw new Error(`${se} is not valid. ${E}`);
  return { domainName: se || ie, subdomainName: se ? ie : void 0 };
}
var G = "0x585fc9f0f0c54183b039ffc770ca282ebd87307916c215a3e692f2f8e4305e82", O = { testnet: "0x5f8fd2347449685cf41d4db97926ec3a096eaf381332be4f1318ad4d16a8497c", mainnet: "0x867ed1f6bf916171b1de3ee92849b8978b7d1b9e0a8cc982a3d19d535dfd9c0c", local: G, custom: null, devnet: null, randomnet: null };
function d$1(ae) {
  let ie = O[ae.network];
  if (!ie)
    throw new Error(`The ANS contract is not deployed to ${ae.network}`);
  return ie;
}
var P = (ae) => ({ vec: [ae] }), I = () => ({ vec: [] }), S$1 = (ae) => ae != null ? P(ae) : I(), b$1 = (ae) => {
  if (ae && typeof ae == "object" && "vec" in ae && Array.isArray(ae.vec))
    return ae.vec[0];
};
async function K(ae) {
  let { aptosConfig: ie, name: se } = ae, fe = d$1(ie), { domainName: ue, subdomainName: ce } = c$1(se), de = await T$5({ aptosConfig: ie, payload: { function: `${fe}::router::get_owner_addr`, functionArguments: [ue, S$1(ce)] } }), me = b$1(de[0]);
  return me ? c$b.from(me).toString() : void 0;
}
async function W$1(ae) {
  let { aptosConfig: ie, expiration: se, name: fe, sender: ue, targetAddress: ce, toAddress: de, options: me, transferable: we } = ae, Ee = d$1(ie), { domainName: Se, subdomainName: Be } = c$1(fe), Ce = se.policy === "subdomain:independent" || se.policy === "subdomain:follow-domain";
  if (Be && !Ce)
    throw new Error("Subdomains must have an expiration policy of either 'subdomain:independent' or 'subdomain:follow-domain'");
  if (Ce && !Be)
    throw new Error(`Policy is set to ${se.policy} but no subdomain was provided`);
  if (se.policy === "domain") {
    let Ne = se.years ?? 1;
    if (Ne !== 1)
      throw new Error("For now, names can only be registered for 1 year at a time");
    let ke = Ne * 31536e3;
    return await h$3({ aptosConfig: ie, sender: ue.accountAddress.toString(), data: { function: `${Ee}::router::register_domain`, functionArguments: [Se, ke, ce, de] }, options: me });
  }
  if (!Be)
    throw new Error(`${se.policy} requires a subdomain to be provided.`);
  let Ie = await q({ aptosConfig: ie, name: Se });
  if (!Ie)
    throw new Error("The domain does not exist");
  let Pe = se.policy === "subdomain:independent" ? se.expirationDate : Ie;
  if (Pe > Ie)
    throw new Error("The subdomain expiration time cannot be greater than the domain expiration time");
  return await h$3({ aptosConfig: ie, sender: ue.accountAddress.toString(), data: { function: `${Ee}::router::register_subdomain`, functionArguments: [Se, Be, Math.round(Pe / 1e3), se.policy === "subdomain:follow-domain" ? 1 : 0, !!we, ce, de] }, options: me });
}
async function q(ae) {
  let { aptosConfig: ie, name: se } = ae, fe = d$1(ie), { domainName: ue, subdomainName: ce } = c$1(se);
  try {
    let de = await T$5({ aptosConfig: ie, payload: { function: `${fe}::router::get_expiration`, functionArguments: [ue, S$1(ce)] } });
    return Number(de[0]) * 1e3;
  } catch {
    return;
  }
}
async function F$1(ae) {
  let { aptosConfig: ie, address: se } = ae, fe = d$1(ie), ue = await T$5({ aptosConfig: ie, payload: { function: `${fe}::router::get_primary_name`, functionArguments: [c$b.from(se).toString()] } }), ce = b$1(ue[1]), de = b$1(ue[0]);
  if (ce)
    return [de, ce].filter(Boolean).join(".");
}
async function H$1(ae) {
  let { aptosConfig: ie, sender: se, name: fe, options: ue } = ae, ce = d$1(ie);
  if (!fe)
    return await h$3({ aptosConfig: ie, sender: se.accountAddress.toString(), data: { function: `${ce}::router::clear_primary_name`, functionArguments: [] }, options: ue });
  let { domainName: de, subdomainName: me } = c$1(fe);
  return await h$3({ aptosConfig: ie, sender: se.accountAddress.toString(), data: { function: `${ce}::router::set_primary_name`, functionArguments: [de, me] }, options: ue });
}
async function J$1(ae) {
  let { aptosConfig: ie, name: se } = ae, fe = d$1(ie), { domainName: ue, subdomainName: ce } = c$1(se), de = await T$5({ aptosConfig: ie, payload: { function: `${fe}::router::get_target_addr`, functionArguments: [ue, S$1(ce)] } }), me = b$1(de[0]);
  return me ? c$b.from(me).toString() : void 0;
}
async function X$1(ae) {
  let { aptosConfig: ie, sender: se, name: fe, address: ue, options: ce } = ae, de = d$1(ie), { domainName: me, subdomainName: we } = c$1(fe);
  return await h$3({ aptosConfig: ie, sender: se.accountAddress.toString(), data: { function: `${de}::router::set_target_addr`, functionArguments: [me, we, ue] }, options: ce });
}
async function Z$1(ae) {
  let { aptosConfig: ie, name: se } = ae, { domainName: fe, subdomainName: ue = "" } = c$1(se), ce = (await p$6({ aptosConfig: ie, query: { query: A$9, variables: { where_condition: { domain: { _eq: fe }, subdomain: { _eq: ue } }, limit: 1 } }, originMethod: "getName" })).current_aptos_names[0];
  return ce && (ce = y$2(ce)), ce;
}
async function ee(ae) {
  let { aptosConfig: ie, options: se, accountAddress: fe } = ae, ue = await C$1({ aptosConfig: ie });
  return (await p$6({ aptosConfig: ie, originMethod: "getAccountNames", query: { query: A$9, variables: { limit: se?.limit, offset: se?.offset, order_by: se?.orderBy, where_condition: { ...ae.options?.where ?? {}, owner_address: { _eq: fe.toString() }, expiration_timestamp: { _gte: ue } } } } })).current_aptos_names.map(y$2);
}
async function ne(ae) {
  let { aptosConfig: ie, options: se, accountAddress: fe } = ae, ue = await C$1({ aptosConfig: ie });
  return (await p$6({ aptosConfig: ie, originMethod: "getAccountDomains", query: { query: A$9, variables: { limit: se?.limit, offset: se?.offset, order_by: se?.orderBy, where_condition: { ...ae.options?.where ?? {}, owner_address: { _eq: fe.toString() }, expiration_timestamp: { _gte: ue }, subdomain: { _eq: "" } } } } })).current_aptos_names.map(y$2);
}
async function te(ae) {
  let { aptosConfig: ie, options: se, accountAddress: fe } = ae, ue = await C$1({ aptosConfig: ie });
  return (await p$6({ aptosConfig: ie, originMethod: "getAccountSubdomains", query: { query: A$9, variables: { limit: se?.limit, offset: se?.offset, order_by: se?.orderBy, where_condition: { ...ae.options?.where ?? {}, owner_address: { _eq: fe.toString() }, expiration_timestamp: { _gte: ue }, subdomain: { _neq: "" } } } } })).current_aptos_names.map(y$2);
}
async function oe(ae) {
  let { aptosConfig: ie, options: se, domain: fe } = ae;
  return (await p$6({ aptosConfig: ie, originMethod: "getDomainSubdomains", query: { query: A$9, variables: { limit: se?.limit, offset: se?.offset, order_by: se?.orderBy, where_condition: { ...ae.options?.where ?? {}, domain: { _eq: fe }, subdomain: { _neq: "" } } } } })).current_aptos_names.map(y$2);
}
async function C$1(ae) {
  let { aptosConfig: ie } = ae, se = d$1(ie), [fe] = await T$5({ aptosConfig: ie, payload: { function: `${se}::config::reregistration_grace_sec`, functionArguments: [] } }), ue = fe / 60 / 60 / 24, ce = () => /* @__PURE__ */ new Date();
  return new Date(ce().setDate(ce().getDate() - ue)).toISOString();
}
async function re(ae) {
  let { aptosConfig: ie, sender: se, name: fe, years: ue = 1, options: ce } = ae, de = d$1(ie), me = ue * 31536e3, { domainName: we, subdomainName: Ee } = c$1(fe);
  if (Ee)
    throw new Error("Subdomains cannot be renewed");
  if (ue !== 1)
    throw new Error("Currently, only 1 year renewals are supported");
  return await h$3({ aptosConfig: ie, sender: se.accountAddress.toString(), data: { function: `${de}::router::renew_domain`, functionArguments: [we, me] }, options: ce });
}
function y$2(ae) {
  return { ...ae, expiration_timestamp: new Date(ae.expiration_timestamp).valueOf() };
}
var A = class {
  constructor(ae) {
    this.config = ae;
  }
  async getOwnerAddress(ae) {
    return K({ aptosConfig: this.config, ...ae });
  }
  async getExpiration(ae) {
    return q({ aptosConfig: this.config, ...ae });
  }
  async getTargetAddress(ae) {
    return J$1({ aptosConfig: this.config, ...ae });
  }
  async setTargetAddress(ae) {
    return X$1({ aptosConfig: this.config, ...ae });
  }
  async getPrimaryName(ae) {
    return F$1({ aptosConfig: this.config, ...ae });
  }
  async setPrimaryName(ae) {
    return H$1({ aptosConfig: this.config, ...ae });
  }
  async registerName(ae) {
    return W$1({ aptosConfig: this.config, ...ae });
  }
  async renewDomain(ae) {
    return re({ aptosConfig: this.config, ...ae });
  }
  async getName(ae) {
    return Z$1({ aptosConfig: this.config, ...ae });
  }
  async getAccountNames(ae) {
    return ee({ aptosConfig: this.config, ...ae });
  }
  async getAccountDomains(ae) {
    return ne({ aptosConfig: this.config, ...ae });
  }
  async getAccountSubdomains(ae) {
    return te({ aptosConfig: this.config, ...ae });
  }
  async getDomainSubdomains(ae) {
    return oe({ aptosConfig: this.config, ...ae });
  }
};
function bind(ae, ie) {
  return function() {
    return ae.apply(ie, arguments);
  };
}
const { toString } = Object.prototype, { getPrototypeOf } = Object, kindOf = /* @__PURE__ */ ((ae) => (ie) => {
  const se = toString.call(ie);
  return ae[se] || (ae[se] = se.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), kindOfTest = (ae) => (ae = ae.toLowerCase(), (ie) => kindOf(ie) === ae), typeOfTest = (ae) => (ie) => typeof ie === ae, { isArray } = Array, isUndefined = typeOfTest("undefined");
function isBuffer(ae) {
  return ae !== null && !isUndefined(ae) && ae.constructor !== null && !isUndefined(ae.constructor) && isFunction$1(ae.constructor.isBuffer) && ae.constructor.isBuffer(ae);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(ae) {
  let ie;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ie = ArrayBuffer.isView(ae) : ie = ae && ae.buffer && isArrayBuffer(ae.buffer), ie;
}
const isString$1 = typeOfTest("string"), isFunction$1 = typeOfTest("function"), isNumber = typeOfTest("number"), isObject$1 = (ae) => ae !== null && typeof ae == "object", isBoolean = (ae) => ae === !0 || ae === !1, isPlainObject = (ae) => {
  if (kindOf(ae) !== "object")
    return !1;
  const ie = getPrototypeOf(ae);
  return (ie === null || ie === Object.prototype || Object.getPrototypeOf(ie) === null) && !(Symbol.toStringTag in ae) && !(Symbol.iterator in ae);
}, isDate = kindOfTest("Date"), isFile = kindOfTest("File"), isBlob = kindOfTest("Blob"), isFileList = kindOfTest("FileList"), isStream = (ae) => isObject$1(ae) && isFunction$1(ae.pipe), isFormData = (ae) => {
  let ie;
  return ae && (typeof FormData == "function" && ae instanceof FormData || isFunction$1(ae.append) && ((ie = kindOf(ae)) === "formdata" || // detect form-data instance
  ie === "object" && isFunction$1(ae.toString) && ae.toString() === "[object FormData]"));
}, isURLSearchParams = kindOfTest("URLSearchParams"), trim = (ae) => ae.trim ? ae.trim() : ae.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(ae, ie, { allOwnKeys: se = !1 } = {}) {
  if (ae === null || typeof ae > "u")
    return;
  let fe, ue;
  if (typeof ae != "object" && (ae = [ae]), isArray(ae))
    for (fe = 0, ue = ae.length; fe < ue; fe++)
      ie.call(null, ae[fe], fe, ae);
  else {
    const ce = se ? Object.getOwnPropertyNames(ae) : Object.keys(ae), de = ce.length;
    let me;
    for (fe = 0; fe < de; fe++)
      me = ce[fe], ie.call(null, ae[me], me, ae);
  }
}
function findKey(ae, ie) {
  ie = ie.toLowerCase();
  const se = Object.keys(ae);
  let fe = se.length, ue;
  for (; fe-- > 0; )
    if (ue = se[fe], ie === ue.toLowerCase())
      return ue;
  return null;
}
const _global = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global$1, isContextDefined = (ae) => !isUndefined(ae) && ae !== _global;
function merge() {
  const { caseless: ae } = isContextDefined(this) && this || {}, ie = {}, se = (fe, ue) => {
    const ce = ae && findKey(ie, ue) || ue;
    isPlainObject(ie[ce]) && isPlainObject(fe) ? ie[ce] = merge(ie[ce], fe) : isPlainObject(fe) ? ie[ce] = merge({}, fe) : isArray(fe) ? ie[ce] = fe.slice() : ie[ce] = fe;
  };
  for (let fe = 0, ue = arguments.length; fe < ue; fe++)
    arguments[fe] && forEach(arguments[fe], se);
  return ie;
}
const extend = (ae, ie, se, { allOwnKeys: fe } = {}) => (forEach(ie, (ue, ce) => {
  se && isFunction$1(ue) ? ae[ce] = bind(ue, se) : ae[ce] = ue;
}, { allOwnKeys: fe }), ae), stripBOM = (ae) => (ae.charCodeAt(0) === 65279 && (ae = ae.slice(1)), ae), inherits = (ae, ie, se, fe) => {
  ae.prototype = Object.create(ie.prototype, fe), ae.prototype.constructor = ae, Object.defineProperty(ae, "super", {
    value: ie.prototype
  }), se && Object.assign(ae.prototype, se);
}, toFlatObject = (ae, ie, se, fe) => {
  let ue, ce, de;
  const me = {};
  if (ie = ie || {}, ae == null)
    return ie;
  do {
    for (ue = Object.getOwnPropertyNames(ae), ce = ue.length; ce-- > 0; )
      de = ue[ce], (!fe || fe(de, ae, ie)) && !me[de] && (ie[de] = ae[de], me[de] = !0);
    ae = se !== !1 && getPrototypeOf(ae);
  } while (ae && (!se || se(ae, ie)) && ae !== Object.prototype);
  return ie;
}, endsWith = (ae, ie, se) => {
  ae = String(ae), (se === void 0 || se > ae.length) && (se = ae.length), se -= ie.length;
  const fe = ae.indexOf(ie, se);
  return fe !== -1 && fe === se;
}, toArray = (ae) => {
  if (!ae)
    return null;
  if (isArray(ae))
    return ae;
  let ie = ae.length;
  if (!isNumber(ie))
    return null;
  const se = new Array(ie);
  for (; ie-- > 0; )
    se[ie] = ae[ie];
  return se;
}, isTypedArray = /* @__PURE__ */ ((ae) => (ie) => ae && ie instanceof ae)(typeof Uint8Array < "u" && getPrototypeOf(Uint8Array)), forEachEntry = (ae, ie) => {
  const fe = (ae && ae[Symbol.iterator]).call(ae);
  let ue;
  for (; (ue = fe.next()) && !ue.done; ) {
    const ce = ue.value;
    ie.call(ae, ce[0], ce[1]);
  }
}, matchAll = (ae, ie) => {
  let se;
  const fe = [];
  for (; (se = ae.exec(ie)) !== null; )
    fe.push(se);
  return fe;
}, isHTMLForm = kindOfTest("HTMLFormElement"), toCamelCase = (ae) => ae.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(se, fe, ue) {
    return fe.toUpperCase() + ue;
  }
), hasOwnProperty = (({ hasOwnProperty: ae }) => (ie, se) => ae.call(ie, se))(Object.prototype), isRegExp = kindOfTest("RegExp"), reduceDescriptors = (ae, ie) => {
  const se = Object.getOwnPropertyDescriptors(ae), fe = {};
  forEach(se, (ue, ce) => {
    let de;
    (de = ie(ue, ce, ae)) !== !1 && (fe[ce] = de || ue);
  }), Object.defineProperties(ae, fe);
}, freezeMethods = (ae) => {
  reduceDescriptors(ae, (ie, se) => {
    if (isFunction$1(ae) && ["arguments", "caller", "callee"].indexOf(se) !== -1)
      return !1;
    const fe = ae[se];
    if (isFunction$1(fe)) {
      if (ie.enumerable = !1, "writable" in ie) {
        ie.writable = !1;
        return;
      }
      ie.set || (ie.set = () => {
        throw Error("Can not rewrite read-only method '" + se + "'");
      });
    }
  });
}, toObjectSet = (ae, ie) => {
  const se = {}, fe = (ue) => {
    ue.forEach((ce) => {
      se[ce] = !0;
    });
  };
  return isArray(ae) ? fe(ae) : fe(String(ae).split(ie)), se;
}, noop = () => {
}, toFiniteNumber = (ae, ie) => (ae = +ae, Number.isFinite(ae) ? ae : ie), ALPHA = "abcdefghijklmnopqrstuvwxyz", DIGIT = "0123456789", ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
}, generateString = (ae = 16, ie = ALPHABET.ALPHA_DIGIT) => {
  let se = "";
  const { length: fe } = ie;
  for (; ae--; )
    se += ie[Math.random() * fe | 0];
  return se;
};
function isSpecCompliantForm(ae) {
  return !!(ae && isFunction$1(ae.append) && ae[Symbol.toStringTag] === "FormData" && ae[Symbol.iterator]);
}
const toJSONObject = (ae) => {
  const ie = new Array(10), se = (fe, ue) => {
    if (isObject$1(fe)) {
      if (ie.indexOf(fe) >= 0)
        return;
      if (!("toJSON" in fe)) {
        ie[ue] = fe;
        const ce = isArray(fe) ? [] : {};
        return forEach(fe, (de, me) => {
          const we = se(de, ue + 1);
          !isUndefined(we) && (ce[me] = we);
        }), ie[ue] = void 0, ce;
      }
    }
    return fe;
  };
  return se(ae, 0);
}, isAsyncFn = kindOfTest("AsyncFunction"), isThenable = (ae) => ae && (isObject$1(ae) || isFunction$1(ae)) && isFunction$1(ae.then) && isFunction$1(ae.catch), utils$1 = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString: isString$1,
  isNumber,
  isBoolean,
  isObject: isObject$1,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction: isFunction$1,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};
function AxiosError(ae, ie, se, fe, ue) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = ae, this.name = "AxiosError", ie && (this.code = ie), se && (this.config = se), fe && (this.request = fe), ue && (this.response = ue);
}
utils$1.inherits(AxiosError, Error, {
  toJSON: function ae() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError.prototype, descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((ae) => {
  descriptors[ae] = { value: ae };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: !0 });
AxiosError.from = (ae, ie, se, fe, ue, ce) => {
  const de = Object.create(prototype$1);
  return utils$1.toFlatObject(ae, de, function(we) {
    return we !== Error.prototype;
  }, (me) => me !== "isAxiosError"), AxiosError.call(de, ae.message, ie, se, fe, ue), de.cause = ae, de.name = ae.name, ce && Object.assign(de, ce), de;
};
const httpAdapter = null;
function isVisitable(ae) {
  return utils$1.isPlainObject(ae) || utils$1.isArray(ae);
}
function removeBrackets(ae) {
  return utils$1.endsWith(ae, "[]") ? ae.slice(0, -2) : ae;
}
function renderKey(ae, ie, se) {
  return ae ? ae.concat(ie).map(function(ue, ce) {
    return ue = removeBrackets(ue), !se && ce ? "[" + ue + "]" : ue;
  }).join(se ? "." : "") : ie;
}
function isFlatArray(ae) {
  return utils$1.isArray(ae) && !ae.some(isVisitable);
}
const predicates = utils$1.toFlatObject(utils$1, {}, null, function ae(ie) {
  return /^is[A-Z]/.test(ie);
});
function toFormData(ae, ie, se) {
  if (!utils$1.isObject(ae))
    throw new TypeError("target must be an object");
  ie = ie || new FormData(), se = utils$1.toFlatObject(se, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(Ne, ke) {
    return !utils$1.isUndefined(ke[Ne]);
  });
  const fe = se.metaTokens, ue = se.visitor || Se, ce = se.dots, de = se.indexes, we = (se.Blob || typeof Blob < "u" && Blob) && utils$1.isSpecCompliantForm(ie);
  if (!utils$1.isFunction(ue))
    throw new TypeError("visitor must be a function");
  function Ee(Pe) {
    if (Pe === null)
      return "";
    if (utils$1.isDate(Pe))
      return Pe.toISOString();
    if (!we && utils$1.isBlob(Pe))
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    return utils$1.isArrayBuffer(Pe) || utils$1.isTypedArray(Pe) ? we && typeof Blob == "function" ? new Blob([Pe]) : Buffer$F.from(Pe) : Pe;
  }
  function Se(Pe, Ne, ke) {
    let He = Pe;
    if (Pe && !ke && typeof Pe == "object") {
      if (utils$1.endsWith(Ne, "{}"))
        Ne = fe ? Ne : Ne.slice(0, -2), Pe = JSON.stringify(Pe);
      else if (utils$1.isArray(Pe) && isFlatArray(Pe) || (utils$1.isFileList(Pe) || utils$1.endsWith(Ne, "[]")) && (He = utils$1.toArray(Pe)))
        return Ne = removeBrackets(Ne), He.forEach(function(Ge, Ye) {
          !(utils$1.isUndefined(Ge) || Ge === null) && ie.append(
            // eslint-disable-next-line no-nested-ternary
            de === !0 ? renderKey([Ne], Ye, ce) : de === null ? Ne : Ne + "[]",
            Ee(Ge)
          );
        }), !1;
    }
    return isVisitable(Pe) ? !0 : (ie.append(renderKey(ke, Ne, ce), Ee(Pe)), !1);
  }
  const Be = [], Ce = Object.assign(predicates, {
    defaultVisitor: Se,
    convertValue: Ee,
    isVisitable
  });
  function Ie(Pe, Ne) {
    if (!utils$1.isUndefined(Pe)) {
      if (Be.indexOf(Pe) !== -1)
        throw Error("Circular reference detected in " + Ne.join("."));
      Be.push(Pe), utils$1.forEach(Pe, function(He, De) {
        (!(utils$1.isUndefined(He) || He === null) && ue.call(
          ie,
          He,
          utils$1.isString(De) ? De.trim() : De,
          Ne,
          Ce
        )) === !0 && Ie(He, Ne ? Ne.concat(De) : [De]);
      }), Be.pop();
    }
  }
  if (!utils$1.isObject(ae))
    throw new TypeError("data must be an object");
  return Ie(ae), ie;
}
function encode$1(ae) {
  const ie = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(ae).replace(/[!'()~]|%20|%00/g, function(fe) {
    return ie[fe];
  });
}
function AxiosURLSearchParams(ae, ie) {
  this._pairs = [], ae && toFormData(ae, this, ie);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function ae(ie, se) {
  this._pairs.push([ie, se]);
};
prototype.toString = function ae(ie) {
  const se = ie ? function(fe) {
    return ie.call(this, fe, encode$1);
  } : encode$1;
  return this._pairs.map(function(ue) {
    return se(ue[0]) + "=" + se(ue[1]);
  }, "").join("&");
};
function encode(ae) {
  return encodeURIComponent(ae).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(ae, ie, se) {
  if (!ie)
    return ae;
  const fe = se && se.encode || encode, ue = se && se.serialize;
  let ce;
  if (ue ? ce = ue(ie, se) : ce = utils$1.isURLSearchParams(ie) ? ie.toString() : new AxiosURLSearchParams(ie, se).toString(fe), ce) {
    const de = ae.indexOf("#");
    de !== -1 && (ae = ae.slice(0, de)), ae += (ae.indexOf("?") === -1 ? "?" : "&") + ce;
  }
  return ae;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(ie, se, fe) {
    return this.handlers.push({
      fulfilled: ie,
      rejected: se,
      synchronous: fe ? fe.synchronous : !1,
      runWhen: fe ? fe.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(ie) {
    this.handlers[ie] && (this.handlers[ie] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(ie) {
    utils$1.forEach(this.handlers, function(fe) {
      fe !== null && ie(fe);
    });
  }
}
const transitionalDefaults = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, URLSearchParams$1 = typeof URLSearchParams < "u" ? URLSearchParams : AxiosURLSearchParams, FormData$1 = typeof FormData < "u" ? FormData : null, Blob$1 = typeof Blob < "u" ? Blob : null, platform$1 = {
  isBrowser: !0,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, hasBrowserEnv = typeof window < "u" && typeof document < "u", hasStandardBrowserEnv = ((ae) => hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(ae) < 0)(typeof navigator < "u" && navigator.product), hasStandardBrowserWebWorkerEnv = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv
}, Symbol.toStringTag, { value: "Module" })), platform = {
  ...utils,
  ...platform$1
};
function toURLEncodedForm(ae, ie) {
  return toFormData(ae, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(se, fe, ue, ce) {
      return platform.isNode && utils$1.isBuffer(se) ? (this.append(fe, se.toString("base64")), !1) : ce.defaultVisitor.apply(this, arguments);
    }
  }, ie));
}
function parsePropPath(ae) {
  return utils$1.matchAll(/\w+|\[(\w*)]/g, ae).map((ie) => ie[0] === "[]" ? "" : ie[1] || ie[0]);
}
function arrayToObject(ae) {
  const ie = {}, se = Object.keys(ae);
  let fe;
  const ue = se.length;
  let ce;
  for (fe = 0; fe < ue; fe++)
    ce = se[fe], ie[ce] = ae[ce];
  return ie;
}
function formDataToJSON(ae) {
  function ie(se, fe, ue, ce) {
    let de = se[ce++];
    const me = Number.isFinite(+de), we = ce >= se.length;
    return de = !de && utils$1.isArray(ue) ? ue.length : de, we ? (utils$1.hasOwnProp(ue, de) ? ue[de] = [ue[de], fe] : ue[de] = fe, !me) : ((!ue[de] || !utils$1.isObject(ue[de])) && (ue[de] = []), ie(se, fe, ue[de], ce) && utils$1.isArray(ue[de]) && (ue[de] = arrayToObject(ue[de])), !me);
  }
  if (utils$1.isFormData(ae) && utils$1.isFunction(ae.entries)) {
    const se = {};
    return utils$1.forEachEntry(ae, (fe, ue) => {
      ie(parsePropPath(fe), ue, se, 0);
    }), se;
  }
  return null;
}
function stringifySafely(ae, ie, se) {
  if (utils$1.isString(ae))
    try {
      return (ie || JSON.parse)(ae), utils$1.trim(ae);
    } catch (fe) {
      if (fe.name !== "SyntaxError")
        throw fe;
    }
  return (se || JSON.stringify)(ae);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http"],
  transformRequest: [function ae(ie, se) {
    const fe = se.getContentType() || "", ue = fe.indexOf("application/json") > -1, ce = utils$1.isObject(ie);
    if (ce && utils$1.isHTMLForm(ie) && (ie = new FormData(ie)), utils$1.isFormData(ie))
      return ue && ue ? JSON.stringify(formDataToJSON(ie)) : ie;
    if (utils$1.isArrayBuffer(ie) || utils$1.isBuffer(ie) || utils$1.isStream(ie) || utils$1.isFile(ie) || utils$1.isBlob(ie))
      return ie;
    if (utils$1.isArrayBufferView(ie))
      return ie.buffer;
    if (utils$1.isURLSearchParams(ie))
      return se.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), ie.toString();
    let me;
    if (ce) {
      if (fe.indexOf("application/x-www-form-urlencoded") > -1)
        return toURLEncodedForm(ie, this.formSerializer).toString();
      if ((me = utils$1.isFileList(ie)) || fe.indexOf("multipart/form-data") > -1) {
        const we = this.env && this.env.FormData;
        return toFormData(
          me ? { "files[]": ie } : ie,
          we && new we(),
          this.formSerializer
        );
      }
    }
    return ce || ue ? (se.setContentType("application/json", !1), stringifySafely(ie)) : ie;
  }],
  transformResponse: [function ae(ie) {
    const se = this.transitional || defaults.transitional, fe = se && se.forcedJSONParsing, ue = this.responseType === "json";
    if (ie && utils$1.isString(ie) && (fe && !this.responseType || ue)) {
      const de = !(se && se.silentJSONParsing) && ue;
      try {
        return JSON.parse(ie);
      } catch (me) {
        if (de)
          throw me.name === "SyntaxError" ? AxiosError.from(me, AxiosError.ERR_BAD_RESPONSE, this, null, this.response) : me;
      }
    }
    return ie;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function ae(ie) {
    return ie >= 200 && ie < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (ae) => {
  defaults.headers[ae] = {};
});
const defaults$1 = defaults, ignoreDuplicateOf = utils$1.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), parseHeaders = (ae) => {
  const ie = {};
  let se, fe, ue;
  return ae && ae.split(`
`).forEach(function(de) {
    ue = de.indexOf(":"), se = de.substring(0, ue).trim().toLowerCase(), fe = de.substring(ue + 1).trim(), !(!se || ie[se] && ignoreDuplicateOf[se]) && (se === "set-cookie" ? ie[se] ? ie[se].push(fe) : ie[se] = [fe] : ie[se] = ie[se] ? ie[se] + ", " + fe : fe);
  }), ie;
}, $internals = Symbol("internals");
function normalizeHeader(ae) {
  return ae && String(ae).trim().toLowerCase();
}
function normalizeValue(ae) {
  return ae === !1 || ae == null ? ae : utils$1.isArray(ae) ? ae.map(normalizeValue) : String(ae);
}
function parseTokens(ae) {
  const ie = /* @__PURE__ */ Object.create(null), se = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let fe;
  for (; fe = se.exec(ae); )
    ie[fe[1]] = fe[2];
  return ie;
}
const isValidHeaderName = (ae) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(ae.trim());
function matchHeaderValue(ae, ie, se, fe, ue) {
  if (utils$1.isFunction(fe))
    return fe.call(this, ie, se);
  if (ue && (ie = se), !!utils$1.isString(ie)) {
    if (utils$1.isString(fe))
      return ie.indexOf(fe) !== -1;
    if (utils$1.isRegExp(fe))
      return fe.test(ie);
  }
}
function formatHeader(ae) {
  return ae.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (ie, se, fe) => se.toUpperCase() + fe);
}
function buildAccessors(ae, ie) {
  const se = utils$1.toCamelCase(" " + ie);
  ["get", "set", "has"].forEach((fe) => {
    Object.defineProperty(ae, fe + se, {
      value: function(ue, ce, de) {
        return this[fe].call(this, ie, ue, ce, de);
      },
      configurable: !0
    });
  });
}
class AxiosHeaders {
  constructor(ie) {
    ie && this.set(ie);
  }
  set(ie, se, fe) {
    const ue = this;
    function ce(me, we, Ee) {
      const Se = normalizeHeader(we);
      if (!Se)
        throw new Error("header name must be a non-empty string");
      const Be = utils$1.findKey(ue, Se);
      (!Be || ue[Be] === void 0 || Ee === !0 || Ee === void 0 && ue[Be] !== !1) && (ue[Be || we] = normalizeValue(me));
    }
    const de = (me, we) => utils$1.forEach(me, (Ee, Se) => ce(Ee, Se, we));
    return utils$1.isPlainObject(ie) || ie instanceof this.constructor ? de(ie, se) : utils$1.isString(ie) && (ie = ie.trim()) && !isValidHeaderName(ie) ? de(parseHeaders(ie), se) : ie != null && ce(se, ie, fe), this;
  }
  get(ie, se) {
    if (ie = normalizeHeader(ie), ie) {
      const fe = utils$1.findKey(this, ie);
      if (fe) {
        const ue = this[fe];
        if (!se)
          return ue;
        if (se === !0)
          return parseTokens(ue);
        if (utils$1.isFunction(se))
          return se.call(this, ue, fe);
        if (utils$1.isRegExp(se))
          return se.exec(ue);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(ie, se) {
    if (ie = normalizeHeader(ie), ie) {
      const fe = utils$1.findKey(this, ie);
      return !!(fe && this[fe] !== void 0 && (!se || matchHeaderValue(this, this[fe], fe, se)));
    }
    return !1;
  }
  delete(ie, se) {
    const fe = this;
    let ue = !1;
    function ce(de) {
      if (de = normalizeHeader(de), de) {
        const me = utils$1.findKey(fe, de);
        me && (!se || matchHeaderValue(fe, fe[me], me, se)) && (delete fe[me], ue = !0);
      }
    }
    return utils$1.isArray(ie) ? ie.forEach(ce) : ce(ie), ue;
  }
  clear(ie) {
    const se = Object.keys(this);
    let fe = se.length, ue = !1;
    for (; fe--; ) {
      const ce = se[fe];
      (!ie || matchHeaderValue(this, this[ce], ce, ie, !0)) && (delete this[ce], ue = !0);
    }
    return ue;
  }
  normalize(ie) {
    const se = this, fe = {};
    return utils$1.forEach(this, (ue, ce) => {
      const de = utils$1.findKey(fe, ce);
      if (de) {
        se[de] = normalizeValue(ue), delete se[ce];
        return;
      }
      const me = ie ? formatHeader(ce) : String(ce).trim();
      me !== ce && delete se[ce], se[me] = normalizeValue(ue), fe[me] = !0;
    }), this;
  }
  concat(...ie) {
    return this.constructor.concat(this, ...ie);
  }
  toJSON(ie) {
    const se = /* @__PURE__ */ Object.create(null);
    return utils$1.forEach(this, (fe, ue) => {
      fe != null && fe !== !1 && (se[ue] = ie && utils$1.isArray(fe) ? fe.join(", ") : fe);
    }), se;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([ie, se]) => ie + ": " + se).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(ie) {
    return ie instanceof this ? ie : new this(ie);
  }
  static concat(ie, ...se) {
    const fe = new this(ie);
    return se.forEach((ue) => fe.set(ue)), fe;
  }
  static accessor(ie) {
    const fe = (this[$internals] = this[$internals] = {
      accessors: {}
    }).accessors, ue = this.prototype;
    function ce(de) {
      const me = normalizeHeader(de);
      fe[me] || (buildAccessors(ue, de), fe[me] = !0);
    }
    return utils$1.isArray(ie) ? ie.forEach(ce) : ce(ie), this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value: ae }, ie) => {
  let se = ie[0].toUpperCase() + ie.slice(1);
  return {
    get: () => ae,
    set(fe) {
      this[se] = fe;
    }
  };
});
utils$1.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(ae, ie) {
  const se = this || defaults$1, fe = ie || se, ue = AxiosHeaders$1.from(fe.headers);
  let ce = fe.data;
  return utils$1.forEach(ae, function(me) {
    ce = me.call(se, ce, ue.normalize(), ie ? ie.status : void 0);
  }), ue.normalize(), ce;
}
function isCancel(ae) {
  return !!(ae && ae.__CANCEL__);
}
function CanceledError(ae, ie, se) {
  AxiosError.call(this, ae ?? "canceled", AxiosError.ERR_CANCELED, ie, se), this.name = "CanceledError";
}
utils$1.inherits(CanceledError, AxiosError, {
  __CANCEL__: !0
});
function settle(ae, ie, se) {
  const fe = se.config.validateStatus;
  !se.status || !fe || fe(se.status) ? ae(se) : ie(new AxiosError(
    "Request failed with status code " + se.status,
    [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(se.status / 100) - 4],
    se.config,
    se.request,
    se
  ));
}
const cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(ae, ie, se, fe, ue, ce) {
      const de = [ae + "=" + encodeURIComponent(ie)];
      utils$1.isNumber(se) && de.push("expires=" + new Date(se).toGMTString()), utils$1.isString(fe) && de.push("path=" + fe), utils$1.isString(ue) && de.push("domain=" + ue), ce === !0 && de.push("secure"), document.cookie = de.join("; ");
    },
    read(ae) {
      const ie = document.cookie.match(new RegExp("(^|;\\s*)(" + ae + ")=([^;]*)"));
      return ie ? decodeURIComponent(ie[3]) : null;
    },
    remove(ae) {
      this.write(ae, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function isAbsoluteURL(ae) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(ae);
}
function combineURLs(ae, ie) {
  return ie ? ae.replace(/\/+$/, "") + "/" + ie.replace(/^\/+/, "") : ae;
}
function buildFullPath(ae, ie) {
  return ae && !isAbsoluteURL(ie) ? combineURLs(ae, ie) : ie;
}
const isURLSameOrigin = platform.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function ae() {
    const ie = /(msie|trident)/i.test(navigator.userAgent), se = document.createElement("a");
    let fe;
    function ue(ce) {
      let de = ce;
      return ie && (se.setAttribute("href", de), de = se.href), se.setAttribute("href", de), {
        href: se.href,
        protocol: se.protocol ? se.protocol.replace(/:$/, "") : "",
        host: se.host,
        search: se.search ? se.search.replace(/^\?/, "") : "",
        hash: se.hash ? se.hash.replace(/^#/, "") : "",
        hostname: se.hostname,
        port: se.port,
        pathname: se.pathname.charAt(0) === "/" ? se.pathname : "/" + se.pathname
      };
    }
    return fe = ue(window.location.href), function(de) {
      const me = utils$1.isString(de) ? ue(de) : de;
      return me.protocol === fe.protocol && me.host === fe.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function ae() {
    return function() {
      return !0;
    };
  }()
);
function parseProtocol(ae) {
  const ie = /^([-+\w]{1,25})(:?\/\/|:)/.exec(ae);
  return ie && ie[1] || "";
}
function speedometer(ae, ie) {
  ae = ae || 10;
  const se = new Array(ae), fe = new Array(ae);
  let ue = 0, ce = 0, de;
  return ie = ie !== void 0 ? ie : 1e3, function(we) {
    const Ee = Date.now(), Se = fe[ce];
    de || (de = Ee), se[ue] = we, fe[ue] = Ee;
    let Be = ce, Ce = 0;
    for (; Be !== ue; )
      Ce += se[Be++], Be = Be % ae;
    if (ue = (ue + 1) % ae, ue === ce && (ce = (ce + 1) % ae), Ee - de < ie)
      return;
    const Ie = Se && Ee - Se;
    return Ie ? Math.round(Ce * 1e3 / Ie) : void 0;
  };
}
function progressEventReducer(ae, ie) {
  let se = 0;
  const fe = speedometer(50, 250);
  return (ue) => {
    const ce = ue.loaded, de = ue.lengthComputable ? ue.total : void 0, me = ce - se, we = fe(me), Ee = ce <= de;
    se = ce;
    const Se = {
      loaded: ce,
      total: de,
      progress: de ? ce / de : void 0,
      bytes: me,
      rate: we || void 0,
      estimated: we && de && Ee ? (de - ce) / we : void 0,
      event: ue
    };
    Se[ie ? "download" : "upload"] = !0, ae(Se);
  };
}
const isXHRAdapterSupported = typeof XMLHttpRequest < "u", xhrAdapter = isXHRAdapterSupported && function(ae) {
  return new Promise(function(se, fe) {
    let ue = ae.data;
    const ce = AxiosHeaders$1.from(ae.headers).normalize();
    let { responseType: de, withXSRFToken: me } = ae, we;
    function Ee() {
      ae.cancelToken && ae.cancelToken.unsubscribe(we), ae.signal && ae.signal.removeEventListener("abort", we);
    }
    let Se;
    if (utils$1.isFormData(ue)) {
      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv)
        ce.setContentType(!1);
      else if ((Se = ce.getContentType()) !== !1) {
        const [Ne, ...ke] = Se ? Se.split(";").map((He) => He.trim()).filter(Boolean) : [];
        ce.setContentType([Ne || "multipart/form-data", ...ke].join("; "));
      }
    }
    let Be = new XMLHttpRequest();
    if (ae.auth) {
      const Ne = ae.auth.username || "", ke = ae.auth.password ? unescape(encodeURIComponent(ae.auth.password)) : "";
      ce.set("Authorization", "Basic " + btoa(Ne + ":" + ke));
    }
    const Ce = buildFullPath(ae.baseURL, ae.url);
    Be.open(ae.method.toUpperCase(), buildURL(Ce, ae.params, ae.paramsSerializer), !0), Be.timeout = ae.timeout;
    function Ie() {
      if (!Be)
        return;
      const Ne = AxiosHeaders$1.from(
        "getAllResponseHeaders" in Be && Be.getAllResponseHeaders()
      ), He = {
        data: !de || de === "text" || de === "json" ? Be.responseText : Be.response,
        status: Be.status,
        statusText: Be.statusText,
        headers: Ne,
        config: ae,
        request: Be
      };
      settle(function(Ge) {
        se(Ge), Ee();
      }, function(Ge) {
        fe(Ge), Ee();
      }, He), Be = null;
    }
    if ("onloadend" in Be ? Be.onloadend = Ie : Be.onreadystatechange = function() {
      !Be || Be.readyState !== 4 || Be.status === 0 && !(Be.responseURL && Be.responseURL.indexOf("file:") === 0) || setTimeout(Ie);
    }, Be.onabort = function() {
      Be && (fe(new AxiosError("Request aborted", AxiosError.ECONNABORTED, ae, Be)), Be = null);
    }, Be.onerror = function() {
      fe(new AxiosError("Network Error", AxiosError.ERR_NETWORK, ae, Be)), Be = null;
    }, Be.ontimeout = function() {
      let ke = ae.timeout ? "timeout of " + ae.timeout + "ms exceeded" : "timeout exceeded";
      const He = ae.transitional || transitionalDefaults;
      ae.timeoutErrorMessage && (ke = ae.timeoutErrorMessage), fe(new AxiosError(
        ke,
        He.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        ae,
        Be
      )), Be = null;
    }, platform.hasStandardBrowserEnv && (me && utils$1.isFunction(me) && (me = me(ae)), me || me !== !1 && isURLSameOrigin(Ce))) {
      const Ne = ae.xsrfHeaderName && ae.xsrfCookieName && cookies.read(ae.xsrfCookieName);
      Ne && ce.set(ae.xsrfHeaderName, Ne);
    }
    ue === void 0 && ce.setContentType(null), "setRequestHeader" in Be && utils$1.forEach(ce.toJSON(), function(ke, He) {
      Be.setRequestHeader(He, ke);
    }), utils$1.isUndefined(ae.withCredentials) || (Be.withCredentials = !!ae.withCredentials), de && de !== "json" && (Be.responseType = ae.responseType), typeof ae.onDownloadProgress == "function" && Be.addEventListener("progress", progressEventReducer(ae.onDownloadProgress, !0)), typeof ae.onUploadProgress == "function" && Be.upload && Be.upload.addEventListener("progress", progressEventReducer(ae.onUploadProgress)), (ae.cancelToken || ae.signal) && (we = (Ne) => {
      Be && (fe(!Ne || Ne.type ? new CanceledError(null, ae, Be) : Ne), Be.abort(), Be = null);
    }, ae.cancelToken && ae.cancelToken.subscribe(we), ae.signal && (ae.signal.aborted ? we() : ae.signal.addEventListener("abort", we)));
    const Pe = parseProtocol(Ce);
    if (Pe && platform.protocols.indexOf(Pe) === -1) {
      fe(new AxiosError("Unsupported protocol " + Pe + ":", AxiosError.ERR_BAD_REQUEST, ae));
      return;
    }
    Be.send(ue || null);
  });
}, knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};
utils$1.forEach(knownAdapters, (ae, ie) => {
  if (ae) {
    try {
      Object.defineProperty(ae, "name", { value: ie });
    } catch {
    }
    Object.defineProperty(ae, "adapterName", { value: ie });
  }
});
const renderReason = (ae) => `- ${ae}`, isResolvedHandle = (ae) => utils$1.isFunction(ae) || ae === null || ae === !1, adapters = {
  getAdapter: (ae) => {
    ae = utils$1.isArray(ae) ? ae : [ae];
    const { length: ie } = ae;
    let se, fe;
    const ue = {};
    for (let ce = 0; ce < ie; ce++) {
      se = ae[ce];
      let de;
      if (fe = se, !isResolvedHandle(se) && (fe = knownAdapters[(de = String(se)).toLowerCase()], fe === void 0))
        throw new AxiosError(`Unknown adapter '${de}'`);
      if (fe)
        break;
      ue[de || "#" + ce] = fe;
    }
    if (!fe) {
      const ce = Object.entries(ue).map(
        ([me, we]) => `adapter ${me} ` + (we === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let de = ie ? ce.length > 1 ? `since :
` + ce.map(renderReason).join(`
`) : " " + renderReason(ce[0]) : "as no adapter specified";
      throw new AxiosError(
        "There is no suitable adapter to dispatch the request " + de,
        "ERR_NOT_SUPPORT"
      );
    }
    return fe;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(ae) {
  if (ae.cancelToken && ae.cancelToken.throwIfRequested(), ae.signal && ae.signal.aborted)
    throw new CanceledError(null, ae);
}
function dispatchRequest(ae) {
  return throwIfCancellationRequested(ae), ae.headers = AxiosHeaders$1.from(ae.headers), ae.data = transformData.call(
    ae,
    ae.transformRequest
  ), ["post", "put", "patch"].indexOf(ae.method) !== -1 && ae.headers.setContentType("application/x-www-form-urlencoded", !1), adapters.getAdapter(ae.adapter || defaults$1.adapter)(ae).then(function(fe) {
    return throwIfCancellationRequested(ae), fe.data = transformData.call(
      ae,
      ae.transformResponse,
      fe
    ), fe.headers = AxiosHeaders$1.from(fe.headers), fe;
  }, function(fe) {
    return isCancel(fe) || (throwIfCancellationRequested(ae), fe && fe.response && (fe.response.data = transformData.call(
      ae,
      ae.transformResponse,
      fe.response
    ), fe.response.headers = AxiosHeaders$1.from(fe.response.headers))), Promise.reject(fe);
  });
}
const headersToObject = (ae) => ae instanceof AxiosHeaders$1 ? ae.toJSON() : ae;
function mergeConfig(ae, ie) {
  ie = ie || {};
  const se = {};
  function fe(Ee, Se, Be) {
    return utils$1.isPlainObject(Ee) && utils$1.isPlainObject(Se) ? utils$1.merge.call({ caseless: Be }, Ee, Se) : utils$1.isPlainObject(Se) ? utils$1.merge({}, Se) : utils$1.isArray(Se) ? Se.slice() : Se;
  }
  function ue(Ee, Se, Be) {
    if (utils$1.isUndefined(Se)) {
      if (!utils$1.isUndefined(Ee))
        return fe(void 0, Ee, Be);
    } else
      return fe(Ee, Se, Be);
  }
  function ce(Ee, Se) {
    if (!utils$1.isUndefined(Se))
      return fe(void 0, Se);
  }
  function de(Ee, Se) {
    if (utils$1.isUndefined(Se)) {
      if (!utils$1.isUndefined(Ee))
        return fe(void 0, Ee);
    } else
      return fe(void 0, Se);
  }
  function me(Ee, Se, Be) {
    if (Be in ie)
      return fe(Ee, Se);
    if (Be in ae)
      return fe(void 0, Ee);
  }
  const we = {
    url: ce,
    method: ce,
    data: ce,
    baseURL: de,
    transformRequest: de,
    transformResponse: de,
    paramsSerializer: de,
    timeout: de,
    timeoutMessage: de,
    withCredentials: de,
    withXSRFToken: de,
    adapter: de,
    responseType: de,
    xsrfCookieName: de,
    xsrfHeaderName: de,
    onUploadProgress: de,
    onDownloadProgress: de,
    decompress: de,
    maxContentLength: de,
    maxBodyLength: de,
    beforeRedirect: de,
    transport: de,
    httpAgent: de,
    httpsAgent: de,
    cancelToken: de,
    socketPath: de,
    responseEncoding: de,
    validateStatus: me,
    headers: (Ee, Se) => ue(headersToObject(Ee), headersToObject(Se), !0)
  };
  return utils$1.forEach(Object.keys(Object.assign({}, ae, ie)), function(Se) {
    const Be = we[Se] || ue, Ce = Be(ae[Se], ie[Se], Se);
    utils$1.isUndefined(Ce) && Be !== me || (se[Se] = Ce);
  }), se;
}
const VERSION$1 = "1.6.2", validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((ae, ie) => {
  validators$1[ae] = function(fe) {
    return typeof fe === ae || "a" + (ie < 1 ? "n " : " ") + ae;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function ae(ie, se, fe) {
  function ue(ce, de) {
    return "[Axios v" + VERSION$1 + "] Transitional option '" + ce + "'" + de + (fe ? ". " + fe : "");
  }
  return (ce, de, me) => {
    if (ie === !1)
      throw new AxiosError(
        ue(de, " has been removed" + (se ? " in " + se : "")),
        AxiosError.ERR_DEPRECATED
      );
    return se && !deprecatedWarnings[de] && (deprecatedWarnings[de] = !0, console.warn(
      ue(
        de,
        " has been deprecated since v" + se + " and will be removed in the near future"
      )
    )), ie ? ie(ce, de, me) : !0;
  };
};
function assertOptions(ae, ie, se) {
  if (typeof ae != "object")
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  const fe = Object.keys(ae);
  let ue = fe.length;
  for (; ue-- > 0; ) {
    const ce = fe[ue], de = ie[ce];
    if (de) {
      const me = ae[ce], we = me === void 0 || de(me, ce, ae);
      if (we !== !0)
        throw new AxiosError("option " + ce + " must be " + we, AxiosError.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (se !== !0)
      throw new AxiosError("Unknown option " + ce, AxiosError.ERR_BAD_OPTION);
  }
}
const validator = {
  assertOptions,
  validators: validators$1
}, validators = validator.validators;
class Axios {
  constructor(ie) {
    this.defaults = ie, this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(ie, se) {
    typeof ie == "string" ? (se = se || {}, se.url = ie) : se = ie || {}, se = mergeConfig(this.defaults, se);
    const { transitional: fe, paramsSerializer: ue, headers: ce } = se;
    fe !== void 0 && validator.assertOptions(fe, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, !1), ue != null && (utils$1.isFunction(ue) ? se.paramsSerializer = {
      serialize: ue
    } : validator.assertOptions(ue, {
      encode: validators.function,
      serialize: validators.function
    }, !0)), se.method = (se.method || this.defaults.method || "get").toLowerCase();
    let de = ce && utils$1.merge(
      ce.common,
      ce[se.method]
    );
    ce && utils$1.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (Pe) => {
        delete ce[Pe];
      }
    ), se.headers = AxiosHeaders$1.concat(de, ce);
    const me = [];
    let we = !0;
    this.interceptors.request.forEach(function(Ne) {
      typeof Ne.runWhen == "function" && Ne.runWhen(se) === !1 || (we = we && Ne.synchronous, me.unshift(Ne.fulfilled, Ne.rejected));
    });
    const Ee = [];
    this.interceptors.response.forEach(function(Ne) {
      Ee.push(Ne.fulfilled, Ne.rejected);
    });
    let Se, Be = 0, Ce;
    if (!we) {
      const Pe = [dispatchRequest.bind(this), void 0];
      for (Pe.unshift.apply(Pe, me), Pe.push.apply(Pe, Ee), Ce = Pe.length, Se = Promise.resolve(se); Be < Ce; )
        Se = Se.then(Pe[Be++], Pe[Be++]);
      return Se;
    }
    Ce = me.length;
    let Ie = se;
    for (Be = 0; Be < Ce; ) {
      const Pe = me[Be++], Ne = me[Be++];
      try {
        Ie = Pe(Ie);
      } catch (ke) {
        Ne.call(this, ke);
        break;
      }
    }
    try {
      Se = dispatchRequest.call(this, Ie);
    } catch (Pe) {
      return Promise.reject(Pe);
    }
    for (Be = 0, Ce = Ee.length; Be < Ce; )
      Se = Se.then(Ee[Be++], Ee[Be++]);
    return Se;
  }
  getUri(ie) {
    ie = mergeConfig(this.defaults, ie);
    const se = buildFullPath(ie.baseURL, ie.url);
    return buildURL(se, ie.params, ie.paramsSerializer);
  }
}
utils$1.forEach(["delete", "get", "head", "options"], function ae(ie) {
  Axios.prototype[ie] = function(se, fe) {
    return this.request(mergeConfig(fe || {}, {
      method: ie,
      url: se,
      data: (fe || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function ae(ie) {
  function se(fe) {
    return function(ce, de, me) {
      return this.request(mergeConfig(me || {}, {
        method: ie,
        headers: fe ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: ce,
        data: de
      }));
    };
  }
  Axios.prototype[ie] = se(), Axios.prototype[ie + "Form"] = se(!0);
});
const Axios$1 = Axios;
class CancelToken {
  constructor(ie) {
    if (typeof ie != "function")
      throw new TypeError("executor must be a function.");
    let se;
    this.promise = new Promise(function(ce) {
      se = ce;
    });
    const fe = this;
    this.promise.then((ue) => {
      if (!fe._listeners)
        return;
      let ce = fe._listeners.length;
      for (; ce-- > 0; )
        fe._listeners[ce](ue);
      fe._listeners = null;
    }), this.promise.then = (ue) => {
      let ce;
      const de = new Promise((me) => {
        fe.subscribe(me), ce = me;
      }).then(ue);
      return de.cancel = function() {
        fe.unsubscribe(ce);
      }, de;
    }, ie(function(ce, de, me) {
      fe.reason || (fe.reason = new CanceledError(ce, de, me), se(fe.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(ie) {
    if (this.reason) {
      ie(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(ie) : this._listeners = [ie];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(ie) {
    if (!this._listeners)
      return;
    const se = this._listeners.indexOf(ie);
    se !== -1 && this._listeners.splice(se, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let ie;
    return {
      token: new CancelToken(function(ue) {
        ie = ue;
      }),
      cancel: ie
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(ae) {
  return function(se) {
    return ae.apply(null, se);
  };
}
function isAxiosError(ae) {
  return utils$1.isObject(ae) && ae.isAxiosError === !0;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([ae, ie]) => {
  HttpStatusCode[ie] = ae;
});
const HttpStatusCode$1 = HttpStatusCode;
function createInstance(ae) {
  const ie = new Axios$1(ae), se = bind(Axios$1.prototype.request, ie);
  return utils$1.extend(se, Axios$1.prototype, ie, { allOwnKeys: !0 }), utils$1.extend(se, ie, null, { allOwnKeys: !0 }), se.create = function(ue) {
    return createInstance(mergeConfig(ae, ue));
  }, se;
}
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION$1;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function ae(ie) {
  return Promise.all(ie);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (ae) => formDataToJSON(utils$1.isHTMLForm(ae) ? new FormData(ae) : ae);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
async function aptosClient(ae) {
  var ie;
  const { params: se, method: fe, url: ue, headers: ce, body: de, overrides: me } = ae, we = {
    headers: ce,
    method: fe,
    url: ue,
    params: se,
    data: de,
    withCredentials: (ie = me?.WITH_CREDENTIALS) != null ? ie : !0
  };
  try {
    const Ee = await axios(we);
    return {
      status: Ee.status,
      statusText: Ee.statusText,
      data: Ee.data,
      headers: Ee.headers,
      config: Ee.config
    };
  } catch (Ee) {
    const Se = Ee;
    if (Se.response)
      return Se.response;
    throw Ee;
  }
}
var n$1 = class {
  constructor(ie) {
    this.network = ie?.network ?? "devnet", this.fullnode = ie?.fullnode, this.faucet = ie?.faucet, this.indexer = ie?.indexer, this.client = ie?.client ?? { provider: aptosClient }, this.clientConfig = ie?.clientConfig ?? {};
  }
  getRequestUrl(ie) {
    switch (ie) {
      case 0:
        if (this.fullnode !== void 0)
          return this.fullnode;
        if (this.network === "custom")
          throw new Error("Please provide a custom full node url");
        return o$2[this.network];
      case 2:
        if (this.faucet !== void 0)
          return this.faucet;
        if (this.network === "custom")
          throw new Error("Please provide a custom faucet url");
        return a$1[this.network];
      case 1:
        if (this.indexer !== void 0)
          return this.indexer;
        if (this.network === "custom")
          throw new Error("Please provide a custom indexer url");
        return n$5[this.network];
      default:
        throw Error(`apiType ${ie} is not supported`);
    }
  }
  isIndexerRequest(ie) {
    return n$5[this.network] === ie;
  }
  isFullnodeRequest(ie) {
    return o$2[this.network] === ie;
  }
  isFaucetRequest(ie) {
    return a$1[this.network] === ie;
  }
}, u$1 = { typeParameters: [{ constraints: [] }], parameters: [new S$4(), new p$4()] };
async function y$1(ae) {
  let { aptosConfig: ie, sender: se, recipient: fe, amount: ue, coinType: ce, options: de } = ae;
  return h$3({ aptosConfig: ie, sender: se, data: { function: "0x1::aptos_account::transfer_coins", typeArguments: [ce ?? N$5], functionArguments: [fe, ue], abi: u$1 }, options: de });
}
var t$1 = class {
  constructor(ie) {
    this.config = ie;
  }
  async transferCoinTransaction(ie) {
    return y$1({ aptosConfig: this.config, ...ie });
  }
}, C = { BOOLEAN: "bool", U8: "u8", U16: "u16", U32: "u32", U64: "u64", U128: "u128", U256: "u256", ADDRESS: "address", STRING: "0x1::string::String", ARRAY: "vector<u8>" }, m$1 = "0x4::token::Token";
async function _t(ae) {
  let { aptosConfig: ie, digitalAssetAddress: se } = ae, fe = { token_data_id: { _eq: c$b.from(se).toStringLong() } };
  return (await p$6({ aptosConfig: ie, query: { query: Q$2, variables: { where_condition: fe } }, originMethod: "getDigitalAssetData" })).current_token_datas_v2[0];
}
async function Pt(ae) {
  let { aptosConfig: ie, digitalAssetAddress: se } = ae, fe = { token_data_id: { _eq: c$b.from(se).toStringLong() } };
  return (await p$6({ aptosConfig: ie, query: { query: q$2, variables: { where_condition: fe } }, originMethod: "getCurrentDigitalAssetOwnership" })).current_token_ownerships_v2[0];
}
async function kt(ae) {
  let { aptosConfig: ie, ownerAddress: se, options: fe } = ae, ue = { owner_address: { _eq: c$b.from(se).toStringLong() }, amount: { _gt: 0 } }, ce = { query: q$2, variables: { where_condition: ue, offset: fe?.offset, limit: fe?.limit, order_by: fe?.orderBy } };
  return (await p$6({ aptosConfig: ie, query: ce, originMethod: "getOwnedDigitalAssets" })).current_token_ownerships_v2;
}
async function Dt(ae) {
  let { aptosConfig: ie, digitalAssetAddress: se, options: fe } = ae, ue = { token_data_id: { _eq: c$b.from(se).toStringLong() } }, ce = { query: C$3, variables: { where_condition: ue, offset: fe?.offset, limit: fe?.limit, order_by: fe?.orderBy } };
  return (await p$6({ aptosConfig: ie, query: ce, originMethod: "getDigitalAssetActivity" })).token_activities_v2;
}
var Q = { typeParameters: [], parameters: [new b$7(V$2()), new p$4(), new b$7(V$2()), new b$7(V$2()), new c$7(), new c$7(), new c$7(), new c$7(), new c$7(), new c$7(), new c$7(), new c$7(), new c$7(), new p$4(), new p$4()] };
async function St(ae) {
  let { aptosConfig: ie, options: se, creator: fe } = ae;
  return h$3({ aptosConfig: ie, sender: fe.accountAddress, data: { function: "0x4::aptos_token::create_collection", functionArguments: [new a$a(ae.description), new m$7(ae.maxSupply ?? _$4), new a$a(ae.name), new a$a(ae.uri), new U$6(ae.mutableDescription ?? !0), new U$6(ae.mutableRoyalty ?? !0), new U$6(ae.mutableURI ?? !0), new U$6(ae.mutableTokenDescription ?? !0), new U$6(ae.mutableTokenName ?? !0), new U$6(ae.mutableTokenProperties ?? !0), new U$6(ae.mutableTokenURI ?? !0), new U$6(ae.tokensBurnableByCreator ?? !0), new U$6(ae.tokensFreezableByCreator ?? !0), new m$7(ae.royaltyNumerator ?? 0), new m$7(ae.royaltyDenominator ?? 1)], abi: Q }, options: se });
}
async function U(ae) {
  let { aptosConfig: ie, creatorAddress: se, collectionName: fe, options: ue } = ae, ce = c$b.from(se), de = { collection_name: { _eq: fe }, creator_address: { _eq: ce.toStringLong() } };
  return ue?.tokenStandard && (de.token_standard = { _eq: ue?.tokenStandard ?? "v2" }), (await p$6({ aptosConfig: ie, query: { query: T$7, variables: { where_condition: de } }, originMethod: "getCollectionData" })).current_collections_v2[0];
}
async function vt(ae) {
  let { aptosConfig: ie, collectionId: se } = ae, fe = { collection_id: { _eq: c$b.from(se).toStringLong() } };
  return (await p$6({ aptosConfig: ie, query: { query: T$7, variables: { where_condition: fe } }, originMethod: "getCollectionData" })).current_collections_v2[0];
}
async function ht(ae) {
  return (await U(ae)).collection_id;
}
var F = { typeParameters: [], parameters: [new b$7(V$2()), new b$7(V$2()), new b$7(V$2()), new b$7(V$2()), new y$a(new b$7(V$2())), new y$a(new b$7(V$2())), new y$a(y$a.u8())] };
async function xt(ae) {
  let { aptosConfig: ie, options: se, creator: fe, collection: ue, description: ce, name: de, uri: me, propertyKeys: we, propertyTypes: Ee, propertyValues: Se } = ae, Be = Ee?.map((Ce) => C[Ce]);
  return h$3({ aptosConfig: ie, sender: fe.accountAddress, data: { function: "0x4::aptos_token::mint", functionArguments: [new a$a(ue), new a$a(ce), new a$a(de), new a$a(me), t$6.MoveString(we ?? []), t$6.MoveString(Be ?? []), R$1(Se ?? [], Be ?? [])], abi: F }, options: se });
}
var N = { typeParameters: [{ constraints: ["key"] }], parameters: [new b$7(G$4(new h$7(0))), new S$4()] };
async function Gt(ae) {
  let { aptosConfig: ie, sender: se, digitalAssetAddress: fe, recipient: ue, digitalAssetType: ce, options: de } = ae;
  return h$3({ aptosConfig: ie, sender: se.accountAddress, data: { function: "0x1::object::transfer", typeArguments: [ce ?? m$1], functionArguments: [c$b.from(fe), c$b.from(ue)], abi: N }, options: de });
}
var Y = { typeParameters: [], parameters: [new b$7(V$2()), new b$7(V$2()), new b$7(V$2()), new b$7(V$2()), new y$a(new b$7(V$2())), new y$a(new b$7(V$2())), new y$a(y$a.u8()), new S$4()] };
async function Bt(ae) {
  let { aptosConfig: ie, account: se, collection: fe, description: ue, name: ce, uri: de, recipient: me, propertyKeys: we, propertyTypes: Ee, propertyValues: Se, options: Be } = ae;
  if (we?.length !== Se?.length)
    throw new Error("Property keys and property values counts do not match");
  if (Ee?.length !== Se?.length)
    throw new Error("Property types and property values counts do not match");
  let Ce = Ee?.map((Ie) => C[Ie]);
  return h$3({ aptosConfig: ie, sender: se.accountAddress, data: { function: "0x4::aptos_token::mint_soul_bound", functionArguments: [fe, ue, ce, de, t$6.MoveString(we ?? []), t$6.MoveString(Ce ?? []), R$1(Se ?? [], Ce ?? []), me], abi: Y }, options: Be });
}
var z = { typeParameters: [{ constraints: ["key"] }], parameters: [new b$7(G$4(new h$7(0)))] };
async function Ot(ae) {
  let { aptosConfig: ie, creator: se, digitalAssetAddress: fe, digitalAssetType: ue, options: ce } = ae;
  return h$3({ aptosConfig: ie, sender: se.accountAddress, data: { function: "0x4::aptos_token::burn", typeArguments: [ue ?? m$1], functionArguments: [c$b.from(fe)], abi: z }, options: ce });
}
var L = { typeParameters: [{ constraints: ["key"] }], parameters: [new b$7(G$4(new h$7(0)))] };
async function Et(ae) {
  let { aptosConfig: ie, creator: se, digitalAssetAddress: fe, digitalAssetType: ue, options: ce } = ae;
  return h$3({ aptosConfig: ie, sender: se.accountAddress, data: { function: "0x4::aptos_token::freeze_transfer", typeArguments: [ue ?? m$1], functionArguments: [fe], abi: L }, options: ce });
}
var j = { typeParameters: [{ constraints: ["key"] }], parameters: [new b$7(G$4(new h$7(0)))] };
async function qt(ae) {
  let { aptosConfig: ie, creator: se, digitalAssetAddress: fe, digitalAssetType: ue, options: ce } = ae;
  return h$3({ aptosConfig: ie, sender: se.accountAddress, data: { function: "0x4::aptos_token::unfreeze_transfer", typeArguments: [ue ?? m$1], functionArguments: [fe], abi: j }, options: ce });
}
var X = { typeParameters: [{ constraints: ["key"] }], parameters: [new b$7(G$4(new h$7(0))), new b$7(V$2())] };
async function Vt(ae) {
  let { aptosConfig: ie, creator: se, description: fe, digitalAssetAddress: ue, digitalAssetType: ce, options: de } = ae;
  return h$3({ aptosConfig: ie, sender: se.accountAddress, data: { function: "0x4::aptos_token::set_description", typeArguments: [ce ?? m$1], functionArguments: [c$b.from(ue), new a$a(fe)], abi: X }, options: de });
}
var H = { typeParameters: [{ constraints: ["key"] }], parameters: [new b$7(G$4(new h$7(0))), new b$7(V$2())] };
async function Mt(ae) {
  let { aptosConfig: ie, creator: se, name: fe, digitalAssetAddress: ue, digitalAssetType: ce, options: de } = ae;
  return h$3({ aptosConfig: ie, sender: se.accountAddress, data: { function: "0x4::aptos_token::set_name", typeArguments: [ce ?? m$1], functionArguments: [c$b.from(ue), new a$a(fe)], abi: H }, options: de });
}
var J = { typeParameters: [{ constraints: ["key"] }], parameters: [new b$7(G$4(new h$7(0))), new b$7(V$2())] };
async function Rt(ae) {
  let { aptosConfig: ie, creator: se, uri: fe, digitalAssetAddress: ue, digitalAssetType: ce, options: de } = ae;
  return h$3({ aptosConfig: ie, sender: se.accountAddress, data: { function: "0x4::aptos_token::set_uri", typeArguments: [ce ?? m$1], functionArguments: [c$b.from(ue), new a$a(fe)], abi: J }, options: de });
}
var W = { typeParameters: [{ constraints: ["key"] }], parameters: [new b$7(G$4(new h$7(0))), new b$7(V$2()), new b$7(V$2()), y$a.u8()] };
async function Kt(ae) {
  let { aptosConfig: ie, creator: se, propertyKey: fe, propertyType: ue, propertyValue: ce, digitalAssetAddress: de, digitalAssetType: me, options: we } = ae;
  return h$3({ aptosConfig: ie, sender: se.accountAddress, data: { function: "0x4::aptos_token::add_property", typeArguments: [me ?? m$1], functionArguments: [c$b.from(de), new a$a(fe), new a$a(C[ue]), t$6.U8(B(ce, C[ue]))], abi: W }, options: we });
}
var Z = { typeParameters: [{ constraints: ["key"] }], parameters: [new b$7(G$4(new h$7(0))), new b$7(V$2())] };
async function Qt(ae) {
  let { aptosConfig: ie, creator: se, propertyKey: fe, digitalAssetAddress: ue, digitalAssetType: ce, options: de } = ae;
  return h$3({ aptosConfig: ie, sender: se.accountAddress, data: { function: "0x4::aptos_token::remove_property", typeArguments: [ce ?? m$1], functionArguments: [c$b.from(ue), new a$a(fe)], abi: Z }, options: de });
}
var $ = { typeParameters: [{ constraints: ["key"] }], parameters: [new b$7(G$4(new h$7(0))), new b$7(V$2()), new b$7(V$2()), y$a.u8()] };
async function Ut(ae) {
  let { aptosConfig: ie, creator: se, propertyKey: fe, propertyType: ue, propertyValue: ce, digitalAssetAddress: de, digitalAssetType: me, options: we } = ae;
  return h$3({ aptosConfig: ie, sender: se.accountAddress, data: { function: "0x4::aptos_token::update_property", typeArguments: [me ?? m$1], functionArguments: [c$b.from(de), new a$a(fe), new a$a(C[ue]), B(ce, C[ue])], abi: $ }, options: we });
}
var tt = { typeParameters: [{ constraints: ["key"] }, { constraints: [] }], parameters: [new b$7(G$4(new h$7(0))), new b$7(V$2()), new h$7(1)] };
async function Ft(ae) {
  let { aptosConfig: ie, creator: se, propertyKey: fe, propertyType: ue, propertyValue: ce, digitalAssetAddress: de, digitalAssetType: me, options: we } = ae;
  return h$3({ aptosConfig: ie, sender: se.accountAddress, data: { function: "0x4::aptos_token::add_typed_property", typeArguments: [me ?? m$1, C[ue]], functionArguments: [c$b.from(de), new a$a(fe), ce], abi: tt }, options: we });
}
var et = { typeParameters: [{ constraints: ["key"] }, { constraints: [] }], parameters: [new b$7(G$4(new h$7(0))), new b$7(V$2()), new h$7(1)] };
async function Nt(ae) {
  let { aptosConfig: ie, creator: se, propertyKey: fe, propertyType: ue, propertyValue: ce, digitalAssetAddress: de, digitalAssetType: me, options: we } = ae;
  return h$3({ aptosConfig: ie, sender: se.accountAddress, data: { function: "0x4::aptos_token::update_typed_property", typeArguments: [me ?? m$1, C[ue]], functionArguments: [c$b.from(de), new a$a(fe), ce], abi: et }, options: we });
}
function R$1(ae, ie) {
  let se = new Array();
  return ie.forEach((fe, ue) => {
    se.push(B(ae[ue], fe));
  }), se;
}
function B(ae, ie) {
  let se = Z$3(ie);
  return U$3(ae, se, 0, []).bcsToBytes();
}
var V = class {
  constructor(ae) {
    this.config = ae;
  }
  async getCollectionData(ae) {
    return await i$4({ config: this.config, minimumLedgerVersion: ae.minimumLedgerVersion, processorType: "token_v2_processor" }), U({ aptosConfig: this.config, ...ae });
  }
  async getCollectionDataByCollectionId(ae) {
    return await i$4({ config: this.config, minimumLedgerVersion: ae.minimumLedgerVersion, processorType: "token_v2_processor" }), vt({ aptosConfig: this.config, ...ae });
  }
  async getCollectionId(ae) {
    return await i$4({ config: this.config, minimumLedgerVersion: ae.minimumLedgerVersion, processorType: "token_v2_processor" }), ht({ aptosConfig: this.config, ...ae });
  }
  async getDigitalAssetData(ae) {
    return await i$4({ config: this.config, minimumLedgerVersion: ae.minimumLedgerVersion, processorType: "token_v2_processor" }), _t({ aptosConfig: this.config, ...ae });
  }
  async getCurrentDigitalAssetOwnership(ae) {
    return await i$4({ config: this.config, minimumLedgerVersion: ae.minimumLedgerVersion, processorType: "token_v2_processor" }), Pt({ aptosConfig: this.config, ...ae });
  }
  async getOwnedDigitalAssets(ae) {
    return await i$4({ config: this.config, minimumLedgerVersion: ae.minimumLedgerVersion, processorType: "token_v2_processor" }), kt({ aptosConfig: this.config, ...ae });
  }
  async getDigitalAssetActivity(ae) {
    return await i$4({ config: this.config, minimumLedgerVersion: ae.minimumLedgerVersion, processorType: "token_v2_processor" }), Dt({ aptosConfig: this.config, ...ae });
  }
  async createCollectionTransaction(ae) {
    return St({ aptosConfig: this.config, ...ae });
  }
  async mintDigitalAssetTransaction(ae) {
    return xt({ aptosConfig: this.config, ...ae });
  }
  async transferDigitalAssetTransaction(ae) {
    return Gt({ aptosConfig: this.config, ...ae });
  }
  async mintSoulBoundTransaction(ae) {
    return Bt({ aptosConfig: this.config, ...ae });
  }
  async burnDigitalAssetTransaction(ae) {
    return Ot({ aptosConfig: this.config, ...ae });
  }
  async freezeDigitalAssetTransaferTransaction(ae) {
    return Et({ aptosConfig: this.config, ...ae });
  }
  async unfreezeDigitalAssetTransaferTransaction(ae) {
    return qt({ aptosConfig: this.config, ...ae });
  }
  async setDigitalAssetDescriptionTransaction(ae) {
    return Vt({ aptosConfig: this.config, ...ae });
  }
  async setDigitalAssetNameTransaction(ae) {
    return Mt({ aptosConfig: this.config, ...ae });
  }
  async setDigitalAssetURITransaction(ae) {
    return Rt({ aptosConfig: this.config, ...ae });
  }
  async addDigitalAssetPropertyTransaction(ae) {
    return Kt({ aptosConfig: this.config, ...ae });
  }
  async removeDigitalAssetPropertyTransaction(ae) {
    return Qt({ aptosConfig: this.config, ...ae });
  }
  async updateDigitalAssetPropertyTransaction(ae) {
    return Ut({ aptosConfig: this.config, ...ae });
  }
  async addDigitalAssetTypedPropertyTransaction(ae) {
    return Ft({ aptosConfig: this.config, ...ae });
  }
  async updateDigitalAssetTypedPropertyTransaction(ae) {
    return Nt({ aptosConfig: this.config, ...ae });
  }
}, t = class {
  constructor(ae) {
    this.config = new n$1(ae), this.account = new l$1(this.config), this.ans = new A(this.config), this.coin = new t$1(this.config), this.digitalAsset = new V(this.config), this.event = new i$3(this.config), this.faucet = new r$7(this.config), this.fungibleAsset = new r$1(this.config), this.general = new u$3(this.config), this.staking = new t$2(this.config), this.transaction = new h$1(this.config);
  }
};
function n(ae, ie, se) {
  Object.getOwnPropertyNames(ie.prototype).forEach((fe) => {
    let ue = Object.getOwnPropertyDescriptor(ie.prototype, fe);
    ue && (ue.value = function(...ce) {
      return this[se][fe](...ce);
    }, Object.defineProperty(ae.prototype, fe, ue));
  });
}
n(t, l$1, "account");
n(t, A, "ans");
n(t, t$1, "coin");
n(t, V, "digitalAsset");
n(t, i$3, "event");
n(t, r$7, "faucet");
n(t, r$1, "fungibleAsset");
n(t, u$3, "general");
n(t, t$2, "staking");
n(t, h$1, "transaction");
var a = ((ae) => (ae.JSON = "application/json", ae.BCS = "application/x-bcs", ae.BCS_SIGNED_TRANSACTION = "application/x.aptos.signed_transaction+bcs", ae))(a || {}), g = ((ae) => (ae[ae.Bool = 0] = "Bool", ae[ae.U8 = 1] = "U8", ae[ae.U64 = 2] = "U64", ae[ae.U128 = 3] = "U128", ae[ae.Address = 4] = "Address", ae[ae.Signer = 5] = "Signer", ae[ae.Vector = 6] = "Vector", ae[ae.Struct = 7] = "Struct", ae[ae.U16 = 8] = "U16", ae[ae.U32 = 9] = "U32", ae[ae.U256 = 10] = "U256", ae[ae.Reference = 254] = "Reference", ae[ae.Generic = 255] = "Generic", ae))(g || {}), y = ((ae) => (ae[ae.U8 = 0] = "U8", ae[ae.U64 = 1] = "U64", ae[ae.U128 = 2] = "U128", ae[ae.Address = 3] = "Address", ae[ae.U8Vector = 4] = "U8Vector", ae[ae.Bool = 5] = "Bool", ae[ae.U16 = 6] = "U16", ae[ae.U32 = 7] = "U32", ae[ae.U256 = 8] = "U256", ae))(y || {}), u = ((ae) => (ae[ae.Script = 0] = "Script", ae[ae.EntryFunction = 2] = "EntryFunction", ae[ae.Multisig = 3] = "Multisig", ae))(u || {}), d = ((ae) => (ae[ae.MultiAgentTransaction = 0] = "MultiAgentTransaction", ae[ae.FeePayerTransaction = 1] = "FeePayerTransaction", ae))(d || {}), c = ((ae) => (ae[ae.Ed25519 = 0] = "Ed25519", ae[ae.MultiEd25519 = 1] = "MultiEd25519", ae[ae.MultiAgent = 2] = "MultiAgent", ae[ae.FeePayer = 3] = "FeePayer", ae[ae.SingleSender = 4] = "SingleSender", ae))(c || {}), l = ((ae) => (ae[ae.Ed25519 = 0] = "Ed25519", ae[ae.MultiEd25519 = 1] = "MultiEd25519", ae[ae.SingleKey = 2] = "SingleKey", ae[ae.MultiKey = 3] = "MultiKey", ae))(l || {}), _ = ((ae) => (ae[ae.Ed25519 = 0] = "Ed25519", ae[ae.Secp256k1 = 1] = "Secp256k1", ae))(_ || {}), x = ((ae) => (ae[ae.Ed25519 = 0] = "Ed25519", ae[ae.Secp256k1 = 1] = "Secp256k1", ae))(x || {}), v = ((ae) => (ae.Pending = "pending_transaction", ae.User = "user_transaction", ae.Genesis = "genesis_transaction", ae.BlockMetadata = "block_metadata_transaction", ae.StateCheckpoint = "state_checkpoint_transaction", ae.Validator = "validator_transaction", ae))(v || {}), h = ((ae) => (ae.PRIVATE = "private", ae.PUBLIC = "public", ae.FRIEND = "friend", ae))(h || {}), M = ((ae) => (ae.STORE = "store", ae.DROP = "drop", ae.KEY = "key", ae.COPY = "copy", ae))(M || {}), m = ((ae) => (ae.VALIDATOR = "validator", ae.FULL_NODE = "full_node", ae))(m || {}), R = ((ae) => (ae[ae.Ed25519 = 0] = "Ed25519", ae[ae.MultiEd25519 = 1] = "MultiEd25519", ae[ae.SingleKey = 2] = "SingleKey", ae[ae.MultiKey = 3] = "MultiKey", ae))(R || {}), S = ((ae) => (ae[ae.Ed25519 = 0] = "Ed25519", ae[ae.Secp256k1Ecdsa = 2] = "Secp256k1Ecdsa", ae))(S || {}), b = ((ae) => (ae[ae.DeriveAuid = 251] = "DeriveAuid", ae[ae.DeriveObjectAddressFromObject = 252] = "DeriveObjectAddressFromObject", ae[ae.DeriveObjectAddressFromGuid = 253] = "DeriveObjectAddressFromGuid", ae[ae.DeriveObjectAddressFromSeed = 254] = "DeriveObjectAddressFromSeed", ae[ae.DeriveResourceAccountAddress = 255] = "DeriveResourceAccountAddress", ae))(b || {});
class AptosConfig extends BaseWebToken {
  signerInstance;
  _publicKey;
  aptosConfig;
  signingFn;
  constructor(ie) {
    super(ie), this.signingFn = ie?.opts?.signingFunction, this.base = ["octa", 1e8];
  }
  async getProvider() {
    return this.providerInstance ??= new t(this.aptosConfig);
  }
  async getTx(ie) {
    const fe = await (await this.getProvider()).waitForTransaction({ transactionHash: ie }), ue = fe?.payload;
    if (!fe.success)
      throw new Error(fe?.vm_status ?? "Unknown Aptos error");
    if (!(ue?.function === "0x1::coin::transfer" && ue?.type_arguments[0] === "0x1::aptos_coin::AptosCoin" && fe?.vm_status === "Executed successfully"))
      throw new Error(`Aptos tx ${ie} failed validation`);
    const ce = fe.type === "pending_transaction";
    return {
      to: ue.arguments[0],
      from: fe.sender,
      amount: new BigNumber$1(ue.arguments[1]),
      pending: ce,
      confirmed: !ce
    };
  }
  ownerToAddress(ie) {
    const se = sha3.sha3_256.create();
    return se.update(Buffer$F.from(ie)), se.update("\0"), `0x${se.hex()}`;
  }
  async sign(ie) {
    return await this.getSigner().sign(ie);
  }
  getSigner() {
    if (this.signerInstance)
      return this.signerInstance;
    if (this.signingFn) {
      const ie = new AptosSigner("", "0x" + this._publicKey.toString("hex"));
      return ie.sign = this.signingFn, this.signerInstance = ie;
    }
    return this.signerInstance = new InjectedAptosSigner(this.wallet, this._publicKey);
  }
  async verify(ie, se, fe) {
    return await InjectedAptosSigner.verify(ie, se, fe);
  }
  async getCurrentHeight() {
    return new BigNumber$1((await (await this.getProvider()).getLedgerInfo()).block_height);
  }
  async getFee(ie, se) {
    const fe = await this.getProvider();
    if (!this.address)
      throw new Error("Address is undefined - you might be missing a wallet, or have not run Irys.ready()");
    const ue = await fe.transaction.build.simple({
      sender: this.address,
      data: {
        function: "0x1::coin::transfer",
        typeArguments: ["0x1::aptos_coin::AptosCoin"],
        functionArguments: [se ?? "0x149f7dc9c8e43c14ab46d3a6b62cfe84d67668f764277411f98732bf6718acf9", new BigNumber$1(ie).toNumber()]
      }
    }), ce = new a$5(new m$5(await this.getPublicKey()), new y$7(new Uint8Array(64))), de = new d$2(ce.public_key, ce.signature), me = new n$6(ue.rawTransaction, de).bcsToBytes(), we = {
      estimate_gas_unit_price: !0,
      estimate_max_gas_amount: !0
    }, { data: Ee } = await A$8({
      aptosConfig: this.aptosConfig,
      body: me,
      path: "transactions/simulate",
      params: we,
      originMethod: "simulateTransaction",
      contentType: a.BCS_SIGNED_TRANSACTION
    });
    return { gasUnitPrice: +Ee[0].gas_unit_price, maxGasAmount: +Ee[0].max_gas_amount };
  }
  async sendTx(ie) {
    if (!this.signingFn)
      return (await this.wallet.signAndSubmitTransaction(ie)).hash;
    const se = await this.getProvider(), { data: fe } = await A$8({
      aptosConfig: this.aptosConfig,
      body: ie,
      path: "transactions",
      originMethod: "submitTransaction",
      contentType: a.BCS_SIGNED_TRANSACTION
    });
    return await se.waitForTransaction({ transactionHash: fe.hash }), fe.hash;
  }
  async createTx(ie, se, fe) {
    if (!this.signingFn)
      return {
        txId: void 0,
        tx: {
          arguments: [se, new BigNumber$1(ie).toNumber()],
          function: "0x1::coin::transfer",
          type: "entry_function_payload",
          type_arguments: ["0x1::aptos_coin::AptosCoin"]
        }
      };
    const ce = await (await this.getProvider()).transaction.build.simple({
      sender: this.address,
      data: {
        function: "0x1::coin::transfer",
        typeArguments: ["0x1::aptos_coin::AptosCoin"],
        functionArguments: [se, new BigNumber$1(ie).toNumber()]
      },
      options: {
        gasUnitPrice: fe?.gasUnitPrice ?? 100,
        maxGasAmount: fe?.maxGasAmount ?? 10
      }
    }), de = An(ce), me = await this.sign(de), we = new a$5(new m$5(await this.getPublicKey()), new y$7(me));
    return { txId: void 0, tx: Un({ transaction: ce, senderAuthenticator: we }) };
  }
  async getPublicKey() {
    return this._publicKey ??= this.signingFn ? Buffer$F.from(this.wallet.slice(2), "hex") : Buffer$F.from((await this.wallet.account()).publicKey.toString().slice(2), "hex");
  }
  async ready() {
    this.aptosConfig = new n$1({ network: this.providerUrl, ...this.config?.opts?.aptosSdkConfig }), this._publicKey = await this.getPublicKey(), this._address = this.ownerToAddress(this._publicKey);
    const ie = await this.getProvider();
    this._address = await ie.lookupOriginalAccountAddress({ authenticationKey: this.address ?? "" }).then((se) => se.toString()).catch((se) => this._address), this._address?.length == 66 && this._address.charAt(2) === "0" && (this._address = this._address.slice(0, 2) + this._address.slice(3));
  }
}
class EthereumEthersV5 extends EthereumConfig {
}
class EthereumEthersV6 extends EthereumConfig {
  async createTx(ie, se, fe) {
    const ue = this.w3signer, ce = { to: se, from: this.address, value: ie.toString(), gasLimit: BigInt(0) }, de = await this.provider.estimateGas(ce);
    return ce.gasLimit = de, { tx: await ue.populateTransaction(ce), txId: void 0 };
  }
  async getTx(ie) {
    const fe = await this.provider.getTransaction(ie);
    if (!fe)
      throw new Error("Tx doesn't exist");
    if (!fe.to)
      throw new Error(`Unable to resolve transactions ${ie} receiver`);
    return {
      from: fe.from,
      to: fe.to,
      blockHeight: fe.blockNumber ? new BigNumber$1(fe.blockNumber) : void 0,
      amount: new BigNumber$1(fe.value.toString()),
      pending: !fe.blockNumber,
      confirmed: await fe.confirmations() >= this.minConfirm
    };
  }
  async ready() {
    const ie = this.wallet;
    this.provider = ie;
    const se = await ie.getSigner();
    se._signTypedData = async (fe, ue, ce) => se.signTypedData(fe, ue, ce), ie.getSigner = () => se, this.wallet = ie, await super.ready();
  }
}
class ArweaveConfig extends BaseWebToken {
  isSlow = !0;
  signerInstance;
  constructor(ie) {
    super(ie), this.base = ["winston", 1e12], this.needsFee = !0;
  }
  getProvider() {
    if (!this.providerInstance) {
      const ie = new URL(this.providerUrl ?? "https://arweave.net");
      this.providerInstance = Arweave.init(
        /* config ??  */
        {
          url: ie,
          network: this?.opts?.network
        }
      );
    }
    return this.providerInstance;
  }
  async getTx(ie) {
    const se = await this.getProvider(), fe = await se.transactions.getStatus(ie);
    let ue;
    fe.status === 200 && (ue = await se.transactions.get(ie));
    const ce = fe.status !== 202 && (fe.confirmed?.number_of_confirmations ?? 0) >= this.minConfirm;
    let de;
    return ue?.owner && (de = this.ownerToAddress(ue.owner)), {
      from: de ?? void 0,
      to: ue?.target ?? void 0,
      amount: new BigNumber$1(ue?.quantity ?? 0),
      pending: fe.status === 202,
      confirmed: ce
    };
  }
  ownerToAddress(ie) {
    return Arweave.utils.bufferTob64Url(crypto$4.createHash("sha256").update(Arweave.utils.b64UrlToBuffer(Buffer$F.isBuffer(ie) ? base64url(ie) : ie)).digest());
  }
  async sign(ie) {
    return this.getSigner().sign(ie);
  }
  getSigner() {
    if (this.signerInstance)
      return this.signerInstance;
    switch (this?.opts?.provider ?? "arconnect") {
      case "arconnect":
        this.signerInstance = new InjectedArweaveSigner(this.wallet, this.getProvider());
    }
    return this.signerInstance;
  }
  async verify(ie, se, fe) {
    return Buffer$F.isBuffer(ie) && (ie = ie.toString()), this.getProvider().crypto.verify(ie, se, fe);
  }
  async getCurrentHeight() {
    return (await this.getProvider()).network.getInfo().then((ie) => new BigNumber$1(ie.height));
  }
  async getFee(ie, se) {
    return new BigNumber$1(await (await this.getProvider()).transactions.getPrice(new BigNumber$1(ie).toNumber(), se)).integerValue(BigNumber$1.ROUND_CEIL);
  }
  async sendTx(ie) {
    return await (await this.getProvider()).transactions.post(ie);
  }
  async createTx(ie, se, fe) {
    const ce = await (await this.getProvider()).createTransaction({ quantity: new BigNumber$1(ie).toString(), reward: fe?.toString(), target: se });
    ce.merkle = void 0, ce.deepHash = void 0;
    const de = await this.wallet.sign(ce);
    return { txId: de.id, tx: de };
  }
  async getPublicKey() {
    const ie = this.getSigner();
    return await ie.setPublicKey(), Arweave.utils.bufferTob64Url(ie.publicKey);
  }
  async ready() {
    const ie = await this.getPublicKey(), se = this.ownerToAddress(ie);
    this._address = se;
  }
}
async function augmentTokenPrivy(ae, ie) {
  if (!ie.sendTransaction)
    throw new Error("missing required sendTransaction function - add sendTransaction from the usePrivy hook to the wallet object");
  const se = ie.sendTransaction;
  ae.sendTx = async (fe) => se({
    ...fe,
    gasLimit: fe.gasLimit.toHexString(),
    maxFeePerGas: fe.maxFeePerGas.toHexString(),
    maxPriorityFeePerGas: fe.maxPriorityFeePerGas.toHexString()
  }).then((ue) => ue.transactionHash);
}
function augmentViemV2(ae, ie) {
  const se = ie.provider, fe = ie.publicClient, ue = ie.accountIndex ?? 0;
  if (ae.ready = async function() {
    await this.getSigner().ready(), this._address = await se.getAddresses().then((ce) => ce[ue].toString().toLowerCase()), this.providerInstance = this.wallet;
  }.bind(ae), ae.getFee = async (ce) => new BigNumber$1(0), ae.getSigner = function() {
    return this.signer || (this.signer = new InjectedTypedEthereumSigner({
      getSigner: () => ({
        getAddress: async () => se.getAddresses().then((ce) => ce[ue]),
        _signTypedData: async (ce, de, me) => (me["Transaction hash"] = "0x" + Buffer$F.from(me["Transaction hash"]).toString("hex"), await se.signTypedData({ account: me.address, domain: ce, types: de, primaryType: "Bundlr", message: me }))
      })
    })), this.signer;
  }.bind(ae), ae.getCurrentHeight = async () => new BigNumber$1((await fe.getBlockNumber()).toString()), ae.contractAddress)
    throw new Error("viemv2 is not supported for ERC20 tokens");
  ae.getTx = async (ce) => {
    const de = await fe.getTransaction({ hash: ce }), me = await fe.getBlockNumber();
    return {
      to: de.to,
      from: de.from,
      blockHeight: new BigNumber$1(de.blockNumber.toString()),
      amount: new BigNumber$1(de.value.toString()),
      pending: !de.blockNumber,
      confirmed: me - de.blockNumber >= ae.minConfirm
    };
  }, ae.createTx = async function(ce, de) {
    return {
      txId: void 0,
      tx: {
        account: ae.address,
        to: de,
        value: ce.toString()
      }
    };
  }.bind(ae), ae.sendTx = async function(ce) {
    return await se.sendTransaction({ account: ce.account, to: ce.to, value: ce.value, chain: se.chain });
  };
}
function getTokenConfig({ irys: ae, token: ie, wallet: se, providerUrl: fe, contractAddress: ue, providerName: ce, tokenOpts: de }) {
  switch (ie) {
    case "ethereum":
      return resolveProvider({
        family: "ethereum",
        providerName: ce,
        config: {
          irys: ae,
          name: "ethereum",
          ticker: "ETH",
          providerUrl: fe ?? "https://cloudflare-eth.com/",
          wallet: se,
          opts: de
        }
      });
    case "matic":
      return resolveProvider({
        family: "ethereum",
        providerName: ce,
        config: {
          irys: ae,
          name: "matic",
          ticker: "MATIC",
          providerUrl: fe ?? "https://polygon-rpc.com",
          wallet: se,
          minConfirm: 1,
          opts: de
        }
      });
    case "arbitrum":
      return resolveProvider({
        family: "ethereum",
        providerName: ce,
        config: {
          irys: ae,
          name: "arbitrum",
          ticker: "ETH",
          providerUrl: fe ?? "https://arb1.arbitrum.io/rpc",
          wallet: se,
          opts: de
        }
      });
    case "bnb":
      return resolveProvider({
        family: "ethereum",
        providerName: ce,
        config: {
          irys: ae,
          name: "bnb",
          ticker: "BNB",
          providerUrl: fe ?? "https://bsc-dataseed.binance.org",
          wallet: se,
          opts: de
        }
      });
    case "avalanche":
      return resolveProvider({
        family: "ethereum",
        providerName: ce,
        config: {
          irys: ae,
          name: "avalanche",
          ticker: "AVAX",
          providerUrl: fe ?? "https://api.avax.network/ext/bc/C/rpc",
          wallet: se,
          opts: de
        }
      });
    case "boba-eth":
      return resolveProvider({
        family: "ethereum",
        providerName: ce,
        config: {
          irys: ae,
          name: "boba-eth",
          ticker: "ETH",
          providerUrl: fe ?? "https://mainnet.boba.network/",
          minConfirm: 1,
          wallet: se,
          opts: de
        }
      });
    case "boba": {
      const me = new ERC20Config({
        irys: ae,
        name: "boba",
        ticker: "BOBA",
        providerUrl: fe ?? "https://mainnet.boba.network/",
        contractAddress: ue ?? "0xa18bF3994C0Cc6E3b63ac420308E5383f53120D7",
        minConfirm: 1,
        wallet: se,
        opts: de
      });
      return me.price = async () => {
        const we = await axios$1.post("https://api.livecoinwatch.com/coins/single", JSON.stringify({ currency: "USD", code: `${me.ticker}` }), {
          headers: { "x-api-key": "75a7a824-6577-45e6-ad86-511d590c7cc8", "content-type": "application/json" }
        });
        if (await Utils.checkAndThrow(we, "Getting price data"), !we?.data?.rate)
          throw new Error(`unable to get price for ${me.name}`);
        return +we.data.rate;
      }, me;
    }
    case "solana":
      return new SolanaConfig({
        irys: ae,
        name: "solana",
        ticker: "SOL",
        providerUrl: fe ?? "https://api.mainnet-beta.solana.com/",
        wallet: se,
        opts: de
      });
    case "near":
      return new NearConfig({
        irys: ae,
        name: "near",
        ticker: "NEAR",
        providerUrl: fe ?? "https://rpc.mainnet.near.org",
        wallet: se,
        opts: de
      });
    case "aptos":
      return new AptosConfig({
        irys: ae,
        name: "aptos",
        ticker: "APTOS",
        providerUrl: fe ?? e.MAINNET,
        wallet: se,
        opts: de
      });
    case "arweave":
      return new ArweaveConfig({
        irys: ae,
        name: "arweave",
        ticker: "AR",
        providerUrl: fe ?? "https://arweave.net",
        wallet: se,
        opts: de
      });
    case "base-eth":
      return new EthereumConfig({
        irys: ae,
        name: "base-eth",
        ticker: "ETH",
        providerUrl: fe ?? "https://mainnet.base.org/",
        minConfirm: 2,
        wallet: se,
        opts: de
      });
    case "usdc-eth":
      return new ERC20Config({
        irys: ae,
        name: "usdc-eth",
        ticker: "USDC",
        providerUrl: fe ?? "https://cloudflare-eth.com/",
        contractAddress: ue ?? "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
        wallet: se,
        opts: de
      });
    case "usdc-polygon":
      return new ERC20Config({
        irys: ae,
        name: "usdc-polygon",
        ticker: "USDC",
        providerUrl: fe ?? "https://polygon-rpc.com",
        contractAddress: ue ?? "0x3c499c542cef5e3811e1192ce70d8cc03d5c3359",
        opts: de
      });
    case "bera":
      return resolveProvider({
        family: "ethereum",
        providerName: ce,
        config: {
          irys: ae,
          name: "bera",
          ticker: "BERA",
          // TODO: make sure this is set to mainnet
          providerUrl: fe ?? "https://artio.rpc.berachain.com/",
          wallet: se,
          opts: de
        }
      });
    default:
      throw new Error(`Unknown/Unsupported token ${ie}`);
  }
}
function resolveProvider({ family: ae, providerName: ie, config: se }) {
  let fe;
  switch (ae) {
    case "ethereum":
      switch (ie) {
        case "ethersv5":
          return new EthereumEthersV5(se);
        case "ethersv6":
          return new EthereumEthersV6(se);
        case "privy-embedded":
          return fe = new EthereumEthersV5(se), augmentTokenPrivy(fe, se.opts), fe;
        case "viemv2":
          return fe = new EthereumConfig(se), augmentViemV2(fe, se.opts), fe;
        default:
          return new EthereumConfig(se);
      }
    default:
      throw new Error(`Unknown token family ${ae}`);
  }
}
class WebIrys extends BaseWebIrys {
  constructor({ url: ie, token: se, wallet: fe, config: ue }) {
    super({
      url: ie,
      wallet: fe,
      config: ue,
      getTokenConfig: (ce) => getTokenConfig({
        irys: ce,
        token: se.toLowerCase(),
        wallet: fe?.provider ?? fe,
        providerUrl: ue?.providerUrl ?? fe?.rpcUrl,
        contractAddress: ue?.contractAddress,
        providerName: fe?.name,
        tokenOpts: { ...ue?.tokenOpts, ...fe }
      })
    });
  }
  static async init(ie) {
    const { url: se, token: fe, provider: ue, publicKey: ce, signingFunction: de, collectSignatures: me, providerUrl: we, timeout: Ee, contractAddress: Se } = ie, Be = new WebIrys({
      url: se,
      token: fe,
      // @ts-expect-error types
      wallet: { name: "init", provider: de ? ce : ue },
      config: {
        providerUrl: we,
        timeout: Ee,
        contractAddress: Se,
        tokenOpts: { signingFunction: de, collectSignatures: me }
      }
    });
    return await Be.ready(), Be;
  }
}
const WebIrys$1 = WebIrys;
var eventemitter3 = { exports: {} };
(function(ae) {
  var ie = Object.prototype.hasOwnProperty, se = "~";
  function fe() {
  }
  Object.create && (fe.prototype = /* @__PURE__ */ Object.create(null), new fe().__proto__ || (se = !1));
  function ue(we, Ee, Se) {
    this.fn = we, this.context = Ee, this.once = Se || !1;
  }
  function ce(we, Ee, Se, Be, Ce) {
    if (typeof Se != "function")
      throw new TypeError("The listener must be a function");
    var Ie = new ue(Se, Be || we, Ce), Pe = se ? se + Ee : Ee;
    return we._events[Pe] ? we._events[Pe].fn ? we._events[Pe] = [we._events[Pe], Ie] : we._events[Pe].push(Ie) : (we._events[Pe] = Ie, we._eventsCount++), we;
  }
  function de(we, Ee) {
    --we._eventsCount === 0 ? we._events = new fe() : delete we._events[Ee];
  }
  function me() {
    this._events = new fe(), this._eventsCount = 0;
  }
  me.prototype.eventNames = function() {
    var Ee = [], Se, Be;
    if (this._eventsCount === 0)
      return Ee;
    for (Be in Se = this._events)
      ie.call(Se, Be) && Ee.push(se ? Be.slice(1) : Be);
    return Object.getOwnPropertySymbols ? Ee.concat(Object.getOwnPropertySymbols(Se)) : Ee;
  }, me.prototype.listeners = function(Ee) {
    var Se = se ? se + Ee : Ee, Be = this._events[Se];
    if (!Be)
      return [];
    if (Be.fn)
      return [Be.fn];
    for (var Ce = 0, Ie = Be.length, Pe = new Array(Ie); Ce < Ie; Ce++)
      Pe[Ce] = Be[Ce].fn;
    return Pe;
  }, me.prototype.listenerCount = function(Ee) {
    var Se = se ? se + Ee : Ee, Be = this._events[Se];
    return Be ? Be.fn ? 1 : Be.length : 0;
  }, me.prototype.emit = function(Ee, Se, Be, Ce, Ie, Pe) {
    var Ne = se ? se + Ee : Ee;
    if (!this._events[Ne])
      return !1;
    var ke = this._events[Ne], He = arguments.length, De, Ge;
    if (ke.fn) {
      switch (ke.once && this.removeListener(Ee, ke.fn, void 0, !0), He) {
        case 1:
          return ke.fn.call(ke.context), !0;
        case 2:
          return ke.fn.call(ke.context, Se), !0;
        case 3:
          return ke.fn.call(ke.context, Se, Be), !0;
        case 4:
          return ke.fn.call(ke.context, Se, Be, Ce), !0;
        case 5:
          return ke.fn.call(ke.context, Se, Be, Ce, Ie), !0;
        case 6:
          return ke.fn.call(ke.context, Se, Be, Ce, Ie, Pe), !0;
      }
      for (Ge = 1, De = new Array(He - 1); Ge < He; Ge++)
        De[Ge - 1] = arguments[Ge];
      ke.fn.apply(ke.context, De);
    } else {
      var Ye = ke.length, st;
      for (Ge = 0; Ge < Ye; Ge++)
        switch (ke[Ge].once && this.removeListener(Ee, ke[Ge].fn, void 0, !0), He) {
          case 1:
            ke[Ge].fn.call(ke[Ge].context);
            break;
          case 2:
            ke[Ge].fn.call(ke[Ge].context, Se);
            break;
          case 3:
            ke[Ge].fn.call(ke[Ge].context, Se, Be);
            break;
          case 4:
            ke[Ge].fn.call(ke[Ge].context, Se, Be, Ce);
            break;
          default:
            if (!De)
              for (st = 1, De = new Array(He - 1); st < He; st++)
                De[st - 1] = arguments[st];
            ke[Ge].fn.apply(ke[Ge].context, De);
        }
    }
    return !0;
  }, me.prototype.on = function(Ee, Se, Be) {
    return ce(this, Ee, Se, Be, !1);
  }, me.prototype.once = function(Ee, Se, Be) {
    return ce(this, Ee, Se, Be, !0);
  }, me.prototype.removeListener = function(Ee, Se, Be, Ce) {
    var Ie = se ? se + Ee : Ee;
    if (!this._events[Ie])
      return this;
    if (!Se)
      return de(this, Ie), this;
    var Pe = this._events[Ie];
    if (Pe.fn)
      Pe.fn === Se && (!Ce || Pe.once) && (!Be || Pe.context === Be) && de(this, Ie);
    else {
      for (var Ne = 0, ke = [], He = Pe.length; Ne < He; Ne++)
        (Pe[Ne].fn !== Se || Ce && !Pe[Ne].once || Be && Pe[Ne].context !== Be) && ke.push(Pe[Ne]);
      ke.length ? this._events[Ie] = ke.length === 1 ? ke[0] : ke : de(this, Ie);
    }
    return this;
  }, me.prototype.removeAllListeners = function(Ee) {
    var Se;
    return Ee ? (Se = se ? se + Ee : Ee, this._events[Se] && de(this, Se)) : (this._events = new fe(), this._eventsCount = 0), this;
  }, me.prototype.off = me.prototype.removeListener, me.prototype.addListener = me.prototype.on, me.prefixed = se, me.EventEmitter = me, ae.exports = me;
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs$2(eventemitter3Exports);
var __extends$4 = /* @__PURE__ */ function() {
  var ae = function(ie, se) {
    return ae = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(fe, ue) {
      fe.__proto__ = ue;
    } || function(fe, ue) {
      for (var ce in ue)
        Object.prototype.hasOwnProperty.call(ue, ce) && (fe[ce] = ue[ce]);
    }, ae(ie, se);
  };
  return function(ie, se) {
    if (typeof se != "function" && se !== null)
      throw new TypeError("Class extends value " + String(se) + " is not a constructor or null");
    ae(ie, se);
    function fe() {
      this.constructor = ie;
    }
    ie.prototype = se === null ? Object.create(se) : (fe.prototype = se.prototype, new fe());
  };
}(), WalletAdapter = (
  /** @class */
  function(ae) {
    __extends$4(ie, ae);
    function ie() {
      return ae !== null && ae.apply(this, arguments) || this;
    }
    return ie;
  }(EventEmitter)
), __extends$3 = /* @__PURE__ */ function() {
  var ae = function(ie, se) {
    return ae = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(fe, ue) {
      fe.__proto__ = ue;
    } || function(fe, ue) {
      for (var ce in ue)
        Object.prototype.hasOwnProperty.call(ue, ce) && (fe[ce] = ue[ce]);
    }, ae(ie, se);
  };
  return function(ie, se) {
    if (typeof se != "function" && se !== null)
      throw new TypeError("Class extends value " + String(se) + " is not a constructor or null");
    ae(ie, se);
    function fe() {
      this.constructor = ie;
    }
    ie.prototype = se === null ? Object.create(se) : (fe.prototype = se.prototype, new fe());
  };
}(), __assign$2 = function() {
  return __assign$2 = Object.assign || function(ae) {
    for (var ie, se = 1, fe = arguments.length; se < fe; se++) {
      ie = arguments[se];
      for (var ue in ie)
        Object.prototype.hasOwnProperty.call(ie, ue) && (ae[ue] = ie[ue]);
    }
    return ae;
  }, __assign$2.apply(this, arguments);
}, __awaiter$3 = function(ae, ie, se, fe) {
  function ue(ce) {
    return ce instanceof se ? ce : new se(function(de) {
      de(ce);
    });
  }
  return new (se || (se = Promise))(function(ce, de) {
    function me(Se) {
      try {
        Ee(fe.next(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function we(Se) {
      try {
        Ee(fe.throw(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function Ee(Se) {
      Se.done ? ce(Se.value) : ue(Se.value).then(me, we);
    }
    Ee((fe = fe.apply(ae, ie || [])).next());
  });
}, __generator$3 = function(ae, ie) {
  var se = { label: 0, sent: function() {
    if (ce[0] & 1)
      throw ce[1];
    return ce[1];
  }, trys: [], ops: [] }, fe, ue, ce, de;
  return de = { next: me(0), throw: me(1), return: me(2) }, typeof Symbol == "function" && (de[Symbol.iterator] = function() {
    return this;
  }), de;
  function me(Ee) {
    return function(Se) {
      return we([Ee, Se]);
    };
  }
  function we(Ee) {
    if (fe)
      throw new TypeError("Generator is already executing.");
    for (; de && (de = 0, Ee[0] && (se = 0)), se; )
      try {
        if (fe = 1, ue && (ce = Ee[0] & 2 ? ue.return : Ee[0] ? ue.throw || ((ce = ue.return) && ce.call(ue), 0) : ue.next) && !(ce = ce.call(ue, Ee[1])).done)
          return ce;
        switch (ue = 0, ce && (Ee = [Ee[0] & 2, ce.value]), Ee[0]) {
          case 0:
          case 1:
            ce = Ee;
            break;
          case 4:
            return se.label++, { value: Ee[1], done: !1 };
          case 5:
            se.label++, ue = Ee[1], Ee = [0];
            continue;
          case 7:
            Ee = se.ops.pop(), se.trys.pop();
            continue;
          default:
            if (ce = se.trys, !(ce = ce.length > 0 && ce[ce.length - 1]) && (Ee[0] === 6 || Ee[0] === 2)) {
              se = 0;
              continue;
            }
            if (Ee[0] === 3 && (!ce || Ee[1] > ce[0] && Ee[1] < ce[3])) {
              se.label = Ee[1];
              break;
            }
            if (Ee[0] === 6 && se.label < ce[1]) {
              se.label = ce[1], ce = Ee;
              break;
            }
            if (ce && se.label < ce[2]) {
              se.label = ce[2], se.ops.push(Ee);
              break;
            }
            ce[2] && se.ops.pop(), se.trys.pop();
            continue;
        }
        Ee = ie.call(ae, se);
      } catch (Se) {
        Ee = [6, Se], ue = 0;
      } finally {
        fe = ce = 0;
      }
    if (Ee[0] & 5)
      throw Ee[1];
    return { value: Ee[0] ? Ee[1] : void 0, done: !0 };
  }
}, __read = function(ae, ie) {
  var se = typeof Symbol == "function" && ae[Symbol.iterator];
  if (!se)
    return ae;
  var fe = se.call(ae), ue, ce = [], de;
  try {
    for (; (ie === void 0 || ie-- > 0) && !(ue = fe.next()).done; )
      ce.push(ue.value);
  } catch (me) {
    de = { error: me };
  } finally {
    try {
      ue && !ue.done && (se = fe.return) && se.call(fe);
    } finally {
      if (de)
        throw de.error;
    }
  }
  return ce;
}, Wallet = (
  /** @class */
  function(ae) {
    __extends$3(ie, ae);
    function ie(se, fe) {
      var ue = ae.call(this) || this;
      if (ue._handleMessage = function(ce) {
        if (ue._injectedProvider && ce.source === window || ce.origin === ue._providerUrl.origin && ce.source === ue._popup) {
          if (ce.data.method === "connected") {
            var de = new PublicKey(ce.data.params.publicKey);
            (!ue._publicKey || !ue._publicKey.equals(de)) && (ue._publicKey && !ue._publicKey.equals(de) && ue._handleDisconnect(), ue._publicKey = de, ue._autoApprove = !!ce.data.params.autoApprove, ue.emit("connect", ue._publicKey));
          } else if (ce.data.method === "disconnected")
            ue._handleDisconnect();
          else if ((ce.data.result || ce.data.error) && ue._responsePromises.has(ce.data.id)) {
            var me = __read(ue._responsePromises.get(ce.data.id), 2), we = me[0], Ee = me[1];
            ce.data.result ? we(ce.data.result) : Ee(new Error(ce.data.error));
          }
        }
      }, ue._handleConnect = function() {
        return ue._handlerAdded || (ue._handlerAdded = !0, window.addEventListener("message", ue._handleMessage), window.addEventListener("beforeunload", ue.disconnect)), ue._injectedProvider ? new Promise(function(ce) {
          ue._sendRequest("connect", {}), ce();
        }) : (window.name = "parent", ue._popup = window.open(ue._providerUrl.toString(), "_blank", "location,resizable,width=460,height=675"), new Promise(function(ce) {
          ue.once("connect", ce);
        }));
      }, ue._handleDisconnect = function() {
        ue._handlerAdded && (ue._handlerAdded = !1, window.removeEventListener("message", ue._handleMessage), window.removeEventListener("beforeunload", ue.disconnect)), ue._publicKey && (ue._publicKey = null, ue.emit("disconnect")), ue._responsePromises.forEach(function(ce, de) {
          var me = __read(ce, 2);
          me[0];
          var we = me[1];
          ue._responsePromises.delete(de), we("Wallet disconnected");
        });
      }, ue._sendRequest = function(ce, de) {
        return __awaiter$3(ue, void 0, void 0, function() {
          var me, we = this;
          return __generator$3(this, function(Ee) {
            if (ce !== "connect" && !this.connected)
              throw new Error("Wallet not connected");
            return me = this._nextRequestId, ++this._nextRequestId, [2, new Promise(function(Se, Be) {
              we._responsePromises.set(me, [Se, Be]), we._injectedProvider ? we._injectedProvider.postMessage({
                jsonrpc: "2.0",
                id: me,
                method: ce,
                params: __assign$2({ network: we._network }, de)
              }) : (we._popup.postMessage({
                jsonrpc: "2.0",
                id: me,
                method: ce,
                params: de
              }, we._providerUrl.origin), we.autoApprove || we._popup.focus());
            })];
          });
        });
      }, ue.connect = function() {
        return ue._popup && ue._popup.close(), ue._handleConnect();
      }, ue.disconnect = function() {
        return __awaiter$3(ue, void 0, void 0, function() {
          return __generator$3(this, function(ce) {
            switch (ce.label) {
              case 0:
                return this._injectedProvider ? [4, this._sendRequest("disconnect", {})] : [3, 2];
              case 1:
                ce.sent(), ce.label = 2;
              case 2:
                return this._popup && this._popup.close(), this._handleDisconnect(), [
                  2
                  /*return*/
                ];
            }
          });
        });
      }, ue.sign = function(ce, de) {
        return __awaiter$3(ue, void 0, void 0, function() {
          var me, we, Ee;
          return __generator$3(this, function(Se) {
            switch (Se.label) {
              case 0:
                if (!(ce instanceof Uint8Array))
                  throw new Error("Data must be an instance of Uint8Array");
                return [4, this._sendRequest("sign", {
                  data: ce,
                  display: de
                })];
              case 1:
                return me = Se.sent(), we = bs58$3.decode(me.signature), Ee = new PublicKey(me.publicKey), [2, {
                  signature: we,
                  publicKey: Ee
                }];
            }
          });
        });
      }, isInjectedProvider(se))
        ue._injectedProvider = se;
      else if (isString(se))
        ue._providerUrl = new URL(se), ue._providerUrl.hash = new URLSearchParams({
          origin: window.location.origin,
          network: fe
        }).toString();
      else
        throw new Error("provider parameter must be an injected provider or a URL string.");
      return ue._network = fe, ue._publicKey = null, ue._autoApprove = !1, ue._popup = null, ue._handlerAdded = !1, ue._nextRequestId = 1, ue._responsePromises = /* @__PURE__ */ new Map(), ue;
    }
    return Object.defineProperty(ie.prototype, "publicKey", {
      get: function() {
        return this._publicKey;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ie.prototype, "connected", {
      get: function() {
        return this._publicKey !== null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ie.prototype, "autoApprove", {
      get: function() {
        return this._autoApprove;
      },
      enumerable: !1,
      configurable: !0
    }), ie;
  }(EventEmitter)
);
function isString(ae) {
  return typeof ae == "string";
}
function isInjectedProvider(ae) {
  return isObject(ae) && isFunction(ae.postMessage);
}
function isObject(ae) {
  return typeof ae == "object" && ae !== null;
}
function isFunction(ae) {
  return typeof ae == "function";
}
var __extends$2 = /* @__PURE__ */ function() {
  var ae = function(ie, se) {
    return ae = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(fe, ue) {
      fe.__proto__ = ue;
    } || function(fe, ue) {
      for (var ce in ue)
        Object.prototype.hasOwnProperty.call(ue, ce) && (fe[ce] = ue[ce]);
    }, ae(ie, se);
  };
  return function(ie, se) {
    if (typeof se != "function" && se !== null)
      throw new TypeError("Class extends value " + String(se) + " is not a constructor or null");
    ae(ie, se);
    function fe() {
      this.constructor = ie;
    }
    ie.prototype = se === null ? Object.create(se) : (fe.prototype = se.prototype, new fe());
  };
}(), __awaiter$2 = function(ae, ie, se, fe) {
  function ue(ce) {
    return ce instanceof se ? ce : new se(function(de) {
      de(ce);
    });
  }
  return new (se || (se = Promise))(function(ce, de) {
    function me(Se) {
      try {
        Ee(fe.next(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function we(Se) {
      try {
        Ee(fe.throw(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function Ee(Se) {
      Se.done ? ce(Se.value) : ue(Se.value).then(me, we);
    }
    Ee((fe = fe.apply(ae, ie || [])).next());
  });
}, __generator$2 = function(ae, ie) {
  var se = { label: 0, sent: function() {
    if (ce[0] & 1)
      throw ce[1];
    return ce[1];
  }, trys: [], ops: [] }, fe, ue, ce, de;
  return de = { next: me(0), throw: me(1), return: me(2) }, typeof Symbol == "function" && (de[Symbol.iterator] = function() {
    return this;
  }), de;
  function me(Ee) {
    return function(Se) {
      return we([Ee, Se]);
    };
  }
  function we(Ee) {
    if (fe)
      throw new TypeError("Generator is already executing.");
    for (; de && (de = 0, Ee[0] && (se = 0)), se; )
      try {
        if (fe = 1, ue && (ce = Ee[0] & 2 ? ue.return : Ee[0] ? ue.throw || ((ce = ue.return) && ce.call(ue), 0) : ue.next) && !(ce = ce.call(ue, Ee[1])).done)
          return ce;
        switch (ue = 0, ce && (Ee = [Ee[0] & 2, ce.value]), Ee[0]) {
          case 0:
          case 1:
            ce = Ee;
            break;
          case 4:
            return se.label++, { value: Ee[1], done: !1 };
          case 5:
            se.label++, ue = Ee[1], Ee = [0];
            continue;
          case 7:
            Ee = se.ops.pop(), se.trys.pop();
            continue;
          default:
            if (ce = se.trys, !(ce = ce.length > 0 && ce[ce.length - 1]) && (Ee[0] === 6 || Ee[0] === 2)) {
              se = 0;
              continue;
            }
            if (Ee[0] === 3 && (!ce || Ee[1] > ce[0] && Ee[1] < ce[3])) {
              se.label = Ee[1];
              break;
            }
            if (Ee[0] === 6 && se.label < ce[1]) {
              se.label = ce[1], ce = Ee;
              break;
            }
            if (ce && se.label < ce[2]) {
              se.label = ce[2], se.ops.push(Ee);
              break;
            }
            ce[2] && se.ops.pop(), se.trys.pop();
            continue;
        }
        Ee = ie.call(ae, se);
      } catch (Se) {
        Ee = [6, Se], ue = 0;
      } finally {
        fe = ce = 0;
      }
    if (Ee[0] & 5)
      throw Ee[1];
    return { value: Ee[0] ? Ee[1] : void 0, done: !0 };
  }
}, WebAdapter = (
  /** @class */
  function(ae) {
    __extends$2(ie, ae);
    function ie(se, fe, ue) {
      var ce = ae.call(this) || this;
      return ce._instance = null, ce.handleMessage = function(de) {
      }, ce._sendRequest = function(de, me) {
        return __awaiter$2(ce, void 0, void 0, function() {
          var we, Ee;
          return __generator$2(this, function(Se) {
            switch (Se.label) {
              case 0:
                return !((we = this._instance) === null || we === void 0) && we.sendRequest ? [4, this._instance.sendRequest(de, me)] : [3, 2];
              case 1:
                return [2, Se.sent()];
              case 2:
                return !((Ee = this._instance) === null || Ee === void 0) && Ee._sendRequest ? [4, this._instance._sendRequest(de, me)] : [3, 4];
              case 3:
                return [2, Se.sent()];
              case 4:
                throw new Error("Unsupported version of `@project-serum/sol-wallet-adapter`");
            }
          });
        });
      }, ce._handleConnect = function() {
        ce.emit("connect");
      }, ce._handleDisconnect = function() {
        window.clearInterval(ce._pollTimer), ce.emit("disconnect");
      }, ce._network = fe, ce._provider = ue, ce;
    }
    return Object.defineProperty(ie.prototype, "publicKey", {
      get: function() {
        return this._instance.publicKey || null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ie.prototype, "connected", {
      get: function() {
        return this._instance.connected || !1;
      },
      enumerable: !1,
      configurable: !0
    }), ie.prototype.connect = function() {
      return __awaiter$2(this, void 0, void 0, function() {
        var se = this;
        return __generator$2(this, function(fe) {
          switch (fe.label) {
            case 0:
              return this._instance = new Wallet(this._provider, this._network), this._instance.on("connect", this._handleConnect), this._instance.on("disconnect", this._handleDisconnect), this._pollTimer = window.setInterval(function() {
                var ue, ce;
                ((ce = (ue = se._instance) === null || ue === void 0 ? void 0 : ue._popup) === null || ce === void 0 ? void 0 : ce.closed) !== !1 && se._handleDisconnect();
              }, 200), [4, this._instance.connect()];
            case 1:
              return fe.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, ie.prototype.disconnect = function() {
      return __awaiter$2(this, void 0, void 0, function() {
        return __generator$2(this, function(se) {
          switch (se.label) {
            case 0:
              if (!this.connected)
                throw new Error("Wallet not connected");
              return this._instance.removeAllListeners("connect"), this._instance.removeAllListeners("disconnect"), [4, this._instance.disconnect()];
            case 1:
              return se.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, ie.prototype.signTransaction = function(se) {
      return __awaiter$2(this, void 0, void 0, function() {
        var fe;
        return __generator$2(this, function(ue) {
          switch (ue.label) {
            case 0:
              if (!this.connected)
                throw new Error("Wallet not connected");
              return [4, this._sendRequest("signTransactionV2", {
                transaction: bs58$3.encode(se)
              })];
            case 1:
              return fe = ue.sent().transaction, [2, bs58$3.decode(fe)];
          }
        });
      });
    }, ie.prototype.signAllTransactions = function(se) {
      return __awaiter$2(this, void 0, void 0, function() {
        var fe;
        return __generator$2(this, function(ue) {
          switch (ue.label) {
            case 0:
              if (!this.connected)
                throw new Error("Wallet not connected");
              return [4, this._sendRequest("signAllTransactionsV2", {
                transactions: se.map(function(ce) {
                  return bs58$3.encode(ce);
                })
              })];
            case 1:
              return fe = ue.sent().transactions, [2, fe.map(function(ce) {
                return bs58$3.decode(ce);
              })];
          }
        });
      });
    }, ie.prototype.signAndSendTransaction = function(se, fe) {
      return __awaiter$2(this, void 0, void 0, function() {
        var ue;
        return __generator$2(this, function(ce) {
          switch (ce.label) {
            case 0:
              if (!this.connected)
                throw new Error("Wallet not connected");
              return [4, this._sendRequest("signAndSendTransaction", {
                transaction: bs58$3.encode(se),
                options: fe
              })];
            case 1:
              return ue = ce.sent(), [2, ue.signature];
          }
        });
      });
    }, ie.prototype.signMessage = function(se, fe) {
      return fe === void 0 && (fe = "hex"), __awaiter$2(this, void 0, void 0, function() {
        var ue;
        return __generator$2(this, function(ce) {
          switch (ce.label) {
            case 0:
              if (!this.connected)
                throw new Error("Wallet not connected");
              return [4, this._instance.sign(se, fe)];
            case 1:
              return ue = ce.sent().signature, [2, Uint8Array.from(ue)];
          }
        });
      });
    }, ie;
  }(WalletAdapter)
);
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues && (getRandomValues = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !getRandomValues))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return getRandomValues(rnds8);
}
const byteToHex = [];
for (let ae = 0; ae < 256; ++ae)
  byteToHex.push((ae + 256).toString(16).slice(1));
function unsafeStringify(ae, ie = 0) {
  return byteToHex[ae[ie + 0]] + byteToHex[ae[ie + 1]] + byteToHex[ae[ie + 2]] + byteToHex[ae[ie + 3]] + "-" + byteToHex[ae[ie + 4]] + byteToHex[ae[ie + 5]] + "-" + byteToHex[ae[ie + 6]] + byteToHex[ae[ie + 7]] + "-" + byteToHex[ae[ie + 8]] + byteToHex[ae[ie + 9]] + "-" + byteToHex[ae[ie + 10]] + byteToHex[ae[ie + 11]] + byteToHex[ae[ie + 12]] + byteToHex[ae[ie + 13]] + byteToHex[ae[ie + 14]] + byteToHex[ae[ie + 15]];
}
const randomUUID = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), native = {
  randomUUID
};
function v4(ae, ie, se) {
  if (native.randomUUID && !ie && !ae)
    return native.randomUUID();
  ae = ae || {};
  const fe = ae.random || (ae.rng || rng)();
  if (fe[6] = fe[6] & 15 | 64, fe[8] = fe[8] & 63 | 128, ie) {
    se = se || 0;
    for (let ue = 0; ue < 16; ++ue)
      ie[se + ue] = fe[ue];
    return ie;
  }
  return unsafeStringify(fe);
}
var __extends$1 = /* @__PURE__ */ function() {
  var ae = function(ie, se) {
    return ae = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(fe, ue) {
      fe.__proto__ = ue;
    } || function(fe, ue) {
      for (var ce in ue)
        Object.prototype.hasOwnProperty.call(ue, ce) && (fe[ce] = ue[ce]);
    }, ae(ie, se);
  };
  return function(ie, se) {
    if (typeof se != "function" && se !== null)
      throw new TypeError("Class extends value " + String(se) + " is not a constructor or null");
    ae(ie, se);
    function fe() {
      this.constructor = ie;
    }
    ie.prototype = se === null ? Object.create(se) : (fe.prototype = se.prototype, new fe());
  };
}(), __assign$1 = function() {
  return __assign$1 = Object.assign || function(ae) {
    for (var ie, se = 1, fe = arguments.length; se < fe; se++) {
      ie = arguments[se];
      for (var ue in ie)
        Object.prototype.hasOwnProperty.call(ie, ue) && (ae[ue] = ie[ue]);
    }
    return ae;
  }, __assign$1.apply(this, arguments);
}, __awaiter$1 = function(ae, ie, se, fe) {
  function ue(ce) {
    return ce instanceof se ? ce : new se(function(de) {
      de(ce);
    });
  }
  return new (se || (se = Promise))(function(ce, de) {
    function me(Se) {
      try {
        Ee(fe.next(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function we(Se) {
      try {
        Ee(fe.throw(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function Ee(Se) {
      Se.done ? ce(Se.value) : ue(Se.value).then(me, we);
    }
    Ee((fe = fe.apply(ae, ie || [])).next());
  });
}, __generator$1 = function(ae, ie) {
  var se = { label: 0, sent: function() {
    if (ce[0] & 1)
      throw ce[1];
    return ce[1];
  }, trys: [], ops: [] }, fe, ue, ce, de;
  return de = { next: me(0), throw: me(1), return: me(2) }, typeof Symbol == "function" && (de[Symbol.iterator] = function() {
    return this;
  }), de;
  function me(Ee) {
    return function(Se) {
      return we([Ee, Se]);
    };
  }
  function we(Ee) {
    if (fe)
      throw new TypeError("Generator is already executing.");
    for (; de && (de = 0, Ee[0] && (se = 0)), se; )
      try {
        if (fe = 1, ue && (ce = Ee[0] & 2 ? ue.return : Ee[0] ? ue.throw || ((ce = ue.return) && ce.call(ue), 0) : ue.next) && !(ce = ce.call(ue, Ee[1])).done)
          return ce;
        switch (ue = 0, ce && (Ee = [Ee[0] & 2, ce.value]), Ee[0]) {
          case 0:
          case 1:
            ce = Ee;
            break;
          case 4:
            return se.label++, { value: Ee[1], done: !1 };
          case 5:
            se.label++, ue = Ee[1], Ee = [0];
            continue;
          case 7:
            Ee = se.ops.pop(), se.trys.pop();
            continue;
          default:
            if (ce = se.trys, !(ce = ce.length > 0 && ce[ce.length - 1]) && (Ee[0] === 6 || Ee[0] === 2)) {
              se = 0;
              continue;
            }
            if (Ee[0] === 3 && (!ce || Ee[1] > ce[0] && Ee[1] < ce[3])) {
              se.label = Ee[1];
              break;
            }
            if (Ee[0] === 6 && se.label < ce[1]) {
              se.label = ce[1], ce = Ee;
              break;
            }
            if (ce && se.label < ce[2]) {
              se.label = ce[2], se.ops.push(Ee);
              break;
            }
            ce[2] && se.ops.pop(), se.trys.pop();
            continue;
        }
        Ee = ie.call(ae, se);
      } catch (Se) {
        Ee = [6, Se], ue = 0;
      } finally {
        fe = ce = 0;
      }
    if (Ee[0] & 5)
      throw Ee[1];
    return { value: Ee[0] ? Ee[1] : void 0, done: !0 };
  }
}, IframeAdapter = (
  /** @class */
  function(ae) {
    __extends$1(ie, ae);
    function ie(se, fe) {
      var ue = this, ce;
      return ue = ae.call(this) || this, ue._publicKey = null, ue._messageHandlers = {}, ue.handleMessage = function(de) {
        if (ue._messageHandlers[de.id]) {
          var me = ue._messageHandlers[de.id], we = me.resolve, Ee = me.reject;
          delete ue._messageHandlers[de.id], de.error ? Ee(de.error) : we(de.result);
        }
      }, ue._sendMessage = function(de) {
        if (!ue.connected)
          throw new Error("Wallet not connected");
        return new Promise(function(me, we) {
          var Ee, Se, Be = v4();
          ue._messageHandlers[Be] = { resolve: me, reject: we }, (Se = (Ee = ue._iframe) === null || Ee === void 0 ? void 0 : Ee.contentWindow) === null || Se === void 0 || Se.postMessage({
            channel: "solflareWalletAdapterToIframe",
            data: __assign$1({ id: Be }, de)
          }, "*");
        });
      }, ue._iframe = se, ue._publicKey = new PublicKey((ce = fe?.toString) === null || ce === void 0 ? void 0 : ce.call(fe)), ue;
    }
    return Object.defineProperty(ie.prototype, "publicKey", {
      get: function() {
        return this._publicKey || null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ie.prototype, "connected", {
      get: function() {
        return !0;
      },
      enumerable: !1,
      configurable: !0
    }), ie.prototype.connect = function() {
      return __awaiter$1(this, void 0, void 0, function() {
        return __generator$1(this, function(se) {
          return [
            2
            /*return*/
          ];
        });
      });
    }, ie.prototype.disconnect = function() {
      return __awaiter$1(this, void 0, void 0, function() {
        return __generator$1(this, function(se) {
          switch (se.label) {
            case 0:
              return [4, this._sendMessage({
                method: "disconnect"
              })];
            case 1:
              return se.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, ie.prototype.signTransaction = function(se) {
      var fe;
      return __awaiter$1(this, void 0, void 0, function() {
        var ue, ce;
        return __generator$1(this, function(de) {
          switch (de.label) {
            case 0:
              if (!this.connected)
                throw new Error("Wallet not connected");
              de.label = 1;
            case 1:
              return de.trys.push([1, 3, , 4]), [4, this._sendMessage({
                method: "signTransaction",
                params: {
                  transaction: bs58$3.encode(se)
                }
              })];
            case 2:
              return ue = de.sent(), [2, bs58$3.decode(ue)];
            case 3:
              throw ce = de.sent(), new Error(((fe = ce?.toString) === null || fe === void 0 ? void 0 : fe.call(ce)) || "Failed to sign transaction");
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, ie.prototype.signAllTransactions = function(se) {
      var fe;
      return __awaiter$1(this, void 0, void 0, function() {
        var ue, ce;
        return __generator$1(this, function(de) {
          switch (de.label) {
            case 0:
              if (!this.connected)
                throw new Error("Wallet not connected");
              de.label = 1;
            case 1:
              return de.trys.push([1, 3, , 4]), [4, this._sendMessage({
                method: "signAllTransactions",
                params: {
                  transactions: se.map(function(me) {
                    return bs58$3.encode(me);
                  })
                }
              })];
            case 2:
              return ue = de.sent(), [2, ue.map(function(me) {
                return bs58$3.decode(me);
              })];
            case 3:
              throw ce = de.sent(), new Error(((fe = ce?.toString) === null || fe === void 0 ? void 0 : fe.call(ce)) || "Failed to sign transactions");
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, ie.prototype.signAndSendTransaction = function(se, fe) {
      var ue;
      return __awaiter$1(this, void 0, void 0, function() {
        var ce, de;
        return __generator$1(this, function(me) {
          switch (me.label) {
            case 0:
              if (!this.connected)
                throw new Error("Wallet not connected");
              me.label = 1;
            case 1:
              return me.trys.push([1, 3, , 4]), [4, this._sendMessage({
                method: "signAndSendTransaction",
                params: {
                  transaction: bs58$3.encode(se),
                  options: fe
                }
              })];
            case 2:
              return ce = me.sent(), [2, ce];
            case 3:
              throw de = me.sent(), new Error(((ue = de?.toString) === null || ue === void 0 ? void 0 : ue.call(de)) || "Failed to sign and send transaction");
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, ie.prototype.signMessage = function(se, fe) {
      var ue;
      return fe === void 0 && (fe = "hex"), __awaiter$1(this, void 0, void 0, function() {
        var ce, de;
        return __generator$1(this, function(me) {
          switch (me.label) {
            case 0:
              if (!this.connected)
                throw new Error("Wallet not connected");
              me.label = 1;
            case 1:
              return me.trys.push([1, 3, , 4]), [4, this._sendMessage({
                method: "signMessage",
                params: {
                  data: se,
                  display: fe
                }
              })];
            case 2:
              return ce = me.sent(), [2, Uint8Array.from(bs58$3.decode(ce))];
            case 3:
              throw de = me.sent(), new Error(((ue = de?.toString) === null || ue === void 0 ? void 0 : ue.call(de)) || "Failed to sign message");
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, ie;
  }(WalletAdapter)
);
function isLegacyTransactionInstance(ae) {
  return ae.version === void 0;
}
var VERSION = "1.4.2", __extends = /* @__PURE__ */ function() {
  var ae = function(ie, se) {
    return ae = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(fe, ue) {
      fe.__proto__ = ue;
    } || function(fe, ue) {
      for (var ce in ue)
        Object.prototype.hasOwnProperty.call(ue, ce) && (fe[ce] = ue[ce]);
    }, ae(ie, se);
  };
  return function(ie, se) {
    if (typeof se != "function" && se !== null)
      throw new TypeError("Class extends value " + String(se) + " is not a constructor or null");
    ae(ie, se);
    function fe() {
      this.constructor = ie;
    }
    ie.prototype = se === null ? Object.create(se) : (fe.prototype = se.prototype, new fe());
  };
}(), __assign = function() {
  return __assign = Object.assign || function(ae) {
    for (var ie, se = 1, fe = arguments.length; se < fe; se++) {
      ie = arguments[se];
      for (var ue in ie)
        Object.prototype.hasOwnProperty.call(ie, ue) && (ae[ue] = ie[ue]);
    }
    return ae;
  }, __assign.apply(this, arguments);
}, __awaiter = function(ae, ie, se, fe) {
  function ue(ce) {
    return ce instanceof se ? ce : new se(function(de) {
      de(ce);
    });
  }
  return new (se || (se = Promise))(function(ce, de) {
    function me(Se) {
      try {
        Ee(fe.next(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function we(Se) {
      try {
        Ee(fe.throw(Se));
      } catch (Be) {
        de(Be);
      }
    }
    function Ee(Se) {
      Se.done ? ce(Se.value) : ue(Se.value).then(me, we);
    }
    Ee((fe = fe.apply(ae, ie || [])).next());
  });
}, __generator = function(ae, ie) {
  var se = { label: 0, sent: function() {
    if (ce[0] & 1)
      throw ce[1];
    return ce[1];
  }, trys: [], ops: [] }, fe, ue, ce, de;
  return de = { next: me(0), throw: me(1), return: me(2) }, typeof Symbol == "function" && (de[Symbol.iterator] = function() {
    return this;
  }), de;
  function me(Ee) {
    return function(Se) {
      return we([Ee, Se]);
    };
  }
  function we(Ee) {
    if (fe)
      throw new TypeError("Generator is already executing.");
    for (; de && (de = 0, Ee[0] && (se = 0)), se; )
      try {
        if (fe = 1, ue && (ce = Ee[0] & 2 ? ue.return : Ee[0] ? ue.throw || ((ce = ue.return) && ce.call(ue), 0) : ue.next) && !(ce = ce.call(ue, Ee[1])).done)
          return ce;
        switch (ue = 0, ce && (Ee = [Ee[0] & 2, ce.value]), Ee[0]) {
          case 0:
          case 1:
            ce = Ee;
            break;
          case 4:
            return se.label++, { value: Ee[1], done: !1 };
          case 5:
            se.label++, ue = Ee[1], Ee = [0];
            continue;
          case 7:
            Ee = se.ops.pop(), se.trys.pop();
            continue;
          default:
            if (ce = se.trys, !(ce = ce.length > 0 && ce[ce.length - 1]) && (Ee[0] === 6 || Ee[0] === 2)) {
              se = 0;
              continue;
            }
            if (Ee[0] === 3 && (!ce || Ee[1] > ce[0] && Ee[1] < ce[3])) {
              se.label = Ee[1];
              break;
            }
            if (Ee[0] === 6 && se.label < ce[1]) {
              se.label = ce[1], ce = Ee;
              break;
            }
            if (ce && se.label < ce[2]) {
              se.label = ce[2], se.ops.push(Ee);
              break;
            }
            ce[2] && se.ops.pop(), se.trys.pop();
            continue;
        }
        Ee = ie.call(ae, se);
      } catch (Se) {
        Ee = [6, Se], ue = 0;
      } finally {
        fe = ce = 0;
      }
    if (Ee[0] & 5)
      throw Ee[1];
    return { value: Ee[0] ? Ee[1] : void 0, done: !0 };
  }
}, __values = function(ae) {
  var ie = typeof Symbol == "function" && Symbol.iterator, se = ie && ae[ie], fe = 0;
  if (se)
    return se.call(ae);
  if (ae && typeof ae.length == "number")
    return {
      next: function() {
        return ae && fe >= ae.length && (ae = void 0), { value: ae && ae[fe++], done: !ae };
      }
    };
  throw new TypeError(ie ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, Solflare = (
  /** @class */
  function(ae) {
    __extends(ie, ae);
    function ie(se) {
      var fe = ae.call(this) || this;
      return fe._network = "mainnet-beta", fe._provider = null, fe._iframeParams = {}, fe._adapterInstance = null, fe._element = null, fe._iframe = null, fe._connectHandler = null, fe._flutterHandlerInterval = null, fe._handleEvent = function(ue) {
        var ce, de, me, we;
        switch (ue.type) {
          case "connect_native_web": {
            fe._collapseIframe(), fe._adapterInstance = new WebAdapter(fe._iframe, fe._network, ((ce = ue.data) === null || ce === void 0 ? void 0 : ce.provider) || fe._provider || "https://solflare.com/provider"), fe._adapterInstance.on("connect", fe._webConnected), fe._adapterInstance.on("disconnect", fe._webDisconnected), fe._adapterInstance.connect(), fe._setPreferredAdapter("native_web");
            return;
          }
          case "connect": {
            fe._collapseIframe(), fe._adapterInstance = new IframeAdapter(fe._iframe, ((de = ue.data) === null || de === void 0 ? void 0 : de.publicKey) || ""), fe._adapterInstance.connect(), fe._setPreferredAdapter((me = ue.data) === null || me === void 0 ? void 0 : me.adapter), fe._connectHandler && (fe._connectHandler.resolve(), fe._connectHandler = null), fe.emit("connect", fe.publicKey);
            return;
          }
          case "disconnect": {
            fe._connectHandler && (fe._connectHandler.reject(), fe._connectHandler = null), fe._disconnected(), fe.emit("disconnect");
            return;
          }
          case "accountChanged": {
            !((we = ue.data) === null || we === void 0) && we.publicKey ? (fe._adapterInstance = new IframeAdapter(fe._iframe, ue.data.publicKey), fe._adapterInstance.connect(), fe.emit("accountChanged", fe.publicKey)) : fe.emit("accountChanged", void 0);
            return;
          }
          case "collapse": {
            fe._collapseIframe();
            return;
          }
          default:
            return;
        }
      }, fe._handleResize = function(ue) {
        ue.resizeMode === "full" ? ue.params.mode === "fullscreen" ? fe._expandIframe() : ue.params.mode === "hide" && fe._collapseIframe() : ue.resizeMode === "coordinates" && fe._iframe && (fe._iframe.style.top = isFinite(ue.params.top) ? "".concat(ue.params.top, "px") : "", fe._iframe.style.bottom = isFinite(ue.params.bottom) ? "".concat(ue.params.bottom, "px") : "", fe._iframe.style.left = isFinite(ue.params.left) ? "".concat(ue.params.left, "px") : "", fe._iframe.style.right = isFinite(ue.params.right) ? "".concat(ue.params.right, "px") : "", fe._iframe.style.width = isFinite(ue.params.width) ? "".concat(ue.params.width, "px") : ue.params.width, fe._iframe.style.height = isFinite(ue.params.height) ? "".concat(ue.params.height, "px") : ue.params.height);
      }, fe._handleMessage = function(ue) {
        var ce;
        if (((ce = ue.data) === null || ce === void 0 ? void 0 : ce.channel) === "solflareIframeToWalletAdapter") {
          var de = ue.data.data || {};
          de.type === "event" ? fe._handleEvent(de.event) : de.type === "resize" ? fe._handleResize(de) : de.type === "response" && fe._adapterInstance && fe._adapterInstance.handleMessage(de);
        }
      }, fe._removeElement = function() {
        fe._flutterHandlerInterval !== null && (clearInterval(fe._flutterHandlerInterval), fe._flutterHandlerInterval = null), fe._element && (fe._element.remove(), fe._element = null);
      }, fe._removeDanglingElements = function() {
        var ue, ce, de = document.getElementsByClassName("solflare-wallet-adapter-iframe");
        try {
          for (var me = __values(de), we = me.next(); !we.done; we = me.next()) {
            var Ee = we.value;
            Ee.parentElement && Ee.remove();
          }
        } catch (Se) {
          ue = { error: Se };
        } finally {
          try {
            we && !we.done && (ce = me.return) && ce.call(me);
          } finally {
            if (ue)
              throw ue.error;
          }
        }
      }, fe._injectElement = function() {
        fe._removeElement(), fe._removeDanglingElements();
        var ue = __assign(__assign({}, fe._iframeParams), { cluster: fe._network || "mainnet-beta", origin: window.location.origin || "", title: document.title || "", version: 1, sdkVersion: VERSION }), ce = fe._getPreferredAdapter();
        ce && (ue.adapter = ce), fe._provider && (ue.provider = fe._provider);
        var de = Object.keys(ue).map(function(we) {
          return "".concat(we, "=").concat(encodeURIComponent(ue[we]));
        }).join("&"), me = "".concat(ie.IFRAME_URL, "?").concat(de);
        fe._element = document.createElement("div"), fe._element.className = "solflare-wallet-adapter-iframe", fe._element.innerHTML = `
      <iframe src='`.concat(me, `' referrerPolicy='strict-origin-when-cross-origin' style='position: fixed; top: 0; bottom: 0; left: 0; right: 0; width: 100%; height: 100%; border: none; border-radius: 0; z-index: 99999; color-scheme: auto;' allowtransparency='true'></iframe>
    `), document.body.appendChild(fe._element), fe._iframe = fe._element.querySelector("iframe"), window.fromFlutter = fe._handleMobileMessage, fe._flutterHandlerInterval = setInterval(function() {
          window.fromFlutter = fe._handleMobileMessage;
        }, 100), window.addEventListener("message", fe._handleMessage, !1);
      }, fe._collapseIframe = function() {
        fe._iframe && (fe._iframe.style.top = "", fe._iframe.style.right = "", fe._iframe.style.height = "2px", fe._iframe.style.width = "2px");
      }, fe._expandIframe = function() {
        fe._iframe && (fe._iframe.style.top = "0px", fe._iframe.style.bottom = "0px", fe._iframe.style.left = "0px", fe._iframe.style.right = "0px", fe._iframe.style.width = "100%", fe._iframe.style.height = "100%");
      }, fe._getPreferredAdapter = function() {
        return localStorage && localStorage.getItem("solflarePreferredWalletAdapter") || null;
      }, fe._setPreferredAdapter = function(ue) {
        localStorage && ue && localStorage.setItem("solflarePreferredWalletAdapter", ue);
      }, fe._clearPreferredAdapter = function() {
        localStorage && localStorage.removeItem("solflarePreferredWalletAdapter");
      }, fe._webConnected = function() {
        fe._connectHandler && (fe._connectHandler.resolve(), fe._connectHandler = null), fe.emit("connect", fe.publicKey);
      }, fe._webDisconnected = function() {
        fe._connectHandler && (fe._connectHandler.reject(), fe._connectHandler = null), fe._disconnected(), fe.emit("disconnect");
      }, fe._disconnected = function() {
        window.removeEventListener("message", fe._handleMessage, !1), fe._removeElement(), fe._clearPreferredAdapter(), fe._adapterInstance = null;
      }, fe._handleMobileMessage = function(ue) {
        var ce, de;
        (de = (ce = fe._iframe) === null || ce === void 0 ? void 0 : ce.contentWindow) === null || de === void 0 || de.postMessage({
          channel: "solflareMobileToIframe",
          data: ue
        }, "*");
      }, se?.network && (fe._network = se?.network), se?.provider && (fe._provider = se?.provider), se?.params && (fe._iframeParams = __assign({}, se?.params)), fe;
    }
    return Object.defineProperty(ie.prototype, "publicKey", {
      get: function() {
        var se;
        return ((se = this._adapterInstance) === null || se === void 0 ? void 0 : se.publicKey) || null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ie.prototype, "isConnected", {
      get: function() {
        var se;
        return !!(!((se = this._adapterInstance) === null || se === void 0) && se.connected);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ie.prototype, "connected", {
      get: function() {
        return this.isConnected;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(ie.prototype, "autoApprove", {
      get: function() {
        return !1;
      },
      enumerable: !1,
      configurable: !0
    }), ie.prototype.connect = function() {
      return __awaiter(this, void 0, void 0, function() {
        var se = this;
        return __generator(this, function(fe) {
          switch (fe.label) {
            case 0:
              return this.connected ? [
                2
                /*return*/
              ] : (this._injectElement(), [4, new Promise(function(ue, ce) {
                se._connectHandler = { resolve: ue, reject: ce };
              })]);
            case 1:
              return fe.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, ie.prototype.disconnect = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(se) {
          switch (se.label) {
            case 0:
              return this._adapterInstance ? [4, this._adapterInstance.disconnect()] : [
                2
                /*return*/
              ];
            case 1:
              return se.sent(), this._disconnected(), this.emit("disconnect"), [
                2
                /*return*/
              ];
          }
        });
      });
    }, ie.prototype.signTransaction = function(se) {
      return __awaiter(this, void 0, void 0, function() {
        var fe, ue;
        return __generator(this, function(ce) {
          switch (ce.label) {
            case 0:
              if (!this.connected)
                throw new Error("Wallet not connected");
              return fe = isLegacyTransactionInstance(se) ? Uint8Array.from(se.serialize({ verifySignatures: !1, requireAllSignatures: !1 })) : se.serialize(), [4, this._adapterInstance.signTransaction(fe)];
            case 1:
              return ue = ce.sent(), [2, isLegacyTransactionInstance(se) ? Transaction.from(ue) : VersionedTransaction.deserialize(ue)];
          }
        });
      });
    }, ie.prototype.signAllTransactions = function(se) {
      return __awaiter(this, void 0, void 0, function() {
        var fe, ue;
        return __generator(this, function(ce) {
          switch (ce.label) {
            case 0:
              if (!this.connected)
                throw new Error("Wallet not connected");
              return fe = se.map(function(de) {
                return isLegacyTransactionInstance(de) ? Uint8Array.from(de.serialize({ verifySignatures: !1, requireAllSignatures: !1 })) : de.serialize();
              }), [4, this._adapterInstance.signAllTransactions(fe)];
            case 1:
              if (ue = ce.sent(), ue.length !== se.length)
                throw new Error("Failed to sign all transactions");
              return [2, ue.map(function(de, me) {
                return isLegacyTransactionInstance(se[me]) ? Transaction.from(de) : VersionedTransaction.deserialize(de);
              })];
          }
        });
      });
    }, ie.prototype.signAndSendTransaction = function(se, fe) {
      return __awaiter(this, void 0, void 0, function() {
        var ue;
        return __generator(this, function(ce) {
          switch (ce.label) {
            case 0:
              if (!this.connected)
                throw new Error("Wallet not connected");
              return ue = isLegacyTransactionInstance(se) ? se.serialize({ verifySignatures: !1, requireAllSignatures: !1 }) : se.serialize(), [4, this._adapterInstance.signAndSendTransaction(ue, fe)];
            case 1:
              return [2, ce.sent()];
          }
        });
      });
    }, ie.prototype.signMessage = function(se, fe) {
      return fe === void 0 && (fe = "utf8"), __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(ue) {
          switch (ue.label) {
            case 0:
              if (!this.connected)
                throw new Error("Wallet not connected");
              return [4, this._adapterInstance.signMessage(se, fe)];
            case 1:
              return [2, ue.sent()];
          }
        });
      });
    }, ie.prototype.sign = function(se, fe) {
      return fe === void 0 && (fe = "utf8"), __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(ue) {
          switch (ue.label) {
            case 0:
              return [4, this.signMessage(se, fe)];
            case 1:
              return [2, ue.sent()];
          }
        });
      });
    }, ie.prototype.detectWallet = function(se) {
      var fe;
      return se === void 0 && (se = 10), __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(ue) {
          return window.SolflareApp || !((fe = window.solflare) === null || fe === void 0) && fe.isSolflare ? [2, !0] : [2, new Promise(function(ce) {
            var de, me;
            de = setInterval(function() {
              var we;
              (window.SolflareApp || !((we = window.solflare) === null || we === void 0) && we.isSolflare) && (clearInterval(de), clearTimeout(me), ce(!0));
            }, 500), me = setTimeout(function() {
              clearInterval(de), ce(!1);
            }, se * 1e3);
          })];
        });
      });
    }, ie.IFRAME_URL = "https://connect.solflare.com/", ie;
  }(EventEmitter)
);
function getSolflareInstance(ae) {
  const ie = new Solflare();
  return ae && ie.connect(), ie;
}
function getIrysInstance(ae, ie, se) {
  return new WebIrys$1({
    url: ae,
    token: ie,
    wallet: se
  });
}
function toAtomic(ae, ie) {
  return ae.utils.toAtomic(ie);
}
function fromAtomic(ae, ie) {
  return ae.utils.fromAtomic(ie);
}
function token(ae) {
  return ae.token;
}
export {
  Solflare,
  WebIrys$1 as WebIrys,
  fromAtomic,
  getIrysInstance,
  getSolflareInstance,
  toAtomic,
  token
};
